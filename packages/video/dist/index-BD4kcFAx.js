var tf = (i) => {
  throw TypeError(i);
}, Zh = (i, e, t) => e.has(i) || tf("Cannot " + t), rg = (i, e, t) => (Zh(i, e, "read from private field"), t ? t.call(i) : e.get(i)), sf = (i, e, t) => e.has(i) ? tf("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(i) : e.set(i, t), ng = (i, e, t, s) => (Zh(i, e, "write to private field"), e.set(i, t), t), bu = (i, e, t) => (Zh(i, e, "access private method"), t), og = Object.defineProperty, rf = (i, e) => {
  for (var t in e)
    og(i, t, { get: e[t], enumerable: !0 });
}, _r = Math.pow(2, 32), be = Math.pow(2, 32) - 1, ag = 1, lg = 2, cg = 4, Fs = 1, Ms = 2, Es = 8, Ps = 16, Us = 32, wu = 131072, Gi = 1, Rs = 4, Hi = 256, Wi = 512, Vi = 1024, $i = 2048, nf = -1, St = 0, De = 1, dt = class of extends ArrayBuffer {
  constructor(e) {
    super(e), this.fileStart = 0, this.usedBytes = 0;
  }
  static fromArrayBuffer(e, t) {
    const s = new of(e.byteLength);
    return new Uint8Array(s).set(new Uint8Array(e)), s.fileStart = t, s;
  }
}, af = /* @__PURE__ */ ((i) => (i[i.BIG_ENDIAN = 1] = "BIG_ENDIAN", i[i.LITTLE_ENDIAN = 2] = "LITTLE_ENDIAN", i))(af || {}), as, br, $, we = ($ = class {
  /**
   * DataStream reads scalars, arrays and structs of data from an ArrayBuffer.
   * It's like a file-like DataView on steroids.
   *
   * @param arrayBuffer ArrayBuffer to read from.
   * @param byteOffset Offset from arrayBuffer beginning for the DataStream.
   * @param endianness Endianness of the DataStream (default: BIG_ENDIAN).
   */
  constructor(i, e, t) {
    sf(this, as), this._byteLength = 0, this.failurePosition = 0, this._dynamicSize = 1, this._byteOffset = e || 0, i instanceof ArrayBuffer ? this.buffer = dt.fromArrayBuffer(i, 0) : i instanceof DataView ? (this.dataView = i, e && (this._byteOffset += e)) : this.buffer = new dt(i || 0), this.position = 0, this.endianness = t || 1;
  }
  getPosition() {
    return this.position;
  }
  /**
   * Internal function to resize the DataStream buffer when required.
   * @param extra Number of bytes to add to the buffer allocation.
   */
  _realloc(i) {
    if (!this._dynamicSize)
      return;
    const e = this._byteOffset + this.position + i;
    let t = this._buffer.byteLength;
    if (e <= t) {
      e > this._byteLength && (this._byteLength = e);
      return;
    }
    for (t < 1 && (t = 1); e > t; )
      t *= 2;
    const s = new dt(t), r = new Uint8Array(this._buffer);
    new Uint8Array(s, 0, r.length).set(r), this.buffer = s, this._byteLength = e;
  }
  /**
   * Internal function to trim the DataStream buffer when required.
   * Used for stripping out the extra bytes from the backing buffer when
   * the virtual byteLength is smaller than the buffer byteLength (happens after
   * growing the buffer with writes and not filling the extra space completely).
   */
  _trimAlloc() {
    if (this._byteLength === this._buffer.byteLength)
      return;
    const i = new dt(this._byteLength), e = new Uint8Array(i), t = new Uint8Array(this._buffer, 0, e.length);
    e.set(t), this.buffer = i;
  }
  /**
   * Returns the byte length of the DataStream object.
   * @type {number}
   */
  get byteLength() {
    return this._byteLength - this._byteOffset;
  }
  /**
   * Set/get the backing ArrayBuffer of the DataStream object.
   * The setter updates the DataView to point to the new buffer.
   * @type {Object}
   */
  get buffer() {
    return this._trimAlloc(), this._buffer;
  }
  set buffer(i) {
    this._buffer = i, this._dataView = new DataView(i, this._byteOffset), this._byteLength = i.byteLength;
  }
  /**
   * Set/get the byteOffset of the DataStream object.
   * The setter updates the DataView to point to the new byteOffset.
   * @type {number}
   */
  get byteOffset() {
    return this._byteOffset;
  }
  set byteOffset(i) {
    this._byteOffset = i, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._buffer.byteLength;
  }
  /**
   * Set/get the byteOffset of the DataStream object.
   * The setter updates the DataView to point to the new byteOffset.
   * @type {number}
   */
  get dataView() {
    return this._dataView;
  }
  set dataView(i) {
    this._byteOffset = i.byteOffset, this._buffer = dt.fromArrayBuffer(i.buffer, 0), this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._byteOffset + i.byteLength;
  }
  /**
   *   Sets the DataStream read/write position to given position.
   *   Clamps between 0 and DataStream length.
   *
   *   @param pos Position to seek to.
   *   @return
   */
  seek(i) {
    const e = Math.max(0, Math.min(this.byteLength, i));
    this.position = isNaN(e) || !isFinite(e) ? 0 : e;
  }
  /**
   * Returns true if the DataStream seek pointer is at the end of buffer and
   * there's no more data to read.
   *
   * @return True if the seek pointer is at the end of the buffer.
   */
  isEof() {
    return this.position >= this._byteLength;
  }
  /**
   * Maps a Uint8Array into the DataStream buffer.
   *
   * Nice for quickly reading in data.
   *
   * @param length Number of elements to map.
   * @param e Endianness of the data to read.
   * @return Uint8Array to the DataStream backing buffer.
   */
  mapUint8Array(i) {
    this._realloc(i * 1);
    const e = new Uint8Array(this._buffer, this.byteOffset + this.position, i);
    return this.position += i * 1, e;
  }
  /**
   * Reads an Int32Array of desired length and endianness from the DataStream.
   *
   * @param length Number of elements to map.
   * @param endianness Endianness of the data to read.
   * @return The read Int32Array.
   */
  readInt32Array(i, e) {
    i = i === void 0 ? this.byteLength - this.position / 4 : i;
    const t = new Int32Array(i);
    return $.memcpy(
      t.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      i * t.BYTES_PER_ELEMENT
    ), $.arrayToNative(t, e ?? this.endianness), this.position += t.byteLength, t;
  }
  /**
   * Reads an Int16Array of desired length and endianness from the DataStream.
   *
   * @param length Number of elements to map.
   * @param endianness Endianness of the data to read.
   * @return The read Int16Array.
   */
  readInt16Array(i, e) {
    i = i === void 0 ? this.byteLength - this.position / 2 : i;
    const t = new Int16Array(i);
    return $.memcpy(
      t.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      i * t.BYTES_PER_ELEMENT
    ), $.arrayToNative(t, e ?? this.endianness), this.position += t.byteLength, t;
  }
  /**
   * Reads an Int8Array of desired length from the DataStream.
   *
   * @param length Number of elements to map.
   * @param e Endianness of the data to read.
   * @return The read Int8Array.
   */
  readInt8Array(i) {
    i = i === void 0 ? this.byteLength - this.position : i;
    const e = new Int8Array(i);
    return $.memcpy(
      e.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      i * e.BYTES_PER_ELEMENT
    ), this.position += e.byteLength, e;
  }
  /**
   * Reads a Uint32Array of desired length and endianness from the DataStream.
   *
   *  @param length Number of elements to map.
   *  @param endianness Endianness of the data to read.
   *  @return The read Uint32Array.
   */
  readUint32Array(i, e) {
    i = i === void 0 ? this.byteLength - this.position / 4 : i;
    const t = new Uint32Array(i);
    return $.memcpy(
      t.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      i * t.BYTES_PER_ELEMENT
    ), $.arrayToNative(t, e ?? this.endianness), this.position += t.byteLength, t;
  }
  /**
   * Reads a Uint16Array of desired length and endianness from the DataStream.
   *
   * @param length Number of elements to map.
   * @param endianness Endianness of the data to read.
   * @return The read Uint16Array.
   */
  readUint16Array(i, e) {
    i = i === void 0 ? this.byteLength - this.position / 2 : i;
    const t = new Uint16Array(i);
    return $.memcpy(
      t.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      i * t.BYTES_PER_ELEMENT
    ), $.arrayToNative(t, e ?? this.endianness), this.position += t.byteLength, t;
  }
  /**
   * Reads a Uint8Array of desired length from the DataStream.
   *
   * @param length Number of elements to map.
   * @param e Endianness of the data to read.
   * @return The read Uint8Array.
   */
  readUint8Array(i) {
    i = i === void 0 ? this.byteLength - this.position : i;
    const e = new Uint8Array(i);
    return $.memcpy(
      e.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      i * e.BYTES_PER_ELEMENT
    ), this.position += e.byteLength, e;
  }
  /**
   * Reads a Float64Array of desired length and endianness from the DataStream.
   *
   * @param length Number of elements to map.
   * @param endianness Endianness of the data to read.
   * @return The read Float64Array.
   */
  readFloat64Array(i, e) {
    i = i === void 0 ? this.byteLength - this.position / 8 : i;
    const t = new Float64Array(i);
    return $.memcpy(
      t.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      i * t.BYTES_PER_ELEMENT
    ), $.arrayToNative(t, e ?? this.endianness), this.position += t.byteLength, t;
  }
  /**
   * Reads a Float32Array of desired length and endianness from the DataStream.
   *
   * @param length Number of elements to map.
   * @param endianness Endianness of the data to read.
   * @return The read Float32Array.
   */
  readFloat32Array(i, e) {
    i = i === void 0 ? this.byteLength - this.position / 4 : i;
    const t = new Float32Array(i);
    return $.memcpy(
      t.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      i * t.BYTES_PER_ELEMENT
    ), $.arrayToNative(t, e ?? this.endianness), this.position += t.byteLength, t;
  }
  /**
   * Reads a 32-bit int from the DataStream with the desired endianness.
   *
   * @param endianness Endianness of the number.
   * @return The read number.
   */
  readInt32(i) {
    const e = this._dataView.getInt32(
      this.position,
      (i ?? this.endianness) === 2
      /* LITTLE_ENDIAN */
    );
    return this.position += 4, e;
  }
  /**
   * Reads a 16-bit int from the DataStream with the desired endianness.
   *
   * @param endianness Endianness of the number.
   * @return The read number.
   */
  readInt16(i) {
    const e = this._dataView.getInt16(
      this.position,
      (i ?? this.endianness) === 2
      /* LITTLE_ENDIAN */
    );
    return this.position += 2, e;
  }
  /**
   * Reads an 8-bit int from the DataStream.
   *
   * @return The read number.
   */
  readInt8() {
    const i = this._dataView.getInt8(this.position);
    return this.position += 1, i;
  }
  /**
   * Reads a 32-bit unsigned int from the DataStream with the desired endianness.
   *
   * @param endianness Endianness of the number.
   * @return The read number.
   */
  readUint32(i) {
    const e = this._dataView.getUint32(
      this.position,
      (i ?? this.endianness) === 2
      /* LITTLE_ENDIAN */
    );
    return this.position += 4, e;
  }
  /**
   * Reads a 16-bit unsigned int from the DataStream with the desired endianness.
   *
   * @param endianness Endianness of the number.
   * @return The read number.
   */
  readUint16(i) {
    const e = this._dataView.getUint16(
      this.position,
      (i ?? this.endianness) === 2
      /* LITTLE_ENDIAN */
    );
    return this.position += 2, e;
  }
  /**
   * Reads an 8-bit unsigned int from the DataStream.
   *
   * @return The read number.
   */
  readUint8() {
    const i = this._dataView.getUint8(this.position);
    return this.position += 1, i;
  }
  /**
   * Reads a 32-bit float from the DataStream with the desired endianness.
   *
   * @param endianness Endianness of the number.
   * @return The read number.
   */
  readFloat32(i) {
    const e = this._dataView.getFloat32(
      this.position,
      (i ?? this.endianness) === 2
      /* LITTLE_ENDIAN */
    );
    return this.position += 4, e;
  }
  /**
   * Reads a 64-bit float from the DataStream with the desired endianness.
   *
   * @param endianness Endianness of the number.
   * @return The read number.
   */
  readFloat64(i) {
    const e = this._dataView.getFloat64(
      this.position,
      (i ?? this.endianness) === 2
      /* LITTLE_ENDIAN */
    );
    return this.position += 8, e;
  }
  /**
   * Copies byteLength bytes from the src buffer at srcOffset to the
   * dst buffer at dstOffset.
   *
   * @param dst Destination ArrayBuffer to write to.
   * @param dstOffset Offset to the destination ArrayBuffer.
   * @param src Source ArrayBuffer to read from.
   * @param srcOffset Offset to the source ArrayBuffer.
   * @param byteLength Number of bytes to copy.
   */
  static memcpy(i, e, t, s, r) {
    const n = new Uint8Array(i, e, r), o = new Uint8Array(t, s, r);
    n.set(o);
  }
  /**
   * Converts array to native endianness in-place.
   *
   * @param typedArray Typed array to convert.
   * @param endianness True if the data in the array is
   *                                      little-endian. Set false for big-endian.
   * @return The converted typed array.
   */
  static arrayToNative(i, e) {
    return e === $.ENDIANNESS ? i : this.flipArrayEndianness(i);
  }
  /**
   * Converts native endianness array to desired endianness in-place.
   *
   * @param typedArray Typed array to convert.
   * @param littleEndian True if the converted array should be
   *                               little-endian. Set false for big-endian.
   * @return The converted typed array.
   */
  static nativeToEndian(i, e) {
    return e && $.ENDIANNESS === 2 ? i : this.flipArrayEndianness(i);
  }
  /**
   * Flips typed array endianness in-place.
   *
   * @param typedArray Typed array to flip.
   * @return The converted typed array.
   */
  static flipArrayEndianness(i) {
    const e = new Uint8Array(i.buffer, i.byteOffset, i.byteLength);
    for (let t = 0; t < i.byteLength; t += i.BYTES_PER_ELEMENT)
      for (let s = t + i.BYTES_PER_ELEMENT - 1, r = t; s > r; s--, r++) {
        const n = e[r];
        e[r] = e[s], e[s] = n;
      }
    return i;
  }
  /**
   * Read a string of desired length and encoding from the DataStream.
   *
   * @param length The length of the string to read in bytes.
   * @param encoding The encoding of the string data in the DataStream.
   *                           Defaults to ASCII.
   * @return The read string.
   */
  readString(i, e) {
    return e === void 0 || e === "ASCII" ? Tu(
      this.mapUint8Array(i === void 0 ? this.byteLength - this.position : i)
    ) : new TextDecoder(e).decode(this.mapUint8Array(i));
  }
  /**
   * Read null-terminated string of desired length from the DataStream. Truncates
   * the returned string so that the null byte is not a part of it.
   *
   * @param length The length of the string to read.
   * @return The read string.
   */
  readCString(i) {
    let e = 0;
    const t = this.byteLength - this.position, s = new Uint8Array(this._buffer, this._byteOffset + this.position), r = i !== void 0 ? Math.min(i, t) : t;
    for (; e < r && s[e] !== 0; e++) ;
    const n = Tu(this.mapUint8Array(e));
    return i !== void 0 ? this.position += r - e : e !== t && (this.position += 1), n;
  }
  readInt64() {
    return this.readInt32() * _r + this.readUint32();
  }
  readUint64() {
    return this.readUint32() * _r + this.readUint32();
  }
  readUint24() {
    return (this.readUint8() << 16) + (this.readUint8() << 8) + this.readUint8();
  }
  /**
   * Saves the DataStream contents to the given filename.
   * Uses Chrome's anchor download property to initiate download.
   *
   * @param filename Filename to save as.
   * @return
   * @bundle DataStream-write.js
   */
  save(i) {
    const e = new Blob([this.buffer]);
    if (typeof window < "u" && typeof document < "u")
      if (window.URL && URL.createObjectURL) {
        const t = window.URL.createObjectURL(e), s = document.createElement("a");
        document.body.appendChild(s), s.setAttribute("href", t), s.setAttribute("download", i), s.setAttribute("target", "_self"), s.click(), window.URL.revokeObjectURL(t), document.body.removeChild(s);
      } else
        throw new Error("DataStream.save: Can't create object URL.");
    return e;
  }
  /** @bundle DataStream-write.js */
  get dynamicSize() {
    return this._dynamicSize;
  }
  /** @bundle DataStream-write.js */
  set dynamicSize(i) {
    i || this._trimAlloc(), this._dynamicSize = i;
  }
  /**
   * Internal function to trim the DataStream buffer when required.
   * Used for stripping out the first bytes when not needed anymore.
   *
   * @return
   * @bundle DataStream-write.js
   */
  shift(i) {
    const e = new dt(this._byteLength - i), t = new Uint8Array(e), s = new Uint8Array(this._buffer, i, t.length);
    t.set(s), this.buffer = e, this.position -= i;
  }
  /**
   * Writes an Int32Array of specified endianness to the DataStream.
   *
   * @param array The array to write.
   * @param endianness Endianness of the data to write.
   * @bundle DataStream-write.js
   */
  writeInt32Array(i, e) {
    if (this._realloc(i.length * 4), i instanceof Int32Array && this.byteOffset + this.position % i.BYTES_PER_ELEMENT === 0)
      $.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        i.buffer,
        0,
        i.byteLength
      ), this.mapInt32Array(i.length, e);
    else
      for (let t = 0; t < i.length; t++)
        this.writeInt32(i[t], e);
  }
  /**
   * Writes an Int16Array of specified endianness to the DataStream.
   *
   * @param array The array to write.
   * @param endianness Endianness of the data to write.
   * @bundle DataStream-write.js
   */
  writeInt16Array(i, e) {
    if (this._realloc(i.length * 2), i instanceof Int16Array && this.byteOffset + this.position % i.BYTES_PER_ELEMENT === 0)
      $.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        i.buffer,
        0,
        i.byteLength
      ), this.mapInt16Array(i.length, e);
    else
      for (let t = 0; t < i.length; t++)
        this.writeInt16(i[t], e);
  }
  /**
   * Writes an Int8Array to the DataStream.
   *
   * @param array The array to write.
   * @bundle DataStream-write.js
   */
  writeInt8Array(i) {
    if (this._realloc(i.length * 1), i instanceof Int8Array && this.byteOffset + this.position % i.BYTES_PER_ELEMENT === 0)
      $.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        i.buffer,
        0,
        i.byteLength
      ), this.mapInt8Array(i.length);
    else
      for (let e = 0; e < i.length; e++)
        this.writeInt8(i[e]);
  }
  /**
   * Writes a Uint32Array of specified endianness to the DataStream.
   *
   * @param array The array to write.
   * @param endianness Endianness of the data to write.
   * @bundle DataStream-write.js
   */
  writeUint32Array(i, e) {
    if (this._realloc(i.length * 4), i instanceof Uint32Array && this.byteOffset + this.position % i.BYTES_PER_ELEMENT === 0)
      $.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        i.buffer,
        0,
        i.byteLength
      ), this.mapUint32Array(i.length, e);
    else
      for (let t = 0; t < i.length; t++)
        this.writeUint32(i[t], e);
  }
  /**
   * Writes a Uint16Array of specified endianness to the DataStream.
   *
   * @param array The array to write.
   * @param endianness Endianness of the data to write.
   * @bundle DataStream-write.js
   */
  writeUint16Array(i, e) {
    if (this._realloc(i.length * 2), i instanceof Uint16Array && this.byteOffset + this.position % i.BYTES_PER_ELEMENT === 0)
      $.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        i.buffer,
        0,
        i.byteLength
      ), this.mapUint16Array(i.length, e);
    else
      for (let t = 0; t < i.length; t++)
        this.writeUint16(i[t], e);
  }
  /**
   * Writes a Uint8Array to the DataStream.
   *
   * @param array The array to write.
   * @bundle DataStream-write.js
   */
  writeUint8Array(i) {
    if (this._realloc(i.length * 1), i instanceof Uint8Array && this.byteOffset + this.position % i.BYTES_PER_ELEMENT === 0)
      $.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        i.buffer,
        0,
        i.byteLength
      ), this.mapUint8Array(i.length);
    else
      for (let e = 0; e < i.length; e++)
        this.writeUint8(i[e]);
  }
  /**
   * Writes a Float64Array of specified endianness to the DataStream.
   *
   * @param array The array to write.
   * @param endianness Endianness of the data to write.
   * @bundle DataStream-write.js
   */
  writeFloat64Array(i, e) {
    if (this._realloc(i.length * 8), i instanceof Float64Array && this.byteOffset + this.position % i.BYTES_PER_ELEMENT === 0)
      $.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        i.buffer,
        0,
        i.byteLength
      ), this.mapFloat64Array(i.length, e);
    else
      for (let t = 0; t < i.length; t++)
        this.writeFloat64(i[t], e);
  }
  /**
   * Writes a Float32Array of specified endianness to the DataStream.
   *
   * @param array The array to write.
   * @param endianness Endianness of the data to write.
   * @bundle DataStream-write.js
   */
  writeFloat32Array(i, e) {
    if (this._realloc(i.length * 4), i instanceof Float32Array && this.byteOffset + this.position % i.BYTES_PER_ELEMENT === 0)
      $.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        i.buffer,
        0,
        i.byteLength
      ), this.mapFloat32Array(i.length, e);
    else
      for (let t = 0; t < i.length; t++)
        this.writeFloat32(i[t], e);
  }
  /**
   * Writes a 64-bit int to the DataStream with the desired endianness.
   *
   * @param value Number to write.
   * @param endianness Endianness of the number.
   * @bundle DataStream-write.js
   */
  writeInt64(i, e) {
    this._realloc(8), this._dataView.setBigInt64(
      this.position,
      BigInt(i),
      (e ?? this.endianness) === 2
      /* LITTLE_ENDIAN */
    ), this.position += 8;
  }
  /**
   * Writes a 32-bit int to the DataStream with the desired endianness.
   *
   * @param value Number to write.
   * @param endianness Endianness of the number.
   * @bundle DataStream-write.js
   */
  writeInt32(i, e) {
    this._realloc(4), this._dataView.setInt32(
      this.position,
      i,
      (e ?? this.endianness) === 2
      /* LITTLE_ENDIAN */
    ), this.position += 4;
  }
  /**
   * Writes a 16-bit int to the DataStream with the desired endianness.
   *
   * @param value Number to write.
   * @param endianness Endianness of the number.
   * @bundle DataStream-write.js
   */
  writeInt16(i, e) {
    this._realloc(2), this._dataView.setInt16(
      this.position,
      i,
      (e ?? this.endianness) === 2
      /* LITTLE_ENDIAN */
    ), this.position += 2;
  }
  /**
   * Writes an 8-bit int to the DataStream.
   *
   * @param value Number to write.
   * @bundle DataStream-write.js
   */
  writeInt8(i) {
    this._realloc(1), this._dataView.setInt8(this.position, i), this.position += 1;
  }
  /**
   * Writes a 32-bit unsigned int to the DataStream with the desired endianness.
   *
   * @param value Number to write.
   * @param endianness Endianness of the number.
   * @bundle DataStream-write.js
   */
  writeUint32(i, e) {
    this._realloc(4), this._dataView.setUint32(
      this.position,
      i,
      (e ?? this.endianness) === 2
      /* LITTLE_ENDIAN */
    ), this.position += 4;
  }
  /**
   * Writes a 16-bit unsigned int to the DataStream with the desired endianness.
   *
   * @param value Number to write.
   * @param endianness Endianness of the number.
   * @bundle DataStream-write.js
   */
  writeUint16(i, e) {
    this._realloc(2), this._dataView.setUint16(
      this.position,
      i,
      (e ?? this.endianness) === 2
      /* LITTLE_ENDIAN */
    ), this.position += 2;
  }
  /**
   * Writes an 8-bit unsigned  int to the DataStream.
   *
   * @param value Number to write.
   * @bundle DataStream-write.js
   */
  writeUint8(i) {
    this._realloc(1), this._dataView.setUint8(this.position, i), this.position += 1;
  }
  /**
   * Writes a 32-bit float to the DataStream with the desired endianness.
   *
   * @param value Number to write.
   * @param endianness Endianness of the number.
   * @bundle DataStream-write.js
   */
  writeFloat32(i, e) {
    this._realloc(4), this._dataView.setFloat32(
      this.position,
      i,
      (e ?? this.endianness) === 2
      /* LITTLE_ENDIAN */
    ), this.position += 4;
  }
  /**
   * Writes a 64-bit float to the DataStream with the desired endianness.
   *
   * @param value Number to write.
   * @param endianness Endianness of the number.
   * @bundle DataStream-write.js
   */
  writeFloat64(i, e) {
    this._realloc(8), this._dataView.setFloat64(
      this.position,
      i,
      (e ?? this.endianness) === 2
      /* LITTLE_ENDIAN */
    ), this.position += 8;
  }
  /**
   * Write a UCS-2 string of desired endianness to the DataStream. The
   * lengthOverride argument lets you define the number of characters to write.
   * If the string is shorter than lengthOverride, the extra space is padded with
   * zeroes.
   *
   * @param value The string to write.
   * @param endianness The endianness to use for the written string data.
   * @param lengthOverride The number of characters to write.
   * @bundle DataStream-write.js
   */
  writeUCS2String(i, e, t) {
    t === void 0 && (t = i.length);
    let s;
    for (s = 0; s < i.length && s < t; s++)
      this.writeUint16(i.charCodeAt(s), e);
    for (; s < t; s++)
      this.writeUint16(0);
  }
  /**
   * Writes a string of desired length and encoding to the DataStream.
   *
   * @param value The string to write.
   * @param encoding The encoding for the written string data.
   *                           Defaults to ASCII.
   * @param length The number of characters to write.
   * @bundle DataStream-write.js
   */
  writeString(i, e, t) {
    let s = 0;
    if (e === void 0 || e === "ASCII")
      if (t !== void 0) {
        const r = Math.min(i.length, t);
        for (s = 0; s < r; s++)
          this.writeUint8(i.charCodeAt(s));
        for (; s < t; s++)
          this.writeUint8(0);
      } else
        for (s = 0; s < i.length; s++)
          this.writeUint8(i.charCodeAt(s));
    else
      this.writeUint8Array(new TextEncoder(e).encode(i.substring(0, t)));
  }
  /**
   * Writes a null-terminated string to DataStream and zero-pads it to length
   * bytes. If length is not given, writes the string followed by a zero.
   * If string is longer than length, the written part of the string does not have
   * a trailing zero.
   *
   * @param value The string to write.
   * @param length The number of characters to write.
   * @bundle DataStream-write.js
   */
  writeCString(i, e) {
    let t = 0;
    if (e !== void 0) {
      const s = Math.min(i.length, e);
      for (t = 0; t < s; t++)
        this.writeUint8(i.charCodeAt(t));
      for (; t < e; t++)
        this.writeUint8(0);
    } else {
      for (t = 0; t < i.length; t++)
        this.writeUint8(i.charCodeAt(t));
      this.writeUint8(0);
    }
  }
  /**
   * Writes a struct to the DataStream. Takes a structDefinition that gives the
   * types and a struct object that gives the values. Refer to readStruct for the
   * structure of structDefinition.
   *
   * @param structDefinition Type definition of the struct.
   * @param struct The struct data object.
   * @bundle DataStream-write.js
   */
  writeStruct(i, e) {
    for (let t = 0; t < i.length; t++) {
      const [s, r] = i[t], n = e[s];
      this.writeType(r, n, e);
    }
  }
  /**
   * Writes object v of type t to the DataStream.
   *
   * @param type Type of data to write.
   * @param value Value of data to write.
   * @param struct Struct to pass to write callback functions.
   * @bundle DataStream-write.js
   */
  writeType(i, e, t) {
    if (typeof i == "function")
      return i(this, e);
    if (typeof i == "object" && !(i instanceof Array))
      return i.set(this, e, t);
    let s, r = "ASCII";
    const n = this.position;
    let o = i;
    if (typeof i == "string" && /:/.test(i)) {
      const a = i.split(":");
      o = a[0], s = parseInt(a[1]);
    }
    if (typeof o == "string" && /,/.test(o)) {
      const a = o.split(",");
      o = a[0], r = a[1];
    }
    switch (o) {
      case "uint8":
        this.writeUint8(e);
        break;
      case "int8":
        this.writeInt8(e);
        break;
      case "uint16":
        this.writeUint16(e, this.endianness);
        break;
      case "int16":
        this.writeInt16(e, this.endianness);
        break;
      case "uint32":
        this.writeUint32(e, this.endianness);
        break;
      case "int32":
        this.writeInt32(e, this.endianness);
        break;
      case "float32":
        this.writeFloat32(e, this.endianness);
        break;
      case "float64":
        this.writeFloat64(e, this.endianness);
        break;
      case "uint16be":
        this.writeUint16(
          e,
          1
          /* BIG_ENDIAN */
        );
        break;
      case "int16be":
        this.writeInt16(
          e,
          1
          /* BIG_ENDIAN */
        );
        break;
      case "uint32be":
        this.writeUint32(
          e,
          1
          /* BIG_ENDIAN */
        );
        break;
      case "int32be":
        this.writeInt32(
          e,
          1
          /* BIG_ENDIAN */
        );
        break;
      case "float32be":
        this.writeFloat32(
          e,
          1
          /* BIG_ENDIAN */
        );
        break;
      case "float64be":
        this.writeFloat64(
          e,
          1
          /* BIG_ENDIAN */
        );
        break;
      case "uint16le":
        this.writeUint16(
          e,
          2
          /* LITTLE_ENDIAN */
        );
        break;
      case "int16le":
        this.writeInt16(
          e,
          2
          /* LITTLE_ENDIAN */
        );
        break;
      case "uint32le":
        this.writeUint32(
          e,
          2
          /* LITTLE_ENDIAN */
        );
        break;
      case "int32le":
        this.writeInt32(
          e,
          2
          /* LITTLE_ENDIAN */
        );
        break;
      case "float32le":
        this.writeFloat32(
          e,
          2
          /* LITTLE_ENDIAN */
        );
        break;
      case "float64le":
        this.writeFloat64(
          e,
          2
          /* LITTLE_ENDIAN */
        );
        break;
      case "cstring":
        this.writeCString(e, s);
        break;
      case "string":
        this.writeString(e, r, s);
        break;
      case "u16string":
        this.writeUCS2String(e, this.endianness, s);
        break;
      case "u16stringle":
        this.writeUCS2String(e, 2, s);
        break;
      case "u16stringbe":
        this.writeUCS2String(e, 1, s);
        break;
      default:
        if (bu(this, as, br).call(this, o)) {
          const [, a] = o;
          for (let l = 0; l < e.length; l++)
            this.writeType(a, e[l]);
          break;
        } else {
          this.writeStruct(o, e);
          break;
        }
    }
    s && (this.position = n, this._realloc(s), this.position = n + s);
  }
  /** @bundle DataStream-write.js */
  writeUint64(i) {
    const e = Math.floor(i / _r);
    this.writeUint32(e), this.writeUint32(i & 4294967295);
  }
  /** @bundle DataStream-write.js */
  writeUint24(i) {
    this.writeUint8((i & 16711680) >> 16), this.writeUint8((i & 65280) >> 8), this.writeUint8(i & 255);
  }
  /** @bundle DataStream-write.js */
  adjustUint32(i, e) {
    const t = this.position;
    this.seek(i), this.writeUint32(e), this.seek(t);
  }
  /**
   * Reads a struct of data from the DataStream. The struct is defined as
   * an array of [name, type]-pairs. See the example below:
   *
   * ```ts
   * ds.readStruct([
   *   ['headerTag', 'uint32'], // Uint32 in DataStream endianness.
   *   ['headerTag2', 'uint32be'], // Big-endian Uint32.
   *   ['headerTag3', 'uint32le'], // Little-endian Uint32.
   *   ['array', ['[]', 'uint32', 16]], // Uint32Array of length 16.
   *   ['array2', ['[]', 'uint32', 'array2Length']] // Uint32Array of length array2Length
   * ]);
   * ```
   *
   * The possible values for the type are as follows:
   *
   * ## Number types
   *
   * Unsuffixed number types use DataStream endianness.
   * To explicitly specify endianness, suffix the type with
   * 'le' for little-endian or 'be' for big-endian,
   * e.g. 'int32be' for big-endian int32.
   *
   * - `uint8` -- 8-bit unsigned int
   * - `uint16` -- 16-bit unsigned int
   * - `uint32` -- 32-bit unsigned int
   * - `int8` -- 8-bit int
   * - `int16` -- 16-bit int
   * - `int32` -- 32-bit int
   * - `float32` -- 32-bit float
   * - `float64` -- 64-bit float
   *
   * ## String types
   *
   * - `cstring` -- ASCII string terminated by a zero byte.
   * - `string:N` -- ASCII string of length N.
   * - `string,CHARSET:N` -- String of byteLength N encoded with given CHARSET.
   * - `u16string:N` -- UCS-2 string of length N in DataStream endianness.
   * - `u16stringle:N` -- UCS-2 string of length N in little-endian.
   * - `u16stringbe:N` -- UCS-2 string of length N in big-endian.
   *
   * ## Complex types
   *
   * ### Struct
   * ```ts
   * [[name, type], [name_2, type_2], ..., [name_N, type_N]]
   * ```
   *
   * ### Callback function to read and return data
   * ```ts
   * function(dataStream, struct) {}
   * ```
   *
   * ###  Getter/setter functions
   * to read and return data, handy for using the same struct definition
   * for reading and writing structs.
   * ```ts
   * {
   *    get: function(dataStream, struct) {},
   *    set: function(dataStream, struct) {}
   * }
   * ```
   *
   * ### Array
   * Array of given type and length. The length can be either
   * - a number
   * - a string that references a previously-read field
   * - `*`
   * - a callback: `function(struct, dataStream, type){}`
   *
   * If length is `*`, reads in as many elements as it can.
   * ```ts
   * ['[]', type, length]
   * ```
   *
   * @param structDefinition Struct definition object.
   * @return The read struct. Null if failed to read struct.
   * @bundle DataStream-read-struct.js
   */
  readStruct(i) {
    const e = {}, t = this.position;
    for (let s = 0; s < i.length; s += 1) {
      const r = i[s][1], n = this.readType(r, e);
      if (!n) {
        this.failurePosition === 0 && (this.failurePosition = this.position), this.position = t;
        return;
      }
      e[i[s][0]] = n;
    }
    return e;
  }
  /**
   * Read UCS-2 string of desired length and endianness from the DataStream.
   *
   * @param length The length of the string to read.
   * @param endianness The endianness of the string data in the DataStream.
   * @return The read string.
   * @bundle DataStream-read-struct.js
   */
  readUCS2String(i, e) {
    return String.fromCharCode.apply(void 0, this.readUint16Array(i, e));
  }
  /**
   * Reads an object of type t from the DataStream, passing struct as the thus-far
   * read struct to possible callbacks that refer to it. Used by readStruct for
   * reading in the values, so the type is one of the readStruct types.
   *
   * @param type Type of the object to read.
   * @param struct Struct to refer to when resolving length references
   *                         and for calling callbacks.
   * @return  Returns the object on successful read, null on unsuccessful.
   * @bundle DataStream-read-struct.js
   */
  readType(i, e) {
    if (typeof i == "function")
      return i(this, e);
    if (typeof i == "object" && !(i instanceof Array))
      return i.get(this, e);
    if (i instanceof Array && i.length !== 3)
      return this.readStruct(i);
    let t, s, r = "ASCII";
    const n = this.position;
    let o = i;
    if (typeof o == "string" && /:/.test(o)) {
      const a = o.split(":");
      o = a[0], s = parseInt(a[1]);
    }
    if (typeof o == "string" && /,/.test(o)) {
      const a = o.split(",");
      o = a[0], r = a[1];
    }
    switch (o) {
      case "uint8":
        t = this.readUint8();
        break;
      case "int8":
        t = this.readInt8();
        break;
      case "uint16":
        t = this.readUint16(this.endianness);
        break;
      case "int16":
        t = this.readInt16(this.endianness);
        break;
      case "uint32":
        t = this.readUint32(this.endianness);
        break;
      case "int32":
        t = this.readInt32(this.endianness);
        break;
      case "float32":
        t = this.readFloat32(this.endianness);
        break;
      case "float64":
        t = this.readFloat64(this.endianness);
        break;
      case "uint16be":
        t = this.readUint16(
          1
          /* BIG_ENDIAN */
        );
        break;
      case "int16be":
        t = this.readInt16(
          1
          /* BIG_ENDIAN */
        );
        break;
      case "uint32be":
        t = this.readUint32(
          1
          /* BIG_ENDIAN */
        );
        break;
      case "int32be":
        t = this.readInt32(
          1
          /* BIG_ENDIAN */
        );
        break;
      case "float32be":
        t = this.readFloat32(
          1
          /* BIG_ENDIAN */
        );
        break;
      case "float64be":
        t = this.readFloat64(
          1
          /* BIG_ENDIAN */
        );
        break;
      case "uint16le":
        t = this.readUint16(
          2
          /* LITTLE_ENDIAN */
        );
        break;
      case "int16le":
        t = this.readInt16(
          2
          /* LITTLE_ENDIAN */
        );
        break;
      case "uint32le":
        t = this.readUint32(
          2
          /* LITTLE_ENDIAN */
        );
        break;
      case "int32le":
        t = this.readInt32(
          2
          /* LITTLE_ENDIAN */
        );
        break;
      case "float32le":
        t = this.readFloat32(
          2
          /* LITTLE_ENDIAN */
        );
        break;
      case "float64le":
        t = this.readFloat64(
          2
          /* LITTLE_ENDIAN */
        );
        break;
      case "cstring":
        t = this.readCString(s);
        break;
      case "string":
        t = this.readString(s, r);
        break;
      case "u16string":
        t = this.readUCS2String(s, this.endianness);
        break;
      case "u16stringle":
        t = this.readUCS2String(
          s,
          2
          /* LITTLE_ENDIAN */
        );
        break;
      case "u16stringbe":
        t = this.readUCS2String(
          s,
          1
          /* BIG_ENDIAN */
        );
        break;
      default:
        if (bu(this, as, br).call(this, o)) {
          const [, a, l] = o, c = typeof l == "function" ? l(e, this, o) : typeof l == "string" && e[l] !== void 0 ? (
            // @ts-expect-error   FIXME: Struct[string] is currently of type Type
            parseInt(e[l])
          ) : typeof l == "number" ? l : l === "*" ? void 0 : parseInt(l);
          if (typeof a == "string") {
            const h = a.replace(/(le|be)$/, "");
            let u;
            switch (/le$/.test(a) ? u = 2 : /be$/.test(a) && (u = 1), h) {
              case "uint8":
                t = this.readUint8Array(c);
                break;
              case "uint16":
                t = this.readUint16Array(c, u);
                break;
              case "uint32":
                t = this.readUint32Array(c, u);
                break;
              case "int8":
                t = this.readInt8Array(c);
                break;
              case "int16":
                t = this.readInt16Array(c, u);
                break;
              case "int32":
                t = this.readInt32Array(c, u);
                break;
              case "float32":
                t = this.readFloat32Array(c, u);
                break;
              case "float64":
                t = this.readFloat64Array(c, u);
                break;
              case "cstring":
              case "utf16string":
              case "string":
                if (c) {
                  t = new Array(c);
                  for (let d = 0; d < c; d++)
                    t[d] = this.readType(a, e);
                } else
                  for (t = []; !this.isEof(); ) {
                    const d = this.readType(a, e);
                    if (!d) break;
                    t.push(d);
                  }
                break;
            }
          } else if (c) {
            t = new Array(c);
            for (let h = 0; h < c; h++) {
              const u = this.readType(a, e);
              if (!u) return;
              t[h] = u;
            }
          } else
            for (t = []; ; ) {
              const h = this.position;
              try {
                const u = this.readType(a, e);
                if (!u) {
                  this.position = h;
                  break;
                }
                t.push(u);
              } catch {
                this.position = h;
                break;
              }
            }
          break;
        }
    }
    return s && (this.position = n + s), t;
  }
  /**
   * Maps an Int32Array into the DataStream buffer, swizzling it to native
   * endianness in-place. The current offset from the start of the buffer needs to
   * be a multiple of element size, just like with typed array views.
   *
   * Nice for quickly reading in data. Warning: potentially modifies the buffer
   * contents.
   *
   * @param length Number of elements to map.
   * @param endianness Endianness of the data to read.
   * @return Int32Array to the DataStream backing buffer.
   * @bundle DataStream-map.js
   */
  mapInt32Array(i, e) {
    this._realloc(i * 4);
    const t = new Int32Array(this._buffer, this.byteOffset + this.position, i);
    return $.arrayToNative(t, e ?? this.endianness), this.position += i * 4, t;
  }
  /**
   * Maps an Int16Array into the DataStream buffer, swizzling it to native
   * endianness in-place. The current offset from the start of the buffer needs to
   * be a multiple of element size, just like with typed array views.
   *
   * Nice for quickly reading in data. Warning: potentially modifies the buffer
   * contents.
   *
   * @param length Number of elements to map.
   * @param endianness Endianness of the data to read.
   * @return Int16Array to the DataStream backing buffer.
   * @bundle DataStream-map.js
   */
  mapInt16Array(i, e) {
    this._realloc(i * 2);
    const t = new Int16Array(this._buffer, this.byteOffset + this.position, i);
    return $.arrayToNative(t, e ?? this.endianness), this.position += i * 2, t;
  }
  /**
   * Maps an Int8Array into the DataStream buffer.
   *
   * Nice for quickly reading in data.
   *
   * @param length Number of elements to map.
   * @param endianness Endianness of the data to read.
   * @return Int8Array to the DataStream backing buffer.
   * @bundle DataStream-map.js
   */
  mapInt8Array(i, e) {
    this._realloc(i * 1);
    const t = new Int8Array(this._buffer, this.byteOffset + this.position, i);
    return this.position += i * 1, t;
  }
  /**
   * Maps a Uint32Array into the DataStream buffer, swizzling it to native
   * endianness in-place. The current offset from the start of the buffer needs to
   * be a multiple of element size, just like with typed array views.
   *
   * Nice for quickly reading in data. Warning: potentially modifies the buffer
   * contents.
   *
   * @param length Number of elements to map.
   * @param endianness Endianness of the data to read.
   * @return Uint32Array to the DataStream backing buffer.
   * @bundle DataStream-map.js
   */
  mapUint32Array(i, e) {
    this._realloc(i * 4);
    const t = new Uint32Array(this._buffer, this.byteOffset + this.position, i);
    return $.arrayToNative(t, e ?? this.endianness), this.position += i * 4, t;
  }
  /**
   * Maps a Uint16Array into the DataStream buffer, swizzling it to native
   * endianness in-place. The current offset from the start of the buffer needs to
   * be a multiple of element size, just like with typed array views.
   *
   * Nice for quickly reading in data. Warning: potentially modifies the buffer
   * contents.
   *
   * @param length Number of elements to map.
   * @param endianness Endianness of the data to read.
   * @return Uint16Array to the DataStream backing buffer.
   * @bundle DataStream-map.js
   */
  mapUint16Array(i, e) {
    this._realloc(i * 2);
    const t = new Uint16Array(this._buffer, this.byteOffset + this.position, i);
    return $.arrayToNative(t, e ?? this.endianness), this.position += i * 2, t;
  }
  /**
   * Maps a Float64Array into the DataStream buffer, swizzling it to native
   * endianness in-place. The current offset from the start of the buffer needs to
   * be a multiple of element size, just like with typed array views.
   *
   * Nice for quickly reading in data. Warning: potentially modifies the buffer
   * contents.
   *
   * @param length Number of elements to map.
   * @param endianness Endianness of the data to read.
   * @return Float64Array to the DataStream backing buffer.
   * @bundle DataStream-map.js
   */
  mapFloat64Array(i, e) {
    this._realloc(i * 8);
    const t = new Float64Array(this._buffer, this.byteOffset + this.position, i);
    return $.arrayToNative(t, e ?? this.endianness), this.position += i * 8, t;
  }
  /**
   * Maps a Float32Array into the DataStream buffer, swizzling it to native
   * endianness in-place. The current offset from the start of the buffer needs to
   * be a multiple of element size, just like with typed array views.
   *
   * Nice for quickly reading in data. Warning: potentially modifies the buffer
   * contents.
   *
   * @param length Number of elements to map.
   * @param endianness Endianness of the data to read.
   * @return Float32Array to the DataStream backing buffer.
   * @bundle DataStream-map.js
   */
  mapFloat32Array(i, e) {
    this._realloc(i * 4);
    const t = new Float32Array(this._buffer, this.byteOffset + this.position, i);
    return $.arrayToNative(t, e ?? this.endianness), this.position += i * 4, t;
  }
}, as = /* @__PURE__ */ new WeakSet(), br = function(i) {
  return Array.isArray(i) && i.length === 3 && i[0] === "[]";
}, $.ENDIANNESS = new Int8Array(new Int16Array([1]).buffer)[0] > 0 ? 2 : 1, $);
function Tu(i) {
  const e = [];
  for (let t = 0; t < i.length; t++)
    e[t] = i[t];
  return String.fromCharCode.apply(void 0, e);
}
var ls = /* @__PURE__ */ new Date(), ph = 4, Su = 3, Cu = 2, Au = 1, Tt = ph, I = {
  setLogLevel(i) {
    i === this.debug ? Tt = Au : i === this.info ? Tt = Cu : i === this.warn ? Tt = Su : (this.error, Tt = ph);
  },
  debug(i, e) {
    console.debug === void 0 && (console.debug = console.log), Au >= Tt && console.debug(
      "[" + I.getDurationString((/* @__PURE__ */ new Date()).getTime() - ls.getTime(), 1e3) + "]",
      "[" + i + "]",
      e
    );
  },
  log(i, e) {
    this.debug(i.msg);
  },
  info(i, e) {
    Cu >= Tt && console.info(
      "[" + I.getDurationString((/* @__PURE__ */ new Date()).getTime() - ls.getTime(), 1e3) + "]",
      "[" + i + "]",
      e
    );
  },
  warn(i, e) {
    Su >= Tt && console.warn(
      "[" + I.getDurationString((/* @__PURE__ */ new Date()).getTime() - ls.getTime(), 1e3) + "]",
      "[" + i + "]",
      e
    );
  },
  error(i, e, t) {
    t?.onError ? t.onError(i, e) : ph >= Tt && console.error(
      "[" + I.getDurationString((/* @__PURE__ */ new Date()).getTime() - ls.getTime(), 1e3) + "]",
      "[" + i + "]",
      e
    );
  },
  /* Helper function to print a duration value in the form H:MM:SS.MS */
  getDurationString(i, e) {
    let t;
    function s(l, c) {
      const h = ("" + l).split(".");
      for (; h[0].length < c; )
        h[0] = "0" + h[0];
      return h.join(".");
    }
    i < 0 ? (t = !0, i = -i) : t = !1;
    let r = i / (e || 1);
    const n = Math.floor(r / 3600);
    r -= n * 3600;
    const o = Math.floor(r / 60);
    r -= o * 60;
    let a = r * 1e3;
    return r = Math.floor(r), a -= r * 1e3, a = Math.floor(a), (t ? "-" : "") + n + ":" + s(o, 2) + ":" + s(r, 2) + "." + s(a, 3);
  },
  /* Helper function to stringify HTML5 TimeRanges objects */
  printRanges(i) {
    const e = i.length;
    if (e > 0) {
      let t = "";
      for (let s = 0; s < e; s++)
        s > 0 && (t += ","), t += "[" + I.getDurationString(i.start(s)) + "," + I.getDurationString(i.end(s)) + "]";
      return t;
    } else
      return "(empty)";
  }
};
function hg(i, e) {
  I.debug(
    "ArrayBuffer",
    "Trying to create a new buffer of size: " + (i.byteLength + e.byteLength)
  );
  const t = new Uint8Array(i.byteLength + e.byteLength);
  return t.set(new Uint8Array(i), 0), t.set(new Uint8Array(e), i.byteLength), t.buffer;
}
var ni = class extends we {
  constructor(i) {
    super(new ArrayBuffer(), 0), this.buffers = [], this.bufferIndex = -1, i && (this.insertBuffer(i), this.bufferIndex = 0);
  }
  /***********************************************************************************
   *                     Methods for the managnement of the buffers                  *
   *                     (insertion, removal, concatenation, ...)                    *
   ***********************************************************************************/
  initialized() {
    if (this.bufferIndex > -1)
      return !0;
    if (this.buffers.length > 0) {
      const i = this.buffers[0];
      return i.fileStart === 0 ? (this.buffer = i, this.bufferIndex = 0, I.debug("MultiBufferStream", "Stream ready for parsing"), !0) : (I.warn("MultiBufferStream", "The first buffer should have a fileStart of 0"), this.logBufferLevel(), !1);
    } else
      return I.warn("MultiBufferStream", "No buffer to start parsing from"), this.logBufferLevel(), !1;
  }
  /**
   * Reduces the size of a given buffer, but taking the part between offset and offset+newlength
   * @param  {ArrayBuffer} buffer
   * @param  {Number}      offset    the start of new buffer
   * @param  {Number}      newLength the length of the new buffer
   * @return {ArrayBuffer}           the new buffer
   */
  reduceBuffer(i, e, t) {
    const s = new Uint8Array(t);
    return s.set(new Uint8Array(i, e, t)), s.buffer.fileStart = i.fileStart + e, s.buffer.usedBytes = 0, s.buffer;
  }
  /**
   * Inserts the new buffer in the sorted list of buffers,
   *  making sure, it is not overlapping with existing ones (possibly reducing its size).
   *  if the new buffer overrides/replaces the 0-th buffer (for instance because it is bigger),
   *  updates the DataStream buffer for parsing
   */
  insertBuffer(i) {
    let e = !0, t = 0;
    for (; t < this.buffers.length; t++) {
      const s = this.buffers[t];
      if (i.fileStart <= s.fileStart) {
        if (i.fileStart === s.fileStart)
          if (i.byteLength > s.byteLength) {
            this.buffers.splice(t, 1), t--;
            continue;
          } else
            I.warn(
              "MultiBufferStream",
              "Buffer (fileStart: " + i.fileStart + " - Length: " + i.byteLength + ") already appended, ignoring"
            );
        else
          i.fileStart + i.byteLength <= s.fileStart || (i = this.reduceBuffer(i, 0, s.fileStart - i.fileStart)), I.debug(
            "MultiBufferStream",
            "Appending new buffer (fileStart: " + i.fileStart + " - Length: " + i.byteLength + ")"
          ), this.buffers.splice(t, 0, i), t === 0 && (this.buffer = i);
        e = !1;
        break;
      } else if (i.fileStart < s.fileStart + s.byteLength) {
        const r = s.fileStart + s.byteLength - i.fileStart, n = i.byteLength - r;
        if (n > 0)
          i = this.reduceBuffer(i, r, n);
        else {
          e = !1;
          break;
        }
      }
    }
    e && (I.debug(
      "MultiBufferStream",
      "Appending new buffer (fileStart: " + i.fileStart + " - Length: " + i.byteLength + ")"
    ), this.buffers.push(i), t === 0 && (this.buffer = i));
  }
  /**
   * Displays the status of the buffers (number and used bytes)
   * @param  {Object} info callback method for display
   */
  logBufferLevel(i) {
    const e = [];
    let t = "", s, r = 0, n = 0;
    for (let a = 0; a < this.buffers.length; a++) {
      const l = this.buffers[a];
      a === 0 ? (s = {
        start: l.fileStart,
        end: l.fileStart + l.byteLength
      }, e.push(s), t += "[" + s.start + "-") : s.end === l.fileStart ? s.end = l.fileStart + l.byteLength : (s = {
        start: l.fileStart,
        end: l.fileStart + l.byteLength
      }, t += e[e.length - 1].end - 1 + "], [" + s.start + "-", e.push(s)), r += l.usedBytes, n += l.byteLength;
    }
    e.length > 0 && (t += s.end - 1 + "]");
    const o = i ? I.info : I.debug;
    this.buffers.length === 0 ? o("MultiBufferStream", "No more buffer in memory") : o(
      "MultiBufferStream",
      "" + this.buffers.length + " stored buffer(s) (" + r + "/" + n + " bytes), continuous ranges: " + t
    );
  }
  cleanBuffers() {
    for (let i = 0; i < this.buffers.length; i++) {
      const e = this.buffers[i];
      e.usedBytes === e.byteLength && (I.debug("MultiBufferStream", "Removing buffer #" + i), this.buffers.splice(i, 1), i--);
    }
  }
  mergeNextBuffer() {
    if (this.bufferIndex + 1 < this.buffers.length) {
      const i = this.buffers[this.bufferIndex + 1];
      if (i.fileStart === this.buffer.fileStart + this.buffer.byteLength) {
        const e = this.buffer.byteLength, t = this.buffer.usedBytes, s = this.buffer.fileStart;
        return this.buffers[this.bufferIndex] = hg(this.buffer, i), this.buffer = this.buffers[this.bufferIndex], this.buffers.splice(this.bufferIndex + 1, 1), this.buffer.usedBytes = t, this.buffer.fileStart = s, I.debug(
          "ISOFile",
          "Concatenating buffer for box parsing (length: " + e + "->" + this.buffer.byteLength + ")"
        ), !0;
      } else
        return !1;
    } else
      return !1;
  }
  /*************************************************************************
   *                        Seek-related functions                         *
   *************************************************************************/
  /**
   * Finds the buffer that holds the given file position
   * @param  {Boolean} fromStart    indicates if the search should start from the current buffer (false)
   *                                or from the first buffer (true)
   * @param  {Number}  filePosition position in the file to seek to
   * @param  {Boolean} markAsUsed   indicates if the bytes in between the current position and the seek position
   *                                should be marked as used for garbage collection
   * @return {Number}               the index of the buffer holding the seeked file position, -1 if not found.
   */
  findPosition(i, e, t) {
    let s = -1, r = i === !0 ? 0 : this.bufferIndex;
    for (; r < this.buffers.length; ) {
      const o = this.buffers[r];
      if (o && o.fileStart <= e)
        s = r, t && (o.fileStart + o.byteLength <= e ? o.usedBytes = o.byteLength : o.usedBytes = e - o.fileStart, this.logBufferLevel());
      else
        break;
      r++;
    }
    if (s === -1)
      return -1;
    const n = this.buffers[s];
    return n.fileStart + n.byteLength >= e ? (I.debug("MultiBufferStream", "Found position in existing buffer #" + s), s) : -1;
  }
  /**
   * Finds the largest file position contained in a buffer or in the next buffers if they are contiguous (no gap)
   * starting from the given buffer index or from the current buffer if the index is not given
   *
   * @param  {Number} inputindex Index of the buffer to start from
   * @return {Number}            The largest file position found in the buffers
   */
  findEndContiguousBuf(i) {
    const e = i !== void 0 ? i : this.bufferIndex;
    let t = this.buffers[e];
    if (this.buffers.length > e + 1)
      for (let s = e + 1; s < this.buffers.length; s++) {
        const r = this.buffers[s];
        if (r.fileStart === t.fileStart + t.byteLength)
          t = r;
        else
          break;
      }
    return t.fileStart + t.byteLength;
  }
  /**
   * Returns the largest file position contained in the buffers, larger than the given position
   * @param  {Number} pos the file position to start from
   * @return {Number}     the largest position in the current buffer or in the buffer and the next contiguous
   *                      buffer that holds the given position
   */
  getEndFilePositionAfter(i) {
    const e = this.findPosition(!0, i, !1);
    return e !== -1 ? this.findEndContiguousBuf(e) : i;
  }
  /*************************************************************************
   *                  Garbage collection related functions                 *
   *************************************************************************/
  /**
   * Marks a given number of bytes as used in the current buffer for garbage collection
   * @param {Number} nbBytes
   */
  addUsedBytes(i) {
    this.buffer.usedBytes += i, this.logBufferLevel();
  }
  /**
   * Marks the entire current buffer as used, ready for garbage collection
   */
  setAllUsedBytes() {
    this.buffer.usedBytes = this.buffer.byteLength, this.logBufferLevel();
  }
  /*************************************************************************
   *          Common API between MultiBufferStream and SimpleStream        *
   *************************************************************************/
  /**
   * Tries to seek to a given file position
   * if possible, repositions the parsing from there and returns true
   * if not possible, does not change anything and returns false
   * @param  {Number}  filePosition position in the file to seek to
   * @param  {Boolean} fromStart    indicates if the search should start from the current buffer (false)
   *                                or from the first buffer (true)
   * @param  {Boolean} markAsUsed   indicates if the bytes in between the current position and the seek position
   *                                should be marked as used for garbage collection
   * @return {Boolean}              true if the seek succeeded, false otherwise
   */
  seek(i, e, t) {
    const s = this.findPosition(e, i, t);
    return s !== -1 ? (this.buffer = this.buffers[s], this.bufferIndex = s, this.position = i - this.buffer.fileStart, I.debug("MultiBufferStream", "Repositioning parser at buffer position: " + this.position), !0) : (I.debug("MultiBufferStream", "Position " + i + " not found in buffered data"), !1);
  }
  /**
   * Returns the current position in the file
   * @return {Number} the position in the file
   */
  getPosition() {
    return this.bufferIndex === -1 || this.buffers[this.bufferIndex] === void 0 ? 0 : this.buffers[this.bufferIndex].fileStart + this.position;
  }
  /**
   * Returns the length of the current buffer
   * @return {Number} the length of the current buffer
   */
  getLength() {
    return this.byteLength;
  }
  getEndPosition() {
    return this.bufferIndex === -1 || this.buffers[this.bufferIndex] === void 0 ? 0 : this.buffers[this.bufferIndex].fileStart + this.byteLength;
  }
  getAbsoluteEndPosition() {
    if (this.buffers.length === 0) return 0;
    const i = this.buffers[this.buffers.length - 1];
    return i.fileStart + i.byteLength;
  }
}, cs, wr, P = (wr = class {
  constructor(i = 0) {
    sf(this, cs), this.size = i;
  }
  get type() {
    return this.constructor.fourcc ?? rg(this, cs);
  }
  set type(i) {
    ng(this, cs, i);
  }
  addBox(i) {
    return this.boxes || (this.boxes = []), this.boxes.push(i), this[i.type + "s"] ? this[i.type + "s"].push(i) : this[i.type] = i, i;
  }
  set(i, e) {
    return this[i] = e, this;
  }
  addEntry(i, e) {
    const t = e || "entries";
    return this[t] || (this[t] = []), this[t].push(i), this;
  }
  /** @bundle box-write.js */
  writeHeader(i, e) {
    if (this.size += 8, (this.size > be || this.original_size === 1) && (this.size += 8), this.type === "uuid" && (this.size += 16), I.debug(
      "BoxWriter",
      "Writing box " + this.type + " of size: " + this.size + " at position " + i.getPosition() + (e || "")
    ), this.original_size === 0 ? i.writeUint32(0) : this.size > be || this.original_size === 1 ? i.writeUint32(1) : (this.sizePosition = i.getPosition(), i.writeUint32(this.size)), i.writeString(this.type, void 0, 4), this.type === "uuid") {
      const t = new Uint8Array(16);
      for (let s = 0; s < 16; s++)
        t[s] = parseInt(this.uuid.substring(s * 2, s * 2 + 2), 16);
      i.writeUint8Array(t);
    }
    (this.size > be || this.original_size === 1) && (this.sizePosition = i.getPosition(), i.writeUint64(this.size));
  }
  /** @bundle box-write.js */
  write(i) {
    if (this.type === "mdat") {
      const e = this;
      if (e.stream) {
        this.size = e.stream.getAbsoluteEndPosition(), this.writeHeader(i);
        for (const t of e.stream.buffers) {
          const s = new Uint8Array(t);
          i.writeUint8Array(s);
        }
      } else e.data && (this.size = e.data.length, this.writeHeader(i), i.writeUint8Array(e.data));
    } else
      this.size = this.data ? this.data.length : 0, this.writeHeader(i), this.data && i.writeUint8Array(this.data);
  }
  /** @bundle box-print.js */
  printHeader(i) {
    this.size += 8, this.size > be && (this.size += 8), this.type === "uuid" && (this.size += 16), i.log(i.indent + "size:" + this.size), i.log(i.indent + "type:" + this.type);
  }
  /** @bundle box-print.js */
  print(i) {
    this.printHeader(i);
  }
  /** @bundle box-parse.js */
  parse(i) {
    this.type !== "mdat" ? this.data = i.readUint8Array(this.size - this.hdr_size) : this.size === 0 ? i.seek(i.getEndPosition()) : i.seek(this.start + this.size);
  }
  /** @bundle box-parse.js */
  parseDataAndRewind(i) {
    this.data = i.readUint8Array(this.size - this.hdr_size), i.seek(this.start + this.hdr_size);
  }
  /** @bundle box-parse.js */
  parseLanguage(i) {
    this.language = i.readUint16();
    const e = [];
    e[0] = this.language >> 10 & 31, e[1] = this.language >> 5 & 31, e[2] = this.language & 31, this.languageString = String.fromCharCode(e[0] + 96, e[1] + 96, e[2] + 96);
  }
  /** @bundle isofile-advanced-creation.js */
  computeSize(i) {
    const e = i || new ni();
    this.write(e);
  }
  isEndOfBox(i) {
    const e = i.getPosition(), t = this.start + this.size;
    return e === t;
  }
}, cs = /* @__PURE__ */ new WeakMap(), wr.registryId = /* @__PURE__ */ Symbol.for("BoxIdentifier"), wr), F = class extends P {
  constructor() {
    super(...arguments), this.flags = 0, this.version = 0;
  }
  /** @bundle box-write.js */
  writeHeader(e) {
    this.size += 4, super.writeHeader(e, " v=" + this.version + " f=" + this.flags), e.writeUint8(this.version), e.writeUint24(this.flags);
  }
  /** @bundle box-print.js */
  printHeader(e) {
    this.size += 4, super.printHeader(e), e.log(e.indent + "version:" + this.version), e.log(e.indent + "flags:" + this.flags);
  }
  /** @bundle box-parse.js */
  parseDataAndRewind(e) {
    this.parseFullHeader(e), this.data = e.readUint8Array(this.size - this.hdr_size), this.hdr_size -= 4, e.seek(this.start + this.hdr_size);
  }
  /** @bundle box-parse.js */
  parseFullHeader(e) {
    this.version = e.readUint8(), this.flags = e.readUint24(), this.hdr_size += 4;
  }
  /** @bundle box-parse.js */
  parse(e) {
    this.parseFullHeader(e), this.data = e.readUint8Array(this.size - this.hdr_size);
  }
}, Tr, ye = (Tr = class {
  constructor(i) {
    this.grouping_type = i;
  }
  /** @bundle writing/samplegroups/samplegroup.js */
  write(i) {
    i.writeUint8Array(this.data);
  }
  /** @bundle parsing/samplegroups/samplegroup.js */
  parse(i) {
    I.warn("BoxParser", `Unknown sample group type: '${this.grouping_type}'`), this.data = i.readUint8Array(this.description_length);
  }
}, Tr.registryId = /* @__PURE__ */ Symbol.for("SampleGroupEntryIdentifier"), Tr), lf = class extends F {
  /** @bundle parsing/TrackGroup.js */
  parse(i) {
    this.parseFullHeader(i), this.track_group_id = i.readUint32();
  }
}, cf = class extends P {
  constructor(i, e, t, s, r) {
    super(e), this.box_name = t, this.hdr_size = s, this.start = r, this.type = i;
  }
  parse(i) {
    this.from_item_ID = i.readUint16();
    const e = i.readUint16();
    this.references = [];
    for (let t = 0; t < e; t++)
      this.references[t] = {
        to_item_ID: i.readUint16()
      };
  }
}, hf = class extends P {
  constructor(i, e, t, s, r) {
    super(e), this.box_name = t, this.hdr_size = s, this.start = r, this.type = i;
  }
  parse(i) {
    this.from_item_ID = i.readUint32();
    const e = i.readUint16();
    this.references = [];
    for (let t = 0; t < e; t++)
      this.references[t] = {
        to_item_ID: i.readUint32()
      };
  }
}, uf = class extends P {
  constructor(i, e, t, s) {
    super(e), this.hdr_size = t, this.start = s, this.type = i;
  }
  parse(i) {
    this.track_ids = i.readUint32Array((this.size - this.hdr_size) / 4);
  }
  /** @bundle box-write.js */
  write(i) {
    this.size = this.track_ids.length * 4, this.writeHeader(i), i.writeUint32Array(this.track_ids);
  }
}, Js = [
  "boxes",
  "entries",
  "references",
  "subsamples",
  "items",
  "item_infos",
  "extents",
  "associations",
  "subsegments",
  "ranges",
  "seekLists",
  "seekPoints",
  "esd",
  "levels"
], df = [
  "compatible_brands",
  "matrix",
  "opcolor",
  "sample_counts",
  "sample_deltas",
  "first_chunk",
  "samples_per_chunk",
  "sample_sizes",
  "chunk_offsets",
  "sample_offsets",
  "sample_description_index",
  "sample_duration"
];
function ff(i, e) {
  if (i && !e) return !1;
  let t;
  for (t in i)
    if (!Js.find((s) => s === t)) {
      if (i[t] instanceof P || e[t] instanceof P || typeof i[t] > "u" || typeof e[t] > "u" || typeof i[t] == "function" || typeof e[t] == "function" || "subBoxNames" in i && i.subBoxNames.indexOf(t.slice(0, 4)) > -1 || "subBoxNames" in e && e.subBoxNames.indexOf(t.slice(0, 4)) > -1 || t === "data" || t === "start" || t === "size" || t === "creation_time" || t === "modification_time" || df.find((s) => s === t))
        continue;
      if (i[t] !== e[t])
        return !1;
    }
  return !0;
}
function Kh(i, e) {
  if (!ff(i, e))
    return !1;
  for (let t = 0; t < Js.length; t++) {
    const s = Js[t];
    if (i[s] && e[s] && !Kh(i[s], e[s]))
      return !1;
  }
  return !0;
}
function Jh(i) {
  let e = i;
  for (; e; ) {
    if ("registryId" in e)
      return e.registryId;
    e = Object.getPrototypeOf(e);
  }
}
var ug = (i) => {
  const e = /* @__PURE__ */ Symbol.for("SampleGroupEntryIdentifier");
  return Jh(i) === e;
}, dg = (i) => {
  const e = /* @__PURE__ */ Symbol.for("SampleEntryIdentifier");
  return Jh(i) === e;
}, fg = (i) => {
  const e = /* @__PURE__ */ Symbol.for("BoxIdentifier");
  return Jh(i) === e;
}, Oe = {
  uuid: {},
  sampleEntry: {},
  sampleGroupEntry: {},
  box: {}
};
function pg(i) {
  const e = {
    uuid: {},
    sampleEntry: {},
    sampleGroupEntry: {},
    box: {}
  };
  for (const [t, s] of Object.entries(i)) {
    if (ug(s)) {
      const r = "grouping_type" in s ? s.grouping_type : void 0;
      if (!r)
        throw new Error(
          `SampleGroupEntry class ${t} does not have a valid static grouping_type. Please ensure it is defined correctly.`
        );
      if (r in e.sampleGroupEntry)
        throw new Error(
          `SampleGroupEntry class ${t} has a grouping_type that is already registered. Please ensure it is unique.`
        );
      e.sampleGroupEntry[r] = s;
      continue;
    }
    if (dg(s)) {
      const r = "fourcc" in s ? s.fourcc : void 0;
      if (!r)
        throw new Error(
          `SampleEntry class ${t} does not have a valid static fourcc. Please ensure it is defined correctly.`
        );
      if (r in e.sampleEntry)
        throw new Error(
          `SampleEntry class ${t} has a fourcc that is already registered. Please ensure it is unique.`
        );
      e.sampleEntry[r] = s;
      continue;
    }
    if (fg(s)) {
      const r = "fourcc" in s ? s.fourcc : void 0, n = "uuid" in s ? s.uuid : void 0;
      if (r === "uuid") {
        if (!n)
          throw new Error(
            `Box class ${t} has a fourcc of 'uuid' but does not have a valid uuid. Please ensure it is defined correctly.`
          );
        if (n in e.uuid)
          throw new Error(
            `Box class ${t} has a uuid that is already registered. Please ensure it is unique.`
          );
        e.uuid[n] = s;
        continue;
      }
      e.box[r] = s;
      continue;
    }
    throw new Error(
      `Box class ${t} does not have a valid static fourcc, uuid, or grouping_type. Please ensure it is defined correctly.`
    );
  }
  return Oe.uuid = { ...e.uuid }, Oe.sampleEntry = { ...e.sampleEntry }, Oe.sampleGroupEntry = { ...e.sampleGroupEntry }, Oe.box = { ...e.box }, Oe;
}
var js = {};
function mg(i) {
  return Object.entries(i).forEach(([e, t]) => js[e] = t), js;
}
function gg(i) {
  return Ht(i);
}
function Ht(i) {
  let e = "";
  for (let t = 0; t < 16; t++) {
    const s = i.readUint8().toString(16);
    e += s.length === 1 ? "0" + s : s;
  }
  return e;
}
function st(i, e, t) {
  let s, r;
  const n = i.getPosition();
  let o = 0, a;
  if (i.getEndPosition() - n < 8)
    return I.debug("BoxParser", "Not enough data in stream to parse the type and size of the box"), { code: St };
  if (t && t < 8)
    return I.debug("BoxParser", "Not enough bytes left in the parent box to parse a new box"), { code: St };
  let l = i.readUint32();
  const c = i.readString(4);
  if (c.length !== 4 || !/^[\x20-\x7E]{4}$/.test(c))
    return I.error("BoxParser", `Invalid box type: '${c}'`), { code: nf, start: n, type: c };
  let h = c;
  if (I.debug(
    "BoxParser",
    "Found box of type '" + c + "' and size " + l + " at position " + n
  ), o = 8, c === "uuid") {
    if (i.getEndPosition() - i.getPosition() < 16 || t - o < 16)
      return i.seek(n), I.debug("BoxParser", "Not enough bytes left in the parent box to parse a UUID box"), { code: St };
    a = gg(i), o += 16, h = a;
  }
  if (l === 1) {
    if (i.getEndPosition() - i.getPosition() < 8 || t && t - o < 8)
      return i.seek(n), I.warn(
        "BoxParser",
        'Not enough data in stream to parse the extended size of the "' + c + '" box'
      ), { code: St };
    r = l, l = i.readUint64(), o += 8;
  } else if (l === 0) {
    if (t)
      l = t;
    else if (c !== "mdat")
      return I.error("BoxParser", "Unlimited box size not supported for type: '" + c + "'"), s = new P(l), s.type = c, { code: De, box: s, size: s.size };
  }
  if (l !== 0 && l < o)
    return I.error(
      "BoxParser",
      "Box of type " + c + " has an invalid size " + l + " (too small to be a box)"
    ), {
      code: St,
      type: c,
      size: l,
      hdr_size: o,
      start: n
    };
  if (l !== 0 && t && l > t)
    return I.error(
      "BoxParser",
      "Box of type '" + c + "' has a size " + l + " greater than its container size " + t
    ), {
      code: St,
      type: c,
      size: l,
      hdr_size: o,
      start: n
    };
  if (l !== 0 && n + l > i.getEndPosition())
    return i.seek(n), I.info("BoxParser", "Not enough data in stream to parse the entire '" + c + "' box"), {
      code: St,
      type: c,
      size: l,
      hdr_size: o,
      start: n,
      original_size: r
    };
  if (e)
    return { code: De, type: c, size: l, hdr_size: o, start: n };
  c in Oe.box ? s = new Oe.box[c](l) : c !== "uuid" ? (I.warn("BoxParser", `Unknown box type: '${c}'`), s = new P(l), s.type = c, s.has_unparsed_data = !0) : a in Oe.uuid ? s = new Oe.uuid[a](l) : (I.warn("BoxParser", `Unknown UUID box type: '${a}'`), s = new P(l), s.type = c, s.uuid = a, s.has_unparsed_data = !0), s.original_size = r, s.hdr_size = o, s.start = n, s.write === P.prototype.write && s.type !== "mdat" && (I.info(
    "BoxParser",
    "'" + h + "' box writing not yet implemented, keeping unparsed data in memory for later write"
  ), s.parseDataAndRewind(i)), s.parse(i);
  const u = i.getPosition() - (s.start + s.size);
  return u < 0 ? (I.warn(
    "BoxParser",
    "Parsing of box '" + h + "' did not read the entire indicated box data size (missing " + -u + " bytes), seeking forward"
  ), i.seek(s.start + s.size)) : u > 0 && s.size !== 0 && (I.error(
    "BoxParser",
    "Parsing of box '" + h + "' read " + u + " more bytes than the indicated box data size, seeking backwards"
  ), i.seek(s.start + s.size)), { code: De, box: s, size: s.size };
}
var Z = class extends P {
  /** @bundle box-write.js */
  write(e) {
    if (this.size = 0, this.writeHeader(e), this.boxes)
      for (let t = 0; t < this.boxes.length; t++)
        this.boxes[t] && (this.boxes[t].write(e), this.size += this.boxes[t].size);
    I.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), e.adjustUint32(this.sizePosition, this.size);
  }
  /** @bundle box-print.js */
  print(e) {
    this.printHeader(e);
    for (let t = 0; t < this.boxes.length; t++)
      if (this.boxes[t]) {
        const s = e.indent;
        e.indent += " ", this.boxes[t].print(e), e.indent = s;
      }
  }
  /** @bundle box-parse.js */
  parse(e) {
    let t;
    for (; e.getPosition() < this.start + this.size; )
      if (t = st(e, !1, this.size - (e.getPosition() - this.start)), t.code === De) {
        const s = t.box;
        if (this.boxes || (this.boxes = []), this.boxes.push(s), this.subBoxNames && this.subBoxNames.indexOf(s.type) !== -1) {
          const r = this.subBoxNames[this.subBoxNames.indexOf(s.type)] + "s";
          this[r] || (this[r] = []), this[r].push(s);
        } else {
          const r = s.type !== "uuid" ? s.type : s.uuid;
          this[r] ? I.warn(
            "ContainerBox",
            `Box of type ${r} already exists in container box ${this.type}.`
          ) : this[r] = s;
        }
      } else
        return;
  }
}, Sr, pt = (Sr = class extends Z {
  constructor(i, e, t) {
    super(i), this.hdr_size = e, this.start = t;
  }
  /** @bundle box-codecs.js */
  isVideo() {
    return !1;
  }
  /** @bundle box-codecs.js */
  isAudio() {
    return !1;
  }
  /** @bundle box-codecs.js */
  isSubtitle() {
    return !1;
  }
  /** @bundle box-codecs.js */
  isMetadata() {
    return !1;
  }
  /** @bundle box-codecs.js */
  isHint() {
    return !1;
  }
  /** @bundle box-codecs.js */
  getCodec() {
    return this.type.replace(".", "");
  }
  /** @bundle box-codecs.js */
  getWidth() {
    return "";
  }
  /** @bundle box-codecs.js */
  getHeight() {
    return "";
  }
  /** @bundle box-codecs.js */
  getChannelCount() {
    return "";
  }
  /** @bundle box-codecs.js */
  getSampleRate() {
    return "";
  }
  /** @bundle box-codecs.js */
  getSampleSize() {
    return "";
  }
  /** @bundle parsing/sampleentries/sampleentry.js */
  parseHeader(i) {
    i.readUint8Array(6), this.data_reference_index = i.readUint16(), this.hdr_size += 8;
  }
  /** @bundle parsing/sampleentries/sampleentry.js */
  parse(i) {
    this.parseHeader(i), this.data = i.readUint8Array(this.size - this.hdr_size);
  }
  /** @bundle parsing/sampleentries/sampleentry.js */
  parseDataAndRewind(i) {
    this.parseHeader(i), this.data = i.readUint8Array(this.size - this.hdr_size), this.hdr_size -= 8, i.seek(this.start + this.hdr_size);
  }
  /** @bundle parsing/sampleentries/sampleentry.js */
  parseFooter(i) {
    super.parse(i);
  }
  /** @bundle writing/sampleentry.js */
  writeHeader(i) {
    this.size = 8, super.writeHeader(i), i.writeUint8(0), i.writeUint8(0), i.writeUint8(0), i.writeUint8(0), i.writeUint8(0), i.writeUint8(0), i.writeUint16(this.data_reference_index);
  }
  /** @bundle writing/sampleentry.js */
  writeFooter(i) {
    if (this.boxes)
      for (let e = 0; e < this.boxes.length; e++)
        this.boxes[e].write(i), this.size += this.boxes[e].size;
    I.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), i.adjustUint32(this.sizePosition, this.size);
  }
  /** @bundle writing/sampleentry.js */
  write(i) {
    this.writeHeader(i), i.writeUint8Array(this.data), this.size += this.data.length, I.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), i.adjustUint32(this.sizePosition, this.size);
  }
}, Sr.registryId = /* @__PURE__ */ Symbol.for("SampleEntryIdentifier"), Sr), mh = class extends pt {
}, Wt = class extends pt {
  /** @bundle box-codecs.js */
  isMetadata() {
    return !0;
  }
}, kt = class extends pt {
  /** @bundle box-codecs.js */
  isSubtitle() {
    return !0;
  }
}, pf = class extends pt {
}, ce = class extends pt {
  parse(e) {
    this.parseHeader(e), e.readUint16(), e.readUint16(), e.readUint32Array(3), this.width = e.readUint16(), this.height = e.readUint16(), this.horizresolution = e.readUint32(), this.vertresolution = e.readUint32(), e.readUint32(), this.frame_count = e.readUint16();
    const t = Math.min(31, e.readUint8());
    this.compressorname = e.readString(t), t < 31 && e.readString(31 - t), this.depth = e.readUint16(), e.readUint16(), this.parseFooter(e);
  }
  /** @bundle box-codecs.js */
  isVideo() {
    return !0;
  }
  /** @bundle box-codecs.js */
  getWidth() {
    return this.width;
  }
  /** @bundle box-codecs.js */
  getHeight() {
    return this.height;
  }
  /** @bundle writing/sampleentries/sampleentry.js */
  write(e) {
    this.writeHeader(e), this.size += 70, e.writeUint16(0), e.writeUint16(0), e.writeUint32(0), e.writeUint32(0), e.writeUint32(0), e.writeUint16(this.width), e.writeUint16(this.height), e.writeUint32(this.horizresolution), e.writeUint32(this.vertresolution), e.writeUint32(0), e.writeUint16(this.frame_count), e.writeUint8(Math.min(31, this.compressorname.length)), e.writeString(this.compressorname, void 0, 31), e.writeUint16(this.depth), e.writeInt16(-1), this.writeFooter(e);
  }
}, Re = class extends pt {
  parse(e) {
    this.parseHeader(e), this.version = e.readUint16(), e.readUint16(), e.readUint32(), this.channel_count = e.readUint16(), this.samplesize = e.readUint16(), e.readUint16(), e.readUint16(), this.samplerate = e.readUint32() / 65536, e.isofile?.ftyp?.major_brand.includes("qt") && (this.version === 1 ? this.extensions = e.readUint8Array(16) : this.version === 2 && (this.extensions = e.readUint8Array(36))), this.parseFooter(e);
  }
  /** @bundle box-codecs.js */
  isAudio() {
    return !0;
  }
  /** @bundle box-codecs.js */
  getChannelCount() {
    return this.channel_count;
  }
  /** @bundle box-codecs.js */
  getSampleRate() {
    return this.samplerate;
  }
  /** @bundle box-codecs.js */
  getSampleSize() {
    return this.samplesize;
  }
  /** @bundle writing/sampleentry.js */
  write(e) {
    this.writeHeader(e), this.size += 20, e.writeUint32(0), e.writeUint32(0), e.writeUint16(this.channel_count), e.writeUint16(this.samplesize), e.writeUint16(0), e.writeUint16(0), e.writeUint32(this.samplerate << 16), this.writeFooter(e);
  }
}, cr = class extends pt {
  parse(i) {
    this.parseHeader(i), this.parseFooter(i);
  }
  /** @bundle writing/sampleentry.js */
  write(i) {
    this.writeHeader(i), this.writeFooter(i);
  }
}, Iu = class extends Array {
  toString() {
    let i = "<table class='inner-table'>";
    i += "<thead><tr><th>length</th><th>nalu_data</th></tr></thead>", i += "<tbody>";
    for (let e = 0; e < this.length; e++) {
      const t = this[e];
      i += "<tr>", i += "<td>" + t.length + "</td>", i += "<td>", i += t.data.reduce(function(s, r) {
        return s + r.toString(16).padStart(2, "0");
      }, "0x"), i += "</td></tr>";
    }
    return i += "</tbody></table>", i;
  }
}, Cr, mf = (Cr = class extends P {
  constructor() {
    super(...arguments), this.box_name = "AVCConfigurationBox";
  }
  parse(i) {
    this.configurationVersion = i.readUint8(), this.AVCProfileIndication = i.readUint8(), this.profile_compatibility = i.readUint8(), this.AVCLevelIndication = i.readUint8(), this.lengthSizeMinusOne = i.readUint8() & 3, this.nb_SPS_nalus = i.readUint8() & 31;
    let e = this.size - this.hdr_size - 6;
    this.SPS = new Iu();
    for (let t = 0; t < this.nb_SPS_nalus; t++) {
      const s = i.readUint16();
      this.SPS.push({ length: s, data: i.readUint8Array(s) }), e -= 2 + s;
    }
    this.nb_PPS_nalus = i.readUint8(), e--, this.PPS = new Iu();
    for (let t = 0; t < this.nb_PPS_nalus; t++) {
      const s = i.readUint16();
      this.PPS.push({ length: s, data: i.readUint8Array(s) }), e -= 2 + s;
    }
    e > 0 && (this.ext = i.readUint8Array(e));
  }
  /** @bundle writing/avcC.js */
  write(i) {
    this.size = 7;
    for (let e = 0; e < this.SPS.length; e++)
      this.size += 2 + this.SPS[e].length;
    for (let e = 0; e < this.PPS.length; e++)
      this.size += 2 + this.PPS[e].length;
    this.ext && (this.size += this.ext.length), this.writeHeader(i), i.writeUint8(this.configurationVersion), i.writeUint8(this.AVCProfileIndication), i.writeUint8(this.profile_compatibility), i.writeUint8(this.AVCLevelIndication), i.writeUint8(this.lengthSizeMinusOne + 252), i.writeUint8(this.SPS.length + 224);
    for (let e = 0; e < this.SPS.length; e++)
      i.writeUint16(this.SPS[e].length), i.writeUint8Array(this.SPS[e].data);
    i.writeUint8(this.PPS.length);
    for (let e = 0; e < this.PPS.length; e++)
      i.writeUint16(this.PPS[e].length), i.writeUint8Array(this.PPS[e].data);
    this.ext && i.writeUint8Array(this.ext);
  }
}, Cr.fourcc = "avcC", Cr), Ar, Bs = (Ar = class extends P {
  constructor() {
    super(...arguments), this.box_name = "MediaDataBox";
  }
}, Ar.fourcc = "mdat", Ar), Ir, xg = (Ir = class extends P {
  constructor() {
    super(...arguments), this.box_name = "ItemDataBox";
  }
}, Ir.fourcc = "idat", Ir), kr, yg = (kr = class extends P {
  constructor() {
    super(...arguments), this.box_name = "FreeSpaceBox";
  }
}, kr.fourcc = "free", kr), Fr, vg = (Fr = class extends P {
  constructor() {
    super(...arguments), this.box_name = "FreeSpaceBox";
  }
}, Fr.fourcc = "skip", Fr), Mr, gf = (Mr = class extends F {
  constructor() {
    super(...arguments), this.box_name = "HintMediaHeaderBox";
  }
}, Mr.fourcc = "hmhd", Mr), Er, zs = (Er = class extends F {
  constructor() {
    super(...arguments), this.box_name = "NullMediaHeaderBox";
  }
}, Er.fourcc = "nmhd", Er), Pr, _g = (Pr = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ObjectDescriptorBox";
  }
}, Pr.fourcc = "iods", Pr), Ur, bg = (Ur = class extends F {
  constructor() {
    super(...arguments), this.box_name = "XMLBox";
  }
}, Ur.fourcc = "xml ", Ur), Rr, wg = (Rr = class extends F {
  constructor() {
    super(...arguments), this.box_name = "BinaryXMLBox";
  }
}, Rr.fourcc = "bxml", Rr), Br, Tg = (Br = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ItemProtectionBox", this.sinfs = [];
  }
  get protections() {
    return this.sinfs;
  }
}, Br.fourcc = "ipro", Br), zr, gh = (zr = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "MovieBox", this.traks = [], this.psshs = [], this.subBoxNames = ["trak", "pssh"];
  }
}, zr.fourcc = "moov", zr), Or, xf = (Or = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "TrackBox", this.samples = [];
  }
}, Or.fourcc = "trak", Or), Dr, Sg = (Dr = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "EditBox";
  }
}, Dr.fourcc = "edts", Dr), Lr, yf = (Lr = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "MediaBox";
  }
}, Lr.fourcc = "mdia", Lr), Nr, vf = (Nr = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "MediaInformationBox";
  }
}, Nr.fourcc = "minf", Nr), Gr, _f = (Gr = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "DataInformationBox";
  }
}, Gr.fourcc = "dinf", Gr), Hr, bf = (Hr = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "SampleTableBox", this.sgpds = [], this.sbgps = [], this.subBoxNames = ["sgpd", "sbgp"];
  }
}, Hr.fourcc = "stbl", Hr), Wr, xh = (Wr = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "MovieExtendsBox", this.trexs = [], this.subBoxNames = ["trex"];
  }
}, Wr.fourcc = "mvex", Wr), Vr, wf = (Vr = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "MovieFragmentBox", this.trafs = [], this.subBoxNames = ["traf"];
  }
}, Vr.fourcc = "moof", Vr), $r, Tf = ($r = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "TrackFragmentBox", this.truns = [], this.sgpds = [], this.sbgps = [], this.subBoxNames = ["trun", "sgpd", "sbgp"];
  }
}, $r.fourcc = "traf", $r), Yr, Cg = (Yr = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "VTTCueBox";
  }
}, Yr.fourcc = "vttc", Yr), Xr, Ag = (Xr = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "MovieFragmentRandomAccessBox", this.tfras = [], this.subBoxNames = ["tfra"];
  }
}, Xr.fourcc = "mfra", Xr), qr, Ig = (qr = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "AdditionalMetadataContainerBox";
  }
}, qr.fourcc = "meco", qr), Zr, kg = (Zr = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "trackhintinformation", this.subBoxNames = ["sdp ", "rtp "];
  }
}, Zr.fourcc = "hnti", Zr), Kr, Fg = (Kr = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "hintstatisticsbox", this.maxrs = [], this.subBoxNames = ["maxr"];
  }
}, Kr.fourcc = "hinf", Kr), Jr, Mg = (Jr = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "SubTrackBox";
  }
}, Jr.fourcc = "strk", Jr), jr, Eg = (jr = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "SubTrackDefinitionBox";
  }
}, jr.fourcc = "strd", jr), Qr, Pg = (Qr = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "ProtectionSchemeInfoBox";
  }
}, Qr.fourcc = "sinf", Qr), en, Ug = (en = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "RestrictedSchemeInfoBox";
  }
}, en.fourcc = "rinf", en), tn, Rg = (tn = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "SchemeInformationBox";
  }
}, tn.fourcc = "schi", tn), sn, Bg = (sn = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "TrackGroupBox";
  }
}, sn.fourcc = "trgr", sn), rn, zg = (rn = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "UserDataBox", this.kinds = [], this.strks = [], this.subBoxNames = ["kind", "strk"];
  }
}, rn.fourcc = "udta", rn), nn, Og = (nn = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "ItemPropertiesBox", this.ipmas = [], this.subBoxNames = ["ipma"];
  }
}, nn.fourcc = "iprp", nn), on, Dg = (on = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "ItemPropertyContainerBox", this.hvcCs = [], this.ispes = [], this.claps = [], this.irots = [], this.subBoxNames = ["hvcC", "ispe", "clap", "irot"];
  }
}, on.fourcc = "ipco", on), an, Lg = (an = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "GroupsListBox";
  }
}, an.fourcc = "grpl", an), ln, Ng = (ln = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "J2KHeaderInfoBox";
  }
}, ln.fourcc = "j2kH", ln), cn, Gg = (cn = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "ExtendedTypeBox", this.tycos = [], this.subBoxNames = ["tyco"];
  }
}, cn.fourcc = "etyp", cn), hn, Hg = (hn = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "ProjectedOmniVideoBox", this.subBoxNames = ["prfr"];
  }
}, hn.fourcc = "povd", hn), un, Sf = (un = class extends F {
  constructor() {
    super(...arguments), this.box_name = "DataReferenceBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.entries = [];
    const e = i.readUint32();
    for (let t = 0; t < e; t++) {
      const s = st(i, !1, this.size - (i.getPosition() - this.start));
      if (s.code === De) {
        const r = s.box;
        this.entries.push(r);
      } else
        return;
    }
  }
  /** @bundle writing/dref.js */
  write(i) {
    this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(i), i.writeUint32(this.entries.length);
    for (let e = 0; e < this.entries.length; e++)
      this.entries[e].write(i), this.size += this.entries[e].size;
    I.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), i.adjustUint32(this.sizePosition, this.size);
  }
}, un.fourcc = "dref", un), dn, Cf = (dn = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ExtendedLanguageBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.extended_language = i.readString(this.size - this.hdr_size);
  }
  /** @bundle writing/elng.js */
  write(i) {
    this.version = 0, this.flags = 0, this.size = this.extended_language.length, this.writeHeader(i), i.writeString(this.extended_language);
  }
}, dn.fourcc = "elng", dn), fn, Af = (fn = class extends P {
  constructor() {
    super(...arguments), this.box_name = "FileTypeBox";
  }
  parse(i) {
    let e = this.size - this.hdr_size;
    this.major_brand = i.readString(4), this.minor_version = i.readUint32(), e -= 8, this.compatible_brands = [];
    let t = 0;
    for (; e >= 4; )
      this.compatible_brands[t] = i.readString(4), e -= 4, t++;
  }
  /** @bundle writing/ftyp.js */
  write(i) {
    this.size = 8 + 4 * this.compatible_brands.length, this.writeHeader(i), i.writeString(this.major_brand, void 0, 4), i.writeUint32(this.minor_version);
    for (let e = 0; e < this.compatible_brands.length; e++)
      i.writeString(this.compatible_brands[e], void 0, 4);
  }
}, fn.fourcc = "ftyp", fn), pn, If = (pn = class extends F {
  constructor() {
    super(...arguments), this.box_name = "HandlerBox";
  }
  parse(i) {
    if (this.parseFullHeader(i), this.version === 0 && (i.readUint32(), this.handler = i.readString(4), i.readUint32Array(3), !this.isEndOfBox(i))) {
      const e = this.start + this.size - i.getPosition();
      this.name = i.readCString();
      const t = this.start + this.size - 1;
      i.seek(t), i.readUint8() !== 0 && e > 1 && (I.info(
        "BoxParser",
        "Warning: hdlr name is not null-terminated, possibly length-prefixed string. Trimming first byte."
      ), this.name = this.name.slice(1));
    }
  }
  /** @bundle writing/hldr.js */
  write(i) {
    this.size = 20 + this.name.length + 1, this.version = 0, this.flags = 0, this.writeHeader(i), i.writeUint32(0), i.writeString(this.handler, void 0, 4), i.writeUint32Array([0, 0, 0]), i.writeCString(this.name);
  }
}, pn.fourcc = "hdlr", pn), mn, kf = (mn = class extends P {
  constructor() {
    super(...arguments), this.box_name = "HEVCConfigurationBox";
  }
  parse(i) {
    this.configurationVersion = i.readUint8();
    let e = i.readUint8();
    this.general_profile_space = e >> 6, this.general_tier_flag = (e & 32) >> 5, this.general_profile_idc = e & 31, this.general_profile_compatibility = i.readUint32(), this.general_constraint_indicator = i.readUint8Array(6), this.general_level_idc = i.readUint8(), this.min_spatial_segmentation_idc = i.readUint16() & 4095, this.parallelismType = i.readUint8() & 3, this.chroma_format_idc = i.readUint8() & 3, this.bit_depth_luma_minus8 = i.readUint8() & 7, this.bit_depth_chroma_minus8 = i.readUint8() & 7, this.avgFrameRate = i.readUint16(), e = i.readUint8(), this.constantFrameRate = e >> 6, this.numTemporalLayers = (e & 13) >> 3, this.temporalIdNested = (e & 4) >> 2, this.lengthSizeMinusOne = e & 3, this.nalu_arrays = [];
    const t = i.readUint8();
    for (let s = 0; s < t; s++) {
      const r = [];
      this.nalu_arrays.push(r), e = i.readUint8(), r.completeness = (e & 128) >> 7, r.nalu_type = e & 63;
      const n = i.readUint16();
      for (let o = 0; o < n; o++) {
        const a = i.readUint16();
        r.push({
          data: i.readUint8Array(a)
        });
      }
    }
  }
  /** @bundle writing/write.js */
  write(i) {
    this.size = 23;
    for (let e = 0; e < this.nalu_arrays.length; e++) {
      this.size += 3;
      for (let t = 0; t < this.nalu_arrays[e].length; t++)
        this.size += 2 + this.nalu_arrays[e][t].data.length;
    }
    this.writeHeader(i), i.writeUint8(this.configurationVersion), i.writeUint8(
      (this.general_profile_space << 6) + (this.general_tier_flag << 5) + this.general_profile_idc
    ), i.writeUint32(this.general_profile_compatibility), i.writeUint8Array(this.general_constraint_indicator), i.writeUint8(this.general_level_idc), i.writeUint16(this.min_spatial_segmentation_idc + (15 << 24)), i.writeUint8(this.parallelismType + 252), i.writeUint8(this.chroma_format_idc + 252), i.writeUint8(this.bit_depth_luma_minus8 + 248), i.writeUint8(this.bit_depth_chroma_minus8 + 248), i.writeUint16(this.avgFrameRate), i.writeUint8(
      (this.constantFrameRate << 6) + (this.numTemporalLayers << 3) + (this.temporalIdNested << 2) + this.lengthSizeMinusOne
    ), i.writeUint8(this.nalu_arrays.length);
    for (let e = 0; e < this.nalu_arrays.length; e++) {
      i.writeUint8((this.nalu_arrays[e].completeness << 7) + this.nalu_arrays[e].nalu_type), i.writeUint16(this.nalu_arrays[e].length);
      for (let t = 0; t < this.nalu_arrays[e].length; t++)
        i.writeUint16(this.nalu_arrays[e][t].data.length), i.writeUint8Array(this.nalu_arrays[e][t].data);
    }
  }
}, mn.fourcc = "hvcC", mn), gn, Ff = (gn = class extends F {
  constructor() {
    super(...arguments), this.box_name = "MediaHeaderBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.version === 1 ? (this.creation_time = i.readUint64(), this.modification_time = i.readUint64(), this.timescale = i.readUint32(), this.duration = i.readUint64()) : (this.creation_time = i.readUint32(), this.modification_time = i.readUint32(), this.timescale = i.readUint32(), this.duration = i.readUint32()), this.parseLanguage(i), i.readUint16();
  }
  /** @bundle writing/mdhd.js */
  write(i) {
    const e = this.modification_time > be || this.creation_time > be || this.duration > be || this.version === 1;
    this.version = e ? 1 : 0, this.size = 20, this.size += e ? 12 : 0, this.flags = 0, this.writeHeader(i), e ? (i.writeUint64(this.creation_time), i.writeUint64(this.modification_time), i.writeUint32(this.timescale), i.writeUint64(this.duration)) : (i.writeUint32(this.creation_time), i.writeUint32(this.modification_time), i.writeUint32(this.timescale), i.writeUint32(this.duration)), i.writeUint16(this.language), i.writeUint16(0);
  }
}, gn.fourcc = "mdhd", gn), xn, Mf = (xn = class extends F {
  constructor() {
    super(...arguments), this.box_name = "MovieExtendsHeaderBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.flags & 1 && (I.warn("BoxParser", "mehd box incorrectly uses flags set to 1, converting version to 1"), this.version = 1), this.version === 1 ? this.fragment_duration = i.readUint64() : this.fragment_duration = i.readUint32();
  }
  /** @bundle writing/mehd.js */
  write(i) {
    const e = this.fragment_duration > be || this.version === 1;
    this.version = e ? 1 : 0, this.size = 4, this.size += e ? 4 : 0, this.flags = 0, this.writeHeader(i), e ? i.writeUint64(this.fragment_duration) : i.writeUint32(this.fragment_duration);
  }
}, xn.fourcc = "mehd", xn), yn, Wg = (yn = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ItemInfoEntry";
  }
  parse(i) {
    if (this.parseFullHeader(i), (this.version === 0 || this.version === 1) && (this.item_ID = i.readUint16(), this.item_protection_index = i.readUint16(), this.item_name = i.readCString(), this.content_type = i.readCString(), this.isEndOfBox(i) || (this.content_encoding = i.readCString())), this.version === 1) {
      this.extension_type = i.readString(4), I.warn("BoxParser", "Cannot parse extension type"), i.seek(this.start + this.size);
      return;
    }
    this.version >= 2 && (this.version === 2 ? this.item_ID = i.readUint16() : this.version === 3 && (this.item_ID = i.readUint32()), this.item_protection_index = i.readUint16(), this.item_type = i.readString(4), this.item_name = i.readCString(), this.item_type === "mime" ? (this.content_type = i.readCString(), this.content_encoding = i.readCString()) : this.item_type === "uri " && (this.item_uri_type = i.readCString()));
  }
}, yn.fourcc = "infe", yn), vn, Vg = (vn = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ItemInfoBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.version === 0 ? this.entry_count = i.readUint16() : this.entry_count = i.readUint32(), this.item_infos = [];
    for (let e = 0; e < this.entry_count; e++) {
      const t = st(i, !1, this.size - (i.getPosition() - this.start));
      if (t.code === De) {
        const s = t.box;
        s.type === "infe" ? this.item_infos[e] = s : I.error("BoxParser", "Expected 'infe' box, got " + t.box.type, i.isofile);
      } else
        return;
    }
  }
}, vn.fourcc = "iinf", vn), _n, $g = (_n = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ItemLocationBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    let e;
    e = i.readUint8(), this.offset_size = e >> 4 & 15, this.length_size = e & 15, e = i.readUint8(), this.base_offset_size = e >> 4 & 15, this.version === 1 || this.version === 2 ? this.index_size = e & 15 : this.index_size = 0, this.items = [];
    let t = 0;
    if (this.version < 2)
      t = i.readUint16();
    else if (this.version === 2)
      t = i.readUint32();
    else
      throw new Error("version of iloc box not supported");
    for (let s = 0; s < t; s++) {
      let r = 0, n = 0, o = 0;
      if (this.version < 2)
        r = i.readUint16();
      else if (this.version === 2)
        r = i.readUint32();
      else
        throw new Error("version of iloc box not supported");
      this.version === 1 || this.version === 2 ? n = i.readUint16() & 15 : n = 0;
      const a = i.readUint16();
      switch (this.base_offset_size) {
        case 0:
          o = 0;
          break;
        case 4:
          o = i.readUint32();
          break;
        case 8:
          o = i.readUint64();
          break;
        default:
          throw new Error("Error reading base offset size");
      }
      const l = [], c = i.readUint16();
      for (let h = 0; h < c; h++) {
        let u = 0, d = 0, f = 0;
        if (this.version === 1 || this.version === 2)
          switch (this.index_size) {
            case 0:
              u = 0;
              break;
            case 4:
              u = i.readUint32();
              break;
            case 8:
              u = i.readUint64();
              break;
            default:
              throw new Error("Error reading extent index");
          }
        switch (this.offset_size) {
          case 0:
            d = 0;
            break;
          case 4:
            d = i.readUint32();
            break;
          case 8:
            d = i.readUint64();
            break;
          default:
            throw new Error("Error reading extent index");
        }
        switch (this.length_size) {
          case 0:
            f = 0;
            break;
          case 4:
            f = i.readUint32();
            break;
          case 8:
            f = i.readUint64();
            break;
          default:
            throw new Error("Error reading extent index");
        }
        l.push({ extent_index: u, extent_length: f, extent_offset: d });
      }
      this.items.push({
        base_offset: o,
        construction_method: n,
        item_ID: r,
        data_reference_index: a,
        extents: l
      });
    }
  }
}, _n.fourcc = "iloc", _n), Yg = {
  auxl: "Auxiliary image item",
  base: "Pre-derived image item base",
  cdsc: "Item describes referenced item",
  dimg: "Derived image item",
  dpnd: "Item coding dependency",
  eroi: "Region",
  evir: "EVC slice",
  exbl: "Scalable image item",
  "fdl ": "File delivery",
  font: "Font item",
  iloc: "Item data location",
  mask: "Region mask",
  mint: "Data integrity",
  pred: "Predictively coded item",
  prem: "Pre-multiplied item",
  tbas: "HEVC tile track base item",
  text: "Text item",
  thmb: "Thumbnail image item"
}, bi, Xg = (bi = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ItemReferenceBox", this.references = [];
  }
  parse(i) {
    for (this.parseFullHeader(i), this.references = []; i.getPosition() < this.start + this.size; ) {
      const e = st(i, !0, this.size - (i.getPosition() - this.start));
      if (e.code === De) {
        let t = "Unknown item reference";
        bi.allowed_types.includes(e.type) ? t = Yg[e.type] : I.warn("BoxParser", `Unknown item reference type: '${e.type}'`);
        const s = this.version === 0 ? new cf(e.type, e.size, t, e.hdr_size, e.start) : new hf(
          e.type,
          e.size,
          t,
          e.hdr_size,
          e.start
        );
        s.write === P.prototype.write && s.type !== "mdat" && (I.warn(
          "BoxParser",
          s.type + " box writing not yet implemented, keeping unparsed data in memory for later write"
        ), s.parseDataAndRewind(i)), s.parse(i), this.references.push(s);
      } else
        return;
    }
  }
}, bi.fourcc = "iref", bi.allowed_types = [
  "auxl",
  "base",
  "cdsc",
  "dimg",
  "dpnd",
  "eroi",
  "evir",
  "exbl",
  "fdl ",
  "font",
  "iloc",
  "mask",
  "mint",
  "pred",
  "prem",
  "tbas",
  "text",
  "thmb"
], bi), bn, qg = (bn = class extends F {
  constructor() {
    super(...arguments), this.box_name = "PrimaryItemBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.version === 0 ? this.item_id = i.readUint16() : this.item_id = i.readUint32();
  }
}, bn.fourcc = "pitm", bn), wn, Zg = (wn = class extends F {
  constructor() {
    super(...arguments), this.box_name = "MetaBox", this.isQT = !1;
  }
  parse(i) {
    const e = i.getPosition();
    if (this.size > 8) {
      switch (i.readUint32(), i.readString(4)) {
        case "hdlr":
        case "mhdr":
        case "keys":
        case "ilst":
        case "ctry":
        case "lang":
          this.isQT = !0;
          break;
      }
      i.seek(e);
    }
    this.isQT || this.parseFullHeader(i), Z.prototype.parse.call(this, i);
  }
}, wn.fourcc = "meta", wn), Tn, Ef = (Tn = class extends F {
  constructor() {
    super(...arguments), this.box_name = "MovieFragmentHeaderBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.sequence_number = i.readUint32();
  }
  /** @bundle writing/mfhd.js */
  write(i) {
    this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(i), i.writeUint32(this.sequence_number);
  }
}, Tn.fourcc = "mfhd", Tn), Sn, Pf = (Sn = class extends F {
  constructor() {
    super(...arguments), this.box_name = "MovieHeaderBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.version === 1 ? (this.creation_time = i.readUint64(), this.modification_time = i.readUint64(), this.timescale = i.readUint32(), this.duration = i.readUint64()) : (this.creation_time = i.readUint32(), this.modification_time = i.readUint32(), this.timescale = i.readUint32(), this.duration = i.readUint32()), this.rate = i.readUint32(), this.volume = i.readUint16() >> 8, i.readUint16(), i.readUint32Array(2), this.matrix = i.readInt32Array(9), i.readUint32Array(6), this.next_track_id = i.readUint32();
  }
  /** @bundle writing/mvhd.js */
  write(i) {
    const e = this.modification_time > be || this.creation_time > be || this.duration > be || this.version === 1;
    this.version = e ? 1 : 0, this.size = 96, this.size += e ? 12 : 0, this.flags = 0, this.writeHeader(i), e ? (i.writeUint64(this.creation_time), i.writeUint64(this.modification_time), i.writeUint32(this.timescale), i.writeUint64(this.duration)) : (i.writeUint32(this.creation_time), i.writeUint32(this.modification_time), i.writeUint32(this.timescale), i.writeUint32(this.duration)), i.writeUint32(this.rate), i.writeUint16(this.volume << 8), i.writeUint16(0), i.writeUint32(0), i.writeUint32(0), i.writeInt32Array(this.matrix), i.writeUint32(0), i.writeUint32(0), i.writeUint32(0), i.writeUint32(0), i.writeUint32(0), i.writeUint32(0), i.writeUint32(this.next_track_id);
  }
  /** @bundle box-print.js */
  print(i) {
    super.printHeader(i), i.log(i.indent + "creation_time: " + this.creation_time), i.log(i.indent + "modification_time: " + this.modification_time), i.log(i.indent + "timescale: " + this.timescale), i.log(i.indent + "duration: " + this.duration), i.log(i.indent + "rate: " + this.rate), i.log(i.indent + "volume: " + (this.volume >> 8)), i.log(i.indent + "matrix: " + this.matrix.join(", ")), i.log(i.indent + "next_track_id: " + this.next_track_id);
  }
}, Sn.fourcc = "mvhd", Sn), Cn, Kg = (Cn = class extends Wt {
  parse(i) {
    this.parseHeader(i), this.content_encoding = i.readCString(), this.mime_format = i.readCString(), this.parseFooter(i);
  }
}, Cn.fourcc = "mett", Cn), An, Jg = (An = class extends Wt {
  parse(i) {
    this.parseHeader(i), this.content_encoding = i.readCString(), this.namespace = i.readCString(), this.schema_location = i.readCString(), this.parseFooter(i);
  }
}, An.fourcc = "metx", An), In, jg = (In = class extends P {
  constructor() {
    super(...arguments), this.box_name = "AV1CodecConfigurationBox";
  }
  parse(i) {
    let e = i.readUint8();
    if ((e >> 7 & 1) !== 1) {
      I.error("BoxParser", "av1C marker problem", i.isofile);
      return;
    }
    if (this.version = e & 127, this.version !== 1) {
      I.error("BoxParser", "av1C version " + this.version + " not supported", i.isofile);
      return;
    }
    if (e = i.readUint8(), this.seq_profile = e >> 5 & 7, this.seq_level_idx_0 = e & 31, e = i.readUint8(), this.seq_tier_0 = e >> 7 & 1, this.high_bitdepth = e >> 6 & 1, this.twelve_bit = e >> 5 & 1, this.monochrome = e >> 4 & 1, this.chroma_subsampling_x = e >> 3 & 1, this.chroma_subsampling_y = e >> 2 & 1, this.chroma_sample_position = e & 3, e = i.readUint8(), this.reserved_1 = e >> 5 & 7, this.reserved_1 !== 0) {
      I.error("BoxParser", "av1C reserved_1 parsing problem", i.isofile);
      return;
    }
    if (this.initial_presentation_delay_present = e >> 4 & 1, this.initial_presentation_delay_present === 1)
      this.initial_presentation_delay_minus_one = e & 15;
    else if (this.reserved_2 = e & 15, this.reserved_2 !== 0) {
      I.error("BoxParser", "av1C reserved_2 parsing problem", i.isofile);
      return;
    }
    const t = this.size - this.hdr_size - 4;
    this.configOBUs = i.readUint8Array(t);
  }
}, In.fourcc = "av1C", In), kn, Qg = (kn = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ElementaryStreamDescriptorBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = i.readUint8Array(this.size - this.hdr_size);
    if ("MPEG4DescriptorParser" in js) {
      const t = new js.MPEG4DescriptorParser();
      this.esd = t.parseOneDescriptor(new we(e.buffer, 0));
    }
  }
}, kn.fourcc = "esds", kn), Fn, e0 = (Fn = class extends F {
  constructor() {
    super(...arguments), this.box_name = "VPCodecConfigurationRecord";
  }
  parse(i) {
    if (this.parseFullHeader(i), this.version === 1) {
      this.profile = i.readUint8(), this.level = i.readUint8();
      const e = i.readUint8();
      this.bitDepth = e >> 4, this.chromaSubsampling = e >> 1 & 7, this.videoFullRangeFlag = e & 1, this.colourPrimaries = i.readUint8(), this.transferCharacteristics = i.readUint8(), this.matrixCoefficients = i.readUint8(), this.codecIntializationDataSize = i.readUint16(), this.codecIntializationData = i.readUint8Array(this.codecIntializationDataSize);
    } else {
      this.profile = i.readUint8(), this.level = i.readUint8();
      let e = i.readUint8();
      this.bitDepth = e >> 4 & 15, this.colorSpace = e & 15, e = i.readUint8(), this.chromaSubsampling = e >> 4 & 15, this.transferFunction = e >> 1 & 7, this.videoFullRangeFlag = e & 1, this.codecIntializationDataSize = i.readUint16(), this.codecIntializationData = i.readUint8Array(this.codecIntializationDataSize);
    }
  }
}, Fn.fourcc = "vpcC", Fn), Mn, t0 = (Mn = class extends F {
  constructor() {
    super(...arguments), this.box_name = "VvcConfigurationBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = {
      held_bits: void 0,
      num_held_bits: 0,
      stream_read_1_bytes: function(n) {
        this.held_bits = n.readUint8(), this.num_held_bits = 8;
      },
      stream_read_2_bytes: function(n) {
        this.held_bits = n.readUint16(), this.num_held_bits = 16;
      },
      extract_bits: function(n) {
        const o = this.held_bits >> this.num_held_bits - n & (1 << n) - 1;
        return this.num_held_bits -= n, o;
      }
    };
    if (e.stream_read_1_bytes(i), e.extract_bits(5), this.lengthSizeMinusOne = e.extract_bits(2), this.ptl_present_flag = e.extract_bits(1), this.ptl_present_flag) {
      e.stream_read_2_bytes(i), this.ols_idx = e.extract_bits(9), this.num_sublayers = e.extract_bits(3), this.constant_frame_rate = e.extract_bits(2), this.chroma_format_idc = e.extract_bits(2), e.stream_read_1_bytes(i), this.bit_depth_minus8 = e.extract_bits(3), e.extract_bits(5);
      {
        if (e.stream_read_2_bytes(i), e.extract_bits(2), this.num_bytes_constraint_info = e.extract_bits(6), this.general_profile_idc = e.extract_bits(7), this.general_tier_flag = e.extract_bits(1), this.general_level_idc = i.readUint8(), e.stream_read_1_bytes(i), this.ptl_frame_only_constraint_flag = e.extract_bits(1), this.ptl_multilayer_enabled_flag = e.extract_bits(1), this.general_constraint_info = new Uint8Array(this.num_bytes_constraint_info), this.num_bytes_constraint_info) {
          for (let n = 0; n < this.num_bytes_constraint_info - 1; n++) {
            const o = e.extract_bits(6);
            e.stream_read_1_bytes(i);
            const a = e.extract_bits(2);
            this.general_constraint_info[n] = o << 2 | a;
          }
          this.general_constraint_info[this.num_bytes_constraint_info - 1] = e.extract_bits(6);
        } else
          e.extract_bits(6);
        if (this.num_sublayers > 1) {
          e.stream_read_1_bytes(i), this.ptl_sublayer_present_mask = 0;
          for (let n = this.num_sublayers - 2; n >= 0; --n) {
            const o = e.extract_bits(1);
            this.ptl_sublayer_present_mask |= o << n;
          }
          for (let n = this.num_sublayers; n <= 8 && this.num_sublayers > 1; ++n)
            e.extract_bits(1);
          this.sublayer_level_idc = [];
          for (let n = this.num_sublayers - 2; n >= 0; --n)
            this.ptl_sublayer_present_mask & 1 << n && (this.sublayer_level_idc[n] = i.readUint8());
        }
        if (this.ptl_num_sub_profiles = i.readUint8(), this.general_sub_profile_idc = [], this.ptl_num_sub_profiles)
          for (let n = 0; n < this.ptl_num_sub_profiles; n++)
            this.general_sub_profile_idc.push(i.readUint32());
      }
      this.max_picture_width = i.readUint16(), this.max_picture_height = i.readUint16(), this.avg_frame_rate = i.readUint16();
    }
    const t = 12, s = 13;
    this.nalu_arrays = [];
    const r = i.readUint8();
    for (let n = 0; n < r; n++) {
      const o = [];
      this.nalu_arrays.push(o), e.stream_read_1_bytes(i), o.completeness = e.extract_bits(1), e.extract_bits(2), o.nalu_type = e.extract_bits(5);
      let a = 1;
      o.nalu_type !== s && o.nalu_type !== t && (a = i.readUint16());
      for (let l = 0; l < a; l++) {
        const c = i.readUint16();
        o.push({
          data: i.readUint8Array(c),
          length: c
        });
      }
    }
  }
}, Mn.fourcc = "vvcC", Mn), En, i0 = (En = class extends P {
  constructor() {
    super(...arguments), this.box_name = "ColourInformationBox";
  }
  parse(i) {
    if (this.colour_type = i.readString(4), this.colour_type === "nclx") {
      this.colour_primaries = i.readUint16(), this.transfer_characteristics = i.readUint16(), this.matrix_coefficients = i.readUint16();
      const e = i.readUint8();
      this.full_range_flag = e >> 7;
    } else this.colour_type === "rICC" ? this.ICC_profile = i.readUint8Array(this.size - 4) : this.colour_type === "prof" && (this.ICC_profile = i.readUint8Array(this.size - 4));
  }
}, En.fourcc = "colr", En);
function oi(i, e) {
  let t = Number(i).toString(16);
  for (e = typeof e > "u" ? 2 : e; t.length < e; )
    t = "0" + t;
  return t;
}
var hr = class extends ce {
  /** @bundle box-codecs.js */
  getCodec() {
    const i = super.getCodec();
    return this.avcC ? `${i}.${oi(this.avcC.AVCProfileIndication)}${oi(
      this.avcC.profile_compatibility
    )}${oi(this.avcC.AVCLevelIndication)}` : i;
  }
}, Pn, s0 = (Pn = class extends hr {
  constructor() {
    super(...arguments), this.box_name = "AVCSampleEntry";
  }
}, Pn.fourcc = "avc1", Pn), Un, r0 = (Un = class extends hr {
  constructor() {
    super(...arguments), this.box_name = "AVC2SampleEntry";
  }
}, Un.fourcc = "avc2", Un), Rn, n0 = (Rn = class extends hr {
  constructor() {
    super(...arguments), this.box_name = "AVCSampleEntry";
  }
}, Rn.fourcc = "avc3", Rn), Bn, o0 = (Bn = class extends hr {
  constructor() {
    super(...arguments), this.box_name = "AVC2SampleEntry";
  }
}, Bn.fourcc = "avc4", Bn), zn, a0 = (zn = class extends ce {
  constructor() {
    super(...arguments), this.box_name = "AV1SampleEntry";
  }
  /** @bundle box-codecs.js */
  getCodec() {
    const i = super.getCodec(), e = this.av1C.seq_level_idx_0, t = e < 10 ? "0" + e : e;
    let s;
    return this.av1C.seq_profile === 2 && this.av1C.high_bitdepth === 1 ? s = this.av1C.twelve_bit === 1 ? "12" : "10" : this.av1C.seq_profile <= 2 && (s = this.av1C.high_bitdepth === 1 ? "10" : "08"), i + "." + this.av1C.seq_profile + "." + t + (this.av1C.seq_tier_0 ? "H" : "M") + "." + s;
  }
}, zn.fourcc = "av01", zn), On, l0 = (On = class extends ce {
}, On.fourcc = "dav1", On), ur = class extends ce {
  /** @bundle box-codecs.js */
  getCodec() {
    let i = super.getCodec();
    if (this.hvcC) {
      switch (i += ".", this.hvcC.general_profile_space) {
        case 0:
          i += "";
          break;
        case 1:
          i += "A";
          break;
        case 2:
          i += "B";
          break;
        case 3:
          i += "C";
          break;
      }
      i += this.hvcC.general_profile_idc, i += ".";
      let e = this.hvcC.general_profile_compatibility, t = 0;
      for (let n = 0; n < 32 && (t |= e & 1, n !== 31); n++)
        t <<= 1, e >>= 1;
      i += oi(t, 0), i += ".", this.hvcC.general_tier_flag === 0 ? i += "L" : i += "H", i += this.hvcC.general_level_idc;
      let s = !1, r = "";
      for (let n = 5; n >= 0; n--)
        (this.hvcC.general_constraint_indicator[n] || s) && (r = "." + oi(this.hvcC.general_constraint_indicator[n], 0) + r, s = !0);
      i += r;
    }
    return i;
  }
}, Dn, c0 = (Dn = class extends ur {
  constructor() {
    super(...arguments), this.box_name = "HEVCSampleEntry";
  }
}, Dn.fourcc = "hvc1", Dn), Ln, h0 = (Ln = class extends ur {
}, Ln.fourcc = "hvc2", Ln), Nn, u0 = (Nn = class extends ur {
  constructor() {
    super(...arguments), this.box_name = "HEVCSampleEntry", this.colrs = [], this.subBoxNames = ["colr"];
  }
}, Nn.fourcc = "hev1", Nn), Gn, d0 = (Gn = class extends ur {
}, Gn.fourcc = "hev2", Gn), Hn, f0 = (Hn = class extends ce {
  constructor() {
    super(...arguments), this.box_name = "HEVCTileSampleSampleEntry";
  }
}, Hn.fourcc = "hvt1", Hn), Wn, p0 = (Wn = class extends ce {
  constructor() {
    super(...arguments), this.box_name = "LHEVCSampleEntry";
  }
}, Wn.fourcc = "lhe1", Wn), Vn, m0 = (Vn = class extends ce {
  constructor() {
    super(...arguments), this.box_name = "LHEVCSampleEntry";
  }
}, Vn.fourcc = "lhv1", Vn), $n, g0 = ($n = class extends ce {
}, $n.fourcc = "dvh1", $n), Yn, x0 = (Yn = class extends ce {
}, Yn.fourcc = "dvhe", Yn), Uf = class extends ce {
  getCodec() {
    let i = super.getCodec();
    if (this.vvcC) {
      i += "." + this.vvcC.general_profile_idc, this.vvcC.general_tier_flag ? i += ".H" : i += ".L", i += this.vvcC.general_level_idc;
      let e = "";
      if (this.vvcC.general_constraint_info) {
        const t = [];
        let s = 0;
        s |= this.vvcC.ptl_frame_only_constraint_flag << 7, s |= this.vvcC.ptl_multilayer_enabled_flag << 6;
        let r;
        for (let n = 0; n < this.vvcC.general_constraint_info.length; ++n)
          s |= this.vvcC.general_constraint_info[n] >> 2 & 63, t.push(s), s && (r = n), s = this.vvcC.general_constraint_info[n] >> 2 & 3;
        if (r === void 0)
          e = ".CA";
        else {
          e = ".C";
          const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
          let o = 0, a = 0;
          for (let l = 0; l <= r; ++l)
            for (o = o << 8 | t[l], a += 8; a >= 5; ) {
              const c = o >> a - 5 & 31;
              e += n[c], a -= 5, o &= (1 << a) - 1;
            }
          a && (o <<= 5 - a, e += n[o & 31]);
        }
      }
      i += e;
    }
    return i;
  }
}, Xn, y0 = (Xn = class extends Uf {
  constructor() {
    super(...arguments), this.box_name = "VvcSampleEntry";
  }
}, Xn.fourcc = "vvc1", Xn), qn, v0 = (qn = class extends Uf {
  constructor() {
    super(...arguments), this.box_name = "VvcSampleEntry";
  }
}, qn.fourcc = "vvi1", qn), Zn, _0 = (Zn = class extends ce {
  constructor() {
    super(...arguments), this.box_name = "VvcSampleEntry";
  }
}, Zn.fourcc = "vvs1", Zn), Kn, b0 = (Kn = class extends ce {
  constructor() {
    super(...arguments), this.box_name = "VvcNonVCLSampleEntry";
  }
}, Kn.fourcc = "vvcN", Kn), Rf = class extends ce {
  getCodec() {
    const i = super.getCodec();
    let e = this.vpcC.level;
    e === 0 && (e = "00");
    let t = this.vpcC.bitDepth;
    return t === 8 && (t = "08"), `${i}.0${this.vpcC.profile}.${e}.${t}`;
  }
}, Jn, w0 = (Jn = class extends Rf {
}, Jn.fourcc = "vp08", Jn), jn, T0 = (jn = class extends Rf {
}, jn.fourcc = "vp09", jn), Qn, S0 = (Qn = class extends ce {
}, Qn.fourcc = "avs3", Qn), eo, C0 = (eo = class extends ce {
  constructor() {
    super(...arguments), this.box_name = "J2KSampleEntry";
  }
}, eo.fourcc = "j2ki", eo), to, A0 = (to = class extends ce {
}, to.fourcc = "mjp2", to), io, I0 = (io = class extends ce {
}, io.fourcc = "mjpg", io), so, k0 = (so = class extends ce {
  constructor() {
    super(...arguments), this.box_name = "UncompressedVideoSampleEntry";
  }
}, so.fourcc = "uncv", so), ro, F0 = (ro = class extends ce {
  constructor() {
    super(...arguments), this.box_name = "MP4VisualSampleEntry";
  }
}, ro.fourcc = "mp4v", ro), no, M0 = (no = class extends Re {
  constructor() {
    super(...arguments), this.box_name = "MP4AudioSampleEntry";
  }
  getCodec() {
    const i = super.getCodec();
    if (this.esds && this.esds.esd) {
      const e = this.esds.esd.getOTI(), t = this.esds.esd.getAudioConfig();
      return i + "." + oi(e) + (t ? "." + t : "");
    } else
      return i;
  }
}, no.fourcc = "mp4a", no), oo, E0 = (oo = class extends Re {
}, oo.fourcc = "m4ae", oo), ao, P0 = (ao = class extends Re {
}, ao.fourcc = "ac-3", ao), lo, U0 = (lo = class extends Re {
}, lo.fourcc = "ac-4", lo), co, R0 = (co = class extends Re {
}, co.fourcc = "ec-3", co), ho, B0 = (ho = class extends Re {
}, ho.fourcc = "Opus", ho), uo, z0 = (uo = class extends Re {
}, uo.fourcc = "mha1", uo), fo, O0 = (fo = class extends Re {
}, fo.fourcc = "mha2", fo), po, D0 = (po = class extends Re {
}, po.fourcc = "mhm1", po), mo, L0 = (mo = class extends Re {
}, mo.fourcc = "mhm2", mo), go, N0 = (go = class extends Re {
}, go.fourcc = "fLaC", go), xo, G0 = (xo = class extends ce {
}, xo.fourcc = "encv", xo), yo, H0 = (yo = class extends Re {
}, yo.fourcc = "enca", yo), vo, W0 = (vo = class extends kt {
  constructor() {
    super(...arguments), this.subBoxNames = ["sinf"], this.sinfs = [];
  }
}, vo.fourcc = "encu", vo), _o, V0 = (_o = class extends cr {
  constructor() {
    super(...arguments), this.subBoxNames = ["sinf"], this.sinfs = [];
  }
}, _o.fourcc = "encs", _o), bo, $0 = (bo = class extends cr {
}, bo.fourcc = "mp4s", bo), wo, Y0 = (wo = class extends pf {
  constructor() {
    super(...arguments), this.subBoxNames = ["sinf"], this.sinfs = [];
  }
}, wo.fourcc = "enct", wo), To, X0 = (To = class extends Wt {
  constructor() {
    super(...arguments), this.subBoxNames = ["sinf"], this.sinfs = [];
  }
}, To.fourcc = "encm", To), So, q0 = (So = class extends ce {
  constructor() {
    super(...arguments), this.box_name = "RestrictedVideoSampleEntry";
  }
}, So.fourcc = "resv", So), Co, Z0 = (Co = class extends kt {
  parse(i) {
    this.parseHeader(i), this.content_encoding = i.readCString(), this.mime_format = i.readCString(), this.parseFooter(i);
  }
}, Co.fourcc = "sbtt", Co), Ao, Bf = (Ao = class extends kt {
  parse(i) {
    this.parseHeader(i), this.namespace = i.readCString(), this.schema_location = i.readCString(), this.auxiliary_mime_types = i.readCString(), this.parseFooter(i);
  }
  /** @bundle writing/sampleentry.js */
  write(i) {
    this.writeHeader(i), this.size += this.namespace.length + 1 + this.schema_location.length + 1 + this.auxiliary_mime_types.length + 1, i.writeCString(this.namespace), i.writeCString(this.schema_location), i.writeCString(this.auxiliary_mime_types), this.writeFooter(i);
  }
}, Ao.fourcc = "stpp", Ao), Io, K0 = (Io = class extends kt {
  parse(i) {
    this.parseHeader(i), this.content_encoding = i.readCString(), this.mime_format = i.readCString(), this.parseFooter(i);
  }
  getCodec() {
    const i = super.getCodec();
    return this.mime_format ? i + "." + this.mime_format : i;
  }
}, Io.fourcc = "stxt", Io), ko, J0 = (ko = class extends kt {
  parse(i) {
    this.parseHeader(i), this.displayFlags = i.readUint32(), this.horizontal_justification = i.readInt8(), this.vertical_justification = i.readInt8(), this.bg_color_rgba = i.readUint8Array(4), this.box_record = i.readInt16Array(4), this.style_record = i.readUint8Array(12), this.parseFooter(i);
  }
}, ko.fourcc = "tx3g", ko), Fo, j0 = (Fo = class extends Wt {
  parse(i) {
    this.parseHeader(i), this.parseFooter(i);
  }
}, Fo.fourcc = "wvtt", Fo), Mo, Q0 = (Mo = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SampleToGroupBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.grouping_type = i.readString(4), this.version === 1 ? this.grouping_type_parameter = i.readUint32() : this.grouping_type_parameter = 0, this.entries = [];
    const e = i.readUint32();
    for (let t = 0; t < e; t++)
      this.entries.push({
        sample_count: i.readInt32(),
        group_description_index: i.readInt32()
      });
  }
  /** @bundle writing/sbgp.js */
  write(i) {
    this.grouping_type_parameter ? this.version = 1 : this.version = 0, this.flags = 0, this.size = 8 + 8 * this.entries.length + (this.version === 1 ? 4 : 0), this.writeHeader(i), i.writeString(this.grouping_type, void 0, 4), this.version === 1 && i.writeUint32(this.grouping_type_parameter), i.writeUint32(this.entries.length);
    for (let e = 0; e < this.entries.length; e++) {
      const t = this.entries[e];
      i.writeInt32(t.sample_count), i.writeInt32(t.group_description_index);
    }
  }
}, Mo.fourcc = "sbgp", Mo), Eo, ex = (Eo = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SampleDependencyTypeBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = this.size - this.hdr_size;
    this.is_leading = [], this.sample_depends_on = [], this.sample_is_depended_on = [], this.sample_has_redundancy = [];
    for (let t = 0; t < e; t++) {
      const s = i.readUint8();
      this.is_leading[t] = s >> 6, this.sample_depends_on[t] = s >> 4 & 3, this.sample_is_depended_on[t] = s >> 2 & 3, this.sample_has_redundancy[t] = s & 3;
    }
  }
}, Eo.fourcc = "sdtp", Eo), Po, tx = (Po = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SampleGroupDescriptionBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.grouping_type = i.readString(4), I.debug("BoxParser", "Found Sample Groups of type " + this.grouping_type), this.version === 1 ? this.default_length = i.readUint32() : this.default_length = 0, this.version >= 2 && (this.default_group_description_index = i.readUint32()), this.entries = [];
    const e = i.readUint32();
    for (let t = 0; t < e; t++) {
      let s;
      this.grouping_type in Oe.sampleGroupEntry ? s = new Oe.sampleGroupEntry[this.grouping_type](this.grouping_type) : s = new ye(this.grouping_type), this.entries.push(s), this.version === 1 ? this.default_length === 0 ? s.description_length = i.readUint32() : s.description_length = this.default_length : s.description_length = this.default_length, s.write === ye.prototype.write && (I.info(
        "BoxParser",
        "SampleGroup for type " + this.grouping_type + " writing not yet implemented, keeping unparsed data in memory for later write"
      ), s.data = i.readUint8Array(s.description_length), i.seek(i.getPosition() - s.description_length)), s.parse(i);
    }
  }
  /** @bundle writing/sgpd.js */
  write(i) {
    this.flags = 0, this.size = 12;
    for (let e = 0; e < this.entries.length; e++) {
      const t = this.entries[e];
      this.version === 1 && (this.default_length === 0 && (this.size += 4), this.size += t.data.length);
    }
    this.writeHeader(i), i.writeString(this.grouping_type, void 0, 4), this.version === 1 && i.writeUint32(this.default_length), this.version >= 2 && i.writeUint32(this.default_sample_description_index), i.writeUint32(this.entries.length);
    for (let e = 0; e < this.entries.length; e++) {
      const t = this.entries[e];
      this.version === 1 && this.default_length === 0 && i.writeUint32(t.description_length), t.write(i);
    }
  }
}, Po.fourcc = "sgpd", Po), Uo, ix = (Uo = class extends F {
  constructor() {
    super(...arguments), this.box_name = "CompressedSegmentIndexBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.reference_ID = i.readUint32(), this.timescale = i.readUint32(), this.version === 0 ? (this.earliest_presentation_time = i.readUint32(), this.first_offset = i.readUint32()) : (this.earliest_presentation_time = i.readUint64(), this.first_offset = i.readUint64()), i.readUint16(), this.references = [];
    const e = i.readUint16();
    for (let t = 0; t < e; t++) {
      const s = i.readUint32(), r = i.readUint32(), n = i.readUint32();
      this.references.push({
        reference_type: s >> 31 & 1,
        referenced_size: s & 2147483647,
        subsegment_duration: r,
        starts_with_SAP: n >> 31 & 1,
        SAP_type: n >> 28 & 7,
        SAP_delta_time: n & 268435455
      });
    }
  }
  /** @bundle writing/sidx.js */
  write(i) {
    const e = this.earliest_presentation_time > be || this.first_offset > be || this.version === 1;
    this.version = e ? 1 : 0, this.size = 12 + 12 * this.references.length, this.size += e ? 16 : 8, this.flags = 0, this.writeHeader(i), i.writeUint32(this.reference_ID), i.writeUint32(this.timescale), e ? (i.writeUint64(this.earliest_presentation_time), i.writeUint64(this.first_offset)) : (i.writeUint32(this.earliest_presentation_time), i.writeUint32(this.first_offset)), i.writeUint16(0), i.writeUint16(this.references.length);
    for (let t = 0; t < this.references.length; t++) {
      const s = this.references[t];
      i.writeUint32(s.reference_type << 31 | s.referenced_size), i.writeUint32(s.subsegment_duration), i.writeUint32(s.starts_with_SAP << 31 | s.SAP_type << 28 | s.SAP_delta_time);
    }
  }
}, Uo.fourcc = "sidx", Uo), Ro, zf = (Ro = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SoundMediaHeaderBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.balance = i.readUint16(), i.readUint16();
  }
  /** @bundle writing/smhd.js */
  write(i) {
    this.version = 0, this.size = 4, this.writeHeader(i), i.writeUint16(this.balance), i.writeUint16(0);
  }
}, Ro.fourcc = "smhd", Ro), Bo, Of = (Bo = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ChunkOffsetBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = i.readUint32();
    if (this.chunk_offsets = [], this.version === 0)
      for (let t = 0; t < e; t++)
        this.chunk_offsets.push(i.readUint32());
  }
  /** @bundle writings/stco.js */
  write(i) {
    this.version = 0, this.flags = 0, this.size = 4 + 4 * this.chunk_offsets.length, this.writeHeader(i), i.writeUint32(this.chunk_offsets.length), i.writeUint32Array(this.chunk_offsets);
  }
  /** @bundle box-unpack.js */
  unpack(i) {
    for (let e = 0; e < this.chunk_offsets.length; e++)
      i[e].offset = this.chunk_offsets[e];
  }
}, Bo.fourcc = "stco", Bo), zo, Df = (zo = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SubtitleMediaHeaderBox";
  }
}, zo.fourcc = "sthd", zo), Oo, Lf = (Oo = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SampleToChunkBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = i.readUint32();
    if (this.first_chunk = [], this.samples_per_chunk = [], this.sample_description_index = [], this.version === 0)
      for (let t = 0; t < e; t++)
        this.first_chunk.push(i.readUint32()), this.samples_per_chunk.push(i.readUint32()), this.sample_description_index.push(i.readUint32());
  }
  write(i) {
    this.version = 0, this.flags = 0, this.size = 4 + 12 * this.first_chunk.length, this.writeHeader(i), i.writeUint32(this.first_chunk.length);
    for (let e = 0; e < this.first_chunk.length; e++)
      i.writeUint32(this.first_chunk[e]), i.writeUint32(this.samples_per_chunk[e]), i.writeUint32(this.sample_description_index[e]);
  }
  unpack(i) {
    let e = 0, t = 0;
    for (let s = 0; s < this.first_chunk.length; s++)
      for (let r = 0; r < (s + 1 < this.first_chunk.length ? this.first_chunk[s + 1] : 1 / 0); r++) {
        t++;
        for (let n = 0; n < this.samples_per_chunk[s]; n++) {
          if (i[e])
            i[e].description_index = this.sample_description_index[s], i[e].chunk_index = t;
          else
            return;
          e++;
        }
      }
  }
}, Oo.fourcc = "stsc", Oo), Do, Nf = (Do = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SampleDescriptionBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.entries = [];
    const e = i.readUint32();
    for (let t = 1; t <= e; t++) {
      const s = st(i, !0, this.size - (i.getPosition() - this.start));
      if (s.code === De) {
        let r;
        s.type in Oe.sampleEntry ? (r = new Oe.sampleEntry[s.type](s.size), r.hdr_size = s.hdr_size, r.start = s.start) : (I.warn("BoxParser", `Unknown sample entry type: '${s.type}'`), r = new pt(s.size, s.hdr_size, s.start), r.type = s.type), r.write === pt.prototype.write && (I.info(
          "BoxParser",
          "SampleEntry " + r.type + " box writing not yet implemented, keeping unparsed data in memory for later write"
        ), r.parseDataAndRewind(i)), r.parse(i), this.entries.push(r);
      } else
        return;
    }
  }
  /** @bundle writing/stsd.js */
  write(i) {
    this.version = 0, this.flags = 0, this.size = 0, this.writeHeader(i), i.writeUint32(this.entries.length), this.size += 4;
    for (let e = 0; e < this.entries.length; e++)
      this.entries[e].write(i), this.size += this.entries[e].size;
    I.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), i.adjustUint32(this.sizePosition, this.size);
  }
}, Do.fourcc = "stsd", Do), Lo, Gf = (Lo = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SampleSizeBox";
  }
  parse(i) {
    if (this.parseFullHeader(i), this.sample_sizes = [], this.version === 0) {
      this.sample_size = i.readUint32(), this.sample_count = i.readUint32();
      for (let e = 0; e < this.sample_count; e++)
        this.sample_size === 0 ? this.sample_sizes.push(i.readUint32()) : this.sample_sizes[e] = this.sample_size;
    }
  }
  /** @bundle writing/stsz.js */
  write(i) {
    let e = !0;
    if (this.version = 0, this.flags = 0, this.sample_sizes.length > 0) {
      let t = 0;
      for (; t + 1 < this.sample_sizes.length; )
        if (this.sample_sizes[t + 1] !== this.sample_sizes[0]) {
          e = !1;
          break;
        } else
          t++;
    } else
      e = !1;
    this.size = 8, e || (this.size += 4 * this.sample_sizes.length), this.writeHeader(i), e ? i.writeUint32(this.sample_sizes[0]) : i.writeUint32(0), i.writeUint32(this.sample_sizes.length), e || i.writeUint32Array(this.sample_sizes);
  }
  /** @bundle box-unpack.js */
  unpack(i) {
    for (let e = 0; e < this.sample_sizes.length; e++)
      i[e].size = this.sample_sizes[e];
  }
}, Lo.fourcc = "stsz", Lo), No, Hf = (No = class extends F {
  constructor() {
    super(...arguments), this.box_name = "TimeToSampleBox", this.sample_counts = [], this.sample_deltas = [];
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = i.readUint32();
    if (this.sample_counts.length = 0, this.sample_deltas.length = 0, this.version === 0)
      for (let t = 0; t < e; t++) {
        this.sample_counts.push(i.readUint32());
        let s = i.readInt32();
        s < 0 && (I.warn(
          "BoxParser",
          "File uses negative stts sample delta, using value 1 instead, sync may be lost!"
        ), s = 1), this.sample_deltas.push(s);
      }
  }
  /** @bundle writing/stts.js */
  write(i) {
    this.version = 0, this.flags = 0, this.size = 4 + 8 * this.sample_counts.length, this.writeHeader(i), i.writeUint32(this.sample_counts.length);
    for (let e = 0; e < this.sample_counts.length; e++)
      i.writeUint32(this.sample_counts[e]), i.writeUint32(this.sample_deltas[e]);
  }
  /** @bundle box-unpack.js */
  unpack(i) {
    let e = 0;
    for (let t = 0; t < this.sample_counts.length; t++)
      for (let s = 0; s < this.sample_counts[t]; s++)
        e === 0 ? i[e].dts = 0 : i[e].dts = i[e - 1].dts + this.sample_deltas[t], e++;
  }
}, No.fourcc = "stts", No), Go, Wf = (Go = class extends F {
  constructor() {
    super(...arguments), this.box_name = "TrackFragmentBaseMediaDecodeTimeBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.version === 1 ? this.baseMediaDecodeTime = i.readUint64() : this.baseMediaDecodeTime = i.readUint32();
  }
  /** @bundle writing/tdft.js */
  write(i) {
    const e = this.baseMediaDecodeTime > be || this.version === 1;
    this.version = e ? 1 : 0, this.size = 4, this.size += e ? 4 : 0, this.flags = 0, this.writeHeader(i), e ? i.writeUint64(this.baseMediaDecodeTime) : i.writeUint32(this.baseMediaDecodeTime);
  }
}, Go.fourcc = "tfdt", Go), Ho, Vf = (Ho = class extends F {
  constructor() {
    super(...arguments), this.box_name = "TrackFragmentHeaderBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    let e = 0;
    this.track_id = i.readUint32(), this.size - this.hdr_size > e && this.flags & Fs ? (this.base_data_offset = i.readUint64(), e += 8) : this.base_data_offset = 0, this.size - this.hdr_size > e && this.flags & Ms ? (this.default_sample_description_index = i.readUint32(), e += 4) : this.default_sample_description_index = 0, this.size - this.hdr_size > e && this.flags & Es ? (this.default_sample_duration = i.readUint32(), e += 4) : this.default_sample_duration = 0, this.size - this.hdr_size > e && this.flags & Ps ? (this.default_sample_size = i.readUint32(), e += 4) : this.default_sample_size = 0, this.size - this.hdr_size > e && this.flags & Us ? (this.default_sample_flags = i.readUint32(), e += 4) : this.default_sample_flags = 0;
  }
  /** @bundle writing/tfhd.js */
  write(i) {
    this.version = 0, this.size = 4, this.flags & Fs && (this.size += 8), this.flags & Ms && (this.size += 4), this.flags & Es && (this.size += 4), this.flags & Ps && (this.size += 4), this.flags & Us && (this.size += 4), this.writeHeader(i), i.writeUint32(this.track_id), this.flags & Fs && i.writeUint64(this.base_data_offset), this.flags & Ms && i.writeUint32(this.default_sample_description_index), this.flags & Es && i.writeUint32(this.default_sample_duration), this.flags & Ps && i.writeUint32(this.default_sample_size), this.flags & Us && i.writeUint32(this.default_sample_flags);
  }
}, Ho.fourcc = "tfhd", Ho), Wo, $f = (Wo = class extends F {
  constructor() {
    super(...arguments), this.box_name = "TrackHeaderBox", this.layer = 0, this.alternate_group = 0;
  }
  parse(i) {
    this.parseFullHeader(i), this.version === 1 ? (this.creation_time = i.readUint64(), this.modification_time = i.readUint64(), this.track_id = i.readUint32(), i.readUint32(), this.duration = i.readUint64()) : (this.creation_time = i.readUint32(), this.modification_time = i.readUint32(), this.track_id = i.readUint32(), i.readUint32(), this.duration = i.readUint32()), i.readUint32Array(2), this.layer = i.readInt16(), this.alternate_group = i.readInt16(), this.volume = i.readInt16() >> 8, i.readUint16(), this.matrix = i.readInt32Array(9), this.width = i.readUint32(), this.height = i.readUint32();
  }
  write(i) {
    const e = this.modification_time > be || this.creation_time > be || this.duration > be || this.version === 1;
    this.version = e ? 1 : 0, this.size = 80, this.size += e ? 12 : 0, this.flags = this.flags ?? 3, this.writeHeader(i), e ? (i.writeUint64(this.creation_time), i.writeUint64(this.modification_time), i.writeUint32(this.track_id), i.writeUint32(0), i.writeUint64(this.duration)) : (i.writeUint32(this.creation_time), i.writeUint32(this.modification_time), i.writeUint32(this.track_id), i.writeUint32(0), i.writeUint32(this.duration)), i.writeUint32Array([0, 0]), i.writeInt16(this.layer), i.writeInt16(this.alternate_group), i.writeInt16(this.volume << 8), i.writeInt16(0), i.writeInt32Array(this.matrix), i.writeUint32(this.width), i.writeUint32(this.height);
  }
  /** @bundle box-print.js */
  print(i) {
    super.printHeader(i), i.log(i.indent + "creation_time: " + this.creation_time), i.log(i.indent + "modification_time: " + this.modification_time), i.log(i.indent + "track_id: " + this.track_id), i.log(i.indent + "duration: " + this.duration), i.log(i.indent + "volume: " + (this.volume >> 8)), i.log(i.indent + "matrix: " + this.matrix.join(", ")), i.log(i.indent + "layer: " + this.layer), i.log(i.indent + "alternate_group: " + this.alternate_group), i.log(i.indent + "width: " + this.width), i.log(i.indent + "height: " + this.height);
  }
}, Wo.fourcc = "tkhd", Wo), Vo, yh = (Vo = class extends F {
  constructor() {
    super(...arguments), this.box_name = "TrackExtendsBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.track_id = i.readUint32(), this.default_sample_description_index = i.readUint32(), this.default_sample_duration = i.readUint32(), this.default_sample_size = i.readUint32(), this.default_sample_flags = i.readUint32();
  }
  write(i) {
    this.version = 0, this.flags = 0, this.size = 20, this.writeHeader(i), i.writeUint32(this.track_id), i.writeUint32(this.default_sample_description_index), i.writeUint32(this.default_sample_duration), i.writeUint32(this.default_sample_size), i.writeUint32(this.default_sample_flags);
  }
}, Vo.fourcc = "trex", Vo), $o, Yf = ($o = class extends F {
  constructor() {
    super(...arguments), this.box_name = "TrackRunBox", this.sample_duration = [], this.sample_size = [], this.sample_flags = [], this.sample_composition_time_offset = [];
  }
  parse(i) {
    this.parseFullHeader(i);
    let e = 0;
    if (this.sample_count = i.readUint32(), e += 4, this.size - this.hdr_size > e && this.flags & Gi ? (this.data_offset = i.readInt32(), e += 4) : this.data_offset = 0, this.size - this.hdr_size > e && this.flags & Rs ? (this.first_sample_flags = i.readUint32(), e += 4) : this.first_sample_flags = 0, this.sample_duration = [], this.sample_size = [], this.sample_flags = [], this.sample_composition_time_offset = [], this.size - this.hdr_size > e)
      for (let t = 0; t < this.sample_count; t++)
        this.flags & Hi && (this.sample_duration[t] = i.readUint32()), this.flags & Wi && (this.sample_size[t] = i.readUint32()), this.flags & Vi && (this.sample_flags[t] = i.readUint32()), this.flags & $i && (this.version === 0 ? this.sample_composition_time_offset[t] = i.readUint32() : this.sample_composition_time_offset[t] = i.readInt32());
  }
  /** @bundle writing/trun.js */
  write(i) {
    this.size = 4, this.flags & Gi && (this.size += 4), this.flags & Rs && (this.size += 4), this.flags & Hi && (this.size += 4 * this.sample_duration.length), this.flags & Wi && (this.size += 4 * this.sample_size.length), this.flags & Vi && (this.size += 4 * this.sample_flags.length), this.flags & $i && (this.size += 4 * this.sample_composition_time_offset.length), this.writeHeader(i), i.writeUint32(this.sample_count), this.flags & Gi && (this.data_offset_position = i.getPosition(), i.writeInt32(this.data_offset)), this.flags & Rs && i.writeUint32(this.first_sample_flags);
    for (let e = 0; e < this.sample_count; e++)
      this.flags & Hi && i.writeUint32(this.sample_duration[e]), this.flags & Wi && i.writeUint32(this.sample_size[e]), this.flags & Vi && i.writeUint32(this.sample_flags[e]), this.flags & $i && (this.version === 0 ? i.writeUint32(this.sample_composition_time_offset[e]) : i.writeInt32(this.sample_composition_time_offset[e]));
  }
}, $o.fourcc = "trun", $o), Yo, Xf = (Yo = class extends F {
  constructor() {
    super(...arguments), this.box_name = "DataEntryUrlBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.flags !== 1 && (this.location = i.readCString());
  }
  /** @bundle writing/url.js */
  write(i) {
    this.version = 0, this.location ? (this.flags = 0, this.size = this.location.length + 1) : (this.flags = 1, this.size = 0), this.writeHeader(i), this.location && i.writeCString(this.location);
  }
}, Yo.fourcc = "url ", Yo), Xo, qf = (Xo = class extends F {
  constructor() {
    super(...arguments), this.box_name = "VideoMediaHeaderBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.graphicsmode = i.readUint16(), this.opcolor = i.readUint16Array(3);
  }
  /** @bundle writing/vmhd.js */
  write(i) {
    this.version = 0, this.size = 8, this.writeHeader(i), i.writeUint16(this.graphicsmode), i.writeUint16Array(this.opcolor);
  }
}, Xo.fourcc = "vmhd", Xo), Os = class {
  constructor(i, e, t) {
    this.grouping_type = i, this.grouping_type_parameter = e, this.sbgp = t, this.last_sample_in_run = -1, this.entry_index = -1;
  }
}, Zf = class Ct {
  constructor(e, t = !0) {
    this.boxes = [], this.mdats = [], this.moofs = [], this.isProgressive = !1, this.moovStartFound = !1, this.moovStartSent = !1, this.readySent = !1, this.sampleListBuilt = !1, this.fragmentedTracks = [], this.extractedTracks = [], this.isFragmentationInitialized = !1, this.sampleProcessingStarted = !1, this.nextMoofNumber = 0, this.itemListBuilt = !1, this.sidxSent = !1, this.items = [], this.entity_groups = [], this.itemsDataSize = 0, this.lastMoofIndex = 0, this.samplesDataSize = 0, this.lastBoxStartPosition = 0, this.nextParsePosition = 0, this.discardMdatData = !0, this.discardMdatData = t, e ? (this.stream = e, this.parse()) : this.stream = new ni(), this.stream.isofile = this;
  }
  setSegmentOptions(e, t, s) {
    const { sizePerSegment: r = Number.MAX_SAFE_INTEGER, rapAlignement: n = !0 } = s;
    let o = s.nbSamples ?? s.nbSamplesPerFragment ?? 1e3;
    const a = s.nbSamplesPerFragment ?? o;
    if (o <= 0 || a <= 0 || r <= 0) {
      I.error(
        "ISOFile",
        `Invalid segment options: nbSamples=${o}, nbSamplesPerFragment=${a}, sizePerSegment=${r}`
      );
      return;
    }
    if (o < a && (I.warn(
      "ISOFile",
      `nbSamples (${o}) is less than nbSamplesPerFragment (${a}), setting nbSamples to nbSamplesPerFragment`
    ), o = a), this.fragmentedTracks.some((c) => c.nb_samples !== o)) {
      I.error(
        "ISOFile",
        `Cannot set segment options for track ${e}: nbSamples (${o}) does not match existing tracks`
      );
      return;
    }
    const l = this.getTrackById(e);
    if (l) {
      const c = {
        id: e,
        user: t,
        trak: l,
        segmentStream: void 0,
        nb_samples: o,
        nb_samples_per_fragment: a,
        size_per_segment: r,
        rapAlignement: n,
        state: {
          lastFragmentSampleNumber: 0,
          lastSegmentSampleNumber: 0,
          accumulatedSize: 0
        }
      };
      this.fragmentedTracks.push(c), l.nextSample = 0;
    }
    this.discardMdatData && I.warn(
      "ISOFile",
      "Segmentation options set but discardMdatData is true, samples will not be segmented"
    );
  }
  unsetSegmentOptions(e) {
    let t = -1;
    for (let s = 0; s < this.fragmentedTracks.length; s++)
      this.fragmentedTracks[s].id === e && (t = s);
    t > -1 && this.fragmentedTracks.splice(t, 1);
  }
  setExtractionOptions(e, t, { nbSamples: s = 1e3 } = {}) {
    const r = this.getTrackById(e);
    r && (this.extractedTracks.push({
      id: e,
      user: t,
      trak: r,
      nb_samples: s,
      samples: []
    }), r.nextSample = 0), this.discardMdatData && I.warn(
      "ISOFile",
      "Extraction options set but discardMdatData is true, samples will not be extracted"
    );
  }
  unsetExtractionOptions(e) {
    let t = -1;
    for (let s = 0; s < this.extractedTracks.length; s++)
      this.extractedTracks[s].id === e && (t = s);
    t > -1 && this.extractedTracks.splice(t, 1);
  }
  parse() {
    if (!(this.restoreParsePosition && !this.restoreParsePosition()))
      for (; ; )
        if (this.hasIncompleteMdat && this.hasIncompleteMdat()) {
          if (this.processIncompleteMdat())
            continue;
          return;
        } else {
          this.saveParsePosition && this.saveParsePosition();
          const e = st(this.stream, !1);
          if (e.code === St)
            if (this.processIncompleteBox) {
              if (this.processIncompleteBox(e))
                continue;
              return;
            } else
              return;
          else if (e.code === De) {
            const t = e.box;
            if (this.boxes.push(t), t.type === "uuid")
              this[t.uuid] !== void 0 && I.warn(
                "ISOFile",
                "Duplicate Box of uuid: " + t.uuid + ", overriding previous occurrence"
              ), this[t.uuid] = t;
            else
              switch (t.type) {
                case "mdat":
                  this.mdats.push(t), this.transferMdatData(t);
                  break;
                case "moof":
                  this.moofs.push(t);
                  break;
                case "free":
                case "skip":
                  break;
                case "moov":
                  this.moovStartFound = !0, this.mdats.length === 0 && (this.isProgressive = !0);
                /* no break */
                /* falls through */
                default:
                  this[t.type] !== void 0 ? Array.isArray(this[t.type + "s"]) ? (I.info(
                    "ISOFile",
                    `Found multiple boxes of type ${t.type} in ISOFile, adding to array`
                  ), this[t.type + "s"].push(t)) : (I.warn(
                    "ISOFile",
                    `Found multiple boxes of type ${t.type} but no array exists. Creating array dynamically.`
                  ), this[t.type + "s"] = [this[t.type], t]) : (this[t.type] = t, Array.isArray(this[t.type + "s"]) && this[t.type + "s"].push(t));
                  break;
              }
            this.updateUsedBytes && this.updateUsedBytes(t, e);
          } else if (e.code === nf) {
            I.error(
              "ISOFile",
              `Invalid data found while parsing box of type '${e.type}' at position ${e.start}. Aborting parsing.`,
              this
            );
            break;
          }
        }
  }
  checkBuffer(e) {
    if (!e) throw new Error("Buffer must be defined and non empty");
    return e.byteLength === 0 ? (I.warn("ISOFile", "Ignoring empty buffer (fileStart: " + e.fileStart + ")"), this.stream.logBufferLevel(), !1) : (I.info("ISOFile", "Processing buffer (fileStart: " + e.fileStart + ")"), e.usedBytes = 0, this.stream.insertBuffer(e), this.stream.logBufferLevel(), this.stream.initialized() ? !0 : (I.warn("ISOFile", "Not ready to start parsing"), !1));
  }
  /**
   * Processes a new ArrayBuffer (with a fileStart property)
   * Returns the next expected file position, or undefined if not ready to parse
   */
  appendBuffer(e, t) {
    let s;
    if (this.checkBuffer(e))
      return this.parse(), this.moovStartFound && !this.moovStartSent && (this.moovStartSent = !0, this.onMoovStart && this.onMoovStart()), this.moov ? (this.sampleListBuilt || (this.buildSampleLists(), this.sampleListBuilt = !0), this.updateSampleLists(), this.onReady && !this.readySent && (this.readySent = !0, this.onReady(this.getInfo())), this.processSamples(t), this.nextSeekPosition ? (s = this.nextSeekPosition, this.nextSeekPosition = void 0) : s = this.nextParsePosition, this.stream.getEndFilePositionAfter && (s = this.stream.getEndFilePositionAfter(s))) : this.nextParsePosition ? s = this.nextParsePosition : s = 0, this.sidx && this.onSidx && !this.sidxSent && (this.onSidx(this.sidx), this.sidxSent = !0), this.meta && (this.flattenItemInfo && !this.itemListBuilt && (this.flattenItemInfo(), this.itemListBuilt = !0), this.processItems && this.processItems(this.onItem)), this.stream.cleanBuffers && (I.info(
        "ISOFile",
        "Done processing buffer (fileStart: " + e.fileStart + ") - next buffer to fetch should have a fileStart position of " + s
      ), this.stream.logBufferLevel(), this.stream.cleanBuffers(), this.stream.logBufferLevel(!0), I.info("ISOFile", "Sample data size in memory: " + this.getAllocatedSampleDataSize())), s;
  }
  getFragmentDuration() {
    const e = this.getBox("mvex");
    if (!e) return;
    if (e.mehd)
      return {
        num: e.mehd.fragment_duration,
        den: this.moov.mvhd.timescale
      };
    const t = this.getBoxes("trak", !1);
    let s = { num: 0, den: 1 };
    for (const r of t) {
      const n = r.samples_duration, o = r.mdia.mdhd.timescale;
      n && o && n / o > s.num / s.den && (s = { num: n, den: o });
    }
    return s;
  }
  getInfo() {
    if (!this.moov)
      return {
        hasMoov: !1,
        mime: ""
      };
    const e = (/* @__PURE__ */ new Date("1904-01-01T00:00:00Z")).getTime(), t = this.getBox("mvex") !== void 0, s = {
      hasMoov: !0,
      duration: this.moov.mvhd.duration,
      timescale: this.moov.mvhd.timescale,
      isFragmented: t,
      fragment_duration: this.getFragmentDuration(),
      isProgressive: this.isProgressive,
      hasIOD: this.moov.iods !== void 0,
      brands: [this.ftyp.major_brand].concat(this.ftyp.compatible_brands),
      created: new Date(e + this.moov.mvhd.creation_time * 1e3),
      modified: new Date(e + this.moov.mvhd.modification_time * 1e3),
      tracks: [],
      audioTracks: [],
      videoTracks: [],
      subtitleTracks: [],
      metadataTracks: [],
      hintTracks: [],
      otherTracks: [],
      mime: ""
    };
    for (let r = 0; r < this.moov.traks.length; r++) {
      const n = this.moov.traks[r], o = n.mdia.minf.stbl.stsd.entries[0], a = n.samples_size, l = n.mdia.mdhd.timescale, c = n.samples_duration, h = a * 8 * l / c, u = {
        samples_duration: c,
        bitrate: h,
        size: a,
        timescale: l,
        alternate_group: n.tkhd.alternate_group,
        codec: o.getCodec(),
        created: new Date(e + n.tkhd.creation_time * 1e3),
        cts_shift: n.mdia.minf.stbl.cslg,
        duration: n.mdia.mdhd.duration,
        id: n.tkhd.track_id,
        kind: n.udta && n.udta.kinds.length ? n.udta.kinds[0] : { schemeURI: "", value: "" },
        // NOTE:   trak.mdia.elng used to be trak.mdia.eln
        language: n.mdia.elng ? n.mdia.elng.extended_language : n.mdia.mdhd.languageString,
        layer: n.tkhd.layer,
        matrix: n.tkhd.matrix,
        modified: new Date(e + n.tkhd.modification_time * 1e3),
        movie_duration: n.tkhd.duration,
        movie_timescale: s.timescale,
        name: n.mdia.hdlr.name,
        nb_samples: n.samples.length,
        references: [],
        track_height: n.tkhd.height / 65536,
        track_width: n.tkhd.width / 65536,
        volume: n.tkhd.volume
      };
      if (s.tracks.push(u), n.tref)
        for (let d = 0; d < n.tref.references.length; d++)
          u.references.push({
            type: n.tref.references[d].type,
            track_ids: n.tref.references[d].track_ids
          });
      n.edts !== void 0 && n.edts.elst !== void 0 && (u.edits = n.edts.elst.entries), o instanceof Re ? (u.type = "audio", s.audioTracks.push(u), u.audio = {
        sample_rate: o.getSampleRate(),
        channel_count: o.getChannelCount(),
        sample_size: o.getSampleSize()
      }) : o instanceof ce ? (u.type = "video", s.videoTracks.push(u), u.video = {
        width: o.getWidth(),
        height: o.getHeight()
      }) : o instanceof kt ? (u.type = "subtitles", s.subtitleTracks.push(u)) : o instanceof mh ? (u.type = "metadata", s.hintTracks.push(u)) : o instanceof Wt ? (u.type = "metadata", s.metadataTracks.push(u)) : (u.type = "metadata", s.otherTracks.push(u));
    }
    s.videoTracks && s.videoTracks.length > 0 ? s.mime += 'video/mp4; codecs="' : s.audioTracks && s.audioTracks.length > 0 ? s.mime += 'audio/mp4; codecs="' : s.mime += 'application/mp4; codecs="';
    for (let r = 0; r < s.tracks.length; r++)
      r !== 0 && (s.mime += ","), s.mime += s.tracks[r].codec;
    return s.mime += '"; profiles="', s.mime += this.ftyp.compatible_brands.join(), s.mime += '"', s;
  }
  setNextSeekPositionFromSample(e) {
    e && (this.nextSeekPosition ? this.nextSeekPosition = Math.min(e.offset + e.alreadyRead, this.nextSeekPosition) : this.nextSeekPosition = e.offset + e.alreadyRead);
  }
  processSamples(e) {
    if (this.sampleProcessingStarted) {
      if (this.isFragmentationInitialized && this.onSegment !== void 0) {
        const t = /* @__PURE__ */ new Set();
        for (; t.size < this.fragmentedTracks.length && this.fragmentedTracks.some((s) => s.trak.nextSample < s.trak.samples.length) && this.sampleProcessingStarted; )
          for (const s of this.fragmentedTracks) {
            const r = s.trak;
            if (!t.has(s.id)) {
              const n = r.nextSample < r.samples.length ? this.getSample(r, r.nextSample) : void 0;
              if (!n) {
                this.setNextSeekPositionFromSample(r.samples[r.nextSample]), t.add(s.id);
                continue;
              }
              s.state.accumulatedSize += n.size;
              const o = r.nextSample + 1, a = o - s.state.lastFragmentSampleNumber > s.nb_samples_per_fragment, l = o - s.state.lastSegmentSampleNumber > s.nb_samples;
              let c = a || o % s.nb_samples_per_fragment === 0, h = l || o % s.nb_samples === 0, u = s.state.accumulatedSize >= s.size_per_segment;
              const d = !s.rapAlignement || n.is_sync, f = e || r.nextSample + 1 >= r.samples.length;
              if (f && !d && I.warn(
                "ISOFile",
                "Flushing track #" + s.id + " at sample #" + r.nextSample + " which is not a RAP, this may lead to playback issues"
              ), c = c && d, h = h && d, u = u && d, c || u || f) {
                a ? I.warn(
                  "ISOFile",
                  "Fragment on track #" + s.id + " is overdue, creating it with samples [" + s.state.lastFragmentSampleNumber + ", " + r.nextSample + "]"
                ) : I.debug(
                  "ISOFile",
                  "Creating media fragment on track #" + s.id + " for samples [" + s.state.lastFragmentSampleNumber + ", " + r.nextSample + "]"
                );
                const m = this.createFragment(
                  s.id,
                  s.state.lastFragmentSampleNumber,
                  r.nextSample,
                  s.segmentStream
                );
                if (m)
                  s.segmentStream = m, s.state.lastFragmentSampleNumber = r.nextSample + 1;
                else {
                  t.add(s.id);
                  continue;
                }
              }
              (h || u || f) && (l ? I.warn(
                "ISOFile",
                "Segment on track #" + s.id + " is overdue, sending it with samples [" + Math.max(0, r.nextSample - s.nb_samples) + ", " + (r.nextSample - 1) + "]"
              ) : I.info(
                "ISOFile",
                "Sending fragmented data on track #" + s.id + " for samples [" + Math.max(0, r.nextSample - s.nb_samples) + ", " + (r.nextSample - 1) + "]"
              ), I.info(
                "ISOFile",
                "Sample data size in memory: " + this.getAllocatedSampleDataSize()
              ), this.onSegment && this.onSegment(
                s.id,
                s.user,
                s.segmentStream.buffer,
                r.nextSample + 1,
                e || r.nextSample + 1 >= r.samples.length
              ), s.segmentStream = void 0, s.state.accumulatedSize = 0, s.state.lastSegmentSampleNumber = r.nextSample + 1), r.nextSample++;
            }
          }
      }
      if (this.onSamples !== void 0)
        for (let t = 0; t < this.extractedTracks.length; t++) {
          const s = this.extractedTracks[t], r = s.trak;
          for (; r.nextSample < r.samples.length && this.sampleProcessingStarted; ) {
            I.debug(
              "ISOFile",
              "Exporting on track #" + s.id + " sample #" + r.nextSample
            );
            const n = this.getSample(r, r.nextSample);
            if (n)
              r.nextSample++, s.samples.push(n);
            else {
              this.setNextSeekPositionFromSample(r.samples[r.nextSample]);
              break;
            }
            if ((r.nextSample % s.nb_samples === 0 || r.nextSample >= r.samples.length) && (I.debug(
              "ISOFile",
              "Sending samples on track #" + s.id + " for sample " + r.nextSample
            ), this.onSamples && this.onSamples(s.id, s.user, s.samples), s.samples = [], s !== this.extractedTracks[t]))
              break;
          }
        }
    }
  }
  /* Find and return specific boxes using recursion and early return */
  getBox(e) {
    const t = this.getBoxes(e, !0);
    return t.length ? t[0] : void 0;
  }
  getBoxes(e, t) {
    const s = [], r = (n) => {
      n instanceof P && n.type && n.type === e && s.push(n);
      const o = [];
      n.boxes && o.push(...n.boxes), n.entries && o.push(...n.entries), n.item_infos && o.push(...n.item_infos), n.references && o.push(...n.references);
      for (const a of o) {
        if (s.length && t) return;
        r(a);
      }
    };
    return r(this), s;
  }
  getTrackSamplesInfo(e) {
    const t = this.getTrackById(e);
    if (t)
      return t.samples;
  }
  getTrackSample(e, t) {
    const s = this.getTrackById(e);
    return this.getSample(s, t);
  }
  /* Called by the application to release the resources associated to samples already forwarded to the application */
  releaseUsedSamples(e, t) {
    let s = 0;
    const r = this.getTrackById(e);
    r.lastValidSample || (r.lastValidSample = 0);
    for (let n = r.lastValidSample; n < t; n++)
      s += this.releaseSample(r, n);
    I.info(
      "ISOFile",
      "Track #" + e + " released samples up to " + t + " (released size: " + s + ", remaining: " + this.samplesDataSize + ")"
    ), r.lastValidSample = t;
  }
  start() {
    this.sampleProcessingStarted = !0, this.processSamples(!1);
  }
  stop() {
    this.sampleProcessingStarted = !1;
  }
  /* Called by the application to flush the remaining samples (e.g. once the download is finished or when no more samples will be added) */
  flush() {
    I.info("ISOFile", "Flushing remaining samples"), this.updateSampleLists(), this.processSamples(!0), this.stream.cleanBuffers(), this.stream.logBufferLevel(!0);
  }
  /* Finds the byte offset for a given time on a given track
     also returns the time of the previous rap */
  seekTrack(e, t, s) {
    let r = 0, n = 0, o;
    if (s.samples.length === 0)
      return I.info(
        "ISOFile",
        "No sample in track, cannot seek! Using time " + I.getDurationString(0, 1) + " and offset: 0"
      ), { offset: 0, time: 0 };
    for (let l = 0; l < s.samples.length; l++) {
      const c = s.samples[l];
      if (l === 0)
        n = 0, o = c.timescale;
      else if (c.cts > e * c.timescale) {
        n = l - 1;
        break;
      }
      t && c.is_sync && (r = l);
    }
    for (t && (n = r), e = s.samples[n].cts, s.nextSample = n; s.samples[n].alreadyRead === s.samples[n].size && s.samples[n + 1]; )
      n++;
    const a = s.samples[n].offset + s.samples[n].alreadyRead;
    return I.info(
      "ISOFile",
      "Seeking to " + (t ? "RAP" : "") + " sample #" + s.nextSample + " on track " + s.tkhd.track_id + ", time " + I.getDurationString(e, o) + " and offset: " + a
    ), { offset: a, time: e / o };
  }
  getTrackDuration(e) {
    if (!e.samples)
      return 1 / 0;
    const t = e.samples[e.samples.length - 1];
    return (t.cts + t.duration) / t.timescale;
  }
  /* Finds the byte offset in the file corresponding to the given time or to the time of the previous RAP */
  seek(e, t) {
    const s = this.moov;
    let r = { offset: 1 / 0, time: 1 / 0 };
    if (this.moov) {
      for (let n = 0; n < s.traks.length; n++) {
        const o = s.traks[n];
        if (e > this.getTrackDuration(o))
          continue;
        const a = this.seekTrack(e, t, o);
        a.offset < r.offset && (r.offset = a.offset), a.time < r.time && (r.time = a.time);
      }
      return I.info(
        "ISOFile",
        "Seeking at time " + I.getDurationString(r.time, 1) + " needs a buffer with a fileStart position of " + r.offset
      ), r.offset === 1 / 0 ? r = { offset: this.nextParsePosition, time: 0 } : r.offset = this.stream.getEndFilePositionAfter(r.offset), I.info(
        "ISOFile",
        "Adjusted seek position (after checking data already in buffer): " + r.offset
      ), r;
    } else
      throw new Error("Cannot seek: moov not received!");
  }
  equal(e) {
    let t = 0;
    for (; t < this.boxes.length && t < e.boxes.length; ) {
      const s = this.boxes[t], r = e.boxes[t];
      if (!Kh(s, r))
        return !1;
      t++;
    }
    return !0;
  }
  /**
   * Rewrite the entire file
   * @bundle isofile-write.js
   */
  write(e) {
    for (let t = 0; t < this.boxes.length; t++)
      this.boxes[t].write(e);
  }
  /** @bundle isofile-write.js */
  createFragment(e, t, s, r) {
    const n = [];
    for (let h = t; h <= s; h++) {
      const u = this.getTrackById(e), d = this.getSample(u, h);
      if (!d) {
        this.setNextSeekPositionFromSample(u.samples[h]);
        return;
      }
      n.push(d);
    }
    const o = r || new we(), a = this.createMoof(n);
    a.write(o), a.trafs[0].truns[0].data_offset = a.size + 8, I.debug(
      "MP4Box",
      "Adjusting data_offset with new value " + a.trafs[0].truns[0].data_offset
    ), o.adjustUint32(
      a.trafs[0].truns[0].data_offset_position,
      a.trafs[0].truns[0].data_offset
    );
    const l = new Bs();
    l.stream = new ni();
    let c = 0;
    for (const h of n)
      if (h.data) {
        const u = dt.fromArrayBuffer(h.data.buffer, c);
        l.stream.insertBuffer(u), c += h.data.byteLength;
      }
    return l.write(o), o;
  }
  /**
   * Modify the file and create the initialization segment
   * @bundle isofile-write.js
   */
  static writeInitializationSegment(e, t, s) {
    I.debug("ISOFile", "Generating initialization segment");
    const r = new we();
    e.write(r);
    const n = t.addBox(new xh());
    if (s) {
      const o = n.addBox(new Mf());
      o.fragment_duration = s;
    }
    for (let o = 0; o < t.traks.length; o++) {
      const a = n.addBox(new yh());
      a.track_id = t.traks[o].tkhd.track_id, a.default_sample_description_index = 1, a.default_sample_duration = t.traks[o].samples[0]?.duration ?? 0, a.default_sample_size = 0, a.default_sample_flags = 65536;
    }
    return t.write(r), r.buffer;
  }
  /** @bundle isofile-write.js */
  save(e) {
    const t = new we();
    return t.isofile = this, this.write(t), t.save(e);
  }
  /** @bundle isofile-write.js */
  getBuffer() {
    const e = new we();
    return e.isofile = this, this.write(e), e;
  }
  /** @bundle isofile-write.js */
  initializeSegmentation() {
    this.onSegment || I.warn("MP4Box", "No segmentation callback set!"), this.isFragmentationInitialized || (this.isFragmentationInitialized = !0, this.resetTables());
    const e = new gh();
    e.addBox(this.moov.mvhd);
    for (let t = 0; t < this.fragmentedTracks.length; t++) {
      const s = this.getTrackById(this.fragmentedTracks[t].id);
      if (!s) {
        I.warn(
          "ISOFile",
          `Track with id ${this.fragmentedTracks[t].id} not found, skipping fragmentation initialization`
        );
        continue;
      }
      e.addBox(s);
    }
    return {
      tracks: e.traks.map((t, s) => ({
        id: t.tkhd.track_id,
        user: this.fragmentedTracks[s].user
      })),
      buffer: Ct.writeInitializationSegment(
        this.ftyp,
        e,
        this.moov?.mvex?.mehd.fragment_duration
      )
    };
  }
  /**
   * Resets all sample tables
   * @bundle isofile-sample-processing.js
   */
  resetTables() {
    this.initial_duration = this.moov.mvhd.duration, this.moov.mvhd.duration = 0;
    for (let e = 0; e < this.moov.traks.length; e++) {
      const t = this.moov.traks[e];
      t.tkhd.duration = 0, t.mdia.mdhd.duration = 0;
      const s = t.mdia.minf.stbl.stco || t.mdia.minf.stbl.co64;
      s.chunk_offsets = [];
      const r = t.mdia.minf.stbl.stsc;
      r.first_chunk = [], r.samples_per_chunk = [], r.sample_description_index = [];
      const n = t.mdia.minf.stbl.stsz || t.mdia.minf.stbl.stz2;
      n.sample_sizes = [];
      const o = t.mdia.minf.stbl.stts;
      o.sample_counts = [], o.sample_deltas = [];
      const a = t.mdia.minf.stbl.ctts;
      a && (a.sample_counts = [], a.sample_offsets = []);
      const l = t.mdia.minf.stbl.stss, c = t.mdia.minf.stbl.boxes.indexOf(l);
      c !== -1 && (t.mdia.minf.stbl.boxes[c] = void 0);
    }
  }
  /** @bundle isofile-sample-processing.js */
  static initSampleGroups(e, t, s, r, n) {
    t && (t.sample_groups_info = []), e.sample_groups_info || (e.sample_groups_info = []);
    for (let o = 0; o < s.length; o++) {
      const a = s[o].grouping_type + "/" + s[o].grouping_type_parameter, l = new Os(
        s[o].grouping_type,
        s[o].grouping_type_parameter,
        s[o]
      );
      t && (t.sample_groups_info[a] = l), e.sample_groups_info[a] || (e.sample_groups_info[a] = l);
      for (let c = 0; c < r.length; c++)
        r[c].grouping_type === s[o].grouping_type && (l.description = r[c], l.description.used = !0);
      if (n)
        for (let c = 0; c < n.length; c++)
          n[c].grouping_type === s[o].grouping_type && (l.fragment_description = n[c], l.fragment_description.used = !0, l.is_fragment = !0);
    }
    if (t) {
      if (n) {
        for (let o = 0; o < n.length; o++)
          if (!n[o].used && n[o].version >= 2) {
            const a = n[o].grouping_type + "/0", l = new Os(n[o].grouping_type, 0);
            l.is_fragment = !0, t.sample_groups_info[a] || (t.sample_groups_info[a] = l);
          }
      }
    } else
      for (let o = 0; o < r.length; o++)
        if (!r[o].used && r[o].version >= 2) {
          const a = r[o].grouping_type + "/0", l = new Os(r[o].grouping_type, 0);
          e.sample_groups_info[a] || (e.sample_groups_info[a] = l);
        }
  }
  /** @bundle isofile-sample-processing.js */
  static setSampleGroupProperties(e, t, s, r) {
    t.sample_groups = [];
    for (const n in r)
      if (t.sample_groups[n] = {
        grouping_type: r[n].grouping_type,
        grouping_type_parameter: r[n].grouping_type_parameter
      }, s >= r[n].last_sample_in_run && (r[n].last_sample_in_run < 0 && (r[n].last_sample_in_run = 0), r[n].entry_index++, r[n].entry_index <= r[n].sbgp.entries.length - 1 && (r[n].last_sample_in_run += r[n].sbgp.entries[r[n].entry_index].sample_count)), r[n].entry_index <= r[n].sbgp.entries.length - 1 ? t.sample_groups[n].group_description_index = r[n].sbgp.entries[r[n].entry_index].group_description_index : t.sample_groups[n].group_description_index = -1, t.sample_groups[n].group_description_index !== 0) {
        let o;
        if (r[n].fragment_description ? o = r[n].fragment_description : o = r[n].description, t.sample_groups[n].group_description_index > 0) {
          let a;
          t.sample_groups[n].group_description_index > 65535 ? a = (t.sample_groups[n].group_description_index >> 16) - 1 : a = t.sample_groups[n].group_description_index - 1, o && a >= 0 && (t.sample_groups[n].description = o.entries[a]);
        } else
          o && o.version >= 2 && o.default_group_description_index > 0 && (t.sample_groups[n].description = o.entries[o.default_group_description_index - 1]);
      }
  }
  /** @bundle isofile-sample-processing.js */
  static process_sdtp(e, t, s) {
    t && (e ? (t.is_leading = e.is_leading[s], t.depends_on = e.sample_depends_on[s], t.is_depended_on = e.sample_is_depended_on[s], t.has_redundancy = e.sample_has_redundancy[s]) : (t.is_leading = 0, t.depends_on = 0, t.is_depended_on = 0, t.has_redundancy = 0));
  }
  /* Build initial sample list from  sample tables */
  buildSampleLists() {
    for (let e = 0; e < this.moov.traks.length; e++)
      this.buildTrakSampleLists(this.moov.traks[e]);
  }
  buildTrakSampleLists(e) {
    let t, s, r, n, o, a;
    e.samples = [], e.samples_duration = 0, e.samples_size = 0;
    const l = e.mdia.minf.stbl.stco || e.mdia.minf.stbl.co64, c = e.mdia.minf.stbl.stsc, h = e.mdia.minf.stbl.stsz || e.mdia.minf.stbl.stz2, u = e.mdia.minf.stbl.stts, d = e.mdia.minf.stbl.ctts, f = e.mdia.minf.stbl.stss, m = e.mdia.minf.stbl.stsd, g = e.mdia.minf.stbl.subs, p = e.mdia.minf.stbl.stdp, x = e.mdia.minf.stbl.sbgps, y = e.mdia.minf.stbl.sgpds;
    let v = -1, _ = -1, b = -1, T = -1, w = 0, A = 0, k = 0;
    if (Ct.initSampleGroups(e, void 0, x, y), !(typeof h > "u")) {
      for (t = 0; t < h.sample_sizes.length; t++) {
        const S = {
          number: t,
          track_id: e.tkhd.track_id,
          timescale: e.mdia.mdhd.timescale,
          alreadyRead: 0,
          size: h.sample_sizes[t]
        };
        e.samples[t] = S, e.samples_size += S.size, t === 0 ? (r = 1, s = 0, S.chunk_index = r, S.chunk_run_index = s, a = c.samples_per_chunk[s], o = 0, s + 1 < c.first_chunk.length ? n = c.first_chunk[s + 1] - 1 : n = 1 / 0) : t < a ? (S.chunk_index = r, S.chunk_run_index = s) : (r++, S.chunk_index = r, o = 0, r <= n || (s++, s + 1 < c.first_chunk.length ? n = c.first_chunk[s + 1] - 1 : n = 1 / 0), S.chunk_run_index = s, a += c.samples_per_chunk[s]), S.description_index = c.sample_description_index[S.chunk_run_index] - 1, S.description = m.entries[S.description_index], S.offset = l.chunk_offsets[S.chunk_index - 1] + o, o += S.size, t > v && (_++, v < 0 && (v = 0), v += u.sample_counts[_]), t > 0 ? (e.samples[t - 1].duration = u.sample_deltas[_], e.samples_duration += e.samples[t - 1].duration, S.dts = e.samples[t - 1].dts + e.samples[t - 1].duration) : S.dts = 0, d ? (t >= b && (T++, b < 0 && (b = 0), b += d.sample_counts[T]), S.cts = e.samples[t].dts + d.sample_offsets[T]) : S.cts = S.dts, f ? (t === f.sample_numbers[w] - 1 ? (S.is_sync = !0, w++) : (S.is_sync = !1, S.degradation_priority = 0), g && g.entries[A].sample_delta + k === t + 1 && (S.subsamples = g.entries[A].subsamples, k += g.entries[A].sample_delta, A++)) : S.is_sync = !0, Ct.process_sdtp(e.mdia.minf.stbl.sdtp, S, S.number), p ? S.degradation_priority = p.priority[t] : S.degradation_priority = 0, g && g.entries[A].sample_delta + k === t && (S.subsamples = g.entries[A].subsamples, k += g.entries[A].sample_delta), (x.length > 0 || y.length > 0) && Ct.setSampleGroupProperties(e, S, t, e.sample_groups_info);
      }
      t > 0 && (e.samples[t - 1].duration = Math.max(e.mdia.mdhd.duration - e.samples[t - 1].dts, 0), e.samples_duration += e.samples[t - 1].duration);
    }
  }
  /**
   * Update sample list when new 'moof' boxes are received
   * @bundle isofile-sample-processing.js
   */
  updateSampleLists() {
    let e, t, s, r, n;
    if (this.moov !== void 0)
      for (; this.lastMoofIndex < this.moofs.length; ) {
        const o = this.moofs[this.lastMoofIndex];
        if (this.lastMoofIndex++, o.type === "moof") {
          const a = o;
          for (let l = 0; l < a.trafs.length; l++) {
            const c = a.trafs[l], h = this.getTrackById(c.tfhd.track_id), u = this.getTrexById(c.tfhd.track_id);
            c.tfhd.flags & Ms ? e = c.tfhd.default_sample_description_index : e = u ? u.default_sample_description_index : 1, c.tfhd.flags & Es ? t = c.tfhd.default_sample_duration : t = u ? u.default_sample_duration : 0, c.tfhd.flags & Ps ? s = c.tfhd.default_sample_size : s = u ? u.default_sample_size : 0, c.tfhd.flags & Us ? r = c.tfhd.default_sample_flags : r = u ? u.default_sample_flags : 0, c.sample_number = 0, c.sbgps.length > 0 && Ct.initSampleGroups(h, c, c.sbgps, h.mdia.minf.stbl.sgpds, c.sgpds);
            for (let d = 0; d < c.truns.length; d++) {
              const f = c.truns[d];
              for (let m = 0; m < f.sample_count; m++) {
                const g = e - 1;
                let p = r;
                f.flags & Vi ? p = f.sample_flags[m] : m === 0 && f.flags & Rs && (p = f.first_sample_flags);
                let x = s;
                f.flags & Wi && (x = f.sample_size[m]), h.samples_size += x;
                let y = t;
                f.flags & Hi && (y = f.sample_duration[m]), h.samples_duration += y;
                let v;
                h.first_traf_merged || m > 0 ? v = h.samples[h.samples.length - 1].dts + h.samples[h.samples.length - 1].duration : (c.tfdt ? v = c.tfdt.baseMediaDecodeTime : v = 0, h.first_traf_merged = !0);
                let _ = v;
                f.flags & $i && (_ = v + f.sample_composition_time_offset[m]);
                const b = !!(c.tfhd.flags & Fs), T = !!(c.tfhd.flags & wu), w = !!(f.flags & Gi);
                let A = 0;
                b ? A = c.tfhd.base_data_offset : T || d === 0 ? A = a.start : A = n;
                let k;
                d === 0 && m === 0 ? w ? k = A + f.data_offset : k = A : k = n, n = k + x;
                const S = c.sample_number;
                c.sample_number++;
                const C = {
                  cts: _,
                  description_index: g,
                  description: h.mdia.minf.stbl.stsd.entries[g],
                  dts: v,
                  duration: y,
                  moof_number: this.lastMoofIndex,
                  number_in_traf: S,
                  number: h.samples.length,
                  offset: k,
                  size: x,
                  timescale: h.mdia.mdhd.timescale,
                  track_id: h.tkhd.track_id,
                  is_sync: !(p >> 16 & 1),
                  is_leading: p >> 26 & 3,
                  depends_on: p >> 24 & 3,
                  is_depended_on: p >> 22 & 3,
                  has_redundancy: p >> 20 & 3,
                  degradation_priority: p & 65535
                };
                c.first_sample_index = h.samples.length, h.samples.push(C), (c.sbgps.length > 0 || c.sgpds.length > 0 || h.mdia.minf.stbl.sbgps.length > 0 || h.mdia.minf.stbl.sgpds.length > 0) && Ct.setSampleGroupProperties(
                  h,
                  C,
                  C.number_in_traf,
                  c.sample_groups_info
                );
              }
            }
            if (c.subs) {
              h.has_fragment_subsamples = !0;
              let d = c.first_sample_index;
              for (let f = 0; f < c.subs.entries.length; f++) {
                d += c.subs.entries[f].sample_delta;
                const m = h.samples[d - 1];
                m.subsamples = c.subs.entries[f].subsamples;
              }
            }
          }
        }
      }
  }
  /**
   * Try to get sample data for a given sample:
   * returns null if not found
   * returns the same sample if already requested
   *
   * @bundle isofile-sample-processing.js
   */
  getSample(e, t) {
    const s = e.samples[t];
    if (this.moov) {
      if (!s.data)
        s.data = new Uint8Array(s.size), s.alreadyRead = 0, this.samplesDataSize += s.size, I.debug(
          "ISOFile",
          "Allocating sample #" + t + " on track #" + e.tkhd.track_id + " of size " + s.size + " (total: " + this.samplesDataSize + ")"
        );
      else if (s.alreadyRead === s.size)
        return s;
      for (; ; ) {
        let r = this.stream, n = r.findPosition(!0, s.offset + s.alreadyRead, !1), o, a;
        if (n > -1)
          o = r.buffers[n], a = o.fileStart;
        else
          for (const l of this.mdats) {
            if (!l.stream) {
              I.debug(
                "ISOFile",
                "mdat stream not yet fully read for #" + this.mdats.indexOf(l) + " mdat"
              );
              continue;
            }
            if (n = l.stream.findPosition(
              !0,
              s.offset + s.alreadyRead - l.start - l.hdr_size,
              !1
            ), n > -1) {
              r = l.stream, o = l.stream.buffers[n], a = l.start + l.hdr_size + o.fileStart;
              break;
            }
          }
        if (o) {
          const l = o.byteLength - (s.offset + s.alreadyRead - a);
          if (s.size - s.alreadyRead <= l)
            return I.debug(
              "ISOFile",
              "Getting sample #" + t + " data (alreadyRead: " + s.alreadyRead + " offset: " + (s.offset + s.alreadyRead - a) + " read size: " + (s.size - s.alreadyRead) + " full size: " + s.size + ")"
            ), we.memcpy(
              s.data.buffer,
              s.alreadyRead,
              o,
              s.offset + s.alreadyRead - a,
              s.size - s.alreadyRead
            ), o.usedBytes += s.size - s.alreadyRead, r.logBufferLevel(), s.alreadyRead = s.size, s;
          if (l === 0) return;
          I.debug(
            "ISOFile",
            "Getting sample #" + t + " partial data (alreadyRead: " + s.alreadyRead + " offset: " + (s.offset + s.alreadyRead - a) + " read size: " + l + " full size: " + s.size + ")"
          ), we.memcpy(
            s.data.buffer,
            s.alreadyRead,
            o,
            s.offset + s.alreadyRead - a,
            l
          ), s.alreadyRead += l, o.usedBytes += l, r.logBufferLevel();
        } else return;
      }
    }
  }
  /**
   * Release the memory used to store the data of the sample
   *
   * @bundle isofile-sample-processing.js
   */
  releaseSample(e, t) {
    const s = e.samples[t];
    return s.data ? (this.samplesDataSize -= s.size, s.data = void 0, s.alreadyRead = 0, s.size) : 0;
  }
  /** @bundle isofile-sample-processing.js */
  getAllocatedSampleDataSize() {
    return this.samplesDataSize;
  }
  /**
   * Builds the MIME Type 'codecs' sub-parameters for the whole file
   *
   * @bundle isofile-sample-processing.js
   */
  getCodecs() {
    let e = "";
    for (let t = 0; t < this.moov.traks.length; t++) {
      const s = this.moov.traks[t];
      t > 0 && (e += ","), e += s.mdia.minf.stbl.stsd.entries[0].getCodec();
    }
    return e;
  }
  /**
   * Helper function
   *
   * @bundle isofile-sample-processing.js
   */
  getTrexById(e) {
    if (!(!this.moov || !this.moov.mvex))
      for (let t = 0; t < this.moov.mvex.trexs.length; t++) {
        const s = this.moov.mvex.trexs[t];
        if (s.track_id === e) return s;
      }
  }
  /**
   * Helper function
   *
   * @bundle isofile-sample-processing.js
   */
  getTrackById(e) {
    if (this.moov)
      for (let t = 0; t < this.moov.traks.length; t++) {
        const s = this.moov.traks[t];
        if (s.tkhd.track_id === e) return s;
      }
  }
  /** @bundle isofile-item-processing.js */
  flattenItemInfo() {
    const e = this.items, t = this.entity_groups, s = this.meta;
    if (!(!s || !s.hdlr || !s.iinf)) {
      for (let r = 0; r < s.iinf.item_infos.length; r++) {
        const n = s.iinf.item_infos[r].item_ID;
        e[n] = {
          id: n,
          name: s.iinf.item_infos[r].item_name,
          ref_to: [],
          content_type: s.iinf.item_infos[r].content_type,
          content_encoding: s.iinf.item_infos[r].content_encoding,
          item_uri_type: s.iinf.item_infos[r].item_uri_type,
          type: s.iinf.item_infos[r].item_type ? s.iinf.item_infos[r].item_type : "mime",
          protection: (
            // NOTE:   This was `meta.iinf.item_infos[i].protection_index` before
            s.iinf.item_infos[r].item_protection_index > 0 ? (
              // NOTE:   This was `meta.iinf.item_infos[i].protection_index - 1` before
              s.ipro.protections[s.iinf.item_infos[r].item_protection_index - 1]
            ) : void 0
          )
        };
      }
      if (s.grpl)
        for (let r = 0; r < s.grpl.boxes.length; r++) {
          const n = s.grpl.boxes[r];
          t[n.group_id] = {
            id: n.group_id,
            entity_ids: n.entity_ids,
            type: n.type
          };
        }
      if (s.iloc)
        for (let r = 0; r < s.iloc.items.length; r++) {
          const n = s.iloc.items[r], o = e[n.item_ID];
          n.data_reference_index !== 0 && (I.warn("Item storage with reference to other files: not supported"), o.source = s.dinf.boxes[n.data_reference_index - 1]), o.extents = [], o.size = 0;
          for (let a = 0; a < n.extents.length; a++)
            o.extents[a] = {
              offset: n.extents[a].extent_offset + n.base_offset,
              length: n.extents[a].extent_length,
              alreadyRead: 0
            }, n.construction_method === 1 && (o.extents[a].offset += s.idat.start + s.idat.hdr_size), o.size += o.extents[a].length;
        }
      if (s.pitm && (e[s.pitm.item_id].primary = !0), s.iref)
        for (let r = 0; r < s.iref.references.length; r++) {
          const n = s.iref.references[r];
          for (let o = 0; o < n.references.length; o++)
            e[n.from_item_ID].ref_to.push({ type: n.type, id: n.references[o] });
        }
      if (s.iprp)
        for (let r = 0; r < s.iprp.ipmas.length; r++) {
          const n = s.iprp.ipmas[r];
          for (let o = 0; o < n.associations.length; o++) {
            const a = n.associations[o], l = e[a.id] ?? t[a.id];
            if (l) {
              l.properties === void 0 && (l.properties = {
                boxes: []
              });
              for (let c = 0; c < a.props.length; c++) {
                const h = a.props[c];
                if (h.property_index > 0 && h.property_index - 1 < s.iprp.ipco.boxes.length) {
                  const u = s.iprp.ipco.boxes[h.property_index - 1];
                  l.properties[u.type] = u, l.properties.boxes.push(u);
                }
              }
            }
          }
        }
    }
  }
  /** @bundle isofile-item-processing.js */
  getItem(e) {
    if (!this.meta) return;
    const t = this.items[e];
    if (!t.data && t.size)
      t.data = new Uint8Array(t.size), t.alreadyRead = 0, this.itemsDataSize += t.size, I.debug(
        "ISOFile",
        "Allocating item #" + e + " of size " + t.size + " (total: " + this.itemsDataSize + ")"
      );
    else if (t.alreadyRead === t.size)
      return t;
    for (let s = 0; s < t.extents.length; s++) {
      const r = t.extents[s];
      if (r.alreadyRead !== r.length) {
        const n = this.stream.findPosition(!0, r.offset + r.alreadyRead, !1);
        if (n > -1) {
          const o = this.stream.buffers[n], a = o.byteLength - (r.offset + r.alreadyRead - o.fileStart);
          if (r.length - r.alreadyRead <= a)
            I.debug(
              "ISOFile",
              "Getting item #" + e + " extent #" + s + " data (alreadyRead: " + r.alreadyRead + " offset: " + (r.offset + r.alreadyRead - o.fileStart) + " read size: " + (r.length - r.alreadyRead) + " full extent size: " + r.length + " full item size: " + t.size + ")"
            ), we.memcpy(
              t.data.buffer,
              t.alreadyRead,
              o,
              r.offset + r.alreadyRead - o.fileStart,
              r.length - r.alreadyRead
            ), (!this.parsingMdat || this.discardMdatData) && (o.usedBytes += r.length - r.alreadyRead), this.stream.logBufferLevel(), t.alreadyRead += r.length - r.alreadyRead, r.alreadyRead = r.length;
          else {
            I.debug(
              "ISOFile",
              "Getting item #" + e + " extent #" + s + " partial data (alreadyRead: " + r.alreadyRead + " offset: " + (r.offset + r.alreadyRead - o.fileStart) + " read size: " + a + " full extent size: " + r.length + " full item size: " + t.size + ")"
            ), we.memcpy(
              t.data.buffer,
              t.alreadyRead,
              o,
              r.offset + r.alreadyRead - o.fileStart,
              a
            ), r.alreadyRead += a, t.alreadyRead += a, (!this.parsingMdat || this.discardMdatData) && (o.usedBytes += a), this.stream.logBufferLevel();
            return;
          }
        } else return;
      }
    }
    if (t.alreadyRead === t.size)
      return t;
  }
  /**
   * Release the memory used to store the data of the item
   *
   * @bundle isofile-item-processing.js
   */
  releaseItem(e) {
    const t = this.items[e];
    if (t.data) {
      this.itemsDataSize -= t.size, t.data = void 0, t.alreadyRead = 0;
      for (let s = 0; s < t.extents.length; s++) {
        const r = t.extents[s];
        r.alreadyRead = 0;
      }
      return t.size;
    } else
      return 0;
  }
  /** @bundle isofile-item-processing.js */
  processItems(e) {
    for (const t in this.items) {
      const s = this.items[t];
      this.getItem(s.id), e && !s.sent && (e(s), s.sent = !0, s.data = void 0);
    }
  }
  /** @bundle isofile-item-processing.js */
  hasItem(e) {
    for (const t in this.items) {
      const s = this.items[t];
      if (s.name === e)
        return s.id;
    }
    return -1;
  }
  /** @bundle isofile-item-processing.js */
  getMetaHandler() {
    if (this.meta) return this.meta.hdlr.handler;
  }
  /** @bundle isofile-item-processing.js */
  getPrimaryItem() {
    if (this.meta && this.meta.pitm) return this.getItem(this.meta.pitm.item_id);
  }
  /** @bundle isofile-item-processing.js */
  itemToFragmentedTrackFile({ itemId: e } = {}) {
    let t;
    if (e ? t = this.getItem(e) : t = this.getPrimaryItem(), !t) return;
    const s = new Ct();
    s.discardMdatData = !1;
    const r = {
      type: t.type,
      description_boxes: t.properties.boxes
    };
    t.properties.ispe && (r.width = t.properties.ispe.image_width, r.height = t.properties.ispe.image_height);
    const n = s.addTrack(r);
    if (n)
      return s.addSample(n, t.data), s;
  }
  /** @bundle isofile-advanced-parsing.js */
  processIncompleteBox(e) {
    if (e.type === "mdat") {
      const t = new Bs(e.size);
      return this.parsingMdat = t, this.boxes.push(t), this.mdats.push(t), t.start = e.start, t.hdr_size = e.hdr_size, t.original_size = e.original_size, this.stream.addUsedBytes(t.hdr_size), this.lastBoxStartPosition = t.start + t.size, this.stream.seek(t.start + t.size, !1, this.discardMdatData) ? (this.transferMdatData(), this.parsingMdat = void 0, !0) : (this.moovStartFound ? this.nextParsePosition = this.stream.findEndContiguousBuf() : this.nextParsePosition = t.start + t.size, !1);
    } else
      return e.type === "moov" && (this.moovStartFound = !0, this.mdats.length === 0 && (this.isProgressive = !0)), this.stream.mergeNextBuffer && this.stream.mergeNextBuffer() ? (this.nextParsePosition = this.stream.getEndPosition(), !0) : (e.type ? this.moovStartFound ? this.nextParsePosition = this.stream.getEndPosition() : this.nextParsePosition = this.stream.getPosition() + e.size : this.nextParsePosition = this.stream.getEndPosition(), !1);
  }
  /** @bundle isofile-advanced-parsing.js */
  hasIncompleteMdat() {
    return this.parsingMdat !== void 0;
  }
  /**
   * Transfer the data of the mdat box to its stream
   * @param mdat the mdat box to use
   */
  transferMdatData(e) {
    const t = e ?? this.parsingMdat;
    if (this.discardMdatData) {
      I.debug("ISOFile", "Discarding 'mdat' data, not transferring it to the mdat box stream");
      return;
    }
    if (!t) {
      I.warn("ISOFile", "Cannot transfer 'mdat' data, no mdat box is being parsed");
      return;
    }
    const s = this.stream.findPosition(!0, t.start + t.hdr_size, !1), r = this.stream.findPosition(!0, t.start + t.size, !1);
    if (s === -1 || r === -1) {
      I.warn("ISOFile", "Cannot transfer 'mdat' data, start or end buffer not found");
      return;
    }
    t.stream = new ni();
    for (let n = s; n <= r; n++) {
      const o = this.stream.buffers[n], a = n === s ? t.start + t.hdr_size - o.fileStart : 0, l = n === r ? t.start + t.size - o.fileStart : o.byteLength;
      if (l > a) {
        I.debug(
          "ISOFile",
          "Transferring 'mdat' data from buffer #" + n + " (" + a + " to " + l + ")"
        );
        const c = l - a, h = new dt(c), u = t.stream.getAbsoluteEndPosition();
        we.memcpy(h, 0, o, a, c), h.fileStart = u, t.stream.insertBuffer(h), o.usedBytes += c;
      }
    }
  }
  /** @bundle isofile-advanced-parsing.js */
  processIncompleteMdat() {
    const e = this.parsingMdat;
    return this.stream.seek(e.start + e.size, !1, this.discardMdatData) ? (I.debug("ISOFile", "Found 'mdat' end in buffered data"), this.transferMdatData(), this.parsingMdat = void 0, !0) : (this.nextParsePosition = this.stream.findEndContiguousBuf(), !1);
  }
  /** @bundle isofile-advanced-parsing.js */
  restoreParsePosition() {
    return this.stream.seek(this.lastBoxStartPosition, !0, this.discardMdatData);
  }
  /** @bundle isofile-advanced-parsing.js */
  saveParsePosition() {
    this.lastBoxStartPosition = this.stream.getPosition();
  }
  /** @bundle isofile-advanced-parsing.js */
  updateUsedBytes(e, t) {
    this.stream.addUsedBytes && (e.type === "mdat" ? (this.stream.addUsedBytes(e.hdr_size), this.discardMdatData && this.stream.addUsedBytes(e.size - e.hdr_size)) : this.stream.addUsedBytes(e.size));
  }
  /** @bundle isofile-advanced-creation.js */
  addBox(e) {
    return P.prototype.addBox.call(this, e);
  }
  /** @bundle isofile-advanced-creation.js */
  init(e = {}) {
    const t = this.addBox(new Af());
    t.major_brand = e.brands && e.brands[0] || "iso4", t.minor_version = 0, t.compatible_brands = e.brands || ["iso4"];
    const s = this.addBox(new gh());
    s.addBox(new xh());
    const r = s.addBox(new Pf());
    return r.timescale = e.timescale || 600, r.rate = e.rate || 65536, r.creation_time = 0, r.modification_time = 0, r.duration = e.duration || 0, r.volume = e.width ? 0 : 256, r.matrix = [65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824], r.next_track_id = 1, this;
  }
  /** @bundle isofile-advanced-creation.js */
  addTrack(e = {}) {
    this.moov || this.init(e);
    const t = e || {};
    t.width = t.width || 320, t.height = t.height || 320, t.id = t.id || this.moov.mvhd.next_track_id, t.type = t.type || "avc1";
    const s = this.moov.addBox(new xf());
    this.moov.mvhd.next_track_id = t.id + 1;
    const r = s.addBox(new $f());
    r.flags = ag | lg | cg, r.creation_time = 0, r.modification_time = 0, r.track_id = t.id, r.duration = t.duration || 0, r.layer = t.layer || 0, r.alternate_group = 0, r.volume = 1, r.matrix = [65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824], r.width = t.width << 16, r.height = t.height << 16;
    const n = s.addBox(new yf()), o = n.addBox(new Ff());
    o.creation_time = 0, o.modification_time = 0, o.timescale = t.timescale || 1, o.duration = t.media_duration || 0, o.language = t.language || "und";
    const a = n.addBox(new If());
    a.handler = t.hdlr || "vide", a.name = t.name || "Track created with MP4Box.js";
    const l = n.addBox(new Cf());
    l.extended_language = t.language || "fr-FR";
    const c = n.addBox(new vf()), h = Oe.sampleEntry[t.type];
    if (!h) return;
    const u = new h();
    if (u.data_reference_index = 1, u instanceof ce) {
      const _ = u, b = c.addBox(new qf());
      b.graphicsmode = 0, b.opcolor = [0, 0, 0], _.width = t.width, _.height = t.height, _.horizresolution = 72 << 16, _.vertresolution = 72 << 16, _.frame_count = 1, _.compressorname = t.type + " Compressor", _.depth = 24, t.avcDecoderConfigRecord ? _.addBox(new mf(t.avcDecoderConfigRecord.byteLength)).parse(new we(t.avcDecoderConfigRecord)) : t.hevcDecoderConfigRecord && _.addBox(new kf(t.hevcDecoderConfigRecord.byteLength)).parse(new we(t.hevcDecoderConfigRecord));
    } else if (u instanceof Re) {
      const _ = u, b = c.addBox(new zf());
      b.balance = t.balance || 0, _.channel_count = t.channel_count || 2, _.samplesize = t.samplesize || 16, _.samplerate = t.samplerate || 65536;
    } else u instanceof mh ? c.addBox(new gf()) : u instanceof kt ? (c.addBox(new Df()), u instanceof Bf && (u.namespace = t.namespace || "nonamespace", u.schema_location = t.schema_location || "", u.auxiliary_mime_types = t.auxiliary_mime_types || "")) : u instanceof Wt ? c.addBox(new zs()) : u instanceof cr ? c.addBox(new zs()) : c.addBox(new zs());
    t.description && u.addBox.call(
      u,
      t.description
    ), t.description_boxes && t.description_boxes.forEach(function(_) {
      u.addBox.call(u, _);
    });
    const d = c.addBox(new _f()).addBox(new Sf()), f = new Xf();
    f.flags = 1, d.addEntry(f);
    const m = c.addBox(new bf());
    m.addBox(new Nf()).addEntry(u);
    const g = m.addBox(new Hf());
    g.sample_counts = [], g.sample_deltas = [];
    const p = m.addBox(new Lf());
    p.first_chunk = [], p.samples_per_chunk = [], p.sample_description_index = [];
    const x = m.addBox(new Of());
    x.chunk_offsets = [];
    const y = m.addBox(new Gf());
    y.sample_sizes = [];
    const v = this.moov.mvex.addBox(new yh());
    return v.track_id = t.id, v.default_sample_description_index = t.default_sample_description_index || 1, v.default_sample_duration = t.default_sample_duration || 0, v.default_sample_size = t.default_sample_size || 0, v.default_sample_flags = t.default_sample_flags || 0, this.buildTrakSampleLists(s), t.id;
  }
  /** @bundle isofile-advanced-creation.js */
  addSample(e, t, {
    sample_description_index: s,
    duration: r = 1,
    cts: n = 0,
    dts: o = 0,
    is_sync: a = !1,
    is_leading: l = 0,
    depends_on: c = 0,
    is_depended_on: h = 0,
    has_redundancy: u = 0,
    degradation_priority: d = 0,
    subsamples: f,
    offset: m = 0
  } = {}) {
    const g = this.getTrackById(e);
    if (g === void 0) return;
    const p = s ? s - 1 : 0, x = {
      number: g.samples.length,
      track_id: g.tkhd.track_id,
      timescale: g.mdia.mdhd.timescale,
      description_index: p,
      description: g.mdia.minf.stbl.stsd.entries[p],
      data: t,
      size: t.byteLength,
      alreadyRead: t.byteLength,
      duration: r,
      cts: n,
      dts: o,
      is_sync: a,
      is_leading: l,
      depends_on: c,
      is_depended_on: h,
      has_redundancy: u,
      degradation_priority: d,
      offset: m,
      subsamples: f
    };
    g.samples.push(x), g.samples_size += x.size, g.samples_duration += x.duration, g.first_dts === void 0 && (g.first_dts = o), this.processSamples();
    const y = this.addBox(this.createMoof([x]));
    y.computeSize(), y.trafs[0].truns[0].data_offset = y.size + 8;
    const v = this.addBox(new Bs());
    return v.data = new Uint8Array(t), x;
  }
  /** @bundle isofile-advanced-creation.js */
  createMoof(e) {
    if (e.length === 0) return;
    if (e.some((h) => h.track_id !== e[0].track_id))
      throw new Error(
        "Cannot create moof for samples from different tracks: " + e.map((h) => h.track_id).join(", ")
      );
    const t = e[0].track_id, s = this.getTrackById(t);
    if (!s)
      throw new Error("Cannot create moof for non-existing track: " + t);
    const r = new wf(), n = r.addBox(new Ef());
    n.sequence_number = ++this.nextMoofNumber;
    const o = r.addBox(new Tf()), a = o.addBox(new Vf());
    a.track_id = t, a.flags = wu;
    const l = o.addBox(new Wf());
    l.baseMediaDecodeTime = e[0].dts - (s.first_dts || 0);
    const c = o.addBox(new Yf());
    c.flags = Gi | Hi | Wi | Vi | $i, c.data_offset = 0, c.first_sample_flags = 0, c.sample_count = e.length;
    for (const h of e) {
      let u = 0;
      h.is_sync ? u = 1 << 25 : u = 65536, c.sample_duration.push(h.duration), c.sample_size.push(h.size), c.sample_flags.push(u), c.sample_composition_time_offset.push(h.cts - h.dts);
    }
    return r;
  }
  /** @bundle box-print.js */
  print(e) {
    e.indent = "";
    for (let t = 0; t < this.boxes.length; t++)
      this.boxes[t] && this.boxes[t].print(e);
  }
};
function Kf(i = !1, e) {
  return new Zf(e, !i);
}
var Jf = {};
rf(Jf, {
  Descriptor: () => Mt,
  ES_Descriptor: () => Qh,
  MPEG4DescriptorParser: () => tp
});
var jf = 3, Qs = 4, jh = 5, Qf = 6, Mt = class ep {
  constructor(e, t) {
    this.tag = e, this.size = t, this.descs = [];
  }
  parse(e) {
    this.data = e.readUint8Array(this.size);
  }
  findDescriptor(e) {
    for (let t = 0; t < this.descs.length; t++)
      if (this.descs[t].tag === e)
        return this.descs[t];
  }
  parseOneDescriptor(e) {
    let t = 0;
    const s = e.readUint8();
    let r = e.readUint8();
    for (; r & 128; )
      t = (t << 7) + (r & 127), r = e.readUint8();
    t = (t << 7) + (r & 127), I.debug(
      "Descriptor",
      "Found " + (Ds[s] || "Descriptor " + s) + ", size " + t + " at position " + e.getPosition()
    );
    const n = Ds[s] ? new ox[Ds[s]](t) : (
      // @ts-expect-error FIXME: Descriptor expects a tag as first parameter
      new ep(t)
    );
    return n.parse(e), n;
  }
  parseRemainingDescriptors(e) {
    const t = e.getPosition();
    for (; e.getPosition() < t + this.size; ) {
      const s = this.parseOneDescriptor?.(e);
      this.descs.push(s);
    }
  }
}, Qh = class extends Mt {
  constructor(i) {
    super(jf, i);
  }
  parse(i) {
    if (this.ES_ID = i.readUint16(), this.flags = i.readUint8(), this.size -= 3, this.flags & 128 ? (this.dependsOn_ES_ID = i.readUint16(), this.size -= 2) : this.dependsOn_ES_ID = 0, this.flags & 64) {
      const e = i.readUint8();
      this.URL = i.readString(e), this.size -= e + 1;
    } else
      this.URL = "";
    this.flags & 32 ? (this.OCR_ES_ID = i.readUint16(), this.size -= 2) : this.OCR_ES_ID = 0, this.parseRemainingDescriptors(i);
  }
  getOTI() {
    const i = this.findDescriptor(Qs);
    return i ? i.oti : 0;
  }
  getAudioConfig() {
    const i = this.findDescriptor(Qs);
    if (!i) return;
    const e = i.findDescriptor(jh);
    if (e && e.data) {
      let t = (e.data[0] & 248) >> 3;
      return t === 31 && e.data.length >= 2 && (t = 32 + ((e.data[0] & 7) << 3) + ((e.data[1] & 224) >> 5)), t;
    }
  }
}, sx = class extends Mt {
  constructor(i) {
    super(Qs, i);
  }
  parse(i) {
    this.oti = i.readUint8(), this.streamType = i.readUint8(), this.upStream = (this.streamType >> 1 & 1) !== 0, this.streamType = this.streamType >>> 2, this.bufferSize = i.readUint24(), this.maxBitrate = i.readUint32(), this.avgBitrate = i.readUint32(), this.size -= 13, this.parseRemainingDescriptors(i);
  }
}, rx = class extends Mt {
  constructor(i) {
    super(jh, i);
  }
}, nx = class extends Mt {
  constructor(i) {
    super(Qf, i);
  }
}, ox = {
  Descriptor: Mt,
  ES_Descriptor: Qh,
  DecoderConfigDescriptor: sx,
  DecoderSpecificInfo: rx,
  SLConfigDescriptor: nx
}, Ds = {
  [jf]: "ES_Descriptor",
  [Qs]: "DecoderConfigDescriptor",
  [jh]: "DecoderSpecificInfo",
  [Qf]: "SLConfigDescriptor"
}, tp = class {
  constructor() {
    this.parseOneDescriptor = Mt.prototype.parseOneDescriptor;
  }
  getDescriptorName(i) {
    return Ds[i];
  }
}, ax = class {
  parseSample(i) {
    const e = [], t = new ni(dt.fromArrayBuffer(i.buffer, 0));
    for (; !t.isEof(); ) {
      const s = st(t, !1);
      s.code === De && s.box?.type === "vttc" && e.push(s.box);
    }
    return e;
  }
  getText(i, e, t) {
    function s(a, l) {
      const c = a.toString();
      return c.length >= l ? c : new Array(l - c.length + 1).join("0") + c;
    }
    function r(a) {
      const l = Math.floor(a / 3600), c = Math.floor((a - l * 3600) / 60), h = Math.floor(a - l * 3600 - c * 60), u = Math.floor((a - l * 3600 - c * 60 - h) * 1e3);
      return "" + s(l, 2) + ":" + s(c, 2) + ":" + s(h, 2) + "." + s(u, 3);
    }
    const n = this.parseSample(t);
    let o = "";
    for (let a = 0; a < n.length; a++) {
      const l = n[a];
      o += r(i) + " --> " + r(e) + `\r
`, o += l.payl.text;
    }
    return o;
  }
}, lx = class {
  parseSample(i) {
    const e = {
      resources: [],
      documentString: "",
      document: void 0
    }, t = new we(i.data.buffer);
    if (!i.subsamples || i.subsamples.length === 0)
      e.documentString = t.readString(i.data.length);
    else if (e.documentString = t.readString(i.subsamples[0].size), i.subsamples.length > 1)
      for (let s = 1; s < i.subsamples.length; s++)
        e.resources[s] = t.readUint8Array(i.subsamples[s].size);
    return typeof DOMParser < "u" && (e.document = new DOMParser().parseFromString(e.documentString, "application/xml")), e;
  }
}, cx = class {
  parseSample(i) {
    return new we(i.data.buffer).readString(i.data.length);
  }
  parseConfig(i) {
    const e = new we(i.buffer);
    return e.readUint32(), e.readCString();
  }
}, hx = class {
  parseSample(i) {
    const e = new we(i.data.buffer), t = e.readUint16();
    if (t !== 0)
      return e.readString(t);
  }
}, ip = {};
rf(ip, {
  CoLLBox: () => Tx,
  ItemContentIDPropertyBox: () => jv,
  OpusSampleEntry: () => B0,
  SmDmBox: () => Zy,
  a1lxBox: () => ux,
  a1opBox: () => dx,
  ac_3SampleEntry: () => P0,
  ac_4SampleEntry: () => U0,
  aebrBox: () => Gx,
  afbrBox: () => Hx,
  albcBox: () => Wx,
  alstSampleGroupEntry: () => Iv,
  altrBox: () => Vx,
  auxCBox: () => fx,
  av01SampleEntry: () => a0,
  av1CBox: () => jg,
  avc1SampleEntry: () => s0,
  avc2SampleEntry: () => r0,
  avc3SampleEntry: () => n0,
  avc4SampleEntry: () => o0,
  avcCBox: () => mf,
  avllSampleGroupEntry: () => kv,
  avs3SampleEntry: () => S0,
  avssSampleGroupEntry: () => Fv,
  brstBox: () => $x,
  btrtBox: () => px,
  bxmlBox: () => wg,
  ccstBox: () => mx,
  cdefBox: () => gx,
  clapBox: () => xx,
  clefBox: () => Uy,
  clliBox: () => yx,
  cmexBox: () => vx,
  cminBox: () => _x,
  cmpdBox: () => bx,
  co64Box: () => wx,
  colrBox: () => i0,
  coviBox: () => Ax,
  cprtBox: () => Ix,
  cschBox: () => kx,
  cslgBox: () => Fx,
  cttsBox: () => Mx,
  dOpsBox: () => Ox,
  dac3Box: () => Ex,
  dataBox: () => Ei,
  dav1SampleEntry: () => l0,
  dec3Box: () => Px,
  dfLaBox: () => Ux,
  dimmBox: () => Rx,
  dinfBox: () => _f,
  dmax: () => Bx,
  dmedBox: () => zx,
  dobrBox: () => Yx,
  drefBox: () => Sf,
  drepBox: () => Dx,
  dtrtSampleGroupEntry: () => Mv,
  dvh1SampleEntry: () => g0,
  dvheSampleEntry: () => x0,
  ec_3SampleEntry: () => R0,
  edtsBox: () => Sg,
  elngBox: () => Cf,
  elstBox: () => Lx,
  emsgBox: () => Nx,
  encaSampleEntry: () => H0,
  encmSampleEntry: () => X0,
  encsSampleEntry: () => V0,
  enctSampleEntry: () => Y0,
  encuSampleEntry: () => W0,
  encvSampleEntry: () => G0,
  enofBox: () => By,
  eqivBox: () => Xx,
  esdsBox: () => Qg,
  etypBox: () => Gg,
  fLaCSampleEntry: () => N0,
  favcBox: () => qx,
  fielBox: () => ry,
  fobrBox: () => Zx,
  freeBox: () => yg,
  frmaBox: () => ny,
  ftypBox: () => Af,
  grplBox: () => Lg,
  hdlrBox: () => If,
  hev1SampleEntry: () => u0,
  hev2SampleEntry: () => d0,
  hinfBox: () => Fg,
  hmhdBox: () => gf,
  hntiBox: () => kg,
  hvc1SampleEntry: () => c0,
  hvc2SampleEntry: () => h0,
  hvcCBox: () => kf,
  hvt1SampleEntry: () => f0,
  iaugBox: () => Kx,
  idatBox: () => xg,
  iinfBox: () => Vg,
  ilocBox: () => $g,
  ilstBox: () => zy,
  imirBox: () => oy,
  infeBox: () => Wg,
  iodsBox: () => _g,
  ipcoBox: () => Dg,
  ipmaBox: () => ay,
  iproBox: () => Tg,
  iprpBox: () => Og,
  irefBox: () => Xg,
  irotBox: () => ly,
  ispeBox: () => cy,
  itaiBox: () => hy,
  j2kHBox: () => Ng,
  j2kiSampleEntry: () => C0,
  keysBox: () => Oy,
  kindBox: () => uy,
  levaBox: () => dy,
  lhe1SampleEntry: () => p0,
  lhv1SampleEntry: () => m0,
  lhvCBox: () => fy,
  lselBox: () => py,
  m4aeSampleEntry: () => E0,
  maxrBox: () => my,
  mdatBox: () => Bs,
  mdcvBox: () => gy,
  mdhdBox: () => Ff,
  mdiaBox: () => yf,
  mecoBox: () => Ig,
  mehdBox: () => Mf,
  metaBox: () => Zg,
  mettSampleEntry: () => Kg,
  metxSampleEntry: () => Jg,
  mfhdBox: () => Ef,
  mfraBox: () => Ag,
  mfroBox: () => xy,
  mha1SampleEntry: () => z0,
  mha2SampleEntry: () => O0,
  mhm1SampleEntry: () => D0,
  mhm2SampleEntry: () => L0,
  minfBox: () => vf,
  mjp2SampleEntry: () => A0,
  mjpgSampleEntry: () => I0,
  moofBox: () => wf,
  moovBox: () => gh,
  mp4aSampleEntry: () => M0,
  mp4sSampleEntry: () => $0,
  mp4vSampleEntry: () => F0,
  mskCBox: () => yy,
  msrcTrackGroupTypeBox: () => mv,
  mvexBox: () => xh,
  mvhdBox: () => Pf,
  mvifSampleGroupEntry: () => Ev,
  nmhdBox: () => zs,
  npckBox: () => vy,
  numpBox: () => _y,
  padbBox: () => wy,
  panoBox: () => Jx,
  paspBox: () => Ty,
  paylBox: () => Sy,
  paytBox: () => Cy,
  pdinBox: () => Ay,
  piffLsmBox: () => Yv,
  piffPsshBox: () => Xv,
  piffSencBox: () => qv,
  piffTencBox: () => Zv,
  piffTfrfBox: () => Kv,
  piffTfxdBox: () => Jv,
  pitmBox: () => qg,
  pixiBox: () => Iy,
  pmaxBox: () => ky,
  povdBox: () => Hg,
  prdiBox: () => Fy,
  prfrBox: () => My,
  prftBox: () => Ey,
  prgrBox: () => iy,
  profBox: () => Dy,
  prolSampleGroupEntry: () => Pv,
  psshBox: () => Py,
  pymdBox: () => sy,
  rapSampleGroupEntry: () => Uv,
  rashSampleGroupEntry: () => Rv,
  resvSampleEntry: () => q0,
  rinfBox: () => Ug,
  rollSampleGroupEntry: () => Bv,
  rtp_Box: () => Gy,
  saioBox: () => Hy,
  saizBox: () => Wy,
  sbgpBox: () => Q0,
  sbpmBox: () => $y,
  sbttSampleEntry: () => Z0,
  schiBox: () => Rg,
  schmBox: () => Yy,
  scifSampleGroupEntry: () => zv,
  scnmSampleGroupEntry: () => Ov,
  sdp_Box: () => Xy,
  sdtpBox: () => ex,
  seigSampleGroupEntry: () => Dv,
  sencBox: () => qy,
  sgpdBox: () => tx,
  sidxBox: () => ix,
  sinfBox: () => Pg,
  skipBox: () => vg,
  slidBox: () => jx,
  smhdBox: () => zf,
  sratBox: () => Ky,
  ssixBox: () => Jy,
  stblBox: () => bf,
  stcoBox: () => Of,
  stdpBox: () => jy,
  sterBox: () => Qx,
  sthdBox: () => Df,
  stppSampleEntry: () => Bf,
  strdBox: () => Eg,
  striBox: () => Qy,
  strkBox: () => Mg,
  stsaSampleGroupEntry: () => Lv,
  stscBox: () => Lf,
  stsdBox: () => Nf,
  stsgBox: () => ev,
  stshBox: () => tv,
  stssBox: () => iv,
  stszBox: () => Gf,
  sttsBox: () => Hf,
  stviBox: () => sv,
  stxtSampleEntry: () => K0,
  stypBox: () => rv,
  stz2Box: () => nv,
  subsBox: () => ov,
  syncSampleGroupEntry: () => Nv,
  taicBox: () => av,
  taptBox: () => Ly,
  teleSampleGroupEntry: () => Gv,
  tencBox: () => lv,
  tfdtBox: () => Wf,
  tfhdBox: () => Vf,
  tfraBox: () => cv,
  tkhdBox: () => $f,
  tmaxBox: () => hv,
  tminBox: () => uv,
  totlBox: () => dv,
  tpayBox: () => fv,
  tpylBox: () => pv,
  trafBox: () => Tf,
  trakBox: () => xf,
  trefBox: () => gv,
  trepBox: () => xv,
  trexBox: () => yh,
  trgrBox: () => Bg,
  trpyBox: () => yv,
  trunBox: () => Yf,
  tsasSampleGroupEntry: () => Hv,
  tsclSampleGroupEntry: () => Wv,
  tselBox: () => vv,
  tsynBox: () => ey,
  tx3gSampleEntry: () => J0,
  txtcBox: () => _v,
  tycoBox: () => bv,
  udesBox: () => wv,
  udtaBox: () => zg,
  uncCBox: () => Tv,
  uncvSampleEntry: () => k0,
  urlBox: () => Xf,
  urnBox: () => Sv,
  viprSampleGroupEntry: () => Vv,
  vmhdBox: () => qf,
  vp08SampleEntry: () => w0,
  vp09SampleEntry: () => T0,
  vpcCBox: () => e0,
  vttCBox: () => Cv,
  vttcBox: () => Cg,
  vvc1SampleEntry: () => y0,
  vvcCBox: () => t0,
  vvcNSampleEntry: () => b0,
  vvi1SampleEntry: () => v0,
  vvnCBox: () => Av,
  vvs1SampleEntry: () => _0,
  waveBox: () => Ny,
  wbbrBox: () => ty,
  wvttSampleEntry: () => j0,
  xmlBox: () => bg
});
var qo, ux = (qo = class extends P {
  constructor() {
    super(...arguments), this.box_name = "AV1LayeredImageIndexingProperty";
  }
  parse(i) {
    const e = ((i.readUint8() & 1 & 1) + 1) * 16;
    this.layer_size = [];
    for (let t = 0; t < 3; t++)
      e === 16 ? this.layer_size[t] = i.readUint16() : this.layer_size[t] = i.readUint32();
  }
}, qo.fourcc = "a1lx", qo), Zo, dx = (Zo = class extends P {
  constructor() {
    super(...arguments), this.box_name = "OperatingPointSelectorProperty";
  }
  parse(i) {
    this.op_index = i.readUint8();
  }
}, Zo.fourcc = "a1op", Zo), Ko, fx = (Ko = class extends F {
  constructor() {
    super(...arguments), this.box_name = "AuxiliaryTypeProperty";
  }
  parse(i) {
    this.parseFullHeader(i), this.aux_type = i.readCString();
    const e = this.size - this.hdr_size - (this.aux_type.length + 1);
    this.aux_subtype = i.readUint8Array(e);
  }
}, Ko.fourcc = "auxC", Ko), Jo, px = (Jo = class extends P {
  constructor() {
    super(...arguments), this.box_name = "BitRateBox";
  }
  parse(i) {
    this.bufferSizeDB = i.readUint32(), this.maxBitrate = i.readUint32(), this.avgBitrate = i.readUint32();
  }
}, Jo.fourcc = "btrt", Jo), jo, mx = (jo = class extends F {
  constructor() {
    super(...arguments), this.box_name = "CodingConstraintsBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = i.readUint8();
    this.all_ref_pics_intra = (e & 128) === 128, this.intra_pred_used = (e & 64) === 64, this.max_ref_per_pic = (e & 63) >> 2, i.readUint24();
  }
}, jo.fourcc = "ccst", jo), Qo, gx = (Qo = class extends P {
  constructor() {
    super(...arguments), this.box_name = "ComponentDefinitionBox";
  }
  parse(i) {
    this.channel_count = i.readUint16(), this.channel_indexes = [], this.channel_types = [], this.channel_associations = [];
    for (let e = 0; e < this.channel_count; e++)
      this.channel_indexes.push(i.readUint16()), this.channel_types.push(i.readUint16()), this.channel_associations.push(i.readUint16());
  }
}, Qo.fourcc = "cdef", Qo), ea, xx = (ea = class extends P {
  constructor() {
    super(...arguments), this.box_name = "CleanApertureBox";
  }
  parse(i) {
    this.cleanApertureWidthN = i.readUint32(), this.cleanApertureWidthD = i.readUint32(), this.cleanApertureHeightN = i.readUint32(), this.cleanApertureHeightD = i.readUint32(), this.horizOffN = i.readUint32(), this.horizOffD = i.readUint32(), this.vertOffN = i.readUint32(), this.vertOffD = i.readUint32();
  }
}, ea.fourcc = "clap", ea), ta, yx = (ta = class extends P {
  constructor() {
    super(...arguments), this.box_name = "ContentLightLevelBox";
  }
  parse(i) {
    this.max_content_light_level = i.readUint16(), this.max_pic_average_light_level = i.readUint16();
  }
}, ta.fourcc = "clli", ta), ia, vx = (ia = class extends P {
  constructor() {
    super(...arguments), this.box_name = "CameraExtrinsicMatrixProperty";
  }
  parse(i) {
    this.flags & 1 && (this.pos_x = i.readInt32()), this.flags & 2 && (this.pos_y = i.readInt32()), this.flags & 4 && (this.pos_z = i.readInt32()), this.flags & 8 && (this.version === 0 ? this.flags & 16 ? (this.quat_x = i.readInt32(), this.quat_y = i.readInt32(), this.quat_z = i.readInt32()) : (this.quat_x = i.readInt16(), this.quat_y = i.readInt16(), this.quat_z = i.readInt16()) : this.version), this.flags & 32 && (this.id = i.readUint32());
  }
}, ia.fourcc = "cmex", ia), sa, _x = (sa = class extends P {
  constructor() {
    super(...arguments), this.box_name = "CameraIntrinsicMatrixProperty";
  }
  parse(i) {
    this.focal_length_x = i.readInt32(), this.principal_point_x = i.readInt32(), this.principal_point_y = i.readInt32(), this.flags & 1 && (this.focal_length_y = i.readInt32(), this.skew_factor = i.readInt32());
  }
}, sa.fourcc = "cmin", sa), ra, bx = (ra = class extends P {
  constructor() {
    super(...arguments), this.box_name = "ComponentDefinitionBox";
  }
  parse(i) {
    this.component_count = i.readUint32(), this.component_types = [], this.component_type_urls = [];
    for (let e = 0; e < this.component_count; e++) {
      const t = i.readUint16();
      this.component_types.push(t), t >= 32768 && this.component_type_urls.push(i.readCString());
    }
  }
}, ra.fourcc = "cmpd", ra), na, wx = (na = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ChunkLargeOffsetBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = i.readUint32();
    if (this.chunk_offsets = [], this.version === 0)
      for (let t = 0; t < e; t++)
        this.chunk_offsets.push(i.readUint64());
  }
  /** @bundle writing/co64.js */
  write(i) {
    this.version = 0, this.flags = 0, this.size = 4 + 8 * this.chunk_offsets.length, this.writeHeader(i), i.writeUint32(this.chunk_offsets.length);
    for (let e = 0; e < this.chunk_offsets.length; e++)
      i.writeUint64(this.chunk_offsets[e]);
  }
}, na.fourcc = "co64", na), oa, Tx = (oa = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ContentLightLevelBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.maxCLL = i.readUint16(), this.maxFALL = i.readUint16();
  }
}, oa.fourcc = "CoLL", oa), Sx = class {
  toString() {
    let i = "centre_azimuth: ";
    return i += this.centre_azimuth, i += " (", i += this.centre_azimuth * 2 ** -16, i += "), centre_elevation: ", i += this.centre_elevation, i += " (", i += this.centre_elevation * 2 ** -16, i += "), centre_tilt: ", i += this.centre_tilt, i += " (", i += this.centre_tilt * 2 ** -16, i += ")", this.range_included_flag && (i += ", azimuth_range: ", i += this.azimuth_range, i += " (", i += this.azimuth_range * 2 ** -16, i += "), elevation_range: ", i += this.elevation_range, i += " (", i += this.elevation_range * 2 ** -16, i += ")"), this.interpolate_included_flag && (i += ", interpolate: ", i += this.interpolate), i;
  }
}, Cx = class {
  toString() {
    let i = "";
    return this.view_idc && (i += "view_idc: ", i += this.view_idc, i += ", "), i += "sphere_region: {", i += this.sphere_region, i += "}", i;
  }
}, aa, Ax = (aa = class extends F {
  constructor() {
    super(...arguments), this.box_name = "CoverageInformationBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.coverage_shape_type = i.readUint8();
    const e = i.readUint8(), t = i.readInt8(), s = t & 128;
    s && (this.default_view_idc = (t & 96) >> 5), this.coverage_regions = new Array();
    for (let r = 0; r < e; r++) {
      const n = new Cx();
      s && (n.view_idc = i.readUint8() >> 6), n.sphere_region = this.parseSphereRegion(i, !0, !0), this.coverage_regions.push(n);
    }
  }
  parseSphereRegion(i, e, t) {
    const s = new Sx();
    return s.centre_azimuth = i.readInt32(), s.centre_elevation = i.readInt32(), s.centre_tilt = i.readInt32(), s.range_included_flag = e, e && (s.azimuth_range = i.readUint32(), s.elevation_range = i.readUint32()), s.interpolate_included_flag = t, t && (s.interpolate = (i.readUint8() & 128) === 128), s;
  }
}, aa.fourcc = "covi", aa), la, Ix = (la = class extends F {
  constructor() {
    super(...arguments), this.box_name = "CopyrightBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.parseLanguage(i), this.notice = i.readCString();
  }
}, la.fourcc = "cprt", la), ca, kx = (ca = class extends F {
  constructor() {
    super(...arguments), this.box_name = "CompatibleSchemeTypeBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.scheme_type = i.readString(4), this.scheme_version = i.readUint32(), this.flags & 1 && (this.scheme_uri = i.readCString());
  }
}, ca.fourcc = "csch", ca), wi = 2147483647, ha, Fx = (ha = class extends F {
  constructor() {
    super(...arguments), this.box_name = "CompositionToDecodeBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.version === 0 ? (this.compositionToDTSShift = i.readInt32(), this.leastDecodeToDisplayDelta = i.readInt32(), this.greatestDecodeToDisplayDelta = i.readInt32(), this.compositionStartTime = i.readInt32(), this.compositionEndTime = i.readInt32()) : this.version === 1 && (this.compositionToDTSShift = i.readInt64(), this.leastDecodeToDisplayDelta = i.readInt64(), this.greatestDecodeToDisplayDelta = i.readInt64(), this.compositionStartTime = i.readInt64(), this.compositionEndTime = i.readInt64());
  }
  /** @bundle writing/cslg.js */
  write(i) {
    this.version = 0, (this.compositionToDTSShift > wi || this.leastDecodeToDisplayDelta > wi || this.greatestDecodeToDisplayDelta > wi || this.compositionStartTime > wi || this.compositionEndTime > wi) && (this.version = 1), this.flags = 0, this.version === 0 ? (this.size = 20, this.writeHeader(i), i.writeInt32(this.compositionToDTSShift), i.writeInt32(this.leastDecodeToDisplayDelta), i.writeInt32(this.greatestDecodeToDisplayDelta), i.writeInt32(this.compositionStartTime), i.writeInt32(this.compositionEndTime)) : this.version === 1 && (this.size = 40, this.writeHeader(i), i.writeInt64(this.compositionToDTSShift), i.writeInt64(this.leastDecodeToDisplayDelta), i.writeInt64(this.greatestDecodeToDisplayDelta), i.writeInt64(this.compositionStartTime), i.writeInt64(this.compositionEndTime));
  }
}, ha.fourcc = "cslg", ha), ua, Mx = (ua = class extends F {
  constructor() {
    super(...arguments), this.box_name = "CompositionOffsetBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = i.readUint32();
    if (this.sample_counts = [], this.sample_offsets = [], this.version === 0)
      for (let t = 0; t < e; t++) {
        this.sample_counts.push(i.readUint32());
        const s = i.readInt32();
        s < 0 && I.warn("BoxParser", "ctts box uses negative values without using version 1"), this.sample_offsets.push(s);
      }
    else if (this.version === 1)
      for (let t = 0; t < e; t++)
        this.sample_counts.push(i.readUint32()), this.sample_offsets.push(i.readInt32());
  }
  /** @bundle writing/ctts.js */
  write(i) {
    this.version = this.sample_offsets.some((e) => e < 0) ? 1 : 0, this.flags = 0, this.size = 4 + 8 * this.sample_counts.length, this.writeHeader(i), i.writeUint32(this.sample_counts.length);
    for (let e = 0; e < this.sample_counts.length; e++)
      i.writeUint32(this.sample_counts[e]), this.version === 1 ? i.writeInt32(this.sample_offsets[e]) : i.writeUint32(this.sample_offsets[e]);
  }
  /** @bundle box-unpack.js */
  unpack(i) {
    let e = 0;
    for (let t = 0; t < this.sample_counts.length; t++)
      for (let s = 0; s < this.sample_counts[t]; s++)
        i[e].pts = i[e].dts + this.sample_offsets[t], e++;
  }
}, ua.fourcc = "ctts", ua), da, Ex = (da = class extends P {
  constructor() {
    super(...arguments), this.box_name = "AC3SpecificBox";
  }
  parse(i) {
    const e = i.readUint8(), t = i.readUint8(), s = i.readUint8();
    this.fscod = e >> 6, this.bsid = e >> 1 & 31, this.bsmod = (e & 1) << 2 | t >> 6 & 3, this.acmod = t >> 3 & 7, this.lfeon = t >> 2 & 1, this.bit_rate_code = t & 3 | s >> 5 & 7;
  }
}, da.fourcc = "dac3", da), fa, Px = (fa = class extends P {
  constructor() {
    super(...arguments), this.box_name = "EC3SpecificBox";
  }
  parse(i) {
    const e = i.readUint16();
    this.data_rate = e >> 3, this.num_ind_sub = e & 7, this.ind_subs = [];
    for (let t = 0; t < this.num_ind_sub + 1; t++) {
      const s = i.readUint8(), r = i.readUint8(), n = i.readUint8(), o = {
        fscod: s >> 6,
        bsid: s >> 1 & 31,
        bsmod: (s & 1) << 4 | r >> 4 & 15,
        acmod: r >> 1 & 7,
        lfeon: r & 1,
        num_dep_sub: n >> 1 & 15
      };
      this.ind_subs.push(o), o.num_dep_sub > 0 && (o.chan_loc = (n & 1) << 8 | i.readUint8());
    }
  }
}, fa.fourcc = "dec3", fa), pa, Ux = (pa = class extends F {
  constructor() {
    super(...arguments), this.box_name = "FLACSpecificBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = 127, t = 128, s = [], r = [
      "STREAMINFO",
      "PADDING",
      "APPLICATION",
      "SEEKTABLE",
      "VORBIS_COMMENT",
      "CUESHEET",
      "PICTURE",
      "RESERVED"
    ];
    let n;
    do {
      n = i.readUint8();
      const o = Math.min(n & e, r.length - 1);
      o ? i.readUint8Array(i.readUint24()) : (i.readUint8Array(13), this.samplerate = i.readUint32() >> 12, i.readUint8Array(20)), s.push(r[o]);
    } while (n & t);
    this.numMetadataBlocks = s.length + " (" + s.join(", ") + ")";
  }
}, pa.fourcc = "dfLa", pa), ma, Rx = (ma = class extends P {
  constructor() {
    super(...arguments), this.box_name = "hintimmediateBytesSent";
  }
  parse(i) {
    this.bytessent = i.readUint64();
  }
}, ma.fourcc = "dimm", ma), ga, Bx = (ga = class extends P {
  constructor() {
    super(...arguments), this.box_name = "hintlongestpacket";
  }
  parse(i) {
    this.time = i.readUint32();
  }
}, ga.fourcc = "dmax", ga), xa, zx = (xa = class extends P {
  constructor() {
    super(...arguments), this.box_name = "hintmediaBytesSent";
  }
  parse(i) {
    this.bytessent = i.readUint64();
  }
}, xa.fourcc = "dmed", xa), ya, Ox = (ya = class extends P {
  constructor() {
    super(...arguments), this.box_name = "OpusSpecificBox";
  }
  parse(i) {
    if (this.Version = i.readUint8(), this.OutputChannelCount = i.readUint8(), this.PreSkip = i.readUint16(), this.InputSampleRate = i.readUint32(), this.OutputGain = i.readInt16(), this.ChannelMappingFamily = i.readUint8(), this.ChannelMappingFamily !== 0) {
      this.StreamCount = i.readUint8(), this.CoupledCount = i.readUint8(), this.ChannelMapping = [];
      for (let e = 0; e < this.OutputChannelCount; e++)
        this.ChannelMapping[e] = i.readUint8();
    }
  }
  write(i) {
    if (this.size = 11, this.ChannelMappingFamily !== 0 && (this.size += 2 + this.OutputChannelCount), this.writeHeader(i), i.writeUint8(this.Version), i.writeUint8(this.OutputChannelCount), i.writeUint16(this.PreSkip), i.writeUint32(this.InputSampleRate), i.writeInt16(this.OutputGain), i.writeUint8(this.ChannelMappingFamily), this.ChannelMappingFamily !== 0) {
      i.writeUint8(this.StreamCount), i.writeUint8(this.CoupledCount);
      for (let e = 0; e < this.OutputChannelCount; e++)
        i.writeUint8(this.ChannelMapping[e]);
    }
  }
}, ya.fourcc = "dOps", ya), va, Dx = (va = class extends P {
  constructor() {
    super(...arguments), this.box_name = "hintrepeatedBytesSent";
  }
  parse(i) {
    this.bytessent = i.readUint64();
  }
}, va.fourcc = "drep", va), _a, Lx = (_a = class extends F {
  constructor() {
    super(...arguments), this.box_name = "EditListBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.entries = [];
    const e = i.readUint32();
    for (let t = 0; t < e; t++) {
      const s = {
        segment_duration: this.version === 1 ? i.readUint64() : i.readUint32(),
        media_time: this.version === 1 ? i.readInt64() : i.readInt32(),
        media_rate_integer: i.readInt16(),
        media_rate_fraction: i.readInt16()
      };
      this.entries.push(s);
    }
  }
  /** @bundle writing/elst.js */
  write(i) {
    const e = this.entries.some(
      (t) => t.segment_duration > be || t.media_time > be
    ) || this.version === 1;
    this.version = e ? 1 : 0, this.size = 4 + 12 * this.entries.length, this.size += e ? 8 * this.entries.length : 0, this.writeHeader(i), i.writeUint32(this.entries.length);
    for (let t = 0; t < this.entries.length; t++) {
      const s = this.entries[t];
      e ? (i.writeUint64(s.segment_duration), i.writeInt64(s.media_time)) : (i.writeUint32(s.segment_duration), i.writeInt32(s.media_time)), i.writeInt16(s.media_rate_integer), i.writeInt16(s.media_rate_fraction);
    }
  }
}, _a.fourcc = "elst", _a), ba, Nx = (ba = class extends F {
  constructor() {
    super(...arguments), this.box_name = "EventMessageBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.version === 1 ? (this.timescale = i.readUint32(), this.presentation_time = i.readUint64(), this.event_duration = i.readUint32(), this.id = i.readUint32(), this.scheme_id_uri = i.readCString(), this.value = i.readCString()) : (this.scheme_id_uri = i.readCString(), this.value = i.readCString(), this.timescale = i.readUint32(), this.presentation_time_delta = i.readUint32(), this.event_duration = i.readUint32(), this.id = i.readUint32());
    let e = this.size - this.hdr_size - (16 + (this.scheme_id_uri.length + 1) + (this.value.length + 1));
    this.version === 1 && (e -= 4), this.message_data = i.readUint8Array(e);
  }
  /** @bundle writing/emsg.js */
  write(i) {
    this.version = 0, this.flags = 0, this.size = 16 + this.message_data.length + (this.scheme_id_uri.length + 1) + (this.value.length + 1), this.writeHeader(i), i.writeCString(this.scheme_id_uri), i.writeCString(this.value), i.writeUint32(this.timescale), i.writeUint32(this.presentation_time_delta), i.writeUint32(this.event_duration), i.writeUint32(this.id), i.writeUint8Array(this.message_data);
  }
}, ba.fourcc = "emsg", ba), Fe = class extends F {
  parse(e) {
    this.parseFullHeader(e), this.group_id = e.readUint32(), this.num_entities_in_group = e.readUint32(), this.entity_ids = [];
    for (let t = 0; t < this.num_entities_in_group; t++) {
      const s = e.readUint32();
      this.entity_ids.push(s);
    }
  }
}, wa, Gx = (wa = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "Auto exposure bracketing";
  }
}, wa.fourcc = "aebr", wa), Ta, Hx = (Ta = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "Flash exposure information";
  }
}, Ta.fourcc = "afbr", Ta), Sa, Wx = (Sa = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "Album collection";
  }
}, Sa.fourcc = "albc", Sa), Ca, Vx = (Ca = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "Alternative entity";
  }
}, Ca.fourcc = "altr", Ca), Aa, $x = (Aa = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "Burst image";
  }
}, Aa.fourcc = "brst", Aa), Ia, Yx = (Ia = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "Depth of field bracketing";
  }
}, Ia.fourcc = "dobr", Ia), ka, Xx = (ka = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "Equivalent entity";
  }
}, ka.fourcc = "eqiv", ka), Fa, qx = (Fa = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "Favorites collection";
  }
}, Fa.fourcc = "favc", Fa), Ma, Zx = (Ma = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "Focus bracketing";
  }
}, Ma.fourcc = "fobr", Ma), Ea, Kx = (Ea = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "Image item with an audio track";
  }
}, Ea.fourcc = "iaug", Ea), Pa, Jx = (Pa = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "Panorama";
  }
}, Pa.fourcc = "pano", Pa), Ua, jx = (Ua = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "Slideshow";
  }
}, Ua.fourcc = "slid", Ua), Ra, Qx = (Ra = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "Stereo";
  }
}, Ra.fourcc = "ster", Ra), Ba, ey = (Ba = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "Time-synchronized capture";
  }
}, Ba.fourcc = "tsyn", Ba), za, ty = (za = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "White balance bracketing";
  }
}, za.fourcc = "wbbr", za), Oa, iy = (Oa = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "Progressive rendering";
  }
}, Oa.fourcc = "prgr", Oa), Da, sy = (Da = class extends Fe {
  constructor() {
    super(...arguments), this.box_name = "Image pyramid";
  }
  parse(i) {
    this.parseFullHeader(i), this.group_id = i.readUint32(), this.num_entities_in_group = i.readUint32(), this.entity_ids = [];
    for (let e = 0; e < this.num_entities_in_group; e++) {
      const t = i.readUint32();
      this.entity_ids.push(t);
    }
    this.tile_size_x = i.readUint16(), this.tile_size_y = i.readUint16(), this.layer_binning = [], this.tiles_in_layer_column_minus1 = [], this.tiles_in_layer_row_minus1 = [];
    for (let e = 0; e < this.num_entities_in_group; e++)
      this.layer_binning[e] = i.readUint16(), this.tiles_in_layer_row_minus1[e] = i.readUint16(), this.tiles_in_layer_column_minus1[e] = i.readUint16();
  }
}, Da.fourcc = "pymd", Da), La, ry = (La = class extends P {
  constructor() {
    super(...arguments), this.box_name = "FieldHandlingBox";
  }
  parse(i) {
    this.fieldCount = i.readUint8(), this.fieldOrdering = i.readUint8();
  }
}, La.fourcc = "fiel", La), Na, ny = (Na = class extends P {
  constructor() {
    super(...arguments), this.box_name = "OriginalFormatBox";
  }
  parse(i) {
    this.data_format = i.readString(4);
  }
}, Na.fourcc = "frma", Na), Ga, oy = (Ga = class extends P {
  constructor() {
    super(...arguments), this.box_name = "ImageMirror";
  }
  parse(i) {
    const e = i.readUint8();
    this.reserved = e >> 7, this.axis = e & 1;
  }
}, Ga.fourcc = "imir", Ga), Ha, ay = (Ha = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ItemPropertyAssociationBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = i.readUint32();
    this.associations = [];
    for (let t = 0; t < e; t++) {
      const s = this.version < 1 ? i.readUint16() : i.readUint32(), r = [], n = i.readUint8();
      for (let o = 0; o < n; o++) {
        const a = i.readUint8();
        r.push({
          essential: (a & 128) >> 7 === 1,
          property_index: this.flags & 1 ? (a & 127) << 8 | i.readUint8() : a & 127
        });
      }
      this.associations.push({
        id: s,
        props: r
      });
    }
  }
}, Ha.fourcc = "ipma", Ha), Wa, ly = (Wa = class extends P {
  constructor() {
    super(...arguments), this.box_name = "ImageRotation";
  }
  parse(i) {
    this.angle = i.readUint8() & 3;
  }
}, Wa.fourcc = "irot", Wa), Va, cy = (Va = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ImageSpatialExtentsProperty";
  }
  parse(i) {
    this.parseFullHeader(i), this.image_width = i.readUint32(), this.image_height = i.readUint32();
  }
}, Va.fourcc = "ispe", Va), $a, hy = ($a = class extends F {
  constructor() {
    super(...arguments), this.box_name = "TAITimestampBox";
  }
  parse(i) {
    this.TAI_timestamp = i.readUint64();
    const e = i.readUint8();
    this.sychronization_state = e >> 7 & 1, this.timestamp_generation_failure = e >> 6 & 1, this.timestamp_is_modified = e >> 5 & 1;
  }
}, $a.fourcc = "itai", $a), Ya, uy = (Ya = class extends F {
  constructor() {
    super(...arguments), this.box_name = "KindBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.schemeURI = i.readCString(), this.isEndOfBox(i) || (this.value = i.readCString());
  }
  /** @bundle writing/kind.js */
  write(i) {
    this.version = 0, this.flags = 0, this.size = this.schemeURI.length + 1 + (this.value ? this.value.length + 1 : 0), this.writeHeader(i), i.writeCString(this.schemeURI), this.value && i.writeCString(this.value);
  }
}, Ya.fourcc = "kind", Ya), Xa, dy = (Xa = class extends F {
  constructor() {
    super(...arguments), this.box_name = "LevelAssignmentBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = i.readUint8();
    this.levels = [];
    for (let t = 0; t < e; t++) {
      const s = {};
      this.levels[t] = s, s.track_ID = i.readUint32();
      const r = i.readUint8();
      switch (s.padding_flag = r >> 7, s.assignment_type = r & 127, s.assignment_type) {
        case 0:
          s.grouping_type = i.readString(4);
          break;
        case 1:
          s.grouping_type = i.readString(4), s.grouping_type_parameter = i.readUint32();
          break;
        case 2:
          break;
        case 3:
          break;
        case 4:
          s.sub_track_id = i.readUint32();
          break;
        default:
          I.warn("BoxParser", `Unknown level assignment type: ${s.assignment_type}`);
      }
    }
  }
}, Xa.fourcc = "leva", Xa), qa, fy = (qa = class extends P {
  constructor() {
    super(...arguments), this.box_name = "LHEVCConfigurationBox";
  }
  parse(i) {
    this.configurationVersion = i.readUint8(), this.min_spatial_segmentation_idc = i.readUint16() & 4095, this.parallelismType = i.readUint8() & 3;
    let e = i.readUint8();
    this.numTemporalLayers = (e & 13) >> 3, this.temporalIdNested = (e & 4) >> 2, this.lengthSizeMinusOne = e & 3, this.nalu_arrays = [];
    const t = i.readUint8();
    for (let s = 0; s < t; s++) {
      const r = [];
      this.nalu_arrays.push(r), e = i.readUint8(), r.completeness = (e & 128) >> 7, r.nalu_type = e & 63;
      const n = i.readUint16();
      for (let o = 0; o < n; o++) {
        const a = i.readUint16();
        r.push({ data: i.readUint8Array(a) });
      }
    }
  }
}, qa.fourcc = "lhvC", qa), Za, py = (Za = class extends P {
  constructor() {
    super(...arguments), this.box_name = "LayerSelectorProperty";
  }
  parse(i) {
    this.layer_id = i.readUint16();
  }
}, Za.fourcc = "lsel", Za), Ka, my = (Ka = class extends P {
  constructor() {
    super(...arguments), this.box_name = "hintmaxrate";
  }
  parse(i) {
    this.period = i.readUint32(), this.bytes = i.readUint32();
  }
}, Ka.fourcc = "maxr", Ka), hs = class {
  constructor(i, e) {
    this.x = i, this.y = e;
  }
  toString() {
    return "(" + this.x + "," + this.y + ")";
  }
}, Ja, gy = (Ja = class extends P {
  constructor() {
    super(...arguments), this.box_name = "MasteringDisplayColourVolumeBox";
  }
  parse(i) {
    this.display_primaries = [], this.display_primaries[0] = new hs(i.readUint16(), i.readUint16()), this.display_primaries[1] = new hs(i.readUint16(), i.readUint16()), this.display_primaries[2] = new hs(i.readUint16(), i.readUint16()), this.white_point = new hs(i.readUint16(), i.readUint16()), this.max_display_mastering_luminance = i.readUint32(), this.min_display_mastering_luminance = i.readUint32();
  }
}, Ja.fourcc = "mdcv", Ja), ja, xy = (ja = class extends F {
  constructor() {
    super(...arguments), this.box_name = "MovieFragmentRandomAccessOffsetBox";
  }
  parse(i) {
    this.parseFullHeader(i), this._size = i.readUint32();
  }
}, ja.fourcc = "mfro", ja), Qa, yy = (Qa = class extends F {
  constructor() {
    super(...arguments), this.box_name = "MaskConfigurationProperty";
  }
  parse(i) {
    this.parseFullHeader(i), this.bits_per_pixel = i.readUint8();
  }
}, Qa.fourcc = "mskC", Qa), el, vy = (el = class extends P {
  constructor() {
    super(...arguments), this.box_name = "hintPacketsSent";
  }
  parse(i) {
    this.packetssent = i.readUint32();
  }
}, el.fourcc = "npck", el), tl, _y = (tl = class extends P {
  constructor() {
    super(...arguments), this.box_name = "hintPacketsSent";
  }
  parse(i) {
    this.packetssent = i.readUint64();
  }
}, tl.fourcc = "nump", tl), by = class {
  constructor(i, e) {
    this.pad1 = i, this.pad2 = e;
  }
}, il, wy = (il = class extends F {
  constructor() {
    super(...arguments), this.box_name = "PaddingBitsBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = i.readUint32();
    this.padbits = [];
    for (let t = 0; t < Math.floor((e + 1) / 2); t++) {
      const s = i.readUint8(), r = (s & 112) >> 4, n = s & 7;
      this.padbits.push(new by(r, n));
    }
  }
}, il.fourcc = "padb", il), sl, Ty = (sl = class extends P {
  constructor() {
    super(...arguments), this.box_name = "PixelAspectRatioBox";
  }
  parse(i) {
    this.hSpacing = i.readUint32(), this.vSpacing = i.readUint32();
  }
}, sl.fourcc = "pasp", sl), rl, Sy = (rl = class extends P {
  constructor() {
    super(...arguments), this.box_name = "CuePayloadBox";
  }
  parse(i) {
    this.text = i.readString(this.size - this.hdr_size);
  }
}, rl.fourcc = "payl", rl), nl, Cy = (nl = class extends P {
  constructor() {
    super(...arguments), this.box_name = "hintpayloadID";
  }
  parse(i) {
    this.payloadID = i.readUint32();
    const e = i.readUint8();
    this.rtpmap_string = i.readString(e);
  }
}, nl.fourcc = "payt", nl), ol, Ay = (ol = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ProgressiveDownloadInfoBox", this.rate = [], this.initial_delay = [];
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = (this.size - this.hdr_size) / 8;
    for (let t = 0; t < e; t++)
      this.rate[t] = i.readUint32(), this.initial_delay[t] = i.readUint32();
  }
}, ol.fourcc = "pdin", ol), al, Iy = (al = class extends F {
  constructor() {
    super(...arguments), this.box_name = "PixelInformationProperty";
  }
  parse(i) {
    this.parseFullHeader(i), this.num_channels = i.readUint8(), this.bits_per_channels = [];
    for (let e = 0; e < this.num_channels; e++)
      this.bits_per_channels[e] = i.readUint8();
  }
}, al.fourcc = "pixi", al), ll, ky = (ll = class extends P {
  constructor() {
    super(...arguments), this.box_name = "hintlargestpacket";
  }
  parse(i) {
    this.bytes = i.readUint32();
  }
}, ll.fourcc = "pmax", ll), cl, Fy = (cl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ProgressiveDerivedImageItemInformationProperty";
  }
  parse(i) {
    if (this.parseFullHeader(i), this.step_count = i.readUint16(), this.item_count = [], this.flags & 2)
      for (let e = 0; e < this.step_count; e++)
        this.item_count[e] = i.readUint16();
  }
}, cl.fourcc = "prdi", cl), hl, My = (hl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ProjectionFormatBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.projection_type = i.readUint8() & 31;
  }
}, hl.fourcc = "prfr", hl), ul, Ey = (ul = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ProducerReferenceTimeBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.ref_track_id = i.readUint32(), this.ntp_timestamp = i.readUint64(), this.version === 0 ? this.media_time = i.readUint32() : this.media_time = i.readUint64();
  }
}, ul.fourcc = "prft", ul), dl, Py = (dl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ProtectionSystemSpecificHeaderBox";
  }
  parse(i) {
    if (this.parseFullHeader(i), this.system_id = Ht(i), this.kid = [], this.version > 0) {
      const t = i.readUint32();
      for (let s = 0; s < t; s++)
        this.kid[s] = Ht(i);
    }
    const e = i.readUint32();
    e > 0 && (this.protection_data = i.readUint8Array(e));
  }
}, dl.fourcc = "pssh", dl), fl, Uy = (fl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "TrackCleanApertureDimensionsBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.width = i.readUint32(), this.height = i.readUint32();
  }
}, fl.fourcc = "clef", fl);
function Ry(i, e) {
  if (i === Ei.Types.UTF8)
    return new TextDecoder("utf-8").decode(e);
  const t = new DataView(e.buffer);
  if (i === Ei.Types.BE_UNSIGNED_INT) {
    if (e.length === 1)
      return t.getUint8(0);
    if (e.length === 2)
      return t.getUint16(0, !1);
    if (e.length === 4)
      return t.getUint32(0, !1);
    if (e.length === 8)
      return t.getBigUint64(0, !1);
    throw new Error("Unsupported ITIF_TYPE_BE_UNSIGNED_INT length " + e.length);
  } else if (i === Ei.Types.BE_SIGNED_INT) {
    if (e.length === 1)
      return t.getInt8(0);
    if (e.length === 2)
      return t.getInt16(0, !1);
    if (e.length === 4)
      return t.getInt32(0, !1);
    if (e.length === 8)
      return t.getBigInt64(0, !1);
    throw new Error("Unsupported ITIF_TYPE_BE_SIGNED_INT length " + e.length);
  } else if (i === Ei.Types.BE_FLOAT32)
    return t.getFloat32(0, !1);
  I.warn("DataBox", "Unsupported or unimplemented itif data type: " + i);
}
var us, Ei = (us = class extends P {
  constructor() {
    super(...arguments), this.box_name = "DataBox";
  }
  parse(i) {
    this.valueType = i.readUint32(), this.country = i.readUint16(), this.country > 255 && (i.seek(i.getPosition() - 2), this.countryString = i.readString(2)), this.language = i.readUint16(), this.language > 255 && (i.seek(i.getPosition() - 2), this.parseLanguage(i)), this.raw = i.readUint8Array(this.size - this.hdr_size - 8), this.value = Ry(this.valueType, this.raw);
  }
}, us.fourcc = "data", us.Types = {
  RESERVED: 0,
  UTF8: 1,
  UTF16: 2,
  SJIS: 3,
  UTF8_SORT: 4,
  UTF16_SORT: 5,
  JPEG: 13,
  PNG: 14,
  BE_SIGNED_INT: 21,
  BE_UNSIGNED_INT: 22,
  BE_FLOAT32: 23,
  BE_FLOAT64: 24,
  BMP: 27,
  QT_ATOM: 28,
  BE_SIGNED_INT8: 65,
  BE_SIGNED_INT16: 66,
  BE_SIGNED_INT32: 67,
  BE_FLOAT32_POINT: 70,
  BE_FLOAT32_DIMENSIONS: 71,
  BE_FLOAT32_RECT: 72,
  BE_SIGNED_INT64: 74,
  BE_UNSIGNED_INT8: 75,
  BE_UNSIGNED_INT16: 76,
  BE_UNSIGNED_INT32: 77,
  BE_UNSIGNED_INT64: 78,
  BE_FLOAT64_AFFINE_TRANSFORM: 79
}, us), pl, By = (pl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "TrackEncodedPixelsDimensionsBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.width = i.readUint32(), this.height = i.readUint32();
  }
}, pl.fourcc = "enof", pl), ml, zy = (ml = class extends P {
  constructor() {
    super(...arguments), this.box_name = "IlstBox";
  }
  parse(i) {
    this.list = {};
    let e = this.size - this.hdr_size;
    for (; e > 0; ) {
      const t = i.readUint32(), s = i.readUint32(), r = st(i, !1, t - 8);
      r.code === De && (this.list[s] = r.box), e -= t;
    }
  }
}, ml.fourcc = "ilst", ml), gl, Oy = (gl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "KeysBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.count = i.readUint32(), this.keys = {};
    for (let e = 0; e < this.count; e++) {
      const t = i.readUint32();
      this.keys[e + 1] = i.readString(t - 4);
    }
  }
}, gl.fourcc = "keys", gl), xl, Dy = (xl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "TrackProductionApertureDimensionsBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.width = i.readUint32(), this.height = i.readUint32();
  }
}, xl.fourcc = "prof", xl), yl, Ly = (yl = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "TrackApertureModeDimensionsBox", this.clefs = [], this.profs = [], this.enofs = [], this.subBoxNames = ["clef", "prof", "enof"];
  }
}, yl.fourcc = "tapt", yl), vl, Ny = (vl = class extends Z {
  constructor() {
    super(...arguments), this.box_name = "siDecompressionParamBox";
  }
}, vl.fourcc = "wave", vl), _l, Gy = (_l = class extends P {
  constructor() {
    super(...arguments), this.box_name = "rtpmoviehintinformation";
  }
  parse(i) {
    this.descriptionformat = i.readString(4), this.sdptext = i.readString(this.size - this.hdr_size - 4);
  }
}, _l.fourcc = "rtp ", _l), bl, Hy = (bl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SampleAuxiliaryInformationOffsetsBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.flags & 1 && (this.aux_info_type = i.readString(4), this.aux_info_type_parameter = i.readUint32());
    const e = i.readUint32();
    this.offset = [];
    for (let t = 0; t < e; t++)
      this.version === 0 ? this.offset[t] = i.readUint32() : this.offset[t] = i.readUint64();
  }
}, bl.fourcc = "saio", bl), wl, Wy = (wl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SampleAuxiliaryInformationSizesBox";
  }
  parse(i) {
    if (this.parseFullHeader(i), this.flags & 1 && (this.aux_info_type = i.readString(4), this.aux_info_type_parameter = i.readUint32()), this.default_sample_info_size = i.readUint8(), this.sample_count = i.readUint32(), this.sample_info_size = [], this.default_sample_info_size === 0)
      for (let e = 0; e < this.sample_count; e++)
        this.sample_info_size[e] = i.readUint8();
  }
}, wl.fourcc = "saiz", wl), Vy = class {
  constructor(i, e) {
    this.bad_pixel_row = i, this.bad_pixel_column = e;
  }
  toString() {
    return "[row: " + this.bad_pixel_row + ", column: " + this.bad_pixel_column + "]";
  }
}, Tl, $y = (Tl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SensorBadPixelsMapBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.component_count = i.readUint16(), this.component_index = [];
    for (let t = 0; t < this.component_count; t++)
      this.component_index.push(i.readUint16());
    const e = i.readUint8();
    this.correction_applied = (e & 128) === 128, this.num_bad_rows = i.readUint32(), this.num_bad_cols = i.readUint32(), this.num_bad_pixels = i.readUint32(), this.bad_rows = [], this.bad_columns = [], this.bad_pixels = [];
    for (let t = 0; t < this.num_bad_rows; t++)
      this.bad_rows.push(i.readUint32());
    for (let t = 0; t < this.num_bad_cols; t++)
      this.bad_columns.push(i.readUint32());
    for (let t = 0; t < this.num_bad_pixels; t++) {
      const s = i.readUint32(), r = i.readUint32();
      this.bad_pixels.push(new Vy(s, r));
    }
  }
}, Tl.fourcc = "sbpm", Tl), Sl, Yy = (Sl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SchemeTypeBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.scheme_type = i.readString(4), this.scheme_version = i.readUint32(), this.flags & 1 && (this.scheme_uri = i.readString(this.size - this.hdr_size - 8));
  }
}, Sl.fourcc = "schm", Sl), Cl, Xy = (Cl = class extends P {
  constructor() {
    super(...arguments), this.box_name = "rtptracksdphintinformation";
  }
  parse(i) {
    this.sdptext = i.readString(this.size - this.hdr_size);
  }
}, Cl.fourcc = "sdp ", Cl), Al, qy = (Al = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SampleEncryptionBox";
  }
  // Cannot be fully parsed because Per_Sample_IV_Size needs to be known
  /* parse(stream: MultiBufferStream) {
    this.parseFullHeader(stream);
    let sample_count = stream.readUint32();
    this.samples = [];
    for (let i = 0; i < sample_count; i++) {
      let sample = {};
      // tenc.default_Per_Sample_IV_Size or seig.Per_Sample_IV_Size
      sample.InitializationVector = this.readUint8Array(Per_Sample_IV_Size*8);
      if (this.flags & 0x2) {
        sample.subsamples = [];
        subsample_count = stream.readUint16();
        for (let j = 0; j < subsample_count; j++) {
          let subsample = {};
          subsample.BytesOfClearData = stream.readUint16();
          subsample.BytesOfProtectedData = stream.readUint32();
          sample.subsamples.push(subsample);
        }
      }
      // TODO
      this.samples.push(sample);
    } 
  } */
}, Al.fourcc = "senc", Al), Il, Zy = (Il = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SMPTE2086MasteringDisplayMetadataBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.primaryRChromaticity_x = i.readUint16(), this.primaryRChromaticity_y = i.readUint16(), this.primaryGChromaticity_x = i.readUint16(), this.primaryGChromaticity_y = i.readUint16(), this.primaryBChromaticity_x = i.readUint16(), this.primaryBChromaticity_y = i.readUint16(), this.whitePointChromaticity_x = i.readUint16(), this.whitePointChromaticity_y = i.readUint16(), this.luminanceMax = i.readUint32(), this.luminanceMin = i.readUint32();
  }
}, Il.fourcc = "SmDm", Il), kl, Ky = (kl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SamplingRateBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.sampling_rate = i.readUint32();
  }
}, kl.fourcc = "srat", kl), Fl, Jy = (Fl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "CompressedSubsegmentIndexBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.subsegments = [];
    const e = i.readUint32();
    for (let t = 0; t < e; t++) {
      const s = {};
      this.subsegments.push(s), s.ranges = [];
      const r = i.readUint32();
      for (let n = 0; n < r; n++) {
        const o = {};
        s.ranges.push(o), o.level = i.readUint8(), o.range_size = i.readUint24();
      }
    }
  }
}, Fl.fourcc = "ssix", Fl), Ml, jy = (Ml = class extends F {
  constructor() {
    super(...arguments), this.box_name = "DegradationPriorityBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = (this.size - this.hdr_size) / 2;
    this.priority = [];
    for (let t = 0; t < e; t++)
      this.priority[t] = i.readUint16();
  }
}, Ml.fourcc = "stpd", Ml), El, Qy = (El = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SubTrackInformationBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.switch_group = i.readUint16(), this.alternate_group = i.readUint16(), this.sub_track_id = i.readUint32();
    const e = (this.size - this.hdr_size - 8) / 4;
    this.attribute_list = [];
    for (let t = 0; t < e; t++)
      this.attribute_list[t] = i.readUint32();
  }
}, El.fourcc = "stri", El), Pl, ev = (Pl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SubTrackSampleGroupBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.grouping_type = i.readUint32();
    const e = i.readUint16();
    this.group_description_index = [];
    for (let t = 0; t < e; t++)
      this.group_description_index[t] = i.readUint32();
  }
}, Pl.fourcc = "stsg", Pl), Ul, tv = (Ul = class extends F {
  constructor() {
    super(...arguments), this.box_name = "ShadowSyncSampleBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = i.readUint32();
    if (this.shadowed_sample_numbers = [], this.sync_sample_numbers = [], this.version === 0)
      for (let t = 0; t < e; t++)
        this.shadowed_sample_numbers.push(i.readUint32()), this.sync_sample_numbers.push(i.readUint32());
  }
  write(i) {
    this.version = 0, this.flags = 0, this.size = 4 + 8 * this.shadowed_sample_numbers.length, this.writeHeader(i), i.writeUint32(this.shadowed_sample_numbers.length);
    for (let e = 0; e < this.shadowed_sample_numbers.length; e++)
      i.writeUint32(this.shadowed_sample_numbers[e]), i.writeUint32(this.sync_sample_numbers[e]);
  }
}, Ul.fourcc = "stsh", Ul), Rl, iv = (Rl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SyncSampleBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = i.readUint32();
    if (this.version === 0) {
      this.sample_numbers = [];
      for (let t = 0; t < e; t++)
        this.sample_numbers.push(i.readUint32());
    }
  }
  /** @bundle writing/stss.js */
  write(i) {
    this.version = 0, this.flags = 0, this.size = 4 + 4 * this.sample_numbers.length, this.writeHeader(i), i.writeUint32(this.sample_numbers.length), i.writeUint32Array(this.sample_numbers);
  }
}, Rl.fourcc = "stss", Rl), Bl, sv = (Bl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "StereoVideoBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = i.readUint32();
    this.single_view_allowed = e & 3, this.stereo_scheme = i.readUint32();
    const t = i.readUint32();
    for (this.stereo_indication_type = i.readString(t), this.boxes = []; i.getPosition() < this.start + this.size; ) {
      const s = st(i, !1, this.size - (i.getPosition() - this.start));
      if (s.code === De) {
        const r = s.box;
        this.boxes.push(r), this[r.type] = r;
      } else
        return;
    }
  }
}, Bl.fourcc = "stvi", Bl), zl, rv = (zl = class extends P {
  constructor() {
    super(...arguments), this.box_name = "SegmentTypeBox";
  }
  parse(i) {
    let e = this.size - this.hdr_size;
    this.major_brand = i.readString(4), this.minor_version = i.readUint32(), e -= 8, this.compatible_brands = [];
    let t = 0;
    for (; e >= 4; )
      this.compatible_brands[t] = i.readString(4), e -= 4, t++;
  }
  write(i) {
    this.size = 8 + 4 * this.compatible_brands.length, this.writeHeader(i), i.writeString(this.major_brand, void 0, 4), i.writeUint32(this.minor_version);
    for (let e = 0; e < this.compatible_brands.length; e++)
      i.writeString(this.compatible_brands[e], void 0, 4);
  }
}, zl.fourcc = "styp", zl), Ol, nv = (Ol = class extends F {
  constructor() {
    super(...arguments), this.box_name = "CompactSampleSizeBox";
  }
  parse(i) {
    if (this.parseFullHeader(i), this.sample_sizes = [], this.version === 0) {
      this.reserved = i.readUint24(), this.field_size = i.readUint8();
      const e = i.readUint32();
      if (this.field_size === 4)
        for (let t = 0; t < e; t += 2) {
          const s = i.readUint8();
          this.sample_sizes[t] = s >> 4 & 15, this.sample_sizes[t + 1] = s & 15;
        }
      else if (this.field_size === 8)
        for (let t = 0; t < e; t++)
          this.sample_sizes[t] = i.readUint8();
      else if (this.field_size === 16)
        for (let t = 0; t < e; t++)
          this.sample_sizes[t] = i.readUint16();
      else
        I.error("BoxParser", "Error in length field in stz2 box", i.isofile);
    }
  }
}, Ol.fourcc = "stz2", Ol), Dl, ov = (Dl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "SubSampleInformationBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = i.readUint32();
    this.entries = [];
    let t;
    for (let s = 0; s < e; s++) {
      const r = {};
      if (this.entries[s] = r, r.sample_delta = i.readUint32(), r.subsamples = [], t = i.readUint16(), t > 0)
        for (let n = 0; n < t; n++) {
          const o = {};
          r.subsamples.push(o), this.version === 1 ? o.size = i.readUint32() : o.size = i.readUint16(), o.priority = i.readUint8(), o.discardable = i.readUint8(), o.codec_specific_parameters = i.readUint32();
        }
    }
  }
}, Dl.fourcc = "subs", Dl), Ll, av = (Ll = class extends F {
  constructor() {
    super(...arguments), this.box_name = "TAIClockInfoBox";
  }
  parse(i) {
    this.time_uncertainty = i.readUint64(), this.clock_resolution = i.readUint32(), this.clock_drift_rate = i.readInt32();
    const e = i.readUint8();
    this.clock_type = (e & 192) >> 6;
  }
}, Ll.fourcc = "taic", Ll), Nl, lv = (Nl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "TrackEncryptionBox";
  }
  parse(i) {
    if (this.parseFullHeader(i), i.readUint8(), this.version === 0)
      i.readUint8();
    else {
      const e = i.readUint8();
      this.default_crypt_byte_block = e >> 4 & 15, this.default_skip_byte_block = e & 15;
    }
    this.default_isProtected = i.readUint8(), this.default_Per_Sample_IV_Size = i.readUint8(), this.default_KID = Ht(i), this.default_isProtected === 1 && this.default_Per_Sample_IV_Size === 0 && (this.default_constant_IV_size = i.readUint8(), this.default_constant_IV = i.readUint8Array(this.default_constant_IV_size));
  }
}, Nl.fourcc = "tenc", Nl), Gl, cv = (Gl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "TrackFragmentRandomAccessBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.track_ID = i.readUint32(), i.readUint24();
    const e = i.readUint8();
    this.length_size_of_traf_num = e >> 4 & 3, this.length_size_of_trun_num = e >> 2 & 3, this.length_size_of_sample_num = e & 3, this.entries = [];
    const t = i.readUint32();
    for (let s = 0; s < t; s++)
      this.version === 1 ? (this.time = i.readUint64(), this.moof_offset = i.readUint64()) : (this.time = i.readUint32(), this.moof_offset = i.readUint32()), this.traf_number = i["readUint" + 8 * (this.length_size_of_traf_num + 1)](), this.trun_number = i["readUint" + 8 * (this.length_size_of_trun_num + 1)](), this.sample_number = i["readUint" + 8 * (this.length_size_of_sample_num + 1)]();
  }
}, Gl.fourcc = "tfra", Gl), Hl, hv = (Hl = class extends P {
  constructor() {
    super(...arguments), this.box_name = "hintmaxrelativetime";
  }
  parse(i) {
    this.time = i.readUint32();
  }
}, Hl.fourcc = "tmax", Hl), Wl, uv = (Wl = class extends P {
  constructor() {
    super(...arguments), this.box_name = "hintminrelativetime";
  }
  parse(i) {
    this.time = i.readUint32();
  }
}, Wl.fourcc = "tmin", Wl), Vl, dv = (Vl = class extends P {
  constructor() {
    super(...arguments), this.box_name = "hintBytesSent";
  }
  parse(i) {
    this.bytessent = i.readUint32();
  }
}, Vl.fourcc = "totl", Vl), $l, fv = ($l = class extends P {
  constructor() {
    super(...arguments), this.box_name = "hintBytesSent";
  }
  parse(i) {
    this.bytessent = i.readUint32();
  }
}, $l.fourcc = "tpay", $l), Yl, pv = (Yl = class extends P {
  constructor() {
    super(...arguments), this.box_name = "hintBytesSent";
  }
  parse(i) {
    this.bytessent = i.readUint64();
  }
}, Yl.fourcc = "tpyl", Yl), Xl, mv = (Xl = class extends lf {
}, Xl.fourcc = "msrc", Xl), Ti, gv = (Ti = class extends P {
  constructor() {
    super(...arguments), this.box_name = "TrackReferenceBox", this.references = [];
  }
  parse(i) {
    for (; i.getPosition() < this.start + this.size; ) {
      const e = st(i, !0, this.size - (i.getPosition() - this.start));
      if (e.code === De) {
        Ti.allowed_types.includes(e.type) || I.warn("BoxParser", `Unknown track reference type: '${e.type}'`);
        const t = new uf(e.type, e.size, e.hdr_size, e.start);
        t.write === P.prototype.write && t.type !== "mdat" && (I.info(
          "BoxParser",
          "TrackReference " + t.type + " box writing not yet implemented, keeping unparsed data in memory for later write"
        ), t.parseDataAndRewind(i)), t.parse(i), this.references.push(t);
      } else
        return;
    }
  }
}, Ti.fourcc = "tref", Ti.allowed_types = [
  "hint",
  "cdsc",
  "font",
  "hind",
  "vdep",
  "vplx",
  "subt",
  "thmb",
  "auxl",
  "cdtg",
  "shsc",
  "aest"
], Ti), ql, xv = (ql = class extends F {
  constructor() {
    super(...arguments), this.box_name = "TrackExtensionPropertiesBox";
  }
  parse(i) {
    for (this.parseFullHeader(i), this.track_ID = i.readUint32(), this.boxes = []; i.getPosition() < this.start + this.size; ) {
      const e = st(i, !1, this.size - (i.getPosition() - this.start));
      if (e.code === De) {
        const t = e.box;
        this.boxes.push(t);
      } else
        return;
    }
  }
}, ql.fourcc = "trep", ql), Zl, yv = (Zl = class extends P {
  constructor() {
    super(...arguments), this.box_name = "hintBytesSent";
  }
  parse(i) {
    this.bytessent = i.readUint64();
  }
}, Zl.fourcc = "trpy", Zl), Kl, vv = (Kl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "TrackSelectionBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.switch_group = i.readUint32();
    const e = (this.size - this.hdr_size - 4) / 4;
    this.attribute_list = [];
    for (let t = 0; t < e; t++)
      this.attribute_list[t] = i.readUint32();
  }
}, Kl.fourcc = "tsel", Kl), Jl, _v = (Jl = class extends F {
  constructor() {
    super(...arguments), this.box_name = "TextConfigBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.config = i.readCString();
  }
}, Jl.fourcc = "txtc", Jl), jl, bv = (jl = class extends P {
  constructor() {
    super(...arguments), this.box_name = "TypeCombinationBox";
  }
  parse(i) {
    const e = (this.size - this.hdr_size) / 4;
    this.compatible_brands = [];
    for (let t = 0; t < e; t++)
      this.compatible_brands[t] = i.readString(4);
  }
}, jl.fourcc = "tyco", jl), Ql, wv = (Ql = class extends F {
  constructor() {
    super(...arguments), this.box_name = "UserDescriptionProperty";
  }
  parse(i) {
    this.parseFullHeader(i), this.lang = i.readCString(), this.name = i.readCString(), this.description = i.readCString(), this.tags = i.readCString();
  }
}, Ql.fourcc = "udes", Ql), ec, Tv = (ec = class extends F {
  constructor() {
    super(...arguments), this.box_name = "UncompressedFrameConfigBox";
  }
  parse(i) {
    if (this.parseFullHeader(i), this.profile = i.readString(4), this.version !== 1 && this.version === 0) {
      this.component_count = i.readUint32(), this.component_index = [], this.component_bit_depth_minus_one = [], this.component_format = [], this.component_align_size = [];
      for (let t = 0; t < this.component_count; t++)
        this.component_index.push(i.readUint16()), this.component_bit_depth_minus_one.push(i.readUint8()), this.component_format.push(i.readUint8()), this.component_align_size.push(i.readUint8());
      this.sampling_type = i.readUint8(), this.interleave_type = i.readUint8(), this.block_size = i.readUint8();
      const e = i.readUint8();
      this.component_little_endian = e >> 7 & 1, this.block_pad_lsb = e >> 6 & 1, this.block_little_endian = e >> 5 & 1, this.block_reversed = e >> 4 & 1, this.pad_unknown = e >> 3 & 1, this.pixel_size = i.readUint32(), this.row_align_size = i.readUint32(), this.tile_align_size = i.readUint32(), this.num_tile_cols_minus_one = i.readUint32(), this.num_tile_rows_minus_one = i.readUint32();
    }
  }
}, ec.fourcc = "uncC", ec), tc, Sv = (tc = class extends F {
  constructor() {
    super(...arguments), this.box_name = "DataEntryUrnBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.name = i.readCString(), this.size - this.hdr_size - this.name.length - 1 > 0 && (this.location = i.readCString());
  }
  /** @bundle writing/urn.js */
  write(i) {
    this.version = 0, this.flags = 0, this.size = this.name.length + 1 + (this.location ? this.location.length + 1 : 0), this.writeHeader(i), i.writeCString(this.name), this.location && i.writeCString(this.location);
  }
}, tc.fourcc = "urn ", tc), ic, Cv = (ic = class extends P {
  constructor() {
    super(...arguments), this.box_name = "WebVTTConfigurationBox";
  }
  parse(i) {
    this.text = i.readString(this.size - this.hdr_size);
  }
}, ic.fourcc = "vttC", ic), sc, Av = (sc = class extends F {
  constructor() {
    super(...arguments), this.box_name = "VvcNALUConfigBox";
  }
  parse(i) {
    this.parseFullHeader(i);
    const e = i.readUint8();
    this.lengthSizeMinusOne = e & 3;
  }
}, sc.fourcc = "vvnC", sc), rc, Iv = (rc = class extends ye {
  parse(i) {
    const e = i.readUint16();
    this.first_output_sample = i.readUint16(), this.sample_offset = [];
    for (let s = 0; s < e; s++)
      this.sample_offset[s] = i.readUint32();
    const t = this.description_length - 4 - 4 * e;
    this.num_output_samples = [], this.num_total_samples = [];
    for (let s = 0; s < t / 4; s++)
      this.num_output_samples[s] = i.readUint16(), this.num_total_samples[s] = i.readUint16();
  }
}, rc.grouping_type = "alst", rc), nc, kv = (nc = class extends ye {
  parse(i) {
    this.layerNumber = i.readUint8(), this.accurateStatisticsFlag = i.readUint8(), this.avgBitRate = i.readUint16(), this.avgFrameRate = i.readUint16();
  }
}, nc.grouping_type = "avll", nc), oc, Fv = (oc = class extends ye {
  parse(i) {
    this.subSequenceIdentifier = i.readUint16(), this.layerNumber = i.readUint8();
    const e = i.readUint8();
    this.durationFlag = e >> 7, this.avgRateFlag = e >> 6 & 1, this.durationFlag && (this.duration = i.readUint32()), this.avgRateFlag && (this.accurateStatisticsFlag = i.readUint8(), this.avgBitRate = i.readUint16(), this.avgFrameRate = i.readUint16()), this.dependency = [];
    const t = i.readUint8();
    for (let s = 0; s < t; s++)
      this.dependency.push({
        subSeqDirectionFlag: i.readUint8(),
        layerNumber: i.readUint8(),
        subSequenceIdentifier: i.readUint16()
      });
  }
}, oc.grouping_type = "avss", oc), ac, Mv = (ac = class extends ye {
  parse(i) {
    I.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }
}, ac.grouping_type = "dtrt", ac), lc, Ev = (lc = class extends ye {
  parse(i) {
    I.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }
}, lc.grouping_type = "mvif", lc), cc, Pv = (cc = class extends ye {
  parse(i) {
    this.roll_distance = i.readInt16();
  }
}, cc.grouping_type = "prol", cc), hc, Uv = (hc = class extends ye {
  parse(i) {
    const e = i.readUint8();
    this.num_leading_samples_known = e >> 7, this.num_leading_samples = e & 127;
  }
}, hc.grouping_type = "rap ", hc), uc, Rv = (uc = class extends ye {
  parse(i) {
    if (this.operation_point_count = i.readUint16(), this.description_length !== 2 + (this.operation_point_count === 1 ? 2 : this.operation_point_count * 6) + 9)
      I.warn("BoxParser", "Mismatch in " + this.grouping_type + " sample group length"), this.data = i.readUint8Array(this.description_length - 2);
    else {
      if (this.operation_point_count === 1)
        this.target_rate_share = i.readUint16();
      else {
        this.target_rate_share = [], this.available_bitrate = [];
        for (let e = 0; e < this.operation_point_count; e++)
          this.available_bitrate[e] = i.readUint32(), this.target_rate_share[e] = i.readUint16();
      }
      this.maximum_bitrate = i.readUint32(), this.minimum_bitrate = i.readUint32(), this.discard_priority = i.readUint8();
    }
  }
}, uc.grouping_type = "rash", uc), dc, Bv = (dc = class extends ye {
  parse(i) {
    this.roll_distance = i.readInt16();
  }
}, dc.grouping_type = "roll", dc), fc, zv = (fc = class extends ye {
  parse(i) {
    I.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }
}, fc.grouping_type = "scif", fc), pc, Ov = (pc = class extends ye {
  parse(i) {
    I.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }
}, pc.grouping_type = "scnm", pc), mc, Dv = (mc = class extends ye {
  parse(i) {
    this.reserved = i.readUint8();
    const e = i.readUint8();
    this.crypt_byte_block = e >> 4, this.skip_byte_block = e & 15, this.isProtected = i.readUint8(), this.Per_Sample_IV_Size = i.readUint8(), this.KID = Ht(i), this.constant_IV_size = 0, this.constant_IV = 0, this.isProtected === 1 && this.Per_Sample_IV_Size === 0 && (this.constant_IV_size = i.readUint8(), this.constant_IV = i.readUint8Array(this.constant_IV_size));
  }
}, mc.grouping_type = "seig", mc), gc, Lv = (gc = class extends ye {
  parse(i) {
    I.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }
}, gc.grouping_type = "stsa", gc), xc, Nv = (xc = class extends ye {
  parse(i) {
    const e = i.readUint8();
    this.NAL_unit_type = e & 63;
  }
}, xc.grouping_type = "sync", xc), yc, Gv = (yc = class extends ye {
  parse(i) {
    const e = i.readUint8();
    this.level_independently_decodable = e >> 7;
  }
}, yc.grouping_type = "tele", yc), vc, Hv = (vc = class extends ye {
  parse(i) {
    I.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }
}, vc.grouping_type = "tsas", vc), _c, Wv = (_c = class extends ye {
  parse(i) {
    I.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }
}, _c.grouping_type = "tscl", _c), bc, Vv = (bc = class extends ye {
  parse(i) {
    I.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }
}, bc.grouping_type = "vipr", bc), wc, $v = (wc = class extends P {
}, wc.fourcc = "uuid", wc), Tc, mi = (Tc = class extends F {
}, Tc.fourcc = "uuid", Tc), Sc, Yv = (Sc = class extends mi {
  constructor() {
    super(...arguments), this.box_name = "LiveServerManifestBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.LiveServerManifest = i.readString(this.size - this.hdr_size).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
}, Sc.uuid = "a5d40b30e81411ddba2f0800200c9a66", Sc), Cc, Xv = (Cc = class extends mi {
  constructor() {
    super(...arguments), this.box_name = "PiffProtectionSystemSpecificHeaderBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.system_id = Ht(i);
    const e = i.readUint32();
    e > 0 && (this.data = i.readUint8Array(e));
  }
}, Cc.uuid = "d08a4f1810f34a82b6c832d8aba183d3", Cc), Ac, qv = (Ac = class extends mi {
  constructor() {
    super(...arguments), this.box_name = "PiffSampleEncryptionBox";
  }
}, Ac.uuid = "a2394f525a9b4f14a2446c427c648df4", Ac), Ic, Zv = (Ic = class extends mi {
  constructor() {
    super(...arguments), this.box_name = "PiffTrackEncryptionBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.default_AlgorithmID = i.readUint24(), this.default_IV_size = i.readUint8(), this.default_KID = Ht(i);
  }
}, Ic.uuid = "8974dbce7be74c5184f97148f9882554", Ic), kc, Kv = (kc = class extends mi {
  constructor() {
    super(...arguments), this.box_name = "TfrfBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.fragment_count = i.readUint8(), this.entries = [];
    for (let e = 0; e < this.fragment_count; e++) {
      let t = 0, s = 0;
      this.version === 1 ? (t = i.readUint64(), s = i.readUint64()) : (t = i.readUint32(), s = i.readUint32()), this.entries.push({
        absolute_time: t,
        absolute_duration: s
      });
    }
  }
}, kc.uuid = "d4807ef2ca3946958e5426cb9e46a79f", kc), Fc, Jv = (Fc = class extends mi {
  constructor() {
    super(...arguments), this.box_name = "TfxdBox";
  }
  parse(i) {
    this.parseFullHeader(i), this.version === 1 ? (this.absolute_time = i.readUint64(), this.duration = i.readUint64()) : (this.absolute_time = i.readUint32(), this.duration = i.readUint32());
  }
}, Fc.uuid = "6d1d9b0542d544e680e2141daff757b2", Fc), Mc, jv = (Mc = class extends $v {
  constructor() {
    super(...arguments), this.box_name = "ItemContentIDProperty";
  }
  parse(i) {
    this.content_id = i.readCString();
  }
}, Mc.uuid = "261ef3741d975bbaacbd9d2c8ea73522", Mc), sp = pg(ip);
mg(Jf);
const $t = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AudioSampleEntry: Re,
  Box: P,
  BoxParser: sp,
  DIFF_BOXES_PROP_NAMES: Js,
  DIFF_PRIMITIVE_ARRAY_PROP_NAMES: df,
  DataStream: we,
  Descriptor: Mt,
  ES_Descriptor: Qh,
  Endianness: af,
  FullBox: F,
  HintSampleEntry: mh,
  ISOFile: Zf,
  Log: I,
  MP4BoxBuffer: dt,
  MPEG4DescriptorParser: tp,
  MetadataSampleEntry: Wt,
  MultiBufferStream: ni,
  SampleEntry: pt,
  SampleGroupEntry: ye,
  SampleGroupInfo: Os,
  SingleItemTypeReferenceBox: cf,
  SingleItemTypeReferenceBoxLarge: hf,
  SubtitleSampleEntry: kt,
  SystemSampleEntry: cr,
  TX3GParser: hx,
  TextSampleEntry: pf,
  Textin4Parser: cx,
  TrackGroupTypeBox: lf,
  TrackReferenceTypeBox: uf,
  VTTin4Parser: ax,
  VisualSampleEntry: ce,
  XMLSubtitlein4Parser: lx,
  boxEqual: Kh,
  boxEqualFields: ff,
  createFile: Kf
}, Symbol.toStringTag, { value: "Module" })), Qv = sp?.box?.esds, e_ = Kf;
class t_ {
  all = /* @__PURE__ */ new Map();
  on(e, t) {
    const s = this.all.get(e);
    return s ? s.push(t) : this.all.set(e, [t]), () => this.off(e, t);
  }
  /**
   * Register a one-time event handler for the given type.
   * @param {string|symbol} type Type of event to listen for
   * @param {Function} handler Function to call in response to given event
   * @returns {Function} A function to unregister the handler
   */
  once(e, t) {
    const s = this.on(e, (r) => {
      s(), t(r);
    });
    return s;
  }
  off(e, t) {
    const s = this.all.get(e);
    s && (t ? s.splice(s.indexOf(t) >>> 0, 1) : this.all.set(e, []));
  }
  emit(e, t) {
    let s = this.all.get(e);
    s && s.slice().forEach((r) => {
      r(t);
    }), s = this.all.get("*"), s && s.slice().forEach((r) => {
      r(e, t);
    });
  }
}
const i_ = {
  0: "debug",
  1: "info",
  2: "warn",
  3: "error"
};
function s_(i) {
  if (i instanceof Error) return String(i);
  if (typeof i == "object" && i !== null)
    try {
      return JSON.stringify(i, (e, t) => t instanceof Error ? String(t) : t);
    } catch {
      return String(i);
    }
  return String(i);
}
function r_() {
  const i = /* @__PURE__ */ new Date(), e = (s) => s.toString().padStart(2, "0"), t = i.getMilliseconds().toString().padStart(3, "0");
  return `${e(i.getHours())}:${e(i.getMinutes())}:${e(i.getSeconds())}.${t}`;
}
class n_ {
  threshold = 1;
  history = [];
  debug = (...e) => this.log(0, console.debug, e);
  info = (...e) => this.log(1, console.info, e);
  warn = (...e) => this.log(2, console.warn, e);
  error = (...e) => this.log(3, console.error, e);
  log(e, t, s) {
    e >= this.threshold && (t(...s), this.history.push({
      level: i_[e],
      time: r_(),
      args: s
    }));
  }
  setThreshold(e) {
    this.threshold = e;
  }
  getThreshold() {
    return this.threshold;
  }
  createTagged(e) {
    return {
      debug: (...t) => this.debug(e, ...t),
      info: (...t) => this.info(e, ...t),
      warn: (...t) => this.warn(e, ...t),
      error: (...t) => this.error(e, ...t)
    };
  }
  dump() {
    return this.history.map(
      ({ level: e, time: t, args: s }) => `[${e.toUpperCase()}][${t}] ${s.map(s_).join(" ")}`
    ).join(`
`);
  }
}
const at = new n_(), Ie = {
  debug: at.debug,
  info: at.info,
  warn: at.warn,
  error: at.error,
  /**
   * Sets the logging threshold. Only logs at this level or higher will be recorded.
   * @example Log.setLogLevel(Log.warn) // Only warn and error will be logged
   */
  setLogLevel: (i) => {
    const e = i;
    e === Ie.debug ? at.setThreshold(
      0
      /* DEBUG */
    ) : e === Ie.info ? at.setThreshold(
      1
      /* INFO */
    ) : e === Ie.warn ? at.setThreshold(
      2
      /* WARN */
    ) : e === Ie.error && at.setThreshold(
      3
      /* ERROR */
    );
  },
  /**
   * Creates a logger instance that prefixes all messages with a tag.
   */
  create: (i) => at.createTagged(i),
  /**
   * Dumps the log history as a string.
   */
  dump: async () => at.dump()
};
(async function() {
  if (!(typeof navigator > "u" || typeof document > "u") && (Ie.info(`User Agent: ${navigator.userAgent}`), document.addEventListener("visibilitychange", () => {
    Ie.info(`visibilitychange: ${document.visibilityState}`);
  }), "PressureObserver" in globalThis))
    try {
      let i = "";
      new globalThis.PressureObserver((e) => {
        const t = JSON.stringify(e.map((s) => s.state));
        t !== i && (Ie.info(`cpu state change: ${t}`), i = t);
      }).observe("cpu");
    } catch (i) {
      Ie.debug("Failed to initialize PressureObserver", i);
    }
})();
let bt = class {
  buffer;
  view;
  offset = 0;
  constructor(e) {
    this.buffer = new Uint8Array(e), this.view = new DataView(this.buffer.buffer);
  }
  /** Writes a 32-bit unsigned integer to the current offset. */
  writeUint32(e) {
    return this.view.setUint32(this.offset, e), this.offset += 4, this;
  }
  /** Writes a 16-bit unsigned integer to the current offset. */
  writeUint16(e) {
    return this.view.setUint16(this.offset, e), this.offset += 2, this;
  }
  /** Writes an 8-bit unsigned integer to the current offset. */
  writeUint8(e) {
    return this.view.setUint8(this.offset, e), this.offset += 1, this;
  }
  /** Writes a 4-character string as a box type to the current offset. */
  writeType(e) {
    for (let t = 0; t < 4; t++) {
      const s = t < e.length ? e.charCodeAt(t) : 0;
      this.buffer[this.offset + t] = s;
    }
    return this.offset += 4, this;
  }
  /** Writes raw bytes to the current offset. */
  writeBytes(e) {
    const t = e instanceof Uint8Array ? e : new Uint8Array(e);
    return this.buffer.set(t, this.offset), this.offset += t.byteLength, this;
  }
  /** Skips the specified number of bytes. */
  skip(e) {
    return this.offset += e, this;
  }
};
const o_ = () => {
  const i = new TextEncoder().encode("mp4 handler"), e = 32 + i.byteLength + 1;
  return new bt(e).writeUint32(e).writeType("hdlr").writeUint32(0).skip(4).writeType("mdta").skip(12).writeBytes(i).skip(1).buffer;
}, a_ = (i) => {
  const e = new TextEncoder(), t = i.map((n) => {
    const o = e.encode(n), a = 8 + o.byteLength;
    return new bt(a).writeUint32(a).writeType("mdta").writeBytes(o).buffer;
  }), s = 16 + t.reduce((n, o) => n + o.byteLength, 0), r = new bt(s).writeUint32(s).writeType("keys").writeUint32(0).writeUint32(i.length);
  return t.forEach((n) => r.writeBytes(n)), r.buffer;
}, l_ = (i) => {
  const e = new TextEncoder(), t = Object.entries(i).map(([n, o], a) => {
    const l = a + 1, c = e.encode(o), h = 16 + c.byteLength, u = 8 + h;
    return new bt(u).writeUint32(u).writeUint32(l).writeUint32(h).writeType("data").writeUint32(1).skip(4).writeBytes(c).buffer;
  }), s = 8 + t.reduce((n, o) => n + o.byteLength, 0), r = new bt(s).writeUint32(s).writeType("ilst");
  return t.forEach((n) => r.writeBytes(n)), r.buffer;
}, c_ = (i) => {
  const e = o_(), t = a_(Object.keys(i)), s = l_(i), r = e.length + t.length + s.length;
  return new bt(r).writeBytes(e).writeBytes(t).writeBytes(s).buffer;
};
function rp(i) {
  const e = new ArrayBuffer(i.byteLength);
  i.copyTo(e);
  const t = i.timestamp;
  return {
    duration: i.duration ?? 0,
    dts: t,
    cts: t,
    is_sync: i.type === "key",
    data: e
  };
}
function h_(i) {
  const e = i.byteLength, t = i instanceof ArrayBuffer ? new Uint8Array(i) : new Uint8Array(i.buffer, i.byteOffset, i.byteLength), s = 26 + e + // DecoderSpecificInfo header + data
  3;
  return new bt(s).writeUint8(3).writeUint8(23 + e).writeUint16(1).writeUint8(0).writeUint8(4).writeUint8(15 + e).writeUint8(64).writeUint8(21).writeBytes([0, 0, 0]).writeUint32(0).writeUint32(0).writeUint8(5).writeUint8(e).writeBytes(t).writeUint8(6).writeUint8(1).writeUint8(2).buffer;
}
function u_(i) {
  const e = new DataView(i instanceof ArrayBuffer ? i : i.buffer, i.byteOffset || 0), t = e.getUint8(9), s = e.getUint16(10, !0), r = e.getUint32(12, !0), n = e.getInt16(16, !0), o = e.getUint8(18);
  return new bt(11).writeUint8(0).writeUint8(t).writeUint16(s).writeUint32(r).writeUint16(n).writeUint8(o).buffer;
}
function d_(i) {
  const e = (i.codec || "vp09.00.40.08").split("."), t = parseInt(e[1] || "0", 10), s = parseInt(e[2] || "40", 10), r = parseInt(e[3] || "08", 10), n = { bt709: 1, bt601: 5, bt2020: 9 }, o = { bt709: 1, srgb: 13, pq: 16, hlg: 18 }, a = { bt709: 1, bt601: 5, bt2020: 9 }, l = n[i.colorSpace?.primaries || "bt709"] || 1, c = o[i.colorSpace?.transfer || "bt709"] || 1, h = a[i.colorSpace?.matrix || "bt709"] || 1, u = i.colorSpace?.fullRange ? 1 : 0;
  return new bt(12).writeUint32(1 << 24).writeUint8(t).writeUint8(s).writeUint8(r << 4 | 2 | u).writeUint8(l).writeUint8(c).writeUint8(h).writeUint16(0).buffer.buffer;
}
function f_(i) {
  if (i.byteLength < 7) return !1;
  const e = new DataView(i);
  let t = 0;
  try {
    t += 6;
    const s = e.getUint8(5) & 31;
    for (let n = 0; n < s; n++) {
      if (t + 2 > i.byteLength) return !1;
      const o = e.getUint16(t);
      t += 2 + o;
    }
    if (t + 1 > i.byteLength) return !1;
    const r = e.getUint8(t++);
    for (let n = 0; n < r; n++) {
      if (t + 2 > i.byteLength) return !1;
      const o = e.getUint16(t);
      t += 2 + o;
    }
    return t <= i.byteLength;
  } catch {
    return !1;
  }
}
function p_(i) {
  if (!i || i.byteLength < 3) return;
  const e = new Uint8Array(i);
  e[2]?.toString(2).slice(-2).includes("1") && (e[2] = 0);
}
class m_ {
  constructor(e, t, s) {
    this.opts = e, this.mp4File = t, this.avSyncTool = s, this.encoder = this.initEncoder(), this.avSyncTool.once("VideoReady", () => {
      this.videoReady = !0, this.flushCache();
    });
  }
  encoder;
  trackId = -1;
  cache = [];
  videoReady = !1;
  initEncoder() {
    const e = {
      codec: this.opts.codec === "aac" ? "mp4a.40.2" : "opus",
      sampleRate: this.opts.sampleRate,
      numberOfChannels: this.opts.channelCount,
      bitrate: 128e3
    }, t = new AudioEncoder({
      error: (s) => {
        const r = `AudioEncoder error: ${s.message}, config: ${JSON.stringify(e)}`;
        throw Ie.error(r), Error(r);
      },
      output: (s, r) => this.onOutput(s, r)
    });
    return t.configure(e), t;
  }
  onOutput(e, t) {
    this.trackId === -1 && this.setupTrack(t);
    const s = rp(e);
    this.videoReady ? this.mp4File.addSample(this.trackId, new Uint8Array(s.data), s) : this.cache.push(s);
  }
  setupTrack(e) {
    const t = e?.decoderConfig?.description, s = this.opts.codec === "aac", r = {
      timescale: 1e6,
      samplerate: this.opts.sampleRate,
      channel_count: this.opts.channelCount,
      hdlr: "soun",
      type: s ? "mp4a" : "Opus",
      name: "Track created with designcombo",
      description: t == null ? void 0 : s ? this.createESDS(t) : this.createDOps(t)
    };
    this.trackId = this.mp4File.addTrack(r), this.avSyncTool.emit("AudioReady", void 0), Ie.info("AudioEncoder, audio track ready, trackId:", this.trackId);
  }
  createESDS(e) {
    const t = new Qv();
    return t.version = 0, t.flags = 0, t.data = h_(e), t;
  }
  createDOps(e) {
    const t = u_(e);
    return {
      type: "dOps",
      size: t.byteLength + 8,
      hdr_size: 8,
      start: 0,
      data: t,
      write: function(s) {
        s.writeUint32(this.size), s.writeString("dOps"), s.writeUint8Array(this.data);
      },
      parse: function() {
      }
    };
  }
  flushCache() {
    this.cache.forEach((e) => {
      this.mp4File.addSample(this.trackId, new Uint8Array(e.data), e);
    }), this.cache = [];
  }
  encode(e) {
    this.encoder.encode(e);
  }
  async flush() {
    this.encoder.state === "configured" && await this.encoder.flush();
  }
  close() {
    this.encoder.state === "configured" && this.encoder.close();
  }
  get encodeQueueSize() {
    return this.encoder.encodeQueueSize;
  }
  get state() {
    return this.encoder.state;
  }
}
const g_ = () => {
  let i, e = 16.6;
  self.onmessage = (t) => {
    t.data.event === "start" && (self.clearInterval(i), i = self.setInterval(() => {
      self.postMessage({});
    }, e)), t.data.event === "stop" && self.clearInterval(i);
  };
}, x_ = () => {
  const i = new Blob([`(${g_.toString()})()`]), e = URL.createObjectURL(i);
  return new Worker(e);
}, Zt = /* @__PURE__ */ new Map();
let vh = 1, er = null;
globalThis.Worker != null && (er = x_(), er.onmessage = () => {
  vh += 1;
  for (const [i, e] of Zt)
    if (vh % i === 0) for (const t of e) t();
});
const y_ = (i, e) => {
  const t = Math.round(e / 16.6), s = Zt.get(t) ?? /* @__PURE__ */ new Set();
  return s.add(i), Zt.set(t, s), Zt.size === 1 && s.size === 1 && er?.postMessage({ event: "start" }), () => {
    s.delete(i), s.size === 0 && Zt.delete(t), Zt.size === 0 && (vh = 0, er?.postMessage({ event: "stop" }));
  };
};
class v_ {
  constructor(e, t, s) {
    this.opts = e, this.mp4File = t, this.avSyncTool = s, this.frameDeltaTime = Math.floor(1e3 / e.expectFPS * 1e3), this.encoder0 = this.initEncoder("encoder0"), this.encoder1 = this.initEncoder("encoder1"), this.avSyncTool.once("AudioReady", () => {
      this.audioReady = !0;
    }), this.stopTimer = y_(() => this.checkCache(), 15);
  }
  encoder0;
  encoder1;
  trackId = -1;
  samplesCache = {
    encoder0: [],
    encoder1: []
  };
  currentEncoderId = "encoder1";
  lastAddedSampleTime = 0;
  audioReady = !1;
  gopId = 0;
  stopTimer;
  frameDeltaTime;
  initEncoder(e) {
    const t = {
      codec: this.opts.codec,
      framerate: this.opts.expectFPS,
      hardwareAcceleration: this.opts.__unsafe_hardwareAcceleration__,
      bitrate: this.opts.bitrate,
      width: this.opts.width,
      height: this.opts.height,
      alpha: "discard",
      avc: { format: "avc" }
    }, s = new VideoEncoder({
      error: (r) => {
        throw Ie.error(`VideoEncoder error: ${r.message}`, t), Error(`VideoEncoder error: ${r.message}`);
      },
      output: (r, n) => this.onOutput(e, r, n)
    });
    return s.configure(t), s;
  }
  onOutput(e, t, s) {
    this.trackId === -1 && s != null && this.setupTrack(s), this.samplesCache[e].push(rp(t));
  }
  setupTrack(e) {
    if (!e.decoderConfig) return;
    let t = e.decoderConfig.description, s = "avc1";
    if (this.opts.codec.startsWith("avc1")) {
      if (p_(t), !f_(t)) {
        Ie.warn("Invalid AVCC descriptor, waiting for next metadata");
        return;
      }
    } else this.opts.codec.startsWith("vp09") && (s = "vp09", t = d_(e.decoderConfig));
    const r = this.getDecoderConfKey();
    if (!r || !t || t.byteLength < 7) {
      Ie.warn("VideoEncoder metadata missing valid configuration");
      return;
    }
    const n = {
      timescale: 1e6,
      width: this.opts.width,
      height: this.opts.height,
      brands: ["isom", "iso2", "avc1", "mp42", "mp41"],
      type: s,
      name: "Track created with designcombo"
    };
    n[r] = t;
    try {
      this.trackId = this.mp4File.addTrack(n), this.avSyncTool.emit("VideoReady", void 0), Ie.info("VideoEncoder, video track ready, trackId:", this.trackId);
    } catch (o) {
      Ie.warn("mp4File.addTrack warning", o);
    }
  }
  getDecoderConfKey() {
    return this.opts.codec.startsWith("avc1") ? "avcDecoderConfigRecord" : this.opts.codec.startsWith("hvc1") ? "hevcDecoderConfigRecord" : this.opts.codec.startsWith("vp09") ? "vpcDecoderConfigRecord" : null;
  }
  checkCache() {
    if (!this.audioReady || this.trackId === -1) return;
    const e = this.currentEncoderId === "encoder1" ? "encoder0" : "encoder1", t = this.samplesCache[this.currentEncoderId], s = this.samplesCache[e];
    if (t.length === 0 && s.length === 0) return;
    const r = t[0];
    if (r != null && (!r.is_sync || r.cts - this.lastAddedSampleTime < this.frameDeltaTime)) {
      const o = this.addSampleToFile(t);
      o > this.lastAddedSampleTime && (this.lastAddedSampleTime = o);
    }
    const n = s[0];
    if (n?.is_sync && n.cts - this.lastAddedSampleTime < this.frameDeltaTime) {
      this.currentEncoderId = e, this.checkCache();
      return;
    }
    if (r?.is_sync && n?.is_sync)
      if (r.cts <= n.cts) {
        const o = this.addSampleToFile(t);
        o > this.lastAddedSampleTime && (this.lastAddedSampleTime = o);
      } else
        this.currentEncoderId = e, this.checkCache();
  }
  addSampleToFile(e) {
    let t = -1, s = 0;
    for (; s < e.length; s++) {
      const r = e[s];
      if (s > 0 && r.is_sync) break;
      this.mp4File.addSample(this.trackId, new Uint8Array(r.data), r), t = r.cts + r.duration;
    }
    return e.splice(0, s), t;
  }
  encode(e, t) {
    t.keyFrame && this.gopId++, (this.gopId % 2 === 0 ? this.encoder0 : this.encoder1).encode(e, t);
  }
  async flush() {
    await Promise.all([
      this.encoder0.state === "configured" ? this.encoder0.flush() : null,
      this.encoder1.state === "configured" ? this.encoder1.flush() : null
    ]), this.stopTimer(), this.checkCache();
  }
  close() {
    this.encoder0.state === "configured" && this.encoder0.close(), this.encoder1.state === "configured" && this.encoder1.close();
  }
  get encodeQueueSize() {
    return this.encoder0.encodeQueueSize + this.encoder1.encodeQueueSize;
  }
}
function __(i) {
  Ie.info("recodemux opts:", i);
  const e = e_(), t = new t_(), s = (l, c) => {
    const h = l.add("udta").add("meta");
    h.data = c_(c), h.size = h.data.byteLength;
  };
  let r = !1;
  const n = () => {
    e.moov == null || r || (r = !0, i.metaDataTags && s(e.moov, i.metaDataTags), i.duration != null && (e.moov.mvhd.duration = i.duration));
  };
  t.once("VideoReady", n), t.once("AudioReady", n);
  const o = i.video ? new v_(i.video, e, t) : null, a = i.audio ? new m_(i.audio, e, t) : null;
  return i.video || t.emit("VideoReady", void 0), i.audio || t.emit("AudioReady", void 0), {
    encodeVideo: (l, c) => {
      o?.encode(l, c), l.close();
    },
    encodeAudio: (l) => {
      if (a)
        try {
          a.encode(l), l.close();
        } catch (c) {
          throw Ie.error("encode audio chunk error", c), c;
        }
    },
    getEncodeQueueSize: () => o?.encodeQueueSize ?? a?.encodeQueueSize ?? 0,
    flush: async () => {
      await Promise.all([
        o?.flush(),
        a?.flush()
      ]);
    },
    close: () => {
      t.all.clear(), o?.close(), a?.close();
    },
    mp4file: e
  };
}
var np = (i) => {
  throw TypeError(i);
}, op = (i, e, t) => e.has(i) || np("Cannot " + t), Y = (i, e, t) => (op(i, e, "read from private field"), t ? t.call(i) : e.get(i)), Ve = (i, e, t) => e.has(i) ? np("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(i) : e.set(i, t), Ee = (i, e, t, s) => (op(i, e, "write to private field"), e.set(i, t), t);
const ap = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHUobil7aWYobj09PSIvIilyZXR1cm57cGFyZW50Om51bGwsbmFtZToiIn07Y29uc3QgZT1uLnNwbGl0KCIvIikuZmlsdGVyKGk9PmkubGVuZ3RoPjApO2lmKGUubGVuZ3RoPT09MCl0aHJvdyBFcnJvcigiSW52YWxpZCBwYXRoIik7Y29uc3QgYT1lW2UubGVuZ3RoLTFdLHI9Ii8iK2Uuc2xpY2UoMCwtMSkuam9pbigiLyIpO3JldHVybntuYW1lOmEscGFyZW50OnJ9fWFzeW5jIGZ1bmN0aW9uIHcobixlKXtjb25zdHtwYXJlbnQ6YSxuYW1lOnJ9PXUobik7aWYoYT09bnVsbClyZXR1cm4gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7Y29uc3QgaT1hLnNwbGl0KCIvIikuZmlsdGVyKHQ9PnQubGVuZ3RoPjApO3RyeXtsZXQgdD1hd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtmb3IoY29uc3QgcyBvZiBpKXQ9YXdhaXQgdC5nZXREaXJlY3RvcnlIYW5kbGUocyx7Y3JlYXRlOmUuY3JlYXRlfSk7aWYoZS5pc0ZpbGUpcmV0dXJuIGF3YWl0IHQuZ2V0RmlsZUhhbmRsZShyLHtjcmVhdGU6ZS5jcmVhdGV9KX1jYXRjaCh0KXtpZih0Lm5hbWU9PT0iTm90Rm91bmRFcnJvciIpcmV0dXJuIG51bGw7dGhyb3cgdH19Y29uc3QgZj17fTtzZWxmLm9ubWVzc2FnZT1hc3luYyBuPT57dmFyIGk7Y29uc3R7ZXZ0VHlwZTplLGFyZ3M6YX09bi5kYXRhO2xldCByPWZbYS5maWxlSWRdO3RyeXtsZXQgdDtjb25zdCBzPVtdO2lmKGU9PT0icmVnaXN0ZXIiKXtjb25zdCBsPWF3YWl0IHcoYS5maWxlUGF0aCx7Y3JlYXRlOiEwLGlzRmlsZTohMH0pO2lmKGw9PW51bGwpdGhyb3cgRXJyb3IoYG5vdCBmb3VuZCBmaWxlOiAke2EuZmlsZUlkfWApO3I9YXdhaXQgbC5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKHttb2RlOmEubW9kZX0pLGZbYS5maWxlSWRdPXJ9ZWxzZSBpZihlPT09ImNsb3NlIilhd2FpdCByLmNsb3NlKCksZGVsZXRlIGZbYS5maWxlSWRdO2Vsc2UgaWYoZT09PSJ0cnVuY2F0ZSIpYXdhaXQgci50cnVuY2F0ZShhLm5ld1NpemUpO2Vsc2UgaWYoZT09PSJ3cml0ZSIpe2NvbnN0e2RhdGE6bCxvcHRzOm99PW4uZGF0YS5hcmdzO3Q9YXdhaXQgci53cml0ZShsLG8pfWVsc2UgaWYoZT09PSJyZWFkIil7Y29uc3R7b2Zmc2V0Omwsc2l6ZTpvfT1uLmRhdGEuYXJncyxnPW5ldyBVaW50OEFycmF5KG8pLGQ9YXdhaXQgci5yZWFkKGcse2F0Omx9KSxjPWcuYnVmZmVyO3Q9ZD09PW8/YzooKGk9Yy50cmFuc2Zlcik9PW51bGw/dm9pZCAwOmkuY2FsbChjLGQpKT8/Yy5zbGljZSgwLGQpLHMucHVzaCh0KX1lbHNlIGU9PT0iZ2V0U2l6ZSI/dD1hd2FpdCByLmdldFNpemUoKTplPT09ImZsdXNoIiYmYXdhaXQgci5mbHVzaCgpO3NlbGYucG9zdE1lc3NhZ2Uoe2V2dFR5cGU6ImNhbGxiYWNrIixjYklkOm4uZGF0YS5jYklkLHJldHVyblZhbDp0fSxzKX1jYXRjaCh0KXtjb25zdCBzPXQ7c2VsZi5wb3N0TWVzc2FnZSh7ZXZ0VHlwZToidGhyb3dFcnJvciIsY2JJZDpuLmRhdGEuY2JJZCxlcnJNc2c6cy5uYW1lKyI6ICIrcy5tZXNzYWdlK2AKYCtKU09OLnN0cmluZ2lmeShuLmRhdGEpfSl9fX0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZnMtd29ya2VyLUY0UldscWNfLmpzLm1hcAo=", b_ = (i) => Uint8Array.from(atob(i), (e) => e.charCodeAt(0)), ku = typeof self < "u" && self.Blob && new Blob([b_(ap)], { type: "text/javascript;charset=utf-8" });
function w_(i) {
  let e;
  try {
    if (e = ku && (self.URL || self.webkitURL).createObjectURL(ku), !e) throw "";
    const t = new Worker(e, {
      name: i?.name
    });
    return t.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(e);
    }), t;
  } catch {
    return new Worker(
      "data:text/javascript;base64," + ap,
      {
        name: i?.name
      }
    );
  } finally {
    e && (self.URL || self.webkitURL).revokeObjectURL(e);
  }
}
async function T_(i, e, t) {
  const s = S_();
  return await s("register", { fileId: i, filePath: e, mode: t }), {
    read: async (r, n) => await s("read", {
      fileId: i,
      offset: r,
      size: n
    }),
    write: async (r, n) => await s(
      "write",
      {
        fileId: i,
        data: r,
        opts: n
      },
      [ArrayBuffer.isView(r) ? r.buffer : r]
    ),
    close: async () => await s("close", {
      fileId: i
    }),
    truncate: async (r) => await s("truncate", {
      fileId: i,
      newSize: r
    }),
    getSize: async () => await s("getSize", {
      fileId: i
    }),
    flush: async () => await s("flush", {
      fileId: i
    })
  };
}
const ds = [];
let Ec = 0;
function S_() {
  if (ds.length < 3) {
    const e = i();
    return ds.push(e), e;
  } else {
    const e = ds[Ec];
    return Ec = (Ec + 1) % ds.length, e;
  }
  function i() {
    const e = new w_();
    let t = 0, s = {};
    return e.onmessage = ({
      data: r
    }) => {
      var n, o;
      r.evtType === "callback" ? (n = s[r.cbId]) == null || n.resolve(r.returnVal) : r.evtType === "throwError" && ((o = s[r.cbId]) == null || o.reject(Error(r.errMsg))), delete s[r.cbId];
    }, async function(r, n, o = []) {
      t += 1;
      const a = new Promise((l, c) => {
        s[t] = { resolve: l, reject: c };
      });
      return e.postMessage(
        {
          cbId: t,
          evtType: r,
          args: n
        },
        o
      ), a;
    };
  }
}
function dr(i) {
  if (i === "/") return { parent: null, name: "" };
  const e = i.split("/").filter((r) => r.length > 0);
  if (e.length === 0) throw Error("Invalid path");
  const t = e[e.length - 1], s = "/" + e.slice(0, -1).join("/");
  return { name: t, parent: s };
}
async function At(i, e) {
  const { parent: t, name: s } = dr(i);
  if (t == null) return await navigator.storage.getDirectory();
  const r = t.split("/").filter((n) => n.length > 0);
  try {
    let n = await navigator.storage.getDirectory();
    for (const o of r)
      n = await n.getDirectoryHandle(o, {
        create: e.create
      });
    return e.isFile ? await n.getFileHandle(s, {
      create: e.create
    }) : await n.getDirectoryHandle(s, {
      create: e.create
    });
  } catch (n) {
    if (n.name === "NotFoundError")
      return null;
    throw n;
  }
}
async function _h(i) {
  const { parent: e, name: t } = dr(i);
  if (e == null) {
    const r = await navigator.storage.getDirectory();
    for await (const n of r.keys())
      await r.removeEntry(n, { recursive: !0 });
    return;
  }
  const s = await At(e, {
    create: !1,
    isFile: !1
  });
  if (s != null)
    try {
      await s.removeEntry(t, { recursive: !0 });
    } catch (r) {
      if (r.name === "NotFoundError") return;
      throw r;
    }
}
function bh(i, e) {
  return `${i}/${e}`.replace("//", "/");
}
function ii(i) {
  return new cp(i);
}
var ct, Ls, Pi;
const C_ = class lp {
  constructor(e) {
    Ve(this, ct), Ve(this, Ls), Ve(this, Pi), Ee(this, ct, e);
    const { parent: t, name: s } = dr(e);
    Ee(this, Ls, s), Ee(this, Pi, t);
  }
  get kind() {
    return "dir";
  }
  get name() {
    return Y(this, Ls);
  }
  get path() {
    return Y(this, ct);
  }
  get parent() {
    return Y(this, Pi) == null ? null : ii(Y(this, Pi));
  }
  /**
   * Creates the directory.
   * return A promise that resolves when the directory is created.
   */
  async create() {
    return await At(Y(this, ct), {
      create: !0,
      isFile: !1
    }), ii(Y(this, ct));
  }
  /**
   * Checks if the directory exists.
   * return A promise that resolves to true if the directory exists, otherwise false.
   */
  async exists() {
    return await At(Y(this, ct), {
      create: !1,
      isFile: !1
    }) instanceof FileSystemDirectoryHandle;
  }
  /**
   * Removes the directory.
   * return A promise that resolves when the directory is removed.
   */
  async remove(e = {}) {
    for (const t of await this.children())
      try {
        await t.remove(e);
      } catch (s) {
        console.warn(s);
      }
    try {
      await _h(Y(this, ct));
    } catch (t) {
      console.warn(t);
    }
  }
  /**
   * Retrieves the children of the directory.
   * return A promise that resolves to an array of objects representing the children.
   */
  async children() {
    const e = await At(Y(this, ct), {
      create: !1,
      isFile: !1
    });
    if (e == null) return [];
    const t = [];
    for await (const s of e.values())
      t.push((s.kind === "file" ? ns : ii)(bh(Y(this, ct), s.name)));
    return t;
  }
  async copyTo(e) {
    if (!await this.exists())
      throw Error(`dir ${this.path} not exists`);
    if (e instanceof lp) {
      const t = await e.exists() ? ii(bh(e.path, this.name)) : e;
      return await t.create(), await Promise.all((await this.children()).map((s) => s.copyTo(t))), t;
    } else if (e instanceof FileSystemDirectoryHandle)
      return await Promise.all(
        (await this.children()).map(async (t) => {
          t.kind === "file" ? await t.copyTo(
            await e.getFileHandle(t.name, { create: !0 })
          ) : await t.copyTo(
            await e.getDirectoryHandle(t.name, { create: !0 })
          );
        })
      ), null;
    throw Error("Illegal target type");
  }
  /**
   * move directory, copy then remove current
   */
  async moveTo(e) {
    const t = await this.copyTo(e);
    return await this.remove(), t;
  }
};
ct = /* @__PURE__ */ new WeakMap(), Ls = /* @__PURE__ */ new WeakMap(), Pi = /* @__PURE__ */ new WeakMap();
let cp = C_;
const wh = /* @__PURE__ */ new Map();
function ns(i, e = "rw") {
  if (e === "rw") {
    const t = wh.get(i) ?? new tr(i, e);
    return wh.set(i, t), t;
  }
  return new tr(i, e);
}
async function Ji(i, e, t = { overwrite: !0 }) {
  if (e instanceof tr) {
    await Ji(i, await e.stream(), t);
    return;
  }
  const s = await (i instanceof tr ? i : ns(i, "rw")).createWriter();
  try {
    if (t.overwrite && await s.truncate(0), e instanceof ReadableStream) {
      const r = e.getReader();
      for (; ; ) {
        const { done: n, value: o } = await r.read();
        if (n) break;
        await s.write(o);
      }
    } else
      await s.write(e);
  } catch (r) {
    throw r;
  } finally {
    await s.close();
  }
}
let A_ = 0;
const I_ = () => ++A_;
var We, Ui, Ns, Ri, Gs, xt, Hs, Ws, Kt;
const k_ = class hp {
  constructor(e, t) {
    Ve(this, We), Ve(this, Ui), Ve(this, Ns), Ve(this, Ri), Ve(this, Gs), Ve(this, xt, 0), Ve(this, Hs, async () => {
    }), Ve(this, Ws, /* @__PURE__ */ (() => {
      let n = null;
      return () => (Ee(this, xt, Y(this, xt) + 1), n != null || (n = new Promise(async (o, a) => {
        try {
          const l = await T_(
            Y(this, Gs),
            Y(this, We),
            Y(this, Ri)
          );
          Ee(this, Hs, async () => {
            n != null && (n = null, Ee(this, xt, 0), await l.close().catch(console.error));
          }), o([
            l,
            async () => {
              Ee(this, xt, Y(this, xt) - 1), !(Y(this, xt) > 0) && (n = null, await l.close());
            }
          ]);
        } catch (l) {
          a(l);
        }
      })), n);
    })()), Ve(this, Kt, !1), Ee(this, Gs, I_()), Ee(this, We, e), Ee(this, Ri, {
      r: "read-only",
      rw: "readwrite",
      "rw-unsafe": "readwrite-unsafe"
    }[t]);
    const { parent: s, name: r } = dr(e);
    if (s == null) throw Error("Invalid path");
    Ee(this, Ns, r), Ee(this, Ui, s);
  }
  get kind() {
    return "file";
  }
  get path() {
    return Y(this, We);
  }
  get name() {
    return Y(this, Ns);
  }
  get parent() {
    return Y(this, Ui) == null ? null : ii(Y(this, Ui));
  }
  /**
   * Random write to file
   */
  async createWriter() {
    if (Y(this, Ri) === "read-only") throw Error("file is read-only");
    if (Y(this, Kt)) throw Error("Other writer have not been closed");
    Ee(this, Kt, !0);
    try {
      const e = new TextEncoder(), [t, s] = await Y(this, Ws).call(this);
      let r = await t.getSize(), n = !1;
      return {
        write: async (o, a = {}) => {
          if (n) throw Error("Writer is closed");
          const l = typeof o == "string" ? e.encode(o) : o, c = a.at ?? r, h = l.byteLength;
          return r = c + h, await t.write(l, { at: c });
        },
        truncate: async (o) => {
          if (n) throw Error("Writer is closed");
          await t.truncate(o), r > o && (r = o);
        },
        flush: async () => {
          if (n) throw Error("Writer is closed");
          await t.flush();
        },
        close: async () => {
          if (n) throw Error("Writer is closed");
          n = !0, Ee(this, Kt, !1), await s();
        }
      };
    } catch (e) {
      throw Ee(this, Kt, !1), e;
    }
  }
  /**
   * Random access to file
   */
  async createReader() {
    const [e, t] = await Y(this, Ws).call(this);
    let s = !1, r = 0;
    return {
      read: async (n, o = {}) => {
        if (s) throw Error("Reader is closed");
        const a = o.at ?? r, l = await e.read(a, n);
        return r = a + l.byteLength, l;
      },
      getSize: async () => {
        if (s) throw Error("Reader is closed");
        return await e.getSize();
      },
      close: async () => {
        s || (s = !0, await t());
      }
    };
  }
  async text() {
    return new TextDecoder().decode(await this.arrayBuffer());
  }
  async arrayBuffer() {
    const e = await At(Y(this, We), { create: !1, isFile: !0 });
    return e == null ? new ArrayBuffer(0) : (await e.getFile()).arrayBuffer();
  }
  async stream() {
    const e = await this.getOriginFile();
    return e == null ? new ReadableStream({
      pull: (t) => {
        t.close();
      }
    }) : e.stream();
  }
  async getOriginFile() {
    var e;
    return (e = await At(Y(this, We), { create: !1, isFile: !0 })) == null ? void 0 : e.getFile();
  }
  async getSize() {
    const e = await At(Y(this, We), { create: !1, isFile: !0 });
    return e == null ? 0 : (await e.getFile()).size;
  }
  async exists() {
    return await At(Y(this, We), {
      create: !1,
      isFile: !0
    }) instanceof FileSystemFileHandle;
  }
  async remove(e = {}) {
    if (e.force === !0) {
      await Y(this, Hs).call(this), await _h(Y(this, We)), wh.delete(Y(this, We));
      return;
    }
    if (Y(this, xt) > 0) throw Error("exists unclosed reader/writer");
    await _h(Y(this, We));
  }
  async copyTo(e) {
    if (e instanceof hp)
      return e.path === this.path ? this : (await Ji(e, this), e);
    if (e instanceof cp) {
      if (!await this.exists())
        throw Error(`file ${this.path} not exists`);
      return await this.copyTo(ns(bh(e.path, this.name)));
    } else if (e instanceof FileSystemFileHandle)
      return await (await this.stream()).pipeTo(await e.createWritable()), null;
    throw Error("Illegal target type");
  }
  /**
   * move file, copy then remove current
   */
  async moveTo(e) {
    const t = await this.copyTo(e);
    return await this.remove(), t;
  }
};
We = /* @__PURE__ */ new WeakMap(), Ui = /* @__PURE__ */ new WeakMap(), Ns = /* @__PURE__ */ new WeakMap(), Ri = /* @__PURE__ */ new WeakMap(), Gs = /* @__PURE__ */ new WeakMap(), xt = /* @__PURE__ */ new WeakMap(), Hs = /* @__PURE__ */ new WeakMap(), Ws = /* @__PURE__ */ new WeakMap(), Kt = /* @__PURE__ */ new WeakMap();
let tr = k_;
const eu = "/.opfs-tools-temp-dir";
async function up(i) {
  try {
    if (i.kind === "file") {
      if (!await i.exists()) return !0;
      const e = await i.createWriter();
      await e.truncate(0), await e.close(), await i.remove();
    } else
      await i.remove();
    return !0;
  } catch (e) {
    return console.warn(e), !1;
  }
}
function F_() {
  setInterval(async () => {
    for (const i of await ii(eu).children()) {
      const e = /^\d+-(\d+)$/.exec(i.name);
      (e == null || Date.now() - Number(e[1]) > 2592e5) && await up(i);
    }
  }, 60 * 1e3);
}
const Th = [];
let Fu = !1;
async function M_() {
  if (globalThis.localStorage == null) return;
  const i = "OPFS_TOOLS_EXPIRES_TMP_FILES";
  Fu || (Fu = !0, globalThis.addEventListener("unload", () => {
    Th.length !== 0 && localStorage.setItem(
      i,
      `${localStorage.getItem(i) ?? ""},${Th.join(",")}`
    );
  }));
  let e = localStorage.getItem(i) ?? "";
  for (const t of e.split(","))
    t.length !== 0 && await up(ns(`${eu}/${t}`)) && (e = e.replace(t, ""));
  localStorage.setItem(i, e.replace(/,{2,}/g, ","));
}
(async function() {
  var i;
  globalThis.__opfs_tools_tmpfile_init__ !== !0 && (globalThis.__opfs_tools_tmpfile_init__ = !0, !(globalThis.FileSystemDirectoryHandle == null || globalThis.FileSystemFileHandle == null || ((i = globalThis.navigator) == null ? void 0 : i.storage.getDirectory) == null) && (F_(), await M_()));
})();
function Sh() {
  const i = `${Math.random().toString().slice(2)}-${Date.now()}`;
  return Th.push(i), ns(`${eu}/${i}`);
}
const E_ = {
  0: "debug",
  1: "info",
  2: "warn",
  3: "error"
};
function P_(i) {
  if (i instanceof Error) return String(i);
  if (typeof i == "object" && i !== null)
    try {
      return JSON.stringify(
        i,
        (e, t) => t instanceof Error ? String(t) : t
      );
    } catch {
      return String(i);
    }
  return String(i);
}
function U_() {
  const i = /* @__PURE__ */ new Date(), e = (s) => s.toString().padStart(2, "0"), t = i.getMilliseconds().toString().padStart(3, "0");
  return `${e(i.getHours())}:${e(i.getMinutes())}:${e(i.getSeconds())}.${t}`;
}
class R_ {
  threshold = 1;
  history = [];
  debug = (...e) => this.log(0, console.debug, e);
  info = (...e) => this.log(1, console.info, e);
  warn = (...e) => this.log(2, console.warn, e);
  error = (...e) => this.log(3, console.error, e);
  log(e, t, s) {
    e >= this.threshold && (t(...s), this.history.push({
      level: E_[e],
      time: U_(),
      args: s
    }));
  }
  setThreshold(e) {
    this.threshold = e;
  }
  getThreshold() {
    return this.threshold;
  }
  createTagged(e) {
    return {
      debug: (...t) => this.debug(e, ...t),
      info: (...t) => this.info(e, ...t),
      warn: (...t) => this.warn(e, ...t),
      error: (...t) => this.error(e, ...t)
    };
  }
  dump() {
    return this.history.map(
      ({ level: e, time: t, args: s }) => `[${e.toUpperCase()}][${t}] ${s.map(P_).join(" ")}`
    ).join(`
`);
  }
}
const lt = new R_(), K = {
  debug: lt.debug,
  info: lt.info,
  warn: lt.warn,
  error: lt.error,
  /**
   * Sets the logging threshold. Only logs at this level or higher will be recorded.
   * @example Log.setLogLevel(Log.warn) // Only warn and error will be logged
   */
  setLogLevel: (i) => {
    const e = i;
    e === K.debug ? lt.setThreshold(
      0
      /* DEBUG */
    ) : e === K.info ? lt.setThreshold(
      1
      /* INFO */
    ) : e === K.warn ? lt.setThreshold(
      2
      /* WARN */
    ) : e === K.error && lt.setThreshold(
      3
      /* ERROR */
    );
  },
  /**
   * Creates a logger instance that prefixes all messages with a tag.
   */
  create: (i) => lt.createTagged(i),
  /**
   * Dumps the log history as a string.
   */
  dump: async () => lt.dump()
};
class B_ {
  /**
   * @param {number} scaleFrom the length of the original array.
   * @param {number} scaleTo The length of the new array.
   * @param {?Object} details The extra configuration, if needed.
   */
  constructor(e, t, s) {
    this.length_ = e, this.scaleFactor_ = (e - 1) / t, this.interpolate = this.cubic, s.method === "point" ? this.interpolate = this.point : s.method === "linear" ? this.interpolate = this.linear : s.method === "sinc" && (this.interpolate = this.sinc), this.tangentFactor_ = 1 - Math.max(0, Math.min(1, s.tension || 0)), this.sincFilterSize_ = s.sincFilterSize || 1, this.kernel_ = O_(s.sincWindow || z_);
  }
  /**
   * @param {number} t The index to interpolate.
   * @param {Array|TypedArray} samples the original array.
   * @return {number} The interpolated value.
   */
  point(e, t) {
    return this.getClippedInput_(Math.round(this.scaleFactor_ * e), t);
  }
  /**
   * @param {number} t The index to interpolate.
   * @param {Array|TypedArray} samples the original array.
   * @return {number} The interpolated value.
   */
  linear(e, t) {
    e = this.scaleFactor_ * e;
    let s = Math.floor(e);
    return e -= s, (1 - e) * this.getClippedInput_(s, t) + e * this.getClippedInput_(s + 1, t);
  }
  /**
   * @param {number} t The index to interpolate.
   * @param {Array|TypedArray} samples the original array.
   * @return {number} The interpolated value.
   */
  cubic(e, t) {
    e = this.scaleFactor_ * e;
    let s = Math.floor(e), r = [this.getTangent_(s, t), this.getTangent_(s + 1, t)], n = [
      this.getClippedInput_(s, t),
      this.getClippedInput_(s + 1, t)
    ];
    e -= s;
    let o = e * e, a = e * o;
    return (2 * a - 3 * o + 1) * n[0] + (a - 2 * o + e) * r[0] + (-2 * a + 3 * o) * n[1] + (a - o) * r[1];
  }
  /**
   * @param {number} t The index to interpolate.
   * @param {Array|TypedArray} samples the original array.
   * @return {number} The interpolated value.
   */
  sinc(e, t) {
    e = this.scaleFactor_ * e;
    let s = Math.floor(e), r = s - this.sincFilterSize_ + 1, n = s + this.sincFilterSize_, o = 0;
    for (let a = r; a <= n; a++)
      o += this.kernel_(e - a) * this.getClippedInput_(a, t);
    return o;
  }
  /**
   * @param {number} k The scaled index to interpolate.
   * @param {Array|TypedArray} samples the original array.
   * @return {number} The tangent.
   * @private
   */
  getTangent_(e, t) {
    return this.tangentFactor_ * (this.getClippedInput_(e + 1, t) - this.getClippedInput_(e - 1, t)) / 2;
  }
  /**
   * @param {number} t The scaled index to interpolate.
   * @param {Array|TypedArray} samples the original array.
   * @return {number} The interpolated value.
   * @private
   */
  getClippedInput_(e, t) {
    return 0 <= e && e < this.length_ ? t[e] : 0;
  }
}
function z_(i) {
  return Math.exp(-i / 2 * i / 2);
}
function O_(i) {
  return function(e) {
    return D_(e) * i(e);
  };
}
function D_(i) {
  return i === 0 ? 1 : Math.sin(Math.PI * i) / (Math.PI * i);
}
class L_ {
  /**
   * @param {number} order The order of the filter.
   * @param {number} sampleRate The sample rate.
   * @param {number} cutOff The cut off frequency.
   */
  constructor(e, t, s) {
    let r = 2 * Math.PI * s / t, n = 0;
    this.filters = [];
    for (let o = 0; o <= e; o++)
      o - e / 2 === 0 ? this.filters[o] = r : (this.filters[o] = Math.sin(r * (o - e / 2)) / (o - e / 2), this.filters[o] *= 0.54 - 0.46 * Math.cos(2 * Math.PI * o / e)), n = n + this.filters[o];
    for (let o = 0; o <= e; o++)
      this.filters[o] /= n;
    this.z = this.initZ_();
  }
  /**
   * @param {number} sample A sample of a sequence.
   * @return {number}
   */
  filter(e) {
    this.z.buf[this.z.pointer] = e;
    let t = 0;
    for (let s = 0, r = this.z.buf.length; s < r; s++)
      t += this.filters[s] * this.z.buf[(this.z.pointer + s) % this.z.buf.length];
    return this.z.pointer = (this.z.pointer + 1) % this.z.buf.length, t;
  }
  /**
   * Reset the filter.
   */
  reset() {
    this.z = this.initZ_();
  }
  /**
   * Return the default value for z.
   * @private
   */
  initZ_() {
    let e = [];
    for (let t = 0; t < this.filters.length - 1; t++)
      e.push(0);
    return {
      buf: e,
      pointer: 0
    };
  }
}
class N_ {
  /**
   * @param {number} order The order of the filter.
   * @param {number} sampleRate The sample rate.
   * @param {number} cutOff The cut off frequency.
   */
  constructor(e, t, s) {
    let r = [];
    for (let n = 0; n < e; n++)
      r.push(this.getCoeffs_({
        Fs: t,
        Fc: s,
        Q: 0.5 / Math.sin(Math.PI / (e * 2) * (n + 0.5))
      }));
    this.stages = [];
    for (let n = 0; n < r.length; n++)
      this.stages[n] = {
        b0: r[n].b[0],
        b1: r[n].b[1],
        b2: r[n].b[2],
        a1: r[n].a[0],
        a2: r[n].a[1],
        k: r[n].k,
        z: [0, 0]
      };
  }
  /**
   * @param {number} sample A sample of a sequence.
   * @return {number}
   */
  filter(e) {
    let t = e;
    for (let s = 0, r = this.stages.length; s < r; s++)
      t = this.runStage_(s, t);
    return t;
  }
  getCoeffs_(e) {
    let t = {};
    t.z = [0, 0], t.a = [], t.b = [];
    let s = this.preCalc_(e, t);
    return t.k = 1, t.b.push((1 - s.cw) / (2 * s.a0)), t.b.push(2 * t.b[0]), t.b.push(t.b[0]), t;
  }
  preCalc_(e, t) {
    let s = {}, r = 2 * Math.PI * e.Fc / e.Fs;
    return s.alpha = Math.sin(r) / (2 * e.Q), s.cw = Math.cos(r), s.a0 = 1 + s.alpha, t.a0 = s.a0, t.a.push(-2 * s.cw / s.a0), t.k = 1, t.a.push((1 - s.alpha) / s.a0), s;
  }
  runStage_(e, t) {
    let s = t * this.stages[e].k - this.stages[e].a1 * this.stages[e].z[0] - this.stages[e].a2 * this.stages[e].z[1], r = this.stages[e].b0 * s + this.stages[e].b1 * this.stages[e].z[0] + this.stages[e].b2 * this.stages[e].z[1];
    return this.stages[e].z[1] = this.stages[e].z[0], this.stages[e].z[0] = s, r;
  }
  /**
   * Reset the filter.
   */
  reset() {
    for (let e = 0; e < this.stages.length; e++)
      this.stages[e].z = [0, 0];
  }
}
const G_ = {
  point: !1,
  linear: !1,
  cubic: !0,
  sinc: !0
}, Mu = {
  IIR: 16,
  FIR: 71
}, H_ = {
  IIR: N_,
  FIR: L_
};
function W_(i, e, t, s = {}) {
  let r = (t - e) / e + 1, n = new Float64Array(i.length * r);
  s.method = s.method || "cubic";
  let o = new B_(
    i.length,
    n.length,
    {
      method: s.method,
      tension: s.tension || 0,
      sincFilterSize: s.sincFilterSize || 6,
      sincWindow: s.sincWindow || void 0
    }
  );
  if (s.LPF === void 0 && (s.LPF = G_[s.method]), s.LPF) {
    s.LPFType = s.LPFType || "IIR";
    const a = H_[s.LPFType];
    if (t > e) {
      let l = new a(
        s.LPFOrder || Mu[s.LPFType],
        t,
        e / 2
      );
      V_(
        i,
        n,
        o,
        l
      );
    } else {
      let l = new a(
        s.LPFOrder || Mu[s.LPFType],
        e,
        t / 2
      );
      $_(
        i,
        n,
        o,
        l
      );
    }
  } else
    dp(i, n, o);
  return n;
}
function dp(i, e, t) {
  for (let s = 0, r = e.length; s < r; s++)
    e[s] = t.interpolate(s, i);
}
function V_(i, e, t, s) {
  for (let r = 0, n = e.length; r < n; r++)
    e[r] = s.filter(t.interpolate(r, i));
  s.reset();
  for (let r = e.length - 1; r >= 0; r--)
    e[r] = s.filter(e[r]);
}
function $_(i, e, t, s) {
  for (let r = 0, n = i.length; r < n; r++)
    i[r] = s.filter(i[r]);
  s.reset();
  for (let r = i.length - 1; r >= 0; r--)
    i[r] = s.filter(i[r]);
  dp(i, e, t);
}
function Y_(i) {
  const e = new Float32Array(
    i.map((s) => s.length).reduce((s, r) => s + r)
  );
  let t = 0;
  for (const s of i)
    e.set(s, t), t += s.length;
  return e;
}
function fp(i) {
  const e = [];
  for (let t = 0; t < i.length; t += 1)
    for (let s = 0; s < i[t].length; s += 1)
      e[s] == null && (e[s] = []), e[s].push(i[t][s]);
  return e.map(Y_);
}
function pp(i) {
  if (i.format === "f32-planar") {
    const e = [];
    for (let t = 0; t < i.numberOfChannels; t += 1) {
      const s = i.allocationSize({ planeIndex: t }), r = new ArrayBuffer(s);
      i.copyTo(r, { planeIndex: t }), e.push(new Float32Array(r));
    }
    return e;
  } else if (i.format === "f32") {
    const e = new ArrayBuffer(i.allocationSize({ planeIndex: 0 }));
    return i.copyTo(e, { planeIndex: 0 }), q_(
      new Float32Array(e),
      i.numberOfChannels
    );
  } else if (i.format === "s16") {
    const e = new ArrayBuffer(i.allocationSize({ planeIndex: 0 }));
    return i.copyTo(e, { planeIndex: 0 }), X_(
      new Int16Array(e),
      i.numberOfChannels
    );
  }
  throw Error("Unsupported audio data format");
}
function X_(i, e) {
  const t = i.length / e, s = Array.from(
    { length: e },
    () => new Float32Array(t)
  );
  for (let r = 0; r < t; r++)
    for (let n = 0; n < e; n++) {
      const o = i[r * e + n];
      s[n][r] = o / 32768;
    }
  return s;
}
function q_(i, e) {
  const t = i.length / e, s = Array.from(
    { length: e },
    () => new Float32Array(t)
  );
  for (let r = 0; r < t; r++)
    for (let n = 0; n < e; n++)
      s[n][r] = i[r * e + n];
  return s;
}
function tu(i) {
  return Array(i.numberOfChannels).fill(0).map((e, t) => i.getChannelData(t));
}
function Eu(i) {
  const e = Math.max(...i.map((s) => s[0]?.length ?? 0)), t = new Float32Array(e * 2);
  for (let s = 0; s < e; s++) {
    let r = 0, n = 0;
    for (let o = 0; o < i.length; o++) {
      const a = i[o][0]?.[s] ?? 0, l = i[o][1]?.[s] ?? a;
      r += a, n += l;
    }
    t[s] = r, t[s + e] = n;
  }
  return t;
}
async function Z_(i, e, t) {
  const s = i.length, r = Array(t.chanCount).fill(0).map(() => new Float32Array(0));
  if (s === 0) return r;
  const n = Math.max(...i.map((c) => c.length));
  if (n === 0) return r;
  if (globalThis.OfflineAudioContext == null)
    return i.map(
      (c) => new Float32Array(
        W_(c, e, t.rate, {
          method: "sinc",
          LPF: !1
        })
      )
    );
  const o = new globalThis.OfflineAudioContext(
    t.chanCount,
    n * t.rate / e,
    t.rate
  ), a = o.createBufferSource(), l = o.createBuffer(s, n, e);
  return i.forEach((c, h) => l.copyToChannel(new Float32Array(c), h)), a.buffer = l, a.connect(o.destination), a.start(), tu(await o.startRendering());
}
function Ch(i, e, t) {
  const s = t - e, r = new Float32Array(s);
  let n = 0;
  for (; n < s; )
    r[n] = i[(e + n) % i.length], n += 1;
  return r;
}
function Pu(i, e) {
  const t = Math.floor(i.length / e), s = new Float32Array(t);
  for (let r = 0; r < t; r++) {
    const n = r * e, o = Math.floor(n), a = n - o;
    o + 1 < i.length ? s[r] = i[o] * (1 - a) + i[o + 1] * a : s[r] = i[o];
  }
  return s;
}
const K_ = [
  {
    codec: "mp4a.40.2",
    // AAC-LC
    codecType: "aac",
    sampleRate: 48e3,
    channelCount: 2
  },
  {
    codec: "opus",
    codecType: "opus",
    sampleRate: 48e3,
    channelCount: 2
  }
];
let Jt = null;
function J_() {
  if (typeof navigator > "u") return "unknown";
  const i = navigator.userAgent.toLowerCase();
  return i.includes("linux") ? "linux" : i.includes("mac") ? "macos" : i.includes("win") ? "windows" : "unknown";
}
async function j_(i) {
  if (typeof AudioEncoder > "u")
    return !1;
  try {
    return (await AudioEncoder.isConfigSupported({
      codec: i.codec,
      sampleRate: i.sampleRate,
      numberOfChannels: i.channelCount
    })).supported ?? !1;
  } catch {
    return !1;
  }
}
async function Q_() {
  if (Jt !== null)
    return Jt;
  const i = J_();
  for (const t of K_)
    if (await j_(t))
      return Jt = { ...t }, console.log(`[AudioCodec] Selected ${t.codec} for ${i}`), Jt;
  const e = {
    codec: "opus",
    codecType: "opus",
    sampleRate: 48e3,
    channelCount: 2
  };
  return console.warn("[AudioCodec] No supported codec found, falling back to Opus"), Jt = e, e;
}
function fs() {
  return Jt;
}
const eb = `#version 300 es
  layout (location = 0) in vec4 a_position;
  layout (location = 1) in vec2 a_texCoord;
  out vec2 v_texCoord;
  void main () {
    gl_Position = a_position;
    v_texCoord = a_texCoord;
  }
`, tb = `#version 300 es
precision mediump float;
out vec4 FragColor;
in vec2 v_texCoord;

uniform sampler2D frameTexture;
uniform vec3 keyColor;

// Chroma similarity calculation
uniform float similarity;
// Smoothness calculation for transparency
uniform float smoothness;
// Reduce green screen saturation to improve keying accuracy
uniform float spill;

vec2 RGBtoUV(vec3 rgb) {
  return vec2(
    rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5    + 0.5,
    rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081  + 0.5
  );
}

void main() {
  // Get current pixel RGBA value
  vec4 rgba = texture(frameTexture, v_texCoord);
  // Calculate chroma difference between current pixel and key color
  vec2 chromaVec = RGBtoUV(rgba.rgb) - RGBtoUV(keyColor);
  // Calculate chroma distance (vector length) between current pixel and key color, smaller distance means more similar
  float chromaDist = sqrt(dot(chromaVec, chromaVec));
  // Set similarity threshold, negative baseMask indicates green screen, positive indicates not green screen
  float baseMask = chromaDist - similarity;
  // If baseMask is negative, fullMask equals 0; if baseMask is positive, larger value means lower transparency
  float fullMask = pow(clamp(baseMask / smoothness, 0., 1.), 1.5);
  rgba.a = fullMask; // Set transparency
  // If baseMask is negative, spillVal equals 0; if baseMask is positive, smaller value means lower saturation
  float spillVal = pow(clamp(baseMask / spill, 0., 1.), 1.5);
  float desat = clamp(rgba.r * 0.2126 + rgba.g * 0.7152 + rgba.b * 0.0722, 0., 1.); // Calculate current pixel grayscale
  rgba.rgb = mix(vec3(desat, desat, desat), rgba.rgb, spillVal);
  FragColor = rgba;
}
`, ib = [-1, 1, -1, -1, 1, -1, 1, -1, 1, 1, -1, 1], sb = [0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1];
function rb(i, e, t) {
  const s = Uu(i, i.VERTEX_SHADER, e), r = Uu(i, i.FRAGMENT_SHADER, t), n = i.createProgram();
  if (i.attachShader(n, s), i.attachShader(n, r), i.linkProgram(n), !i.getProgramParameter(n, i.LINK_STATUS))
    throw Error(
      i.getProgramInfoLog(n) ?? "Unable to initialize the shader program"
    );
  return n;
}
function Uu(i, e, t) {
  const s = i.createShader(e);
  if (i.shaderSource(s, t), i.compileShader(s), !i.getShaderParameter(s, i.COMPILE_STATUS)) {
    const r = i.getShaderInfoLog(s);
    throw i.deleteShader(s), Error(r ?? "An error occurred compiling the shaders");
  }
  return s;
}
function nb(i, e, t) {
  i.bindTexture(i.TEXTURE_2D, t), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, i.RGBA, i.UNSIGNED_BYTE, e), i.drawArrays(i.TRIANGLES, 0, 6);
}
function ob(i) {
  const e = i.createTexture();
  if (e == null) throw Error("Create WebGL texture error");
  i.bindTexture(i.TEXTURE_2D, e);
  const t = 0, s = i.RGBA, r = 1, n = 1, o = 0, a = i.RGBA, l = i.UNSIGNED_BYTE, c = new Uint8Array([0, 0, 255, 255]);
  return i.texImage2D(
    i.TEXTURE_2D,
    t,
    s,
    r,
    n,
    o,
    a,
    l,
    c
  ), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), e;
}
function ab(i) {
  const e = "document" in globalThis ? globalThis.document.createElement("canvas") : new OffscreenCanvas(i.width, i.height);
  e.width = i.width, e.height = i.height;
  const t = e.getContext("webgl2", {
    premultipliedAlpha: !1,
    alpha: !0
  });
  if (t == null) throw Error("Cant create gl context");
  const s = rb(t, eb, tb);
  t.useProgram(s), t.uniform3fv(
    t.getUniformLocation(s, "keyColor"),
    i.keyColor.map((l) => l / 255)
  ), t.uniform1f(
    t.getUniformLocation(s, "similarity"),
    i.similarity
  ), t.uniform1f(
    t.getUniformLocation(s, "smoothness"),
    i.smoothness
  ), t.uniform1f(t.getUniformLocation(s, "spill"), i.spill);
  const r = t.createBuffer();
  t.bindBuffer(t.ARRAY_BUFFER, r), t.bufferData(t.ARRAY_BUFFER, new Float32Array(ib), t.STATIC_DRAW);
  const n = t.getAttribLocation(s, "a_position");
  t.vertexAttribPointer(
    n,
    2,
    t.FLOAT,
    !1,
    Float32Array.BYTES_PER_ELEMENT * 2,
    0
  ), t.enableVertexAttribArray(n);
  const o = t.createBuffer();
  t.bindBuffer(t.ARRAY_BUFFER, o), t.bufferData(
    t.ARRAY_BUFFER,
    new Float32Array(sb),
    t.STATIC_DRAW
  );
  const a = t.getAttribLocation(s, "a_texCoord");
  return t.vertexAttribPointer(
    a,
    2,
    t.FLOAT,
    !1,
    Float32Array.BYTES_PER_ELEMENT * 2,
    0
  ), t.enableVertexAttribArray(a), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, 1), { canvas: e, gl: t };
}
function lb(i) {
  return i instanceof VideoFrame ? { width: i.codedWidth, height: i.codedHeight } : { width: i.width, height: i.height };
}
function cb(i) {
  const t = new OffscreenCanvas(1, 1).getContext("2d");
  t.drawImage(i, 0, 0);
  const {
    data: [s, r, n]
  } = t.getImageData(0, 0, 1, 1);
  return [s, r, n];
}
const sk = (i) => {
  let e = null, t = null, s = i.keyColor, r = null;
  return async (n) => {
    if ((e == null || t == null || r == null) && (s == null && (s = cb(n)), { canvas: e, gl: t } = ab({
      ...lb(n),
      keyColor: s,
      ...i
    }), r = ob(t)), nb(t, n, r), globalThis.VideoFrame != null && n instanceof globalThis.VideoFrame) {
      const o = new VideoFrame(e, {
        alpha: "keep",
        timestamp: n.timestamp,
        duration: n.duration ?? void 0
      });
      return n.close(), o;
    }
    return createImageBitmap(e, {
      imageOrientation: n instanceof ImageBitmap ? "flipY" : "none"
    });
  };
}, hb = () => {
  let i, e = 16.6;
  self.onmessage = (t) => {
    t.data.event === "start" && (self.clearInterval(i), i = self.setInterval(() => {
      self.postMessage({});
    }, e)), t.data.event === "stop" && self.clearInterval(i);
  };
}, ub = () => {
  const i = new Blob([`(${hb.toString()})()`]), e = URL.createObjectURL(i);
  return new Worker(e);
}, jt = /* @__PURE__ */ new Map();
let Ah = 1, ir = null;
globalThis.Worker != null && (ir = ub(), ir.onmessage = () => {
  Ah += 1;
  for (const [i, e] of jt)
    if (Ah % i === 0) for (const t of e) t();
});
const db = (i, e) => {
  const t = Math.round(e / 16.6), s = jt.get(t) ?? /* @__PURE__ */ new Set();
  return s.add(i), jt.set(t, s), jt.size === 1 && s.size === 1 && ir?.postMessage({ event: "start" }), () => {
    s.delete(i), s.size === 0 && jt.delete(t), jt.size === 0 && (Ah = 0, ir?.postMessage({ event: "stop" }));
  };
};
function iu(i) {
  return new Promise((e) => {
    const t = db(() => {
      t(), e();
    }, i);
  });
}
function fb(i) {
  return document.createElement(i);
}
function pb(i) {
  var e = "", t = new Uint8Array(i), s = t.byteLength;
  for (let r = 0; r < s; r++)
    e += String.fromCharCode(t[r]);
  return window.btoa(e);
}
async function mb(i, e, t = {}) {
  const s = fb("pre");
  s.style.cssText = `margin: 0; ${e}; position: fixed;`, s.textContent = i, document.body.appendChild(s), t.onCreated?.(s);
  const { width: r, height: n } = s.getBoundingClientRect();
  s.remove();
  const o = new Image();
  o.width = r, o.height = n;
  const a = t.font == null ? "" : `
    @font-face {
      font-family: '${t.font.name}';
      src: url('data:font/woff2;base64,${pb(await (await fetch(t.font.url)).arrayBuffer())}') format('woff2');
    }
  `, l = `
    <svg xmlns="http://www.w3.org/2000/svg" width="${r}" height="${n}">
      <style>
        ${a}
      </style>
      <foreignObject width="100%" height="100%">
        <div xmlns="http://www.w3.org/1999/xhtml">${s.outerHTML}</div>
      </foreignObject>
    </svg>
  `.replace(/\t/g, "").replace(/#/g, "%23");
  return o.src = `data:image/svg+xml;charset=utf-8,${l}`, await new Promise((c) => {
    o.onload = c;
  }), o;
}
async function rk(i, e, t = {}) {
  const s = await mb(i, e, t), r = new OffscreenCanvas(s.width, s.height);
  return r.getContext("2d")?.drawImage(s, 0, 0, s.width, s.height), await createImageBitmap(r);
}
async function gb(i, e) {
  const t = {
    type: e,
    data: i
  }, s = new ImageDecoder(t);
  await Promise.all([s.completed, s.tracks.ready]);
  const r = s.tracks.selectedTrack?.frameCount ?? 1, n = [];
  for (let o = 0; o < r; o += 1)
    n.push((await s.decode({ frameIndex: o })).image);
  return n;
}
let su = class {
  all = /* @__PURE__ */ new Map();
  on(e, t) {
    const s = this.all.get(e);
    return s ? s.push(t) : this.all.set(e, [t]), () => this.off(e, t);
  }
  /**
   * Register a one-time event handler for the given type.
   * @param {string|symbol} type Type of event to listen for
   * @param {Function} handler Function to call in response to given event
   * @returns {Function} A function to unregister the handler
   */
  once(e, t) {
    const s = this.on(e, (r) => {
      s(), t(r);
    });
    return s;
  }
  off(e, t) {
    const s = this.all.get(e);
    s && (t ? s.splice(s.indexOf(t) >>> 0, 1) : this.all.set(e, []));
  }
  emit(e, t) {
    let s = this.all.get(e);
    s && s.slice().forEach((r) => {
      r(t);
    }), s = this.all.get("*"), s && s.slice().forEach((r) => {
      r(e, t);
    });
  }
};
class xb extends su {
  /**
   * Unique identifier for the sprite/clip
   */
  id = "";
  /**
   * Control display time range of clips, commonly used in editing scenario timeline (track) module
   * from: start time offset in microseconds
   * to: end time (from + duration) in microseconds
   */
  display = {
    from: 0,
    to: 0
  };
  /**
   * Duration of the clip in microseconds
   * Cannot exceed the duration of the referenced {@link IClip}
   */
  duration = 0;
  /**
   * Playback rate of current clip, 1 means normal playback
   * **Note**
   *    1. When setting playbackRate, duration must be actively corrected
   *    2. Audio uses the simplest interpolation algorithm to change rate, so changing rate will cause pitch variation, for custom algorithm please use {@link VideoClip.tickInterceptor} to implement
   */
  playbackRate = 1;
  /**
   * Trim range of the source media in microseconds
   * from: start time in microseconds
   * to: end time in microseconds
   */
  trim = {
    from: 0,
    to: 0
  };
  constructor() {
    super();
  }
  // Spatial properties
  _left = 0;
  /**
   * Left position (x coordinate)
   */
  get left() {
    return this._left;
  }
  set left(e) {
    const t = this._left !== e;
    this._left = e, t && this.emit("propsChange", { left: e });
  }
  _top = 0;
  /**
   * Top position (y coordinate)
   */
  get top() {
    return this._top;
  }
  set top(e) {
    const t = this._top !== e;
    this._top = e, t && this.emit("propsChange", { top: e });
  }
  _width = 0;
  /**
   * Width
   */
  get width() {
    return this._width;
  }
  set width(e) {
    const t = this._width !== e;
    this._width = e, t && this.emit("propsChange", { width: e });
  }
  _height = 0;
  /**
   * Height
   */
  get height() {
    return this._height;
  }
  set height(e) {
    const t = this._height !== e;
    this._height = e, t && this.emit("propsChange", { height: e });
  }
  _angle = 0;
  /**
   * Rotation angle in degrees
   */
  get angle() {
    return this._angle;
  }
  set angle(e) {
    const t = this._angle !== e;
    this._angle = e, t && this.emit("propsChange", { angle: e });
  }
  /**
   * Center point calculated from position and dimensions
   */
  get center() {
    return {
      x: this.left + this.width / 2,
      y: this.top + this.height / 2
    };
  }
  _zIndex = 0;
  get zIndex() {
    return this._zIndex;
  }
  /**
   * Control layering relationship between clips, clips with smaller zIndex will be occluded
   */
  set zIndex(e) {
    const t = this._zIndex !== e;
    this._zIndex = e, t && this.emit("propsChange", { zIndex: e });
  }
  _opacity = 1;
  /**
   * Opacity (0.0 to 1.0)
   */
  get opacity() {
    return this._opacity;
  }
  set opacity(e) {
    const t = this._opacity !== e;
    this._opacity = e, t && this.emit("propsChange", { opacity: e });
  }
  _volume = 1;
  /**
   * Audio volume level (0.0 to 1.0)
   */
  get volume() {
    return this._volume;
  }
  set volume(e) {
    const t = this._volume !== e;
    this._volume = e, t && this.emit("propsChange", { volume: e });
  }
  /**
   * Flip clip horizontally or vertically
   */
  flip = null;
  effects = [];
  /**
   * Styling properties (e.g., stroke, dropShadow, borderRadius)
   * This is a generic object to hold visual styles across different clip types
   */
  _style = {};
  get style() {
    return this._style;
  }
  set style(e) {
    this._style = e;
  }
  animatKeyFrame = null;
  animatOpts = null;
  /**
   * @see {@link IClip.ready}
   * For clips, this should be Promise<IClipMeta>, but for BaseSprite it's just Promise<void>
   */
  ready = Promise.resolve();
  _render(e) {
    const { center: t } = this;
    e.setTransform(
      // Horizontal scale, skew
      this.flip === "horizontal" ? -1 : 1,
      0,
      // Vertical skew, scale
      0,
      this.flip === "vertical" ? -1 : 1,
      // Coordinate origin offset x y
      t.x,
      t.y
    );
    const s = this.angle * Math.PI / 180;
    e.rotate((this.flip == null ? 1 : -1) * s), e.globalAlpha = this.opacity;
  }
  /**
   * Add animation to clip, usage reference CSS animation
   *
   * @example
   * sprite.setAnimation(
   *   {
   *     '0%': { x: 0, y: 0 },
   *     '25%': { x: 1200, y: 680 },
   *     '50%': { x: 1200, y: 0 },
   *     '75%': { x: 0, y: 680 },
   *     '100%': { x: 0, y: 0 },
   *   },
   *   { duration: 4e6, iterCount: 1 },
   * );
   *
   */
  setAnimation(e, t) {
    this.animatKeyFrame = Object.entries(e).map(([s, r]) => {
      const n = { from: 0, to: 100 }[s] ?? Number(s.slice(0, -1));
      if (isNaN(n) || n > 100 || n < 0)
        throw Error("keyFrame must between 0~100");
      return [n / 100, r];
    }), this.animatOpts = Object.assign({}, this.animatOpts, {
      duration: t.duration,
      delay: t.delay ?? 0,
      iterCount: t.iterCount ?? 1 / 0
    });
  }
  /**
   * If current sprite has animation set, set sprite's animation properties to state at specified time
   */
  animate(e) {
    if (this.animatKeyFrame == null || this.animatOpts == null || e < this.animatOpts.delay)
      return;
    const t = yb(
      e,
      this.animatKeyFrame,
      this.animatOpts
    );
    for (const s in t)
      switch (s) {
        case "opacity":
          this.opacity = t[s];
          break;
        case "x":
          this.left = t[s];
          break;
        case "y":
          this.top = t[s];
          break;
        case "w":
          this.width = t[s];
          break;
        case "h":
          this.height = t[s];
          break;
        case "angle":
          this.angle = t[s];
          break;
      }
  }
  /**
   * Copy current sprite's properties to target
   *
   * Used for cloning or copying state between {@link OffscreenSprite} instances
   */
  copyStateTo(e) {
    e.animatKeyFrame = this.animatKeyFrame, e.animatOpts = this.animatOpts, e.zIndex = this.zIndex, e.opacity = this.opacity, e.volume = this.volume, e.flip = this.flip, e.left = this.left, e.top = this.top, e.width = this.width, e.height = this.height, e.angle = this.angle, e.display = { ...this.display }, e.duration = this.duration, e.playbackRate = this.playbackRate, e.trim = { ...this.trim }, e.style = JSON.parse(JSON.stringify(this.style || {})), "src" in this && "src" in e && (e.src = this.src);
  }
  /**
   * Update multiple properties at once
   */
  update(e) {
    Object.assign(this, e), this.emit("propsChange", e);
  }
  destroy() {
    this.all.clear();
  }
}
function yb(i, e, t) {
  const s = i - t.delay, r = s % t.duration, n = s / t.duration >= t.iterCount || s === t.duration ? 1 : r / t.duration, o = e.findIndex((f) => f[0] >= n);
  if (o === -1) return {};
  const a = e[o - 1], l = e[o], c = l[1];
  if (a == null) return c;
  const h = a[1], u = {}, d = (n - a[0]) / (l[0] - a[0]);
  for (const f in c) {
    if (!Object.hasOwn(c, f) || typeof f != "string") continue;
    const m = f;
    h[m] != null && (u[m] = (c[m] - h[m]) * d + h[m]);
  }
  return u;
}
class Yt extends xb {
  // Keep last frame, if clip has no data at current frame, render last frame
  // Store as ImageBitmap for reusability (VideoFrames can only be used once)
  lastVf = null;
  destroyed = !1;
  /**
   * Source URL or identifier for this clip
   * Used for serialization and reloading from JSON
   */
  src = "";
  /**
   * Transition info (optional)
   */
  transition;
  constructor() {
    super();
  }
  /**
   * Get video frame and audio at specified time without rendering to canvas
   * Useful for Pixi.js rendering where canvas context is not needed
   * @param time Specified time in microseconds
   */
  async getFrame(e) {
    const t = e * this.playbackRate, { video: s, audio: r, state: n } = await this.tick(t);
    let o = r ?? [];
    r != null && this.playbackRate !== 1 && (o = r.map(
      (l) => Pu(l, this.playbackRate)
    ));
    let a = null;
    return s != null ? (this.lastVf?.close(), s instanceof VideoFrame ? (a = await createImageBitmap(s), s.close()) : a = s, this.lastVf = a) : this.lastVf != null && (a = this.lastVf), {
      video: a,
      audio: o,
      done: n === "done"
    };
  }
  /**
   * Draw image at specified time to canvas context and return corresponding audio data
   * @param time Specified time in microseconds
   */
  async offscreenRender(e, t) {
    const s = t * this.playbackRate;
    this.animate(s), super._render(e);
    const { width: r, height: n } = this, { video: o, audio: a, state: l } = await this.tick(s);
    let c = a ?? [];
    if (a != null && this.playbackRate !== 1 && (c = a.map(
      (u) => Pu(u, this.playbackRate)
    )), l === "done")
      return {
        audio: c,
        done: !0
      };
    const h = o ?? this.lastVf;
    if (h != null) {
      const u = this.style.borderRadius || 0, d = this.style.dropShadow;
      if (e.save(), d && (d.blur > 0 || d.distance > 0)) {
        const m = d.distance ?? 0, g = d.angle ?? 0;
        e.shadowColor = d.color || "#000000", e.shadowBlur = d.blur || 0, e.shadowOffsetX = Math.cos(g) * m, e.shadowOffsetY = Math.sin(g) * m;
      }
      if (u > 0) {
        const m = Math.min(u, r / 2, n / 2);
        e.beginPath(), e.roundRect(-r / 2, -n / 2, r, n, m), e.clip();
      }
      e.drawImage(h, -r / 2, -n / 2, r, n), e.restore();
      const f = this.style.stroke;
      if (f && f.width > 0) {
        if (e.save(), e.strokeStyle = f.color, e.lineWidth = f.width, u > 0) {
          const m = Math.min(u, r / 2, n / 2);
          e.beginPath(), e.roundRect(-r / 2, -n / 2, r, n, m), e.stroke();
        } else
          e.strokeRect(-r / 2, -n / 2, r, n);
        e.restore();
      }
    }
    return o != null && (this.lastVf?.close(), o instanceof ImageBitmap && (this.lastVf = o)), {
      audio: c,
      done: !1
    };
  }
  /**
   * Set clip properties (position, size, display timeline)
   * @param props Properties to set
   * @param fps Optional FPS for frame-to-time conversion (default: 30)
   * @returns this for method chaining
   *
   * @example
   * // Using frames (will be converted to microseconds)
   * clip.set({
   *   display: {
   *     from: 150, // frames
   *     to: 450, // frames (10 seconds at 30fps)
   *   },
   * }, 30);
   *
   * // Using microseconds directly
   * clip.set({
   *   display: {
   *     from: 5000000, // microseconds
   *     to: 15000000, // microseconds
   *   },
   * });
   */
  set(e, t = 30) {
    if (e.display && (e.display.from !== void 0 && (this.display.from = e.display.from < 1e6 ? e.display.from / t * 1e6 : e.display.from), e.display.to !== void 0 && (this.display.to = e.display.to < 1e6 ? e.display.to / t * 1e6 : e.display.to)), e.x !== void 0 && (this.left = e.x), e.y !== void 0 && (this.top = e.y), e.width !== void 0 && (this.width = e.width), e.height !== void 0 && (this.height = e.height), e.duration !== void 0) {
      const s = e.duration < 1e6 ? e.duration / t * 1e6 : e.duration;
      this.duration = s, this.display.from !== void 0 && (this.display.to = this.display.from + s);
    }
    return this;
  }
  /**
   * Base implementation of toJSON that handles common clip properties
   * Subclasses should override to add their specific options
   * @param main Whether this is the main clip (for Compositor)
   */
  toJSON(e = !1) {
    const t = this.animatKeyFrame && this.animatOpts ? {
      keyFrames: this.animatKeyFrame.reduce(
        (s, [r, n]) => {
          const o = r === 0 ? "from" : r === 1 ? "to" : `${Math.round(r * 100)}%`;
          return s[o] = n, s;
        },
        {}
      ),
      opts: this.animatOpts
    } : void 0;
    return {
      type: this.constructor.name,
      src: this.src,
      display: {
        from: this.display.from,
        to: this.display.to
      },
      playbackRate: this.playbackRate,
      duration: this.duration,
      left: this.left,
      top: this.top,
      width: this.width,
      height: this.height,
      angle: this.angle,
      zIndex: this.zIndex,
      opacity: this.opacity,
      flip: this.flip,
      style: this.style,
      trim: {
        from: this.trim.from,
        to: this.trim.to
      },
      ...t && { animation: t },
      ...e && { main: !0 }
    };
  }
  /**
   * Get the list of visible transformer handles for this clip type
   * Default implementation returns all handles
   * Override in subclasses to customize handle visibility (e.g., TextClip)
   */
  getVisibleHandles() {
    return ["tl", "tr", "bl", "br", "ml", "mr", "mt", "mb", "rot"];
  }
  destroy() {
    this.destroyed || (this.destroyed = !0, K.info("BaseClip destroy"), super.destroy(), this.lastVf?.close(), this.lastVf = null);
  }
}
let Pc = null;
async function Ru() {
  return Pc === null && (Pc = Q_()), await Pc;
}
const ie = {
  get codec() {
    return fs()?.codec ?? "mp4a.40.2";
  },
  get codecType() {
    return fs()?.codecType ?? "aac";
  },
  get sampleRate() {
    return fs()?.sampleRate ?? 48e3;
  },
  get channelCount() {
    return fs()?.channelCount ?? 2;
  }
};
class Ne extends Yt {
  type = "Audio";
  static ctx = null;
  ready;
  _meta = {
    // microseconds
    duration: 0,
    width: 0,
    height: 0
  };
  /**
   * Audio metadata
   *
   *  Note, these are converted (normalized) metadata, not original audio metadata
   */
  get meta() {
    return {
      ...this._meta,
      sampleRate: ie.sampleRate,
      chanCount: 2
    };
  }
  // Use type assertion to avoid type compatibility issues between ArrayBufferLike and ArrayBuffer
  chan0Buf = new Float32Array();
  chan1Buf = new Float32Array();
  /**
   * Get complete PCM data from audio clip
   */
  getPCMData() {
    return [this.chan0Buf, this.chan1Buf];
  }
  opts;
  /**
   * Whether to loop the audio (hybrid JSON structure)
   */
  loop = !1;
  /**
   * Load an audio clip from a URL
   * @param url Audio URL
   * @param opts Audio configuration (loop, volume)
   * @returns Promise that resolves to an audio clip
   *
   * @example
   * const audioClip = await AudioClip.fromUrl('path/to/audio.mp3', {
   *   loop: true,
   *   volume: 0.8,
   * });
   */
  static async fromUrl(e, t = {}) {
    const s = await fetch(e);
    if (!s.ok)
      throw new Error(
        `Failed to fetch audio from ${e}: ${s.status} ${s.statusText}`
      );
    const r = new Ne(s.body, t, e);
    return await r.ready, r;
  }
  /**
   * Create an AudioClip instance from a JSON object (fabric.js pattern)
   * @param json The JSON object representing the clip
   * @returns Promise that resolves to an AudioClip instance
   */
  static async fromObject(e) {
    if (e.type !== "Audio")
      throw new Error(`Expected Audio, got ${e.type}`);
    if (!e.src || e.src.trim() === "")
      throw new Error("AudioClip requires a valid source URL");
    const t = {};
    e.loop !== void 0 && (t.loop = e.loop), e.volume !== void 0 && (t.volume = e.volume);
    const s = await Ne.fromUrl(e.src, t);
    return s.left = e.left, s.top = e.top, s.width = e.width, s.height = e.height, s.angle = e.angle, s.display.from = e.display.from, s.display.to = e.display.to, s.duration = e.duration, s.playbackRate = e.playbackRate, s.zIndex = e.zIndex, s.opacity = e.opacity, s.flip = e.flip, e.animation && s.setAnimation(e.animation.keyFrames, e.animation.opts), s;
  }
  /**
   *
   * @param dataSource Audio file stream
   * @param opts Audio configuration, controls volume and whether to loop
   */
  constructor(e, t = {}, s) {
    super(), this.src = s !== void 0 ? s : "", this.opts = {
      loop: !1,
      volume: 1,
      ...t
    }, this.loop = this.opts.loop ?? !1, this.volume = this.opts.volume ?? 1, this.ready = this.init(e).then((r) => {
      const n = {
        width: 0,
        height: 0,
        duration: t.loop ? 1 / 0 : this._meta.duration
      };
      return this.width = this.width === 0 ? n.width : this.width, this.height = this.height === 0 ? n.height : this.height, this.duration = this.duration === 0 ? n.duration : this.duration, this.display.to = this.display.from + this.duration, n;
    });
  }
  async init(e) {
    Ne.ctx == null && (Ne.ctx = new AudioContext({
      sampleRate: ie.sampleRate
    }));
    const t = performance.now(), s = e instanceof ReadableStream ? await _b(e, Ne.ctx) : e;
    K.info("Audio clip decoded complete:", performance.now() - t), this._meta.duration = s[0].length / ie.sampleRate * 1e6, this.chan0Buf = s[0], this.chan1Buf = s[1] ?? this.chan0Buf, K.info(
      "Audio clip convert to AudioData, time:",
      performance.now() - t
    );
  }
  /**
   * Intercept data returned by {@link AudioClip.tick} method for secondary processing of audio data
   * @param time Time when tick was called
   * @param tickRet Data returned by tick
   *
   */
  tickInterceptor = async (e, t) => t;
  // microseconds
  timestamp = 0;
  frameOffset = 0;
  /**
   * Return audio PCM data corresponding to the time difference between last and current moments
   *
   * If the difference exceeds 3s or current time is less than last time, reset state
   * @example
   * tick(0) // => []
   * tick(1e6) // => [leftChanPCM(1s), rightChanPCM(1s)]
   *
   */
  async tick(e) {
    if (!this.opts.loop && e >= this._meta.duration)
      return await this.tickInterceptor(e, { audio: [], state: "done" });
    const t = e - this.timestamp;
    if (e < this.timestamp || t > 3e6)
      return this.timestamp = e, this.frameOffset = Math.ceil(
        this.timestamp / 1e6 * ie.sampleRate
      ), await this.tickInterceptor(e, {
        audio: [new Float32Array(0), new Float32Array(0)],
        state: "success"
      });
    this.timestamp = e;
    const s = Math.ceil(
      t / 1e6 * ie.sampleRate
    ), r = this.frameOffset + s, n = this.opts.loop ? [
      Ch(this.chan0Buf, this.frameOffset, r),
      Ch(this.chan1Buf, this.frameOffset, r)
    ] : [
      this.chan0Buf.slice(this.frameOffset, r),
      this.chan1Buf.slice(this.frameOffset, r)
    ];
    if (this.volume !== 1)
      for (const o of n)
        for (let a = 0; a < o.length; a++)
          o[a] *= this.volume;
    return this.frameOffset = r, await this.tickInterceptor(e, { audio: n, state: "success" });
  }
  /**
   * Split at specified time, return two audio clips before and after
   * @param time Time in microseconds
   */
  async split(e) {
    await this.ready;
    const t = Math.ceil(e / 1e6 * ie.sampleRate), s = new Ne(
      this.getPCMData().map((n) => n.slice(0, t)),
      this.opts,
      this.src
    ), r = new Ne(
      this.getPCMData().map((n) => n.slice(t)),
      this.opts,
      this.src
    );
    return [s, r];
  }
  async clone() {
    await this.ready;
    const e = new Ne(this.getPCMData(), this.opts, this.src);
    return await e.ready, this.copyStateTo(e), e;
  }
  /**
   * Destroy instance and release resources
   */
  destroy() {
    this.chan0Buf = new Float32Array(0), this.chan1Buf = new Float32Array(0), K.info("---- audioclip destroy ----"), super.destroy();
  }
  toJSON(e = !1) {
    return {
      ...super.toJSON(e),
      type: "Audio",
      loop: this.loop,
      id: this.id,
      volume: this.volume
    };
  }
  static concatAudioClip = vb;
  /**
   * Create HTMLAudioElement for playback
   */
  async createPlaybackElement() {
    if (await this.ready, !this.src || this.src.trim() === "")
      throw new Error("AudioClip requires a source URL for playback");
    const e = this.src.startsWith("blob:") ? this.src : void 0, t = document.createElement("audio");
    return t.crossOrigin = "anonymous", t.autoplay = !1, t.preload = "auto", t.loop = this.opts.loop || !1, t.src = this.src, await new Promise((s, r) => {
      const n = () => {
        t.removeEventListener("loadeddata", n), t.removeEventListener("error", o), t.pause(), t.currentTime = 0, s();
      }, o = () => {
        t.removeEventListener("loadeddata", n), t.removeEventListener("error", o), r(new Error("Failed to load audio"));
      };
      t.addEventListener("loadeddata", n, { once: !0 }), t.addEventListener("error", o, { once: !0 }), t.load();
    }), { element: t, objectUrl: e };
  }
  async play(e, t) {
    const s = e;
    if (Math.abs(s.currentTime - t) > 0.1 && (s.currentTime = t), s.paused)
      try {
        await s.play();
      } catch {
        try {
          await s.play();
        } catch (n) {
          console.warn("Failed to play audio:", n);
        }
      }
  }
  pause(e) {
    e.pause();
  }
  async seek(e, t) {
    const s = e;
    return s.pause(), s.currentTime = t, new Promise((r) => {
      if (Math.abs(s.currentTime - t) < 0.01) {
        r();
        return;
      }
      const n = () => {
        s.removeEventListener("seeked", n), r();
      };
      s.addEventListener("seeked", n, { once: !0 }), setTimeout(() => {
        s.removeEventListener("seeked", n), r();
      }, 500);
    });
  }
  syncPlayback(e, t, s) {
    const r = e, n = this.meta.duration / 1e6, o = s >= 0 && s < n;
    r.volume = this.volume, t && o ? r.paused && this.play(r, s).catch(console.warn) : (r.paused || r.pause(), o && Math.abs(r.currentTime - s) > 0.1 && (r.currentTime = s));
  }
  cleanupPlayback(e, t) {
    const s = e;
    s.pause(), s.removeAttribute("src"), s.load(), t && t.startsWith("blob:") && URL.revokeObjectURL(t);
  }
}
async function vb(i, e) {
  const t = [];
  for (const s of i)
    await s.ready, t.push(s.getPCMData());
  return new Ne(fp(t), e);
}
async function _b(i, e) {
  const t = await new Response(i).arrayBuffer();
  return tu(await e.decodeAudioData(t));
}
var O = /* @__PURE__ */ ((i) => (i.Application = "application", i.WebGLPipes = "webgl-pipes", i.WebGLPipesAdaptor = "webgl-pipes-adaptor", i.WebGLSystem = "webgl-system", i.WebGPUPipes = "webgpu-pipes", i.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", i.WebGPUSystem = "webgpu-system", i.CanvasSystem = "canvas-system", i.CanvasPipesAdaptor = "canvas-pipes-adaptor", i.CanvasPipes = "canvas-pipes", i.Asset = "asset", i.LoadParser = "load-parser", i.ResolveParser = "resolve-parser", i.CacheParser = "cache-parser", i.DetectionParser = "detection-parser", i.MaskEffect = "mask-effect", i.BlendMode = "blend-mode", i.TextureSource = "texture-source", i.Environment = "environment", i.ShapeBuilder = "shape-builder", i.Batcher = "batcher", i))(O || {});
const Ih = (i) => {
  if (typeof i == "function" || typeof i == "object" && i.extension) {
    if (!i.extension)
      throw new Error("Extension class must have an extension object");
    i = { ...typeof i.extension != "object" ? { type: i.extension } : i.extension, ref: i };
  }
  if (typeof i == "object")
    i = { ...i };
  else
    throw new Error("Invalid extension type");
  return typeof i.type == "string" && (i.type = [i.type]), i;
}, ps = (i, e) => Ih(i).priority ?? e, ke = {
  /** @ignore */
  _addHandlers: {},
  /** @ignore */
  _removeHandlers: {},
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed. Can be:
   * - Extension class with static `extension` property
   * - Extension format object with `type` and `ref`
   * - Multiple extensions as separate arguments
   * @returns {extensions} this for chaining
   * @example
   * ```ts
   * // Remove a single extension
   * extensions.remove(MyRendererPlugin);
   *
   * // Remove multiple extensions
   * extensions.remove(
   *     MyRendererPlugin,
   *     MySystemPlugin
   * );
   * ```
   * @see {@link ExtensionType} For available extension types
   * @see {@link ExtensionFormat} For extension format details
   */
  remove(...i) {
    return i.map(Ih).forEach((e) => {
      e.type.forEach((t) => this._removeHandlers[t]?.(e));
    }), this;
  },
  /**
   * Register new extensions with PixiJS. Extensions can be registered in multiple formats:
   * - As a class with a static `extension` property
   * - As an extension format object
   * - As multiple extensions passed as separate arguments
   * @param extensions - Extensions to add to PixiJS. Each can be:
   * - A class with static `extension` property
   * - An extension format object with `type` and `ref`
   * - Multiple extensions as separate arguments
   * @returns This extensions instance for chaining
   * @example
   * ```ts
   * // Register a simple extension
   * extensions.add(MyRendererPlugin);
   *
   * // Register multiple extensions
   * extensions.add(
   *     MyRendererPlugin,
   *     MySystemPlugin,
   * });
   * ```
   * @see {@link ExtensionType} For available extension types
   * @see {@link ExtensionFormat} For extension format details
   * @see {@link extensions.remove} For removing registered extensions
   */
  add(...i) {
    return i.map(Ih).forEach((e) => {
      e.type.forEach((t) => {
        const s = this._addHandlers, r = this._queue;
        s[t] ? s[t]?.(e) : (r[t] = r[t] || [], r[t]?.push(e));
      });
    }), this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.
   * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.
   * @returns this for chaining.
   * @internal
   * @ignore
   */
  handle(i, e, t) {
    const s = this._addHandlers, r = this._removeHandlers;
    if (s[i] || r[i])
      throw new Error(`Extension type ${i} already has a handler`);
    s[i] = e, r[i] = t;
    const n = this._queue;
    return n[i] && (n[i]?.forEach((o) => e(o)), delete n[i]), this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns this for chaining.
   * @ignore
   */
  handleByMap(i, e) {
    return this.handle(
      i,
      (t) => {
        t.name && (e[t.name] = t.ref);
      },
      (t) => {
        t.name && delete e[t.name];
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions with a `name` property.
   * @param type - Type of extension to handle.
   * @param map - The array of named extensions.
   * @param defaultPriority - Fallback priority if none is defined.
   * @returns this for chaining.
   * @ignore
   */
  handleByNamedList(i, e, t = -1) {
    return this.handle(
      i,
      (s) => {
        e.findIndex((n) => n.name === s.name) >= 0 || (e.push({ name: s.name, value: s.ref }), e.sort((n, o) => ps(o.value, t) - ps(n.value, t)));
      },
      (s) => {
        const r = e.findIndex((n) => n.name === s.name);
        r !== -1 && e.splice(r, 1);
      }
    );
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @param defaultPriority - The default priority to use if none is specified.
   * @returns this for chaining.
   * @ignore
   */
  handleByList(i, e, t = -1) {
    return this.handle(
      i,
      (s) => {
        e.includes(s.ref) || (e.push(s.ref), e.sort((r, n) => ps(n, t) - ps(r, t)));
      },
      (s) => {
        const r = e.indexOf(s.ref);
        r !== -1 && e.splice(r, 1);
      }
    );
  },
  /**
   * Mixin the source object(s) properties into the target class's prototype.
   * Copies all property descriptors from source objects to the target's prototype.
   * @param Target - The target class to mix properties into
   * @param sources - One or more source objects containing properties to mix in
   * @example
   * ```ts
   * // Create a mixin with shared properties
   * const moveable = {
   *     x: 0,
   *     y: 0,
   *     move(x: number, y: number) {
   *         this.x += x;
   *         this.y += y;
   *     }
   * };
   *
   * // Create a mixin with computed properties
   * const scalable = {
   *     scale: 1,
   *     get scaled() {
   *         return this.scale > 1;
   *     }
   * };
   *
   * // Apply mixins to a class
   * extensions.mixin(Sprite, moveable, scalable);
   *
   * // Use mixed-in properties
   * const sprite = new Sprite();
   * sprite.move(10, 20);
   * console.log(sprite.x, sprite.y); // 10, 20
   * ```
   * @remarks
   * - Copies all properties including getters/setters
   * - Does not modify source objects
   * - Preserves property descriptors
   * @see {@link Object.defineProperties} For details on property descriptors
   * @see {@link Object.getOwnPropertyDescriptors} For details on property copying
   */
  mixin(i, ...e) {
    for (const t of e)
      Object.defineProperties(i.prototype, Object.getOwnPropertyDescriptors(t));
  }
}, bb = {
  extension: {
    type: O.Environment,
    name: "browser",
    priority: -1
  },
  test: () => !0,
  load: async () => {
    await import("./browserAll-2UneHHuS.js");
  }
}, wb = {
  extension: {
    type: O.Environment,
    name: "webworker",
    priority: 0
  },
  test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
  load: async () => {
    await import("./webworkerAll-CRJdxR_9.js");
  }
};
class Ae {
  /**
   * Creates a new `ObservablePoint`
   * @param observer - Observer to pass to listen for change events.
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(e, t, s) {
    this._x = t || 0, this._y = s || 0, this._observer = e;
  }
  /**
   * Creates a clone of this point.
   * @example
   * ```ts
   * // Basic cloning
   * const point = new ObservablePoint(observer, 100, 200);
   * const copy = point.clone();
   *
   * // Clone with new observer
   * const newObserver = {
   *     _onUpdate: (p) => console.log(`Clone updated: (${p.x}, ${p.y})`)
   * };
   * const watched = point.clone(newObserver);
   *
   * // Verify independence
   * watched.set(300, 400); // Only triggers new observer
   * ```
   * @param observer - Optional observer to pass to the new observable point
   * @returns A copy of this observable point
   * @see {@link ObservablePoint.copyFrom} For copying into existing point
   * @see {@link Observer} For observer interface details
   */
  clone(e) {
    return new Ae(e ?? this._observer, this._x, this._y);
  }
  /**
   * Sets the point to a new x and y position.
   *
   * If y is omitted, both x and y will be set to x.
   * @example
   * ```ts
   * // Basic position setting
   * const point = new ObservablePoint(observer);
   * point.set(100, 200);
   *
   * // Set both x and y to same value
   * point.set(50); // x=50, y=50
   * ```
   * @param x - Position on the x axis
   * @param y - Position on the y axis, defaults to x
   * @returns The point instance itself
   * @see {@link ObservablePoint.copyFrom} For copying from another point
   * @see {@link ObservablePoint.equals} For comparing positions
   */
  set(e = 0, t = e) {
    return (this._x !== e || this._y !== t) && (this._x = e, this._y = t, this._observer._onUpdate(this)), this;
  }
  /**
   * Copies x and y from the given point into this point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new ObservablePoint(observer, 100, 200);
   * const target = new ObservablePoint();
   * target.copyFrom(source);
   *
   * // Copy and chain operations
   * const point = new ObservablePoint()
   *     .copyFrom(source)
   *     .set(x + 50, y + 50);
   *
   * // Copy from any PointData
   * const data = { x: 10, y: 20 };
   * point.copyFrom(data);
   * ```
   * @param p - The point to copy from
   * @returns The point instance itself
   * @see {@link ObservablePoint.copyTo} For copying to another point
   * @see {@link ObservablePoint.clone} For creating new point copy
   */
  copyFrom(e) {
    return (this._x !== e.x || this._y !== e.y) && (this._x = e.x, this._y = e.y, this._observer._onUpdate(this)), this;
  }
  /**
   * Copies this point's x and y into the given point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new ObservablePoint(100, 200);
   * const target = new ObservablePoint();
   * source.copyTo(target);
   * ```
   * @param p - The point to copy to. Can be any type that is or extends `PointLike`
   * @returns The point (`p`) with values updated
   * @see {@link ObservablePoint.copyFrom} For copying from another point
   * @see {@link ObservablePoint.clone} For creating new point copy
   */
  copyTo(e) {
    return e.set(this._x, this._y), e;
  }
  /**
   * Checks if another point is equal to this point.
   *
   * Compares x and y values using strict equality.
   * @example
   * ```ts
   * // Basic equality check
   * const p1 = new ObservablePoint(100, 200);
   * const p2 = new ObservablePoint(100, 200);
   * console.log(p1.equals(p2)); // true
   *
   * // Compare with PointData
   * const data = { x: 100, y: 200 };
   * console.log(p1.equals(data)); // true
   *
   * // Check different points
   * const p3 = new ObservablePoint(200, 300);
   * console.log(p1.equals(p3)); // false
   * ```
   * @param p - The point to check
   * @returns `true` if both `x` and `y` are equal
   * @see {@link ObservablePoint.copyFrom} For making points equal
   * @see {@link PointData} For point data interface
   */
  equals(e) {
    return e.x === this._x && e.y === this._y;
  }
  toString() {
    return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`;
  }
  /**
   * Position of the observable point on the x axis.
   * Triggers observer callback when value changes.
   * @example
   * ```ts
   * // Basic x position
   * const point = new ObservablePoint(observer);
   * point.x = 100; // Triggers observer
   *
   * // Use in calculations
   * const width = rightPoint.x - leftPoint.x;
   * ```
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x !== e && (this._x = e, this._observer._onUpdate(this));
  }
  /**
   * Position of the observable point on the y axis.
   * Triggers observer callback when value changes.
   * @example
   * ```ts
   * // Basic y position
   * const point = new ObservablePoint(observer);
   * point.y = 200; // Triggers observer
   *
   * // Use in calculations
   * const height = bottomPoint.y - topPoint.y;
   * ```
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y !== e && (this._y = e, this._observer._onUpdate(this));
  }
}
function ru(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var Uc = { exports: {} }, Bu;
function Tb() {
  return Bu || (Bu = 1, (function(i) {
    var e = Object.prototype.hasOwnProperty, t = "~";
    function s() {
    }
    Object.create && (s.prototype = /* @__PURE__ */ Object.create(null), new s().__proto__ || (t = !1));
    function r(l, c, h) {
      this.fn = l, this.context = c, this.once = h || !1;
    }
    function n(l, c, h, u, d) {
      if (typeof h != "function")
        throw new TypeError("The listener must be a function");
      var f = new r(h, u || l, d), m = t ? t + c : c;
      return l._events[m] ? l._events[m].fn ? l._events[m] = [l._events[m], f] : l._events[m].push(f) : (l._events[m] = f, l._eventsCount++), l;
    }
    function o(l, c) {
      --l._eventsCount === 0 ? l._events = new s() : delete l._events[c];
    }
    function a() {
      this._events = new s(), this._eventsCount = 0;
    }
    a.prototype.eventNames = function() {
      var c = [], h, u;
      if (this._eventsCount === 0) return c;
      for (u in h = this._events)
        e.call(h, u) && c.push(t ? u.slice(1) : u);
      return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(h)) : c;
    }, a.prototype.listeners = function(c) {
      var h = t ? t + c : c, u = this._events[h];
      if (!u) return [];
      if (u.fn) return [u.fn];
      for (var d = 0, f = u.length, m = new Array(f); d < f; d++)
        m[d] = u[d].fn;
      return m;
    }, a.prototype.listenerCount = function(c) {
      var h = t ? t + c : c, u = this._events[h];
      return u ? u.fn ? 1 : u.length : 0;
    }, a.prototype.emit = function(c, h, u, d, f, m) {
      var g = t ? t + c : c;
      if (!this._events[g]) return !1;
      var p = this._events[g], x = arguments.length, y, v;
      if (p.fn) {
        switch (p.once && this.removeListener(c, p.fn, void 0, !0), x) {
          case 1:
            return p.fn.call(p.context), !0;
          case 2:
            return p.fn.call(p.context, h), !0;
          case 3:
            return p.fn.call(p.context, h, u), !0;
          case 4:
            return p.fn.call(p.context, h, u, d), !0;
          case 5:
            return p.fn.call(p.context, h, u, d, f), !0;
          case 6:
            return p.fn.call(p.context, h, u, d, f, m), !0;
        }
        for (v = 1, y = new Array(x - 1); v < x; v++)
          y[v - 1] = arguments[v];
        p.fn.apply(p.context, y);
      } else {
        var _ = p.length, b;
        for (v = 0; v < _; v++)
          switch (p[v].once && this.removeListener(c, p[v].fn, void 0, !0), x) {
            case 1:
              p[v].fn.call(p[v].context);
              break;
            case 2:
              p[v].fn.call(p[v].context, h);
              break;
            case 3:
              p[v].fn.call(p[v].context, h, u);
              break;
            case 4:
              p[v].fn.call(p[v].context, h, u, d);
              break;
            default:
              if (!y) for (b = 1, y = new Array(x - 1); b < x; b++)
                y[b - 1] = arguments[b];
              p[v].fn.apply(p[v].context, y);
          }
      }
      return !0;
    }, a.prototype.on = function(c, h, u) {
      return n(this, c, h, u, !1);
    }, a.prototype.once = function(c, h, u) {
      return n(this, c, h, u, !0);
    }, a.prototype.removeListener = function(c, h, u, d) {
      var f = t ? t + c : c;
      if (!this._events[f]) return this;
      if (!h)
        return o(this, f), this;
      var m = this._events[f];
      if (m.fn)
        m.fn === h && (!d || m.once) && (!u || m.context === u) && o(this, f);
      else {
        for (var g = 0, p = [], x = m.length; g < x; g++)
          (m[g].fn !== h || d && !m[g].once || u && m[g].context !== u) && p.push(m[g]);
        p.length ? this._events[f] = p.length === 1 ? p[0] : p : o(this, f);
      }
      return this;
    }, a.prototype.removeAllListeners = function(c) {
      var h;
      return c ? (h = t ? t + c : c, this._events[h] && o(this, h)) : (this._events = new s(), this._eventsCount = 0), this;
    }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = t, a.EventEmitter = a, i.exports = a;
  })(Uc)), Uc.exports;
}
var Sb = Tb();
const rt = /* @__PURE__ */ ru(Sb), Cb = Math.PI * 2, Ab = 180 / Math.PI, Ib = Math.PI / 180;
class q {
  /**
   * Creates a new `Point`
   * @param {number} [x=0] - position of the point on the x axis
   * @param {number} [y=0] - position of the point on the y axis
   */
  constructor(e = 0, t = 0) {
    this.x = 0, this.y = 0, this.x = e, this.y = t;
  }
  /**
   * Creates a clone of this point, which is a new instance with the same `x` and `y` values.
   * @example
   * ```ts
   * // Basic point cloning
   * const original = new Point(100, 200);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.set(300, 400);
   *
   * // Verify independence
   * console.log(original); // Point(100, 200)
   * console.log(modified); // Point(300, 400)
   * ```
   * @remarks
   * - Creates new Point instance
   * - Deep copies x and y values
   * - Independent from original
   * - Useful for preserving values
   * @returns A clone of this point
   * @see {@link Point.copyFrom} For copying into existing point
   * @see {@link Point.copyTo} For copying to existing point
   */
  clone() {
    return new q(this.x, this.y);
  }
  /**
   * Copies x and y from the given point into this point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Point(100, 200);
   * const target = new Point();
   * target.copyFrom(source);
   *
   * // Copy and chain operations
   * const point = new Point()
   *     .copyFrom(source)
   *     .set(x + 50, y + 50);
   *
   * // Copy from any PointData
   * const data = { x: 10, y: 20 };
   * point.copyFrom(data);
   * ```
   * @param p - The point to copy from
   * @returns The point instance itself
   * @see {@link Point.copyTo} For copying to another point
   * @see {@link Point.clone} For creating new point copy
   */
  copyFrom(e) {
    return this.set(e.x, e.y), this;
  }
  /**
   * Copies this point's x and y into the given point.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Point(100, 200);
   * const target = new Point();
   * source.copyTo(target);
   * ```
   * @param p - The point to copy to. Can be any type that is or extends `PointLike`
   * @returns The point (`p`) with values updated
   * @see {@link Point.copyFrom} For copying from another point
   * @see {@link Point.clone} For creating new point copy
   */
  copyTo(e) {
    return e.set(this.x, this.y), e;
  }
  /**
   * Checks if another point is equal to this point.
   *
   * Compares x and y values using strict equality.
   * @example
   * ```ts
   * // Basic equality check
   * const p1 = new Point(100, 200);
   * const p2 = new Point(100, 200);
   * console.log(p1.equals(p2)); // true
   *
   * // Compare with PointData
   * const data = { x: 100, y: 200 };
   * console.log(p1.equals(data)); // true
   *
   * // Check different points
   * const p3 = new Point(200, 300);
   * console.log(p1.equals(p3)); // false
   * ```
   * @param p - The point to check
   * @returns `true` if both `x` and `y` are equal
   * @see {@link Point.copyFrom} For making points equal
   * @see {@link PointData} For point data interface
   */
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  /**
   * Sets the point to a new x and y position.
   *
   * If y is omitted, both x and y will be set to x.
   * @example
   * ```ts
   * // Basic position setting
   * const point = new Point();
   * point.set(100, 200);
   *
   * // Set both x and y to same value
   * point.set(50); // x=50, y=50
   *
   * // Chain with other operations
   * point
   *     .set(10, 20)
   *     .copyTo(otherPoint);
   * ```
   * @param x - Position on the x axis
   * @param y - Position on the y axis, defaults to x
   * @returns The point instance itself
   * @see {@link Point.copyFrom} For copying from another point
   * @see {@link Point.equals} For comparing positions
   */
  set(e = 0, t = e) {
    return this.x = e, this.y = t, this;
  }
  toString() {
    return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
  }
  /**
   * A static Point object with `x` and `y` values of `0`.
   *
   * This shared instance is reset to zero values when accessed.
   *
   * > [!IMPORTANT] This point is shared and temporary. Do not store references to it.
   * @example
   * ```ts
   * // Use for temporary calculations
   * const tempPoint = Point.shared;
   * tempPoint.set(100, 200);
   * matrix.apply(tempPoint);
   *
   * // Will be reset to (0,0) on next access
   * const fresh = Point.shared; // x=0, y=0
   * ```
   * @readonly
   * @returns A fresh zeroed point for temporary use
   * @see {@link Point.constructor} For creating new points
   * @see {@link PointData} For basic point interface
   */
  static get shared() {
    return Rc.x = 0, Rc.y = 0, Rc;
  }
}
const Rc = new q();
class W {
  /**
   * @param a - x scale
   * @param b - y skew
   * @param c - x skew
   * @param d - y scale
   * @param tx - x translation
   * @param ty - y translation
   */
  constructor(e = 1, t = 0, s = 0, r = 1, n = 0, o = 0) {
    this.array = null, this.a = e, this.b = t, this.c = s, this.d = r, this.tx = n, this.ty = o;
  }
  /**
   * Creates a Matrix object based on the given array.
   * Populates matrix components from a flat array in column-major order.
   *
   * > [!NOTE] Array mapping order:
   * > ```
   * > array[0] = a  (x scale)
   * > array[1] = b  (y skew)
   * > array[2] = tx (x translation)
   * > array[3] = c  (x skew)
   * > array[4] = d  (y scale)
   * > array[5] = ty (y translation)
   * > ```
   * @example
   * ```ts
   * // Create matrix from array
   * const matrix = new Matrix();
   * matrix.fromArray([
   *     2, 0,  100,  // a, b, tx
   *     0, 2,  100   // c, d, ty
   * ]);
   *
   * // Create matrix from typed array
   * const float32Array = new Float32Array([
   *     1, 0, 0,     // Scale x1, no skew
   *     0, 1, 0      // No skew, scale x1
   * ]);
   * matrix.fromArray(float32Array);
   * ```
   * @param array - The array to populate the matrix from
   * @see {@link Matrix.toArray} For converting matrix to array
   * @see {@link Matrix.set} For setting values directly
   */
  fromArray(e) {
    this.a = e[0], this.b = e[1], this.c = e[3], this.d = e[4], this.tx = e[2], this.ty = e[5];
  }
  /**
   * Sets the matrix properties directly.
   * All matrix components can be set in one call.
   * @example
   * ```ts
   * // Set to identity matrix
   * matrix.set(1, 0, 0, 1, 0, 0);
   *
   * // Set to scale matrix
   * matrix.set(2, 0, 0, 2, 0, 0); // Scale 2x
   *
   * // Set to translation matrix
   * matrix.set(1, 0, 0, 1, 100, 50); // Move 100,50
   * ```
   * @param a - Scale on x axis
   * @param b - Shear on y axis
   * @param c - Shear on x axis
   * @param d - Scale on y axis
   * @param tx - Translation on x axis
   * @param ty - Translation on y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.fromArray} For setting from array
   */
  set(e, t, s, r, n, o) {
    return this.a = e, this.b = t, this.c = s, this.d = r, this.tx = n, this.ty = o, this;
  }
  /**
   * Creates an array from the current Matrix object.
   *
   * > [!NOTE] The array format is:
   * > ```
   * > Non-transposed:
   * > [a, c, tx,
   * > b, d, ty,
   * > 0, 0, 1]
   * >
   * > Transposed:
   * > [a, b, 0,
   * > c, d, 0,
   * > tx,ty,1]
   * > ```
   * @example
   * ```ts
   * // Basic array conversion
   * const matrix = new Matrix(2, 0, 0, 2, 100, 100);
   * const array = matrix.toArray();
   *
   * // Using existing array
   * const float32Array = new Float32Array(9);
   * matrix.toArray(false, float32Array);
   *
   * // Get transposed array
   * const transposed = matrix.toArray(true);
   * ```
   * @param transpose - Whether to transpose the matrix
   * @param out - Optional Float32Array to store the result
   * @returns The array containing the matrix values
   * @see {@link Matrix.fromArray} For creating matrix from array
   * @see {@link Matrix.array} For cached array storage
   */
  toArray(e, t) {
    this.array || (this.array = new Float32Array(9));
    const s = t || this.array;
    return e ? (s[0] = this.a, s[1] = this.b, s[2] = 0, s[3] = this.c, s[4] = this.d, s[5] = 0, s[6] = this.tx, s[7] = this.ty, s[8] = 1) : (s[0] = this.a, s[1] = this.c, s[2] = this.tx, s[3] = this.b, s[4] = this.d, s[5] = this.ty, s[6] = 0, s[7] = 0, s[8] = 1), s;
  }
  /**
   * Get a new position with the current transformation applied.
   *
   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
   * @example
   * ```ts
   * // Basic point transformation
   * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);
   * const point = new Point(10, 20);
   * const transformed = matrix.apply(point);
   *
   * // Reuse existing point
   * const output = new Point();
   * matrix.apply(point, output);
   * ```
   * @param pos - The origin point to transform
   * @param newPos - Optional point to store the result
   * @returns The transformed point
   * @see {@link Matrix.applyInverse} For inverse transformation
   * @see {@link Point} For point operations
   */
  apply(e, t) {
    t = t || new q();
    const s = e.x, r = e.y;
    return t.x = this.a * s + this.c * r + this.tx, t.y = this.b * s + this.d * r + this.ty, t;
  }
  /**
   * Get a new position with the inverse of the current transformation applied.
   *
   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
   * @example
   * ```ts
   * // Basic inverse transformation
   * const matrix = new Matrix().translate(100, 50).rotate(Math.PI / 4);
   * const worldPoint = new Point(150, 100);
   * const localPoint = matrix.applyInverse(worldPoint);
   *
   * // Reuse existing point
   * const output = new Point();
   * matrix.applyInverse(worldPoint, output);
   *
   * // Convert mouse position to local space
   * const mousePoint = new Point(mouseX, mouseY);
   * const localMouse = matrix.applyInverse(mousePoint);
   * ```
   * @param pos - The origin point to inverse-transform
   * @param newPos - Optional point to store the result
   * @returns The inverse-transformed point
   * @see {@link Matrix.apply} For forward transformation
   * @see {@link Matrix.invert} For getting inverse matrix
   */
  applyInverse(e, t) {
    t = t || new q();
    const s = this.a, r = this.b, n = this.c, o = this.d, a = this.tx, l = this.ty, c = 1 / (s * o + n * -r), h = e.x, u = e.y;
    return t.x = o * c * h + -n * c * u + (l * n - a * o) * c, t.y = s * c * u + -r * c * h + (-l * s + a * r) * c, t;
  }
  /**
   * Translates the matrix on the x and y axes.
   * Adds to the position values while preserving scale, rotation and skew.
   * @example
   * ```ts
   * // Basic translation
   * const matrix = new Matrix();
   * matrix.translate(100, 50); // Move right 100, down 50
   *
   * // Chain with other transformations
   * matrix
   *     .scale(2, 2)
   *     .translate(100, 0)
   *     .rotate(Math.PI / 4);
   * ```
   * @param x - How much to translate on the x axis
   * @param y - How much to translate on the y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.set} For setting position directly
   * @see {@link Matrix.setTransform} For complete transform setup
   */
  translate(e, t) {
    return this.tx += e, this.ty += t, this;
  }
  /**
   * Applies a scale transformation to the matrix.
   * Multiplies the scale values with existing matrix components.
   * @example
   * ```ts
   * // Basic scaling
   * const matrix = new Matrix();
   * matrix.scale(2, 3); // Scale 2x horizontally, 3x vertically
   *
   * // Chain with other transformations
   * matrix
   *     .translate(100, 100)
   *     .scale(2, 2)     // Scales after translation
   *     .rotate(Math.PI / 4);
   * ```
   * @param x - The amount to scale horizontally
   * @param y - The amount to scale vertically
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.setTransform} For setting scale directly
   * @see {@link Matrix.append} For combining transformations
   */
  scale(e, t) {
    return this.a *= e, this.d *= t, this.c *= e, this.b *= t, this.tx *= e, this.ty *= t, this;
  }
  /**
   * Applies a rotation transformation to the matrix.
   *
   * Rotates around the origin (0,0) by the given angle in radians.
   * @example
   * ```ts
   * // Basic rotation
   * const matrix = new Matrix();
   * matrix.rotate(Math.PI / 4); // Rotate 45 degrees
   *
   * // Chain with other transformations
   * matrix
   *     .translate(100, 100) // Move to rotation center
   *     .rotate(Math.PI)     // Rotate 180 degrees
   *     .scale(2, 2);        // Scale after rotation
   *
   * // Common angles
   * matrix.rotate(Math.PI / 2);  // 90 degrees
   * matrix.rotate(Math.PI);      // 180 degrees
   * matrix.rotate(Math.PI * 2);  // 360 degrees
   * ```
   * @remarks
   * - Rotates around origin point (0,0)
   * - Affects position if translation was set
   * - Uses counter-clockwise rotation
   * - Order of operations matters when chaining
   * @param angle - The angle in radians
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.setTransform} For setting rotation directly
   * @see {@link Matrix.append} For combining transformations
   */
  rotate(e) {
    const t = Math.cos(e), s = Math.sin(e), r = this.a, n = this.c, o = this.tx;
    return this.a = r * t - this.b * s, this.b = r * s + this.b * t, this.c = n * t - this.d * s, this.d = n * s + this.d * t, this.tx = o * t - this.ty * s, this.ty = o * s + this.ty * t, this;
  }
  /**
   * Appends the given Matrix to this Matrix.
   * Combines two matrices by multiplying them together: this = this * matrix
   * @example
   * ```ts
   * // Basic matrix combination
   * const matrix = new Matrix();
   * const other = new Matrix().translate(100, 0).rotate(Math.PI / 4);
   * matrix.append(other);
   * ```
   * @remarks
   * - Order matters: A.append(B) !== B.append(A)
   * - Modifies current matrix
   * - Preserves transformation order
   * - Commonly used for combining transforms
   * @param matrix - The matrix to append
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.prepend} For prepending transformations
   * @see {@link Matrix.appendFrom} For appending two external matrices
   */
  append(e) {
    const t = this.a, s = this.b, r = this.c, n = this.d;
    return this.a = e.a * t + e.b * r, this.b = e.a * s + e.b * n, this.c = e.c * t + e.d * r, this.d = e.c * s + e.d * n, this.tx = e.tx * t + e.ty * r + this.tx, this.ty = e.tx * s + e.ty * n + this.ty, this;
  }
  /**
   * Appends two matrices and sets the result to this matrix.
   * Performs matrix multiplication: this = A * B
   * @example
   * ```ts
   * // Basic matrix multiplication
   * const result = new Matrix();
   * const matrixA = new Matrix().scale(2, 2);
   * const matrixB = new Matrix().rotate(Math.PI / 4);
   * result.appendFrom(matrixA, matrixB);
   * ```
   * @remarks
   * - Order matters: A * B !== B * A
   * - Creates a new transformation from two others
   * - More efficient than append() for multiple operations
   * - Does not modify input matrices
   * @param a - The first matrix to multiply
   * @param b - The second matrix to multiply
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.append} For single matrix combination
   * @see {@link Matrix.prepend} For reverse order multiplication
   */
  appendFrom(e, t) {
    const s = e.a, r = e.b, n = e.c, o = e.d, a = e.tx, l = e.ty, c = t.a, h = t.b, u = t.c, d = t.d;
    return this.a = s * c + r * u, this.b = s * h + r * d, this.c = n * c + o * u, this.d = n * h + o * d, this.tx = a * c + l * u + t.tx, this.ty = a * h + l * d + t.ty, this;
  }
  /**
   * Sets the matrix based on all the available properties.
   * Combines position, scale, rotation, skew and pivot in a single operation.
   * @example
   * ```ts
   * // Basic transform setup
   * const matrix = new Matrix();
   * matrix.setTransform(
   *     100, 100,    // position
   *     0, 0,        // pivot
   *     2, 2,        // scale
   *     Math.PI / 4, // rotation (45 degrees)
   *     0, 0         // skew
   * );
   * ```
   * @remarks
   * - Updates all matrix components at once
   * - More efficient than separate transform calls
   * - Uses radians for rotation and skew
   * - Pivot affects rotation center
   * @param x - Position on the x axis
   * @param y - Position on the y axis
   * @param pivotX - Pivot on the x axis
   * @param pivotY - Pivot on the y axis
   * @param scaleX - Scale on the x axis
   * @param scaleY - Scale on the y axis
   * @param rotation - Rotation in radians
   * @param skewX - Skew on the x axis
   * @param skewY - Skew on the y axis
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.decompose} For extracting transform properties
   * @see {@link TransformableObject} For transform data structure
   */
  setTransform(e, t, s, r, n, o, a, l, c) {
    return this.a = Math.cos(a + c) * n, this.b = Math.sin(a + c) * n, this.c = -Math.sin(a - l) * o, this.d = Math.cos(a - l) * o, this.tx = e - (s * this.a + r * this.c), this.ty = t - (s * this.b + r * this.d), this;
  }
  /**
   * Prepends the given Matrix to this Matrix.
   * Combines two matrices by multiplying them together: this = matrix * this
   * @example
   * ```ts
   * // Basic matrix prepend
   * const matrix = new Matrix().scale(2, 2);
   * const other = new Matrix().translate(100, 0);
   * matrix.prepend(other); // Translation happens before scaling
   * ```
   * @remarks
   * - Order matters: A.prepend(B) !== B.prepend(A)
   * - Modifies current matrix
   * - Reverses transformation order compared to append()
   * @param matrix - The matrix to prepend
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.append} For appending transformations
   * @see {@link Matrix.appendFrom} For combining external matrices
   */
  prepend(e) {
    const t = this.tx;
    if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
      const s = this.a, r = this.c;
      this.a = s * e.a + this.b * e.c, this.b = s * e.b + this.b * e.d, this.c = r * e.a + this.d * e.c, this.d = r * e.b + this.d * e.d;
    }
    return this.tx = t * e.a + this.ty * e.c + e.tx, this.ty = t * e.b + this.ty * e.d + e.ty, this;
  }
  /**
   * Decomposes the matrix into its individual transform components.
   * Extracts position, scale, rotation and skew values from the matrix.
   * @example
   * ```ts
   * // Basic decomposition
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4)
   *     .scale(2, 2);
   *
   * const transform = {
   *     position: new Point(),
   *     scale: new Point(),
   *     pivot: new Point(),
   *     skew: new Point(),
   *     rotation: 0
   * };
   *
   * matrix.decompose(transform);
   * console.log(transform.position); // Point(100, 100)
   * console.log(transform.rotation); // ~0.785 (PI/4)
   * console.log(transform.scale); // Point(2, 2)
   * ```
   * @remarks
   * - Handles combined transformations
   * - Accounts for pivot points
   * - Chooses between rotation/skew based on transform type
   * - Uses radians for rotation and skew
   * @param transform - The transform object to store the decomposed values
   * @returns The transform with the newly applied properties
   * @see {@link Matrix.setTransform} For composing from components
   * @see {@link TransformableObject} For transform structure
   */
  decompose(e) {
    const t = this.a, s = this.b, r = this.c, n = this.d, o = e.pivot, a = -Math.atan2(-r, n), l = Math.atan2(s, t), c = Math.abs(a + l);
    return c < 1e-5 || Math.abs(Cb - c) < 1e-5 ? (e.rotation = l, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = a, e.skew.y = l), e.scale.x = Math.sqrt(t * t + s * s), e.scale.y = Math.sqrt(r * r + n * n), e.position.x = this.tx + (o.x * t + o.y * r), e.position.y = this.ty + (o.x * s + o.y * n), e;
  }
  /**
   * Inverts this matrix.
   * Creates the matrix that when multiplied with this matrix results in an identity matrix.
   * @example
   * ```ts
   * // Basic matrix inversion
   * const matrix = new Matrix()
   *     .translate(100, 50)
   *     .scale(2, 2);
   *
   * matrix.invert(); // Now transforms in opposite direction
   *
   * // Verify inversion
   * const point = new Point(50, 50);
   * const transformed = matrix.apply(point);
   * const original = matrix.invert().apply(transformed);
   * // original  point
   * ```
   * @remarks
   * - Modifies the current matrix
   * - Useful for reversing transformations
   * - Cannot invert matrices with zero determinant
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.applyInverse} For inverse transformations
   */
  invert() {
    const e = this.a, t = this.b, s = this.c, r = this.d, n = this.tx, o = e * r - t * s;
    return this.a = r / o, this.b = -t / o, this.c = -s / o, this.d = e / o, this.tx = (s * this.ty - r * n) / o, this.ty = -(e * this.ty - t * n) / o, this;
  }
  /**
   * Checks if this matrix is an identity matrix.
   *
   * An identity matrix has no transformations applied (default state).
   * @example
   * ```ts
   * // Check if matrix is identity
   * const matrix = new Matrix();
   * console.log(matrix.isIdentity()); // true
   *
   * // Check after transformations
   * matrix.translate(100, 0);
   * console.log(matrix.isIdentity()); // false
   *
   * // Reset and verify
   * matrix.identity();
   * console.log(matrix.isIdentity()); // true
   * ```
   * @remarks
   * - Verifies a = 1, d = 1 (no scale)
   * - Verifies b = 0, c = 0 (no skew)
   * - Verifies tx = 0, ty = 0 (no translation)
   * @returns True if matrix has no transformations
   * @see {@link Matrix.identity} For resetting to identity
   * @see {@link Matrix.IDENTITY} For constant identity matrix
   */
  isIdentity() {
    return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;
  }
  /**
   * Resets this Matrix to an identity (default) matrix.
   * Sets all components to their default values: scale=1, no skew, no translation.
   * @example
   * ```ts
   * // Reset transformed matrix
   * const matrix = new Matrix()
   *     .scale(2, 2)
   *     .rotate(Math.PI / 4);
   * matrix.identity(); // Back to default state
   *
   * // Chain after reset
   * matrix
   *     .identity()
   *     .translate(100, 100)
   *     .scale(2, 2);
   *
   * // Compare with identity constant
   * const isDefault = matrix.equals(Matrix.IDENTITY);
   * ```
   * @remarks
   * - Sets a=1, d=1 (default scale)
   * - Sets b=0, c=0 (no skew)
   * - Sets tx=0, ty=0 (no translation)
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.IDENTITY} For constant identity matrix
   * @see {@link Matrix.isIdentity} For checking identity state
   */
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @returns A copy of this matrix. Good for chaining method calls.
   */
  clone() {
    const e = new W();
    return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
  }
  /**
   * Creates a new Matrix object with the same values as this one.
   * @param matrix
   * @example
   * ```ts
   * // Basic matrix cloning
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4);
   * const copy = matrix.clone();
   *
   * // Clone and modify
   * const modified = matrix.clone()
   *     .scale(2, 2);
   *
   * // Compare matrices
   * console.log(matrix.equals(copy));     // true
   * console.log(matrix.equals(modified)); // false
   * ```
   * @returns A copy of this matrix. Good for chaining method calls.
   * @see {@link Matrix.copyTo} For copying to existing matrix
   * @see {@link Matrix.copyFrom} For copying from another matrix
   */
  copyTo(e) {
    return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
  }
  /**
   * Changes the values of the matrix to be the same as the ones in given matrix.
   * @example
   * ```ts
   * // Basic matrix copying
   * const source = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4);
   * const target = new Matrix();
   * target.copyFrom(source);
   * ```
   * @param matrix - The matrix to copy from
   * @returns This matrix. Good for chaining method calls.
   * @see {@link Matrix.clone} For creating new matrix copy
   * @see {@link Matrix.copyTo} For copying to another matrix
   */
  copyFrom(e) {
    return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this;
  }
  /**
   * Checks if this matrix equals another matrix.
   * Compares all components for exact equality.
   * @example
   * ```ts
   * // Basic equality check
   * const m1 = new Matrix();
   * const m2 = new Matrix();
   * console.log(m1.equals(m2)); // true
   *
   * // Compare transformed matrices
   * const transform = new Matrix()
   *     .translate(100, 100)
   * const clone = new Matrix()
   *     .scale(2, 2);
   * console.log(transform.equals(clone)); // false
   * ```
   * @param matrix - The matrix to compare to
   * @returns True if matrices are identical
   * @see {@link Matrix.copyFrom} For copying matrix values
   * @see {@link Matrix.isIdentity} For identity comparison
   */
  equals(e) {
    return e.a === this.a && e.b === this.b && e.c === this.c && e.d === this.d && e.tx === this.tx && e.ty === this.ty;
  }
  toString() {
    return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  }
  /**
   * A default (identity) matrix with no transformations applied.
   *
   * > [!IMPORTANT] This is a shared read-only object. Create a new Matrix if you need to modify it.
   * @example
   * ```ts
   * // Get identity matrix reference
   * const identity = Matrix.IDENTITY;
   * console.log(identity.isIdentity()); // true
   *
   * // Compare with identity
   * const matrix = new Matrix();
   * console.log(matrix.equals(Matrix.IDENTITY)); // true
   *
   * // Create new matrix instead of modifying IDENTITY
   * const transform = new Matrix()
   *     .copyFrom(Matrix.IDENTITY)
   *     .translate(100, 100);
   * ```
   * @readonly
   * @returns A read-only identity matrix
   * @see {@link Matrix.shared} For temporary calculations
   * @see {@link Matrix.identity} For resetting matrices
   */
  static get IDENTITY() {
    return Fb.identity();
  }
  /**
   * A static Matrix that can be used to avoid creating new objects.
   * Will always ensure the matrix is reset to identity when requested.
   *
   * > [!IMPORTANT] This matrix is shared and temporary. Do not store references to it.
   * @example
   * ```ts
   * // Use for temporary calculations
   * const tempMatrix = Matrix.shared;
   * tempMatrix.translate(100, 100).rotate(Math.PI / 4);
   * const point = tempMatrix.apply({ x: 10, y: 20 });
   *
   * // Will be reset to identity on next access
   * const fresh = Matrix.shared; // Back to identity
   * ```
   * @remarks
   * - Always returns identity matrix
   * - Safe to modify temporarily
   * - Not safe to store references
   * - Useful for one-off calculations
   * @readonly
   * @returns A fresh identity matrix for temporary use
   * @see {@link Matrix.IDENTITY} For immutable identity matrix
   * @see {@link Matrix.identity} For resetting matrices
   */
  static get shared() {
    return kb.identity();
  }
}
const kb = new W(), Fb = new W(), zt = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], Ot = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], Dt = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], Lt = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], kh = [], mp = [], ms = Math.sign;
function Mb() {
  for (let i = 0; i < 16; i++) {
    const e = [];
    kh.push(e);
    for (let t = 0; t < 16; t++) {
      const s = ms(zt[i] * zt[t] + Dt[i] * Ot[t]), r = ms(Ot[i] * zt[t] + Lt[i] * Ot[t]), n = ms(zt[i] * Dt[t] + Dt[i] * Lt[t]), o = ms(Ot[i] * Dt[t] + Lt[i] * Lt[t]);
      for (let a = 0; a < 16; a++)
        if (zt[a] === s && Ot[a] === r && Dt[a] === n && Lt[a] === o) {
          e.push(a);
          break;
        }
    }
  }
  for (let i = 0; i < 16; i++) {
    const e = new W();
    e.set(zt[i], Ot[i], Dt[i], Lt[i], 0, 0), mp.push(e);
  }
}
Mb();
const Q = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0       | East      |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45     | Southeast |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90     | South     |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135    | Southwest |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180     | West      |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135/225 | Northwest    |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90/270  | North        |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45/315  | Northeast    |
   * @group groupD8
   * @type {GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @group groupD8
   * @type {GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @group groupD8
   * @type {GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @group groupD8
   * @type {GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @group groupD8
   * @type {GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @group groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: (i) => zt[i],
  /**
   * @group groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: (i) => Ot[i],
  /**
   * @group groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: (i) => Dt[i],
  /**
   * @group groupD8
   * @param {GD8Symmetry} ind - sprite rotation angle.
   * @returns {GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: (i) => Lt[i],
  /**
   * @group groupD8
   * @param {GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: (i) => i & 8 ? i & 15 : -i & 7,
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @group groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {GD8Symmetry} Composed operation
   */
  add: (i, e) => kh[i][e],
  /**
   * Reverse of `add`.
   * @group groupD8
   * @param {GD8Symmetry} rotationSecond - Second operation
   * @param {GD8Symmetry} rotationFirst - First operation
   * @returns {GD8Symmetry} Result
   */
  sub: (i, e) => kh[i][Q.inv(e)],
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @group groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: (i) => i ^ 4,
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @group groupD8
   * @param {GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: (i) => (i & 3) === 2,
  // rotation % 4 === 2
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @group groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: (i, e) => Math.abs(i) * 2 <= Math.abs(e) ? e >= 0 ? Q.S : Q.N : Math.abs(e) * 2 <= Math.abs(i) ? i > 0 ? Q.E : Q.W : e > 0 ? i > 0 ? Q.SE : Q.SW : i > 0 ? Q.NE : Q.NW,
  /**
   * Helps sprite to compensate texture packer rotation.
   * @group groupD8
   * @param {Matrix} matrix - sprite world matrix
   * @param {GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: (i, e, t = 0, s = 0) => {
    const r = mp[Q.inv(e)];
    r.tx = t, r.ty = s, i.append(r);
  },
  /**
   * Transforms rectangle coordinates based on texture packer rotation.
   * Used when texture atlas pages are rotated and coordinates need to be adjusted.
   * @group groupD8
   * @param {RectangleLike} rect - Rectangle with original coordinates to transform
   * @param {RectangleLike} sourceFrame - Source texture frame (includes offset and dimensions)
   * @param {GD8Symmetry} rotation - The groupD8 rotation value
   * @param {Rectangle} out - Rectangle to store the result
   * @returns {Rectangle} Transformed coordinates (includes source frame offset)
   */
  transformRectCoords: (i, e, t, s) => {
    const { x: r, y: n, width: o, height: a } = i, { x: l, y: c, width: h, height: u } = e;
    return t === Q.E ? (s.set(r + l, n + c, o, a), s) : t === Q.S ? s.set(
      h - n - a + l,
      r + c,
      a,
      o
    ) : t === Q.W ? s.set(
      h - r - o + l,
      u - n - a + c,
      o,
      a
    ) : t === Q.N ? s.set(
      n + l,
      u - r - o + c,
      a,
      o
    ) : s.set(r + l, n + c, o, a);
  }
}, gs = [new q(), new q(), new q(), new q()];
class G {
  /**
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   */
  constructor(e = 0, t = 0, s = 0, r = 0) {
    this.type = "rectangle", this.x = Number(e), this.y = Number(t), this.width = Number(s), this.height = Number(r);
  }
  /**
   * Returns the left edge (x-coordinate) of the rectangle.
   * @example
   * ```ts
   * // Get left edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.left); // 100
   *
   * // Use in alignment calculations
   * sprite.x = rect.left + padding;
   *
   * // Compare positions
   * if (point.x > rect.left) {
   *     console.log('Point is right of rectangle');
   * }
   * ```
   * @readonly
   * @returns The x-coordinate of the left edge
   * @see {@link Rectangle.right} For right edge position
   * @see {@link Rectangle.x} For direct x-coordinate access
   */
  get left() {
    return this.x;
  }
  /**
   * Returns the right edge (x + width) of the rectangle.
   * @example
   * ```ts
   * // Get right edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.right); // 300
   *
   * // Align to right edge
   * sprite.x = rect.right - sprite.width;
   *
   * // Check boundaries
   * if (point.x < rect.right) {
   *     console.log('Point is inside right bound');
   * }
   * ```
   * @readonly
   * @returns The x-coordinate of the right edge
   * @see {@link Rectangle.left} For left edge position
   * @see {@link Rectangle.width} For width value
   */
  get right() {
    return this.x + this.width;
  }
  /**
   * Returns the top edge (y-coordinate) of the rectangle.
   * @example
   * ```ts
   * // Get top edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.top); // 100
   *
   * // Position above rectangle
   * sprite.y = rect.top - sprite.height;
   *
   * // Check vertical position
   * if (point.y > rect.top) {
   *     console.log('Point is below top edge');
   * }
   * ```
   * @readonly
   * @returns The y-coordinate of the top edge
   * @see {@link Rectangle.bottom} For bottom edge position
   * @see {@link Rectangle.y} For direct y-coordinate access
   */
  get top() {
    return this.y;
  }
  /**
   * Returns the bottom edge (y + height) of the rectangle.
   * @example
   * ```ts
   * // Get bottom edge position
   * const rect = new Rectangle(100, 100, 200, 150);
   * console.log(rect.bottom); // 250
   *
   * // Stack below rectangle
   * sprite.y = rect.bottom + margin;
   *
   * // Check vertical bounds
   * if (point.y < rect.bottom) {
   *     console.log('Point is above bottom edge');
   * }
   * ```
   * @readonly
   * @returns The y-coordinate of the bottom edge
   * @see {@link Rectangle.top} For top edge position
   * @see {@link Rectangle.height} For height value
   */
  get bottom() {
    return this.y + this.height;
  }
  /**
   * Determines whether the Rectangle is empty (has no area).
   * @example
   * ```ts
   * // Check zero dimensions
   * const rect = new Rectangle(100, 100, 0, 50);
   * console.log(rect.isEmpty()); // true
   * ```
   * @returns True if the rectangle has no area
   * @see {@link Rectangle.width} For width value
   * @see {@link Rectangle.height} For height value
   */
  isEmpty() {
    return this.left === this.right || this.top === this.bottom;
  }
  /**
   * A constant empty rectangle. This is a new object every time the property is accessed.
   * @example
   * ```ts
   * // Get fresh empty rectangle
   * const empty = Rectangle.EMPTY;
   * console.log(empty.isEmpty()); // true
   * ```
   * @returns A new empty rectangle instance
   * @see {@link Rectangle.isEmpty} For empty state testing
   */
  static get EMPTY() {
    return new G(0, 0, 0, 0);
  }
  /**
   * Creates a clone of this Rectangle
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Rectangle(100, 100, 200, 150);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.width *= 2;
   * modified.height += 50;
   *
   * // Verify independence
   * console.log(original.width);  // 200
   * console.log(modified.width);  // 400
   * ```
   * @returns A copy of the rectangle
   * @see {@link Rectangle.copyFrom} For copying into existing rectangle
   * @see {@link Rectangle.copyTo} For copying to another rectangle
   */
  clone() {
    return new G(this.x, this.y, this.width, this.height);
  }
  /**
   * Converts a Bounds object to a Rectangle object.
   * @example
   * ```ts
   * // Convert bounds to rectangle
   * const bounds = container.getBounds();
   * const rect = new Rectangle().copyFromBounds(bounds);
   * ```
   * @param bounds - The bounds to copy and convert to a rectangle
   * @returns Returns itself
   * @see {@link Bounds} For bounds object structure
   * @see {@link Rectangle.getBounds} For getting rectangle bounds
   */
  copyFromBounds(e) {
    return this.x = e.minX, this.y = e.minY, this.width = e.maxX - e.minX, this.height = e.maxY - e.minY, this;
  }
  /**
   * Copies another rectangle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Rectangle(100, 100, 200, 150);
   * const target = new Rectangle();
   * target.copyFrom(source);
   *
   * // Chain with other operations
   * const rect = new Rectangle()
   *     .copyFrom(source)
   *     .pad(10);
   * ```
   * @param rectangle - The rectangle to copy from
   * @returns Returns itself
   * @see {@link Rectangle.copyTo} For copying to another rectangle
   * @see {@link Rectangle.clone} For creating new rectangle copy
   */
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Rectangle(100, 100, 200, 150);
   * const target = new Rectangle();
   * source.copyTo(target);
   *
   * // Chain with other operations
   * const result = source
   *     .copyTo(new Rectangle())
   *     .getBounds();
   * ```
   * @param rectangle - The rectangle to copy to
   * @returns Returns given parameter
   * @see {@link Rectangle.copyFrom} For copying from another rectangle
   * @see {@link Rectangle.clone} For creating new rectangle copy
   */
  copyTo(e) {
    return e.copyFrom(this), e;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rectangle
   * @example
   * ```ts
   * // Basic containment check
   * const rect = new Rectangle(100, 100, 200, 150);
   * const isInside = rect.contains(150, 125); // true
   * // Check edge cases
   * console.log(rect.contains(100, 100)); // true (on edge)
   * console.log(rect.contains(300, 250)); // false (outside)
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rectangle
   * @see {@link Rectangle.containsRect} For rectangle containment
   * @see {@link Rectangle.strokeContains} For checking stroke intersection
   */
  contains(e, t) {
    return this.width <= 0 || this.height <= 0 ? !1 : e >= this.x && e < this.x + this.width && t >= this.y && t < this.y + this.height;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const rect = new Rectangle(100, 100, 200, 150);
   * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this rectangle's stroke
   * @see {@link Rectangle.contains} For checking fill containment
   * @see {@link Rectangle.getBounds} For getting stroke bounds
   */
  strokeContains(e, t, s, r = 0.5) {
    const { width: n, height: o } = this;
    if (n <= 0 || o <= 0)
      return !1;
    const a = this.x, l = this.y, c = s * (1 - r), h = s - c, u = a - c, d = a + n + c, f = l - c, m = l + o + c, g = a + h, p = a + n - h, x = l + h, y = l + o - h;
    return e >= u && e <= d && t >= f && t <= m && !(e > g && e < p && t > x && t < y);
  }
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   * Returns true only if the area of the intersection is >0, this means that Rectangles
   * sharing a side are not overlapping. Another side effect is that an arealess rectangle
   * (width or height equal to zero) can't intersect any other rectangle.
   * @param {Rectangle} other - The Rectangle to intersect with `this`.
   * @param {Matrix} transform - The transformation matrix of `other`.
   * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.
   */
  /**
   * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.
   *
   * Returns true only if the area of the intersection is greater than 0.
   * This means that rectangles sharing only a side are not considered intersecting.
   * @example
   * ```ts
   * // Basic intersection check
   * const rect1 = new Rectangle(0, 0, 100, 100);
   * const rect2 = new Rectangle(50, 50, 100, 100);
   * console.log(rect1.intersects(rect2)); // true
   *
   * // With transformation matrix
   * const matrix = new Matrix();
   * matrix.rotate(Math.PI / 4); // 45 degrees
   * console.log(rect1.intersects(rect2, matrix)); // Checks with rotation
   *
   * // Edge cases
   * const zeroWidth = new Rectangle(0, 0, 0, 100);
   * console.log(rect1.intersects(zeroWidth)); // false (no area)
   * ```
   * @remarks
   * - Returns true only if intersection area is > 0
   * - Rectangles sharing only a side are not intersecting
   * - Zero-area rectangles cannot intersect anything
   * - Supports optional transformation matrix
   * @param other - The Rectangle to intersect with `this`
   * @param transform - Optional transformation matrix of `other`
   * @returns True if the transformed `other` Rectangle intersects with `this`
   * @see {@link Rectangle.containsRect} For containment testing
   * @see {@link Rectangle.contains} For point testing
   */
  intersects(e, t) {
    if (!t) {
      const A = this.x < e.x ? e.x : this.x;
      if ((this.right > e.right ? e.right : this.right) <= A)
        return !1;
      const S = this.y < e.y ? e.y : this.y;
      return (this.bottom > e.bottom ? e.bottom : this.bottom) > S;
    }
    const s = this.left, r = this.right, n = this.top, o = this.bottom;
    if (r <= s || o <= n)
      return !1;
    const a = gs[0].set(e.left, e.top), l = gs[1].set(e.left, e.bottom), c = gs[2].set(e.right, e.top), h = gs[3].set(e.right, e.bottom);
    if (c.x <= a.x || l.y <= a.y)
      return !1;
    const u = Math.sign(t.a * t.d - t.b * t.c);
    if (u === 0 || (t.apply(a, a), t.apply(l, l), t.apply(c, c), t.apply(h, h), Math.max(a.x, l.x, c.x, h.x) <= s || Math.min(a.x, l.x, c.x, h.x) >= r || Math.max(a.y, l.y, c.y, h.y) <= n || Math.min(a.y, l.y, c.y, h.y) >= o))
      return !1;
    const d = u * (l.y - a.y), f = u * (a.x - l.x), m = d * s + f * n, g = d * r + f * n, p = d * s + f * o, x = d * r + f * o;
    if (Math.max(m, g, p, x) <= d * a.x + f * a.y || Math.min(m, g, p, x) >= d * h.x + f * h.y)
      return !1;
    const y = u * (a.y - c.y), v = u * (c.x - a.x), _ = y * s + v * n, b = y * r + v * n, T = y * s + v * o, w = y * r + v * o;
    return !(Math.max(_, b, T, w) <= y * a.x + v * a.y || Math.min(_, b, T, w) >= y * h.x + v * h.y);
  }
  /**
   * Pads the rectangle making it grow in all directions.
   *
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @example
   * ```ts
   * // Basic padding
   * const rect = new Rectangle(100, 100, 200, 150);
   * rect.pad(10); // Adds 10px padding on all sides
   *
   * // Different horizontal and vertical padding
   * const uiRect = new Rectangle(0, 0, 100, 50);
   * uiRect.pad(20, 10); // 20px horizontal, 10px vertical
   * ```
   * @remarks
   * - Adjusts x/y by subtracting padding
   * - Increases width/height by padding * 2
   * - Common in UI layout calculations
   * - Chainable with other methods
   * @param paddingX - The horizontal padding amount
   * @param paddingY - The vertical padding amount
   * @returns Returns itself
   * @see {@link Rectangle.enlarge} For growing to include another rectangle
   * @see {@link Rectangle.fit} For shrinking to fit within another rectangle
   */
  pad(e = 0, t = e) {
    return this.x -= e, this.y -= t, this.width += e * 2, this.height += t * 2, this;
  }
  /**
   * Fits this rectangle around the passed one.
   * @example
   * ```ts
   * // Basic fitting
   * const container = new Rectangle(0, 0, 100, 100);
   * const content = new Rectangle(25, 25, 200, 200);
   * content.fit(container); // Clips to container bounds
   * ```
   * @param rectangle - The rectangle to fit around
   * @returns Returns itself
   * @see {@link Rectangle.enlarge} For growing to include another rectangle
   * @see {@link Rectangle.pad} For adding padding around the rectangle
   */
  fit(e) {
    const t = Math.max(this.x, e.x), s = Math.min(this.x + this.width, e.x + e.width), r = Math.max(this.y, e.y), n = Math.min(this.y + this.height, e.y + e.height);
    return this.x = t, this.width = Math.max(s - t, 0), this.y = r, this.height = Math.max(n - r, 0), this;
  }
  /**
   * Enlarges rectangle so that its corners lie on a grid defined by resolution.
   * @example
   * ```ts
   * // Basic grid alignment
   * const rect = new Rectangle(10.2, 10.6, 100.8, 100.4);
   * rect.ceil(); // Aligns to whole pixels
   *
   * // Custom resolution grid
   * const uiRect = new Rectangle(5.3, 5.7, 50.2, 50.8);
   * uiRect.ceil(0.5); // Aligns to half pixels
   *
   * // Use with precision value
   * const preciseRect = new Rectangle(20.001, 20.999, 100.001, 100.999);
   * preciseRect.ceil(1, 0.01); // Handles small decimal variations
   * ```
   * @param resolution - The grid size to align to (1 = whole pixels)
   * @param eps - Small number to prevent floating point errors
   * @returns Returns itself
   * @see {@link Rectangle.fit} For constraining to bounds
   * @see {@link Rectangle.enlarge} For growing dimensions
   */
  ceil(e = 1, t = 1e-3) {
    const s = Math.ceil((this.x + this.width - t) * e) / e, r = Math.ceil((this.y + this.height - t) * e) / e;
    return this.x = Math.floor((this.x + t) * e) / e, this.y = Math.floor((this.y + t) * e) / e, this.width = s - this.x, this.height = r - this.y, this;
  }
  /**
   * Scales the rectangle's dimensions and position by the specified factors.
   * @example
   * ```ts
   * const rect = new Rectangle(50, 50, 100, 100);
   *
   * // Scale uniformly
   * rect.scale(0.5, 0.5);
   * // rect is now: x=25, y=25, width=50, height=50
   *
   * // non-uniformly
   * rect.scale(0.5, 1);
   * // rect is now: x=25, y=50, width=50, height=100
   * ```
   * @param x - The factor by which to scale the horizontal properties (x, width).
   * @param y - The factor by which to scale the vertical properties (y, height).
   * @returns Returns itself
   */
  scale(e, t = e) {
    return this.x *= e, this.y *= t, this.width *= e, this.height *= t, this;
  }
  /**
   * Enlarges this rectangle to include the passed rectangle.
   * @example
   * ```ts
   * // Basic enlargement
   * const rect = new Rectangle(50, 50, 100, 100);
   * const other = new Rectangle(0, 0, 200, 75);
   * rect.enlarge(other);
   * // rect is now: x=0, y=0, width=200, height=150
   *
   * // Use for bounding box calculation
   * const bounds = new Rectangle();
   * objects.forEach((obj) => {
   *     bounds.enlarge(obj.getBounds());
   * });
   * ```
   * @param rectangle - The rectangle to include
   * @returns Returns itself
   * @see {@link Rectangle.fit} For shrinking to fit within another rectangle
   * @see {@link Rectangle.pad} For adding padding around the rectangle
   */
  enlarge(e) {
    const t = Math.min(this.x, e.x), s = Math.max(this.x + this.width, e.x + e.width), r = Math.min(this.y, e.y), n = Math.max(this.y + this.height, e.y + e.height);
    return this.x = t, this.width = s - t, this.y = r, this.height = n - r, this;
  }
  /**
   * Returns the framing rectangle of the rectangle as a Rectangle object
   * @example
   * ```ts
   * // Basic bounds retrieval
   * const rect = new Rectangle(100, 100, 200, 150);
   * const bounds = rect.getBounds();
   *
   * // Reuse existing rectangle
   * const out = new Rectangle();
   * rect.getBounds(out);
   * ```
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle.copyFrom} For direct copying
   * @see {@link Rectangle.clone} For creating new copy
   */
  getBounds(e) {
    return e || (e = new G()), e.copyFrom(this), e;
  }
  /**
   * Determines whether another Rectangle is fully contained within this Rectangle.
   *
   * Rectangles that occupy the same space are considered to be containing each other.
   *
   * Rectangles without area (width or height equal to zero) can't contain anything,
   * not even other arealess rectangles.
   * @example
   * ```ts
   * // Check if one rectangle contains another
   * const container = new Rectangle(0, 0, 100, 100);
   * const inner = new Rectangle(25, 25, 50, 50);
   *
   * console.log(container.containsRect(inner)); // true
   *
   * // Check overlapping rectangles
   * const partial = new Rectangle(75, 75, 50, 50);
   * console.log(container.containsRect(partial)); // false
   *
   * // Zero-area rectangles
   * const empty = new Rectangle(0, 0, 0, 100);
   * console.log(container.containsRect(empty)); // false
   * ```
   * @param other - The Rectangle to check for containment
   * @returns True if other is fully contained within this Rectangle
   * @see {@link Rectangle.contains} For point containment
   * @see {@link Rectangle.intersects} For overlap testing
   */
  containsRect(e) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    const t = e.x, s = e.y, r = e.x + e.width, n = e.y + e.height;
    return t >= this.x && t < this.x + this.width && s >= this.y && s < this.y + this.height && r >= this.x && r < this.x + this.width && n >= this.y && n < this.y + this.height;
  }
  /**
   * Sets the position and dimensions of the rectangle.
   * @example
   * ```ts
   * // Basic usage
   * const rect = new Rectangle();
   * rect.set(100, 100, 200, 150);
   *
   * // Chain with other operations
   * const bounds = new Rectangle()
   *     .set(0, 0, 100, 100)
   *     .pad(10);
   * ```
   * @param x - The X coordinate of the upper-left corner of the rectangle
   * @param y - The Y coordinate of the upper-left corner of the rectangle
   * @param width - The overall width of the rectangle
   * @param height - The overall height of the rectangle
   * @returns Returns itself for method chaining
   * @see {@link Rectangle.copyFrom} For copying from another rectangle
   * @see {@link Rectangle.clone} For creating a new copy
   */
  set(e, t, s, r) {
    return this.x = e, this.y = t, this.width = s, this.height = r, this;
  }
  toString() {
    return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  }
}
const Bc = {
  default: -1
};
function de(i = "default") {
  return Bc[i] === void 0 && (Bc[i] = -1), ++Bc[i];
}
const zu = /* @__PURE__ */ new Set(), J = "8.0.0", Eb = "8.3.4", si = {
  quiet: !1,
  noColor: !1
}, N = (i, e, t = 3) => {
  if (si.quiet || zu.has(e))
    return;
  let s = new Error().stack;
  const r = `${e}
Deprecated since v${i}`, n = typeof console.groupCollapsed == "function" && !si.noColor;
  typeof s > "u" ? console.warn("PixiJS Deprecation Warning: ", r) : (s = s.split(`
`).splice(t).join(`
`), n ? (console.groupCollapsed(
    "%cPixiJS Deprecation Warning: %c%s",
    "color:#614108;background:#fffbe6",
    "font-weight:normal;color:#614108;background:#fffbe6",
    r
  ), console.warn(s), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", r), console.warn(s))), zu.add(e);
};
Object.defineProperties(N, {
  quiet: {
    get: () => si.quiet,
    set: (i) => {
      si.quiet = i;
    },
    enumerable: !0,
    configurable: !1
  },
  noColor: {
    get: () => si.noColor,
    set: (i) => {
      si.noColor = i;
    },
    enumerable: !0,
    configurable: !1
  }
});
const gp = () => {
};
function ci(i) {
  return i += i === 0 ? 1 : 0, --i, i |= i >>> 1, i |= i >>> 2, i |= i >>> 4, i |= i >>> 8, i |= i >>> 16, i + 1;
}
function Ou(i) {
  return !(i & i - 1) && !!i;
}
function xp(i) {
  const e = {};
  for (const t in i)
    i[t] !== void 0 && (e[t] = i[t]);
  return e;
}
const Du = /* @__PURE__ */ Object.create(null);
function Pb(i) {
  const e = Du[i];
  return e === void 0 && (Du[i] = de("resource")), e;
}
const yp = class vp extends rt {
  /**
   * @param options - options for the style
   */
  constructor(e = {}) {
    super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = !1, e = { ...vp.defaultOptions, ...e }, this.addressMode = e.addressMode, this.addressModeU = e.addressModeU ?? this.addressModeU, this.addressModeV = e.addressModeV ?? this.addressModeV, this.addressModeW = e.addressModeW ?? this.addressModeW, this.scaleMode = e.scaleMode, this.magFilter = e.magFilter ?? this.magFilter, this.minFilter = e.minFilter ?? this.minFilter, this.mipmapFilter = e.mipmapFilter ?? this.mipmapFilter, this.lodMinClamp = e.lodMinClamp, this.lodMaxClamp = e.lodMaxClamp, this.compare = e.compare, this.maxAnisotropy = e.maxAnisotropy ?? 1;
  }
  set addressMode(e) {
    this.addressModeU = e, this.addressModeV = e, this.addressModeW = e;
  }
  /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */
  get addressMode() {
    return this.addressModeU;
  }
  set wrapMode(e) {
    N(J, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = e;
  }
  get wrapMode() {
    return this.addressMode;
  }
  set scaleMode(e) {
    this.magFilter = e, this.minFilter = e, this.mipmapFilter = e;
  }
  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
  get scaleMode() {
    return this.magFilter;
  }
  /** Specifies the maximum anisotropy value clamp used by the sampler. */
  set maxAnisotropy(e) {
    this._maxAnisotropy = Math.min(e, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear");
  }
  get maxAnisotropy() {
    return this._maxAnisotropy;
  }
  // TODO - move this to WebGL?
  get _resourceId() {
    return this._sharedResourceId || this._generateResourceId();
  }
  update() {
    this.emit("change", this), this._sharedResourceId = null;
  }
  _generateResourceId() {
    const e = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
    return this._sharedResourceId = Pb(e), this._resourceId;
  }
  /** Destroys the style */
  destroy() {
    this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners();
  }
};
yp.defaultOptions = {
  addressMode: "clamp-to-edge",
  scaleMode: "linear"
};
let hi = yp;
const _p = class bp extends rt {
  /**
   * @param options - options for creating a new TextureSource
   */
  constructor(e = {}) {
    super(), this.options = e, this.uid = de("textureSource"), this._resourceType = "textureSource", this._resourceId = de("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = !1, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = !1, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, e = { ...bp.defaultOptions, ...e }, this.label = e.label ?? "", this.resource = e.resource, this.autoGarbageCollect = e.autoGarbageCollect, this._resolution = e.resolution, e.width ? this.pixelWidth = e.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ?? 1 : 1, e.height ? this.pixelHeight = e.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ?? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = e.format, this.dimension = e.dimensions, this.mipLevelCount = e.mipLevelCount, this.autoGenerateMipmaps = e.autoGenerateMipmaps, this.sampleCount = e.sampleCount, this.antialias = e.antialias, this.alphaMode = e.alphaMode, this.style = new hi(xp(e)), this.destroyed = !1, this._refreshPOT();
  }
  /** returns itself */
  get source() {
    return this;
  }
  /** the style of the texture */
  get style() {
    return this._style;
  }
  set style(e) {
    this.style !== e && (this._style?.off("change", this._onStyleChange, this), this._style = e, this._style?.on("change", this._onStyleChange, this), this._onStyleChange());
  }
  /** Specifies the maximum anisotropy value clamp used by the sampler. */
  set maxAnisotropy(e) {
    this._style.maxAnisotropy = e;
  }
  get maxAnisotropy() {
    return this._style.maxAnisotropy;
  }
  /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */
  get addressMode() {
    return this._style.addressMode;
  }
  set addressMode(e) {
    this._style.addressMode = e;
  }
  /** setting this will set wrapModeU, wrapModeV and wrapModeW all at once! */
  get repeatMode() {
    return this._style.addressMode;
  }
  set repeatMode(e) {
    this._style.addressMode = e;
  }
  /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */
  get magFilter() {
    return this._style.magFilter;
  }
  set magFilter(e) {
    this._style.magFilter = e;
  }
  /** Specifies the sampling behavior when the sample footprint is larger than one texel. */
  get minFilter() {
    return this._style.minFilter;
  }
  set minFilter(e) {
    this._style.minFilter = e;
  }
  /** Specifies behavior for sampling between mipmap levels. */
  get mipmapFilter() {
    return this._style.mipmapFilter;
  }
  set mipmapFilter(e) {
    this._style.mipmapFilter = e;
  }
  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
  get lodMinClamp() {
    return this._style.lodMinClamp;
  }
  set lodMinClamp(e) {
    this._style.lodMinClamp = e;
  }
  /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */
  get lodMaxClamp() {
    return this._style.lodMaxClamp;
  }
  set lodMaxClamp(e) {
    this._style.lodMaxClamp = e;
  }
  _onStyleChange() {
    this.emit("styleChange", this);
  }
  /** call this if you have modified the texture outside of the constructor */
  update() {
    if (this.resource) {
      const e = this._resolution;
      if (this.resize(this.resourceWidth / e, this.resourceHeight / e))
        return;
    }
    this.emit("update", this);
  }
  /** Destroys this texture source */
  destroy() {
    this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners();
  }
  /**
   * This will unload the Texture source from the GPU. This will free up the GPU memory
   * As soon as it is required fore rendering, it will be re-uploaded.
   */
  unload() {
    this._resourceId = de("resource"), this.emit("change", this), this.emit("unload", this);
  }
  /** the width of the resource. This is the REAL pure number, not accounting resolution   */
  get resourceWidth() {
    const { resource: e } = this;
    return e.naturalWidth || e.videoWidth || e.displayWidth || e.width;
  }
  /** the height of the resource. This is the REAL pure number, not accounting resolution */
  get resourceHeight() {
    const { resource: e } = this;
    return e.naturalHeight || e.videoHeight || e.displayHeight || e.height;
  }
  /**
   * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture
   * but will the size of the texture when rendered.
   *
   * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel
   * density will have increased)
   */
  get resolution() {
    return this._resolution;
  }
  set resolution(e) {
    this._resolution !== e && (this._resolution = e, this.width = this.pixelWidth / e, this.height = this.pixelHeight / e);
  }
  /**
   * Resize the texture, this is handy if you want to use the texture as a render texture
   * @param width - the new width of the texture
   * @param height - the new height of the texture
   * @param resolution - the new resolution of the texture
   * @returns - if the texture was resized
   */
  resize(e, t, s) {
    s || (s = this._resolution), e || (e = this.width), t || (t = this.height);
    const r = Math.round(e * s), n = Math.round(t * s);
    return this.width = r / s, this.height = n / s, this._resolution = s, this.pixelWidth === r && this.pixelHeight === n ? !1 : (this._refreshPOT(), this.pixelWidth = r, this.pixelHeight = n, this.emit("resize", this), this._resourceId = de("resource"), this.emit("change", this), !0);
  }
  /**
   * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.
   * This is only important for RenderTexture instances, as standard Texture instances will have their
   * mipmaps generated on upload. You should call this method after you make any change to the texture
   *
   * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,
   * We want you, the developer to specify when this action should happen.
   *
   * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,
   */
  updateMipmaps() {
    this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this);
  }
  set wrapMode(e) {
    this._style.wrapMode = e;
  }
  get wrapMode() {
    return this._style.wrapMode;
  }
  set scaleMode(e) {
    this._style.scaleMode = e;
  }
  /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */
  get scaleMode() {
    return this._style.scaleMode;
  }
  /**
   * Refresh check for isPowerOfTwo texture based on size
   * @private
   */
  _refreshPOT() {
    this.isPowerOfTwo = Ou(this.pixelWidth) && Ou(this.pixelHeight);
  }
  static test(e) {
    throw new Error("Unimplemented");
  }
};
_p.defaultOptions = {
  resolution: 1,
  format: "bgra8unorm",
  alphaMode: "premultiply-alpha-on-upload",
  dimensions: "2d",
  mipLevelCount: 1,
  autoGenerateMipmaps: !1,
  sampleCount: 1,
  antialias: !1,
  autoGarbageCollect: !1
};
let Ke = _p;
class nu extends Ke {
  constructor(e) {
    const t = e.resource || new Float32Array(e.width * e.height * 4);
    let s = e.format;
    s || (t instanceof Float32Array ? s = "rgba32float" : t instanceof Int32Array || t instanceof Uint32Array ? s = "rgba32uint" : t instanceof Int16Array || t instanceof Uint16Array ? s = "rgba16uint" : (t instanceof Int8Array, s = "bgra8unorm")), super({
      ...e,
      resource: t,
      format: s
    }), this.uploadMethodId = "buffer";
  }
  static test(e) {
    return e instanceof Int8Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array;
  }
}
nu.extension = O.TextureSource;
const Lu = new W();
class Ub {
  /**
   * @param texture - observed texture
   * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.
   */
  constructor(e, t) {
    this.mapCoord = new W(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof t > "u" ? this.clampMargin = e.width < 10 ? 0 : 0.5 : this.clampMargin = t, this.isSimple = !1, this.texture = e;
  }
  /** Texture property. */
  get texture() {
    return this._texture;
  }
  set texture(e) {
    this.texture !== e && (this._texture?.removeListener("update", this.update, this), this._texture = e, this._texture.addListener("update", this.update, this), this.update());
  }
  /**
   * Multiplies uvs array to transform
   * @param uvs - mesh uvs
   * @param [out=uvs] - output
   * @returns - output
   */
  multiplyUvs(e, t) {
    t === void 0 && (t = e);
    const s = this.mapCoord;
    for (let r = 0; r < e.length; r += 2) {
      const n = e[r], o = e[r + 1];
      t[r] = n * s.a + o * s.c + s.tx, t[r + 1] = n * s.b + o * s.d + s.ty;
    }
    return t;
  }
  /**
   * Updates matrices if texture was changed
   * @returns - whether or not it was updated
   */
  update() {
    const e = this._texture;
    this._updateID++;
    const t = e.uvs;
    this.mapCoord.set(t.x1 - t.x0, t.y1 - t.y0, t.x3 - t.x0, t.y3 - t.y0, t.x0, t.y0);
    const s = e.orig, r = e.trim;
    r && (Lu.set(
      s.width / r.width,
      0,
      0,
      s.height / r.height,
      -r.x / r.width,
      -r.y / r.height
    ), this.mapCoord.append(Lu));
    const n = e.source, o = this.uClampFrame, a = this.clampMargin / n._resolution, l = this.clampOffset / n._resolution;
    return o[0] = (e.frame.x + a + l) / n.width, o[1] = (e.frame.y + a + l) / n.height, o[2] = (e.frame.x + e.frame.width - a + l) / n.width, o[3] = (e.frame.y + e.frame.height - a + l) / n.height, this.uClampOffset[0] = this.clampOffset / n.pixelWidth, this.uClampOffset[1] = this.clampOffset / n.pixelHeight, this.isSimple = e.frame.width === n.width && e.frame.height === n.height && e.rotate === 0, !0;
  }
}
class L extends rt {
  /**
   * @param {TextureOptions} options - Options for the texture
   */
  constructor({
    source: e,
    label: t,
    frame: s,
    orig: r,
    trim: n,
    defaultAnchor: o,
    defaultBorders: a,
    rotate: l,
    dynamic: c
  } = {}) {
    if (super(), this.uid = de("texture"), this.uvs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 }, this.frame = new G(), this.noFrame = !1, this.dynamic = !1, this.isTexture = !0, this.label = t, this.source = e?.source ?? new Ke(), this.noFrame = !s, s)
      this.frame.copyFrom(s);
    else {
      const { width: h, height: u } = this._source;
      this.frame.width = h, this.frame.height = u;
    }
    this.orig = r || this.frame, this.trim = n, this.rotate = l ?? 0, this.defaultAnchor = o, this.defaultBorders = a, this.destroyed = !1, this.dynamic = c || !1, this.updateUvs();
  }
  set source(e) {
    this._source && this._source.off("resize", this.update, this), this._source = e, e.on("resize", this.update, this), this.emit("update", this);
  }
  /** the underlying source of the texture (equivalent of baseTexture in v7) */
  get source() {
    return this._source;
  }
  /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */
  get textureMatrix() {
    return this._textureMatrix || (this._textureMatrix = new Ub(this)), this._textureMatrix;
  }
  /** The width of the Texture in pixels. */
  get width() {
    return this.orig.width;
  }
  /** The height of the Texture in pixels. */
  get height() {
    return this.orig.height;
  }
  /** Call this function when you have modified the frame of this texture. */
  updateUvs() {
    const { uvs: e, frame: t } = this, { width: s, height: r } = this._source, n = t.x / s, o = t.y / r, a = t.width / s, l = t.height / r;
    let c = this.rotate;
    if (c) {
      const h = a / 2, u = l / 2, d = n + h, f = o + u;
      c = Q.add(c, Q.NW), e.x0 = d + h * Q.uX(c), e.y0 = f + u * Q.uY(c), c = Q.add(c, 2), e.x1 = d + h * Q.uX(c), e.y1 = f + u * Q.uY(c), c = Q.add(c, 2), e.x2 = d + h * Q.uX(c), e.y2 = f + u * Q.uY(c), c = Q.add(c, 2), e.x3 = d + h * Q.uX(c), e.y3 = f + u * Q.uY(c);
    } else
      e.x0 = n, e.y0 = o, e.x1 = n + a, e.y1 = o, e.x2 = n + a, e.y2 = o + l, e.x3 = n, e.y3 = o + l;
  }
  /**
   * Destroys this texture
   * @param destroySource - Destroy the source when the texture is destroyed.
   */
  destroy(e = !1) {
    this._source && (this._source.off("resize", this.update, this), e && (this._source.destroy(), this._source = null)), this._textureMatrix = null, this.destroyed = !0, this.emit("destroy", this), this.removeAllListeners();
  }
  /**
   * Call this if you have modified the `texture outside` of the constructor.
   *
   * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.
   */
  update() {
    this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this);
  }
  /** @deprecated since 8.0.0 */
  get baseTexture() {
    return N(J, "Texture.baseTexture is now Texture.source"), this._source;
  }
}
L.EMPTY = new L({
  label: "EMPTY",
  source: new Ke({
    label: "EMPTY"
  })
});
L.EMPTY.destroy = gp;
L.WHITE = new L({
  source: new nu({
    resource: new Uint8Array([255, 255, 255, 255]),
    width: 1,
    height: 1,
    alphaMode: "premultiply-alpha-on-upload",
    label: "WHITE"
  }),
  label: "WHITE"
});
L.WHITE.destroy = gp;
function Rb(i, e, t) {
  const { width: s, height: r } = t.orig, n = t.trim;
  if (n) {
    const o = n.width, a = n.height;
    i.minX = n.x - e._x * s, i.maxX = i.minX + o, i.minY = n.y - e._y * r, i.maxY = i.minY + a;
  } else
    i.minX = -e._x * s, i.maxX = i.minX + s, i.minY = -e._y * r, i.maxY = i.minY + r;
}
const Nu = new W();
class it {
  /**
   * Creates a new Bounds object.
   * @param minX - The minimum X coordinate of the bounds.
   * @param minY - The minimum Y coordinate of the bounds.
   * @param maxX - The maximum X coordinate of the bounds.
   * @param maxY - The maximum Y coordinate of the bounds.
   */
  constructor(e = 1 / 0, t = 1 / 0, s = -1 / 0, r = -1 / 0) {
    this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = Nu, this.minX = e, this.minY = t, this.maxX = s, this.maxY = r;
  }
  /**
   * Checks if bounds are empty, meaning either width or height is zero or negative.
   * Empty bounds occur when min values exceed max values on either axis.
   * @example
   * ```ts
   * const bounds = new Bounds();
   *
   * // Check if newly created bounds are empty
   * console.log(bounds.isEmpty()); // true, default bounds are empty
   *
   * // Add frame and check again
   * bounds.addFrame(0, 0, 100, 100);
   * console.log(bounds.isEmpty()); // false, bounds now have area
   *
   * // Clear bounds
   * bounds.clear();
   * console.log(bounds.isEmpty()); // true, bounds are empty again
   * ```
   * @returns True if bounds are empty (have no area)
   * @see {@link Bounds#clear} For resetting bounds
   * @see {@link Bounds#isValid} For checking validity
   */
  isEmpty() {
    return this.minX > this.maxX || this.minY > this.maxY;
  }
  /**
   * The bounding rectangle representation of these bounds.
   * Lazily creates and updates a Rectangle instance based on the current bounds.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Get rectangle representation
   * const rect = bounds.rectangle;
   * console.log(rect.x, rect.y, rect.width, rect.height);
   *
   * // Use for hit testing
   * if (bounds.rectangle.contains(mouseX, mouseY)) {
   *     console.log('Mouse is inside bounds!');
   * }
   * ```
   * @see {@link Rectangle} For rectangle methods
   * @see {@link Bounds.isEmpty} For bounds validation
   */
  get rectangle() {
    this._rectangle || (this._rectangle = new G());
    const e = this._rectangle;
    return this.minX > this.maxX || this.minY > this.maxY ? (e.x = 0, e.y = 0, e.width = 0, e.height = 0) : e.copyFromBounds(this), e;
  }
  /**
   * Clears the bounds and resets all coordinates to their default values.
   * Resets the transformation matrix back to identity.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * console.log(bounds.isEmpty()); // false
   * // Clear the bounds
   * bounds.clear();
   * console.log(bounds.isEmpty()); // true
   * ```
   * @returns This bounds object for chaining
   */
  clear() {
    return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = Nu, this;
  }
  /**
   * Sets the bounds directly using coordinate values.
   * Provides a way to set all bounds values at once.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * bounds.set(0, 0, 100, 100);
   * ```
   * @param x0 - Left X coordinate of frame
   * @param y0 - Top Y coordinate of frame
   * @param x1 - Right X coordinate of frame
   * @param y1 - Bottom Y coordinate of frame
   * @see {@link Bounds#addFrame} For matrix-aware bounds setting
   * @see {@link Bounds#clear} For resetting bounds
   */
  set(e, t, s, r) {
    this.minX = e, this.minY = t, this.maxX = s, this.maxY = r;
  }
  /**
   * Adds a rectangular frame to the bounds, optionally transformed by a matrix.
   * Updates the bounds to encompass the new frame coordinates.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * bounds.addFrame(0, 0, 100, 100);
   *
   * // Add transformed frame
   * const matrix = new Matrix()
   *     .translate(50, 50)
   *     .rotate(Math.PI / 4);
   * bounds.addFrame(0, 0, 100, 100, matrix);
   * ```
   * @param x0 - Left X coordinate of frame
   * @param y0 - Top Y coordinate of frame
   * @param x1 - Right X coordinate of frame
   * @param y1 - Bottom Y coordinate of frame
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addRect} For adding Rectangle objects
   * @see {@link Bounds#addBounds} For adding other Bounds
   */
  addFrame(e, t, s, r, n) {
    n || (n = this.matrix);
    const o = n.a, a = n.b, l = n.c, c = n.d, h = n.tx, u = n.ty;
    let d = this.minX, f = this.minY, m = this.maxX, g = this.maxY, p = o * e + l * t + h, x = a * e + c * t + u;
    p < d && (d = p), x < f && (f = x), p > m && (m = p), x > g && (g = x), p = o * s + l * t + h, x = a * s + c * t + u, p < d && (d = p), x < f && (f = x), p > m && (m = p), x > g && (g = x), p = o * e + l * r + h, x = a * e + c * r + u, p < d && (d = p), x < f && (f = x), p > m && (m = p), x > g && (g = x), p = o * s + l * r + h, x = a * s + c * r + u, p < d && (d = p), x < f && (f = x), p > m && (m = p), x > g && (g = x), this.minX = d, this.minY = f, this.maxX = m, this.maxY = g;
  }
  /**
   * Adds a rectangle to the bounds, optionally transformed by a matrix.
   * Updates the bounds to encompass the given rectangle.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * // Add simple rectangle
   * const rect = new Rectangle(0, 0, 100, 100);
   * bounds.addRect(rect);
   *
   * // Add transformed rectangle
   * const matrix = new Matrix()
   *     .translate(50, 50)
   *     .rotate(Math.PI / 4);
   * bounds.addRect(rect, matrix);
   * ```
   * @param rect - The rectangle to be added
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addFrame} For adding raw coordinates
   * @see {@link Bounds#addBounds} For adding other bounds
   */
  addRect(e, t) {
    this.addFrame(e.x, e.y, e.x + e.width, e.y + e.height, t);
  }
  /**
   * Adds another bounds object to this one, optionally transformed by a matrix.
   * Expands the bounds to include the given bounds' area.
   * @example
   * ```ts
   * const bounds = new Bounds();
   *
   * // Add child bounds
   * const childBounds = sprite.getBounds();
   * bounds.addBounds(childBounds);
   *
   * // Add transformed bounds
   * const matrix = new Matrix()
   *     .scale(2, 2);
   * bounds.addBounds(childBounds, matrix);
   * ```
   * @param bounds - The bounds to be added
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addFrame} For adding raw coordinates
   * @see {@link Bounds#addRect} For adding rectangles
   */
  addBounds(e, t) {
    this.addFrame(e.minX, e.minY, e.maxX, e.maxY, t);
  }
  /**
   * Adds other Bounds as a mask, creating an intersection of the two bounds.
   * Only keeps the overlapping region between current bounds and mask bounds.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Create mask bounds
   * const mask = new Bounds();
   * mask.addFrame(50, 50, 150, 150);
   * // Apply mask - results in bounds of (50,50,100,100)
   * bounds.addBoundsMask(mask);
   * ```
   * @param mask - The Bounds to use as a mask
   * @see {@link Bounds#addBounds} For union operation
   * @see {@link Bounds#fit} For fitting to rectangle
   */
  addBoundsMask(e) {
    this.minX = this.minX > e.minX ? this.minX : e.minX, this.minY = this.minY > e.minY ? this.minY : e.minY, this.maxX = this.maxX < e.maxX ? this.maxX : e.maxX, this.maxY = this.maxY < e.maxY ? this.maxY : e.maxY;
  }
  /**
   * Applies a transformation matrix to the bounds, updating its coordinates.
   * Transforms all corners of the bounds using the given matrix.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Apply translation
   * const translateMatrix = new Matrix()
   *     .translate(50, 50);
   * bounds.applyMatrix(translateMatrix);
   * ```
   * @param matrix - The matrix to apply to the bounds
   * @see {@link Matrix} For matrix operations
   * @see {@link Bounds#addFrame} For adding transformed frames
   */
  applyMatrix(e) {
    const t = this.minX, s = this.minY, r = this.maxX, n = this.maxY, { a: o, b: a, c: l, d: c, tx: h, ty: u } = e;
    let d = o * t + l * s + h, f = a * t + c * s + u;
    this.minX = d, this.minY = f, this.maxX = d, this.maxY = f, d = o * r + l * s + h, f = a * r + c * s + u, this.minX = d < this.minX ? d : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = f > this.maxY ? f : this.maxY, d = o * t + l * n + h, f = a * t + c * n + u, this.minX = d < this.minX ? d : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = f > this.maxY ? f : this.maxY, d = o * r + l * n + h, f = a * r + c * n + u, this.minX = d < this.minX ? d : this.minX, this.minY = f < this.minY ? f : this.minY, this.maxX = d > this.maxX ? d : this.maxX, this.maxY = f > this.maxY ? f : this.maxY;
  }
  /**
   * Resizes the bounds object to fit within the given rectangle.
   * Clips the bounds if they extend beyond the rectangle's edges.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 200, 200);
   * // Fit within viewport
   * const viewport = new Rectangle(50, 50, 100, 100);
   * bounds.fit(viewport);
   * // bounds are now (50, 50, 150, 150)
   * ```
   * @param rect - The rectangle to fit within
   * @returns This bounds object for chaining
   * @see {@link Bounds#addBoundsMask} For intersection
   * @see {@link Bounds#pad} For expanding bounds
   */
  fit(e) {
    return this.minX < e.left && (this.minX = e.left), this.maxX > e.right && (this.maxX = e.right), this.minY < e.top && (this.minY = e.top), this.maxY > e.bottom && (this.maxY = e.bottom), this;
  }
  /**
   * Resizes the bounds object to include the given bounds.
   * Similar to fit() but works with raw coordinate values instead of a Rectangle.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 200, 200);
   * // Fit to specific coordinates
   * bounds.fitBounds(50, 150, 50, 150);
   * // bounds are now (50, 50, 150, 150)
   * ```
   * @param left - The left value of the bounds
   * @param right - The right value of the bounds
   * @param top - The top value of the bounds
   * @param bottom - The bottom value of the bounds
   * @returns This bounds object for chaining
   * @see {@link Bounds#fit} For fitting to Rectangle
   * @see {@link Bounds#addBoundsMask} For intersection
   */
  fitBounds(e, t, s, r) {
    return this.minX < e && (this.minX = e), this.maxX > t && (this.maxX = t), this.minY < s && (this.minY = s), this.maxY > r && (this.maxY = r), this;
  }
  /**
   * Pads bounds object, making it grow in all directions.
   * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Add equal padding
   * bounds.pad(10);
   * // bounds are now (-10, -10, 110, 110)
   *
   * // Add different padding for x and y
   * bounds.pad(20, 10);
   * // bounds are now (-30, -20, 130, 120)
   * ```
   * @param paddingX - The horizontal padding amount
   * @param paddingY - The vertical padding amount
   * @returns This bounds object for chaining
   * @see {@link Bounds#fit} For constraining bounds
   * @see {@link Bounds#scale} For uniform scaling
   */
  pad(e, t = e) {
    return this.minX -= e, this.maxX += e, this.minY -= t, this.maxY += t, this;
  }
  /**
   * Ceils the bounds by rounding up max values and rounding down min values.
   * Useful for pixel-perfect calculations and avoiding fractional pixels.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * bounds.set(10.2, 10.9, 50.1, 50.8);
   *
   * // Round to whole pixels
   * bounds.ceil();
   * // bounds are now (10, 10, 51, 51)
   * ```
   * @returns This bounds object for chaining
   * @see {@link Bounds#scale} For size adjustments
   * @see {@link Bounds#fit} For constraining bounds
   */
  ceil() {
    return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this;
  }
  /**
   * Creates a new Bounds instance with the same values.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Create a copy
   * const copy = bounds.clone();
   *
   * // Original and copy are independent
   * bounds.pad(10);
   * console.log(copy.width === bounds.width); // false
   * ```
   * @returns A new Bounds instance with the same values
   * @see {@link Bounds#copyFrom} For reusing existing bounds
   */
  clone() {
    return new it(this.minX, this.minY, this.maxX, this.maxY);
  }
  /**
   * Scales the bounds by the given values, adjusting all edges proportionally.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   *
   * // Scale uniformly
   * bounds.scale(2);
   * // bounds are now (0, 0, 200, 200)
   *
   * // Scale non-uniformly
   * bounds.scale(0.5, 2);
   * // bounds are now (0, 0, 100, 400)
   * ```
   * @param x - The X value to scale by
   * @param y - The Y value to scale by (defaults to x)
   * @returns This bounds object for chaining
   * @see {@link Bounds#pad} For adding padding
   * @see {@link Bounds#fit} For constraining size
   */
  scale(e, t = e) {
    return this.minX *= e, this.minY *= t, this.maxX *= e, this.maxY *= t, this;
  }
  /**
   * The x position of the bounds in local space.
   * Setting this value will move the bounds while maintaining its width.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get x position
   * console.log(bounds.x); // 0
   *
   * // Move bounds horizontally
   * bounds.x = 50;
   * console.log(bounds.minX, bounds.maxX); // 50, 150
   *
   * // Width stays the same
   * console.log(bounds.width); // Still 100
   * ```
   */
  get x() {
    return this.minX;
  }
  set x(e) {
    const t = this.maxX - this.minX;
    this.minX = e, this.maxX = e + t;
  }
  /**
   * The y position of the bounds in local space.
   * Setting this value will move the bounds while maintaining its height.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get y position
   * console.log(bounds.y); // 0
   *
   * // Move bounds vertically
   * bounds.y = 50;
   * console.log(bounds.minY, bounds.maxY); // 50, 150
   *
   * // Height stays the same
   * console.log(bounds.height); // Still 100
   * ```
   */
  get y() {
    return this.minY;
  }
  set y(e) {
    const t = this.maxY - this.minY;
    this.minY = e, this.maxY = e + t;
  }
  /**
   * The width value of the bounds.
   * Represents the distance between minX and maxX coordinates.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get width
   * console.log(bounds.width); // 100
   * // Resize width
   * bounds.width = 200;
   * console.log(bounds.maxX - bounds.minX); // 200
   * ```
   */
  get width() {
    return this.maxX - this.minX;
  }
  set width(e) {
    this.maxX = this.minX + e;
  }
  /**
   * The height value of the bounds.
   * Represents the distance between minY and maxY coordinates.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Get height
   * console.log(bounds.height); // 100
   * // Resize height
   * bounds.height = 150;
   * console.log(bounds.maxY - bounds.minY); // 150
   * ```
   */
  get height() {
    return this.maxY - this.minY;
  }
  set height(e) {
    this.maxY = this.minY + e;
  }
  /**
   * The left edge coordinate of the bounds.
   * Alias for minX.
   * @example
   * ```ts
   * const bounds = new Bounds(50, 0, 150, 100);
   * console.log(bounds.left); // 50
   * console.log(bounds.left === bounds.minX); // true
   * ```
   * @readonly
   */
  get left() {
    return this.minX;
  }
  /**
   * The right edge coordinate of the bounds.
   * Alias for maxX.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * console.log(bounds.right); // 100
   * console.log(bounds.right === bounds.maxX); // true
   * ```
   * @readonly
   */
  get right() {
    return this.maxX;
  }
  /**
   * The top edge coordinate of the bounds.
   * Alias for minY.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 25, 100, 125);
   * console.log(bounds.top); // 25
   * console.log(bounds.top === bounds.minY); // true
   * ```
   * @readonly
   */
  get top() {
    return this.minY;
  }
  /**
   * The bottom edge coordinate of the bounds.
   * Alias for maxY.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 200);
   * console.log(bounds.bottom); // 200
   * console.log(bounds.bottom === bounds.maxY); // true
   * ```
   * @readonly
   */
  get bottom() {
    return this.maxY;
  }
  /**
   * Whether the bounds has positive width and height.
   * Checks if both dimensions are greater than zero.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Check if bounds are positive
   * console.log(bounds.isPositive); // true
   *
   * // Negative bounds
   * bounds.maxX = bounds.minX;
   * console.log(bounds.isPositive); // false, width is 0
   * ```
   * @readonly
   * @see {@link Bounds#isEmpty} For checking empty state
   * @see {@link Bounds#isValid} For checking validity
   */
  get isPositive() {
    return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
  }
  /**
   * Whether the bounds has valid coordinates.
   * Checks if the bounds has been initialized with real values.
   * @example
   * ```ts
   * const bounds = new Bounds();
   * console.log(bounds.isValid); // false, default state
   *
   * // Set valid bounds
   * bounds.addFrame(0, 0, 100, 100);
   * console.log(bounds.isValid); // true
   * ```
   * @readonly
   * @see {@link Bounds#isEmpty} For checking empty state
   * @see {@link Bounds#isPositive} For checking dimensions
   */
  get isValid() {
    return this.minX + this.minY !== 1 / 0;
  }
  /**
   * Adds vertices from a Float32Array to the bounds, optionally transformed by a matrix.
   * Used for efficiently updating bounds from raw vertex data.
   * @example
   * ```ts
   * const bounds = new Bounds();
   *
   * // Add vertices from geometry
   * const vertices = new Float32Array([
   *     0, 0,    // Vertex 1
   *     100, 0,  // Vertex 2
   *     100, 100 // Vertex 3
   * ]);
   * bounds.addVertexData(vertices, 0, 6);
   *
   * // Add transformed vertices
   * const matrix = new Matrix()
   *     .translate(50, 50)
   *     .rotate(Math.PI / 4);
   * bounds.addVertexData(vertices, 0, 6, matrix);
   *
   * // Add subset of vertices
   * bounds.addVertexData(vertices, 2, 4); // Only second vertex
   * ```
   * @param vertexData - The array of vertices to add
   * @param beginOffset - Starting index in the vertex array
   * @param endOffset - Ending index in the vertex array (excluded)
   * @param matrix - Optional transformation matrix
   * @see {@link Bounds#addFrame} For adding rectangular frames
   * @see {@link Matrix} For transformation details
   */
  addVertexData(e, t, s, r) {
    let n = this.minX, o = this.minY, a = this.maxX, l = this.maxY;
    r || (r = this.matrix);
    const c = r.a, h = r.b, u = r.c, d = r.d, f = r.tx, m = r.ty;
    for (let g = t; g < s; g += 2) {
      const p = e[g], x = e[g + 1], y = c * p + u * x + f, v = h * p + d * x + m;
      n = y < n ? y : n, o = v < o ? v : o, a = y > a ? y : a, l = v > l ? v : l;
    }
    this.minX = n, this.minY = o, this.maxX = a, this.maxY = l;
  }
  /**
   * Checks if a point is contained within the bounds.
   * Returns true if the point's coordinates fall within the bounds' area.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * // Basic point check
   * console.log(bounds.containsPoint(50, 50)); // true
   * console.log(bounds.containsPoint(150, 150)); // false
   *
   * // Check edges
   * console.log(bounds.containsPoint(0, 0));   // true, includes edges
   * console.log(bounds.containsPoint(100, 100)); // true, includes edges
   * ```
   * @param x - x coordinate to check
   * @param y - y coordinate to check
   * @returns True if the point is inside the bounds
   * @see {@link Bounds#isPositive} For valid bounds check
   * @see {@link Bounds#rectangle} For Rectangle representation
   */
  containsPoint(e, t) {
    return this.minX <= e && this.minY <= t && this.maxX >= e && this.maxY >= t;
  }
  /**
   * Returns a string representation of the bounds.
   * Useful for debugging and logging bounds information.
   * @example
   * ```ts
   * const bounds = new Bounds(0, 0, 100, 100);
   * console.log(bounds.toString()); // "[pixi.js:Bounds minX=0 minY=0 maxX=100 maxY=100 width=100 height=100]"
   * ```
   * @returns A string describing the bounds
   * @see {@link Bounds#copyFrom} For copying bounds
   * @see {@link Bounds#clone} For creating a new instance
   */
  toString() {
    return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
  }
  /**
   * Copies the bounds from another bounds object.
   * Useful for reusing bounds objects and avoiding allocations.
   * @example
   * ```ts
   * const sourceBounds = new Bounds(0, 0, 100, 100);
   * // Copy bounds
   * const targetBounds = new Bounds();
   * targetBounds.copyFrom(sourceBounds);
   * ```
   * @param bounds - The bounds to copy from
   * @returns This bounds object for chaining
   * @see {@link Bounds#clone} For creating new instances
   */
  copyFrom(e) {
    return this.minX = e.minX, this.minY = e.minY, this.maxX = e.maxX, this.maxY = e.maxY, this;
  }
}
var Bb = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) }, mt = function(i) {
  return typeof i == "string" ? i.length > 0 : typeof i == "number";
}, Te = function(i, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = Math.pow(10, e)), Math.round(t * i) / t + 0;
}, Ye = function(i, e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = 1), i > t ? t : i > e ? i : e;
}, wp = function(i) {
  return (i = isFinite(i) ? i % 360 : 0) > 0 ? i : i + 360;
}, Gu = function(i) {
  return { r: Ye(i.r, 0, 255), g: Ye(i.g, 0, 255), b: Ye(i.b, 0, 255), a: Ye(i.a) };
}, zc = function(i) {
  return { r: Te(i.r), g: Te(i.g), b: Te(i.b), a: Te(i.a, 3) };
}, zb = /^#([0-9a-f]{3,8})$/i, xs = function(i) {
  var e = i.toString(16);
  return e.length < 2 ? "0" + e : e;
}, Tp = function(i) {
  var e = i.r, t = i.g, s = i.b, r = i.a, n = Math.max(e, t, s), o = n - Math.min(e, t, s), a = o ? n === e ? (t - s) / o : n === t ? 2 + (s - e) / o : 4 + (e - t) / o : 0;
  return { h: 60 * (a < 0 ? a + 6 : a), s: n ? o / n * 100 : 0, v: n / 255 * 100, a: r };
}, Sp = function(i) {
  var e = i.h, t = i.s, s = i.v, r = i.a;
  e = e / 360 * 6, t /= 100, s /= 100;
  var n = Math.floor(e), o = s * (1 - t), a = s * (1 - (e - n) * t), l = s * (1 - (1 - e + n) * t), c = n % 6;
  return { r: 255 * [s, a, o, o, l, s][c], g: 255 * [l, s, s, a, o, o][c], b: 255 * [o, o, l, s, s, a][c], a: r };
}, Hu = function(i) {
  return { h: wp(i.h), s: Ye(i.s, 0, 100), l: Ye(i.l, 0, 100), a: Ye(i.a) };
}, Wu = function(i) {
  return { h: Te(i.h), s: Te(i.s), l: Te(i.l), a: Te(i.a, 3) };
}, Vu = function(i) {
  return Sp((t = (e = i).s, { h: e.h, s: (t *= ((s = e.l) < 50 ? s : 100 - s) / 100) > 0 ? 2 * t / (s + t) * 100 : 0, v: s + t, a: e.a }));
  var e, t, s;
}, Yi = function(i) {
  return { h: (e = Tp(i)).h, s: (r = (200 - (t = e.s)) * (s = e.v) / 100) > 0 && r < 200 ? t * s / 100 / (r <= 100 ? r : 200 - r) * 100 : 0, l: r / 2, a: e.a };
  var e, t, s, r;
}, Ob = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Db = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Lb = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Nb = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i, Fh = { string: [[function(i) {
  var e = zb.exec(i);
  return e ? (i = e[1]).length <= 4 ? { r: parseInt(i[0] + i[0], 16), g: parseInt(i[1] + i[1], 16), b: parseInt(i[2] + i[2], 16), a: i.length === 4 ? Te(parseInt(i[3] + i[3], 16) / 255, 2) : 1 } : i.length === 6 || i.length === 8 ? { r: parseInt(i.substr(0, 2), 16), g: parseInt(i.substr(2, 2), 16), b: parseInt(i.substr(4, 2), 16), a: i.length === 8 ? Te(parseInt(i.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
}, "hex"], [function(i) {
  var e = Lb.exec(i) || Nb.exec(i);
  return e ? e[2] !== e[4] || e[4] !== e[6] ? null : Gu({ r: Number(e[1]) / (e[2] ? 100 / 255 : 1), g: Number(e[3]) / (e[4] ? 100 / 255 : 1), b: Number(e[5]) / (e[6] ? 100 / 255 : 1), a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1) }) : null;
}, "rgb"], [function(i) {
  var e = Ob.exec(i) || Db.exec(i);
  if (!e) return null;
  var t, s, r = Hu({ h: (t = e[1], s = e[2], s === void 0 && (s = "deg"), Number(t) * (Bb[s] || 1)), s: Number(e[3]), l: Number(e[4]), a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1) });
  return Vu(r);
}, "hsl"]], object: [[function(i) {
  var e = i.r, t = i.g, s = i.b, r = i.a, n = r === void 0 ? 1 : r;
  return mt(e) && mt(t) && mt(s) ? Gu({ r: Number(e), g: Number(t), b: Number(s), a: Number(n) }) : null;
}, "rgb"], [function(i) {
  var e = i.h, t = i.s, s = i.l, r = i.a, n = r === void 0 ? 1 : r;
  if (!mt(e) || !mt(t) || !mt(s)) return null;
  var o = Hu({ h: Number(e), s: Number(t), l: Number(s), a: Number(n) });
  return Vu(o);
}, "hsl"], [function(i) {
  var e = i.h, t = i.s, s = i.v, r = i.a, n = r === void 0 ? 1 : r;
  if (!mt(e) || !mt(t) || !mt(s)) return null;
  var o = (function(a) {
    return { h: wp(a.h), s: Ye(a.s, 0, 100), v: Ye(a.v, 0, 100), a: Ye(a.a) };
  })({ h: Number(e), s: Number(t), v: Number(s), a: Number(n) });
  return Sp(o);
}, "hsv"]] }, $u = function(i, e) {
  for (var t = 0; t < e.length; t++) {
    var s = e[t][0](i);
    if (s) return [s, e[t][1]];
  }
  return [null, void 0];
}, Gb = function(i) {
  return typeof i == "string" ? $u(i.trim(), Fh.string) : typeof i == "object" && i !== null ? $u(i, Fh.object) : [null, void 0];
}, Oc = function(i, e) {
  var t = Yi(i);
  return { h: t.h, s: Ye(t.s + 100 * e, 0, 100), l: t.l, a: t.a };
}, Dc = function(i) {
  return (299 * i.r + 587 * i.g + 114 * i.b) / 1e3 / 255;
}, Yu = function(i, e) {
  var t = Yi(i);
  return { h: t.h, s: t.s, l: Ye(t.l + 100 * e, 0, 100), a: t.a };
}, Mh = (function() {
  function i(e) {
    this.parsed = Gb(e)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
  }
  return i.prototype.isValid = function() {
    return this.parsed !== null;
  }, i.prototype.brightness = function() {
    return Te(Dc(this.rgba), 2);
  }, i.prototype.isDark = function() {
    return Dc(this.rgba) < 0.5;
  }, i.prototype.isLight = function() {
    return Dc(this.rgba) >= 0.5;
  }, i.prototype.toHex = function() {
    return e = zc(this.rgba), t = e.r, s = e.g, r = e.b, o = (n = e.a) < 1 ? xs(Te(255 * n)) : "", "#" + xs(t) + xs(s) + xs(r) + o;
    var e, t, s, r, n, o;
  }, i.prototype.toRgb = function() {
    return zc(this.rgba);
  }, i.prototype.toRgbString = function() {
    return e = zc(this.rgba), t = e.r, s = e.g, r = e.b, (n = e.a) < 1 ? "rgba(" + t + ", " + s + ", " + r + ", " + n + ")" : "rgb(" + t + ", " + s + ", " + r + ")";
    var e, t, s, r, n;
  }, i.prototype.toHsl = function() {
    return Wu(Yi(this.rgba));
  }, i.prototype.toHslString = function() {
    return e = Wu(Yi(this.rgba)), t = e.h, s = e.s, r = e.l, (n = e.a) < 1 ? "hsla(" + t + ", " + s + "%, " + r + "%, " + n + ")" : "hsl(" + t + ", " + s + "%, " + r + "%)";
    var e, t, s, r, n;
  }, i.prototype.toHsv = function() {
    return e = Tp(this.rgba), { h: Te(e.h), s: Te(e.s), v: Te(e.v), a: Te(e.a, 3) };
    var e;
  }, i.prototype.invert = function() {
    return ht({ r: 255 - (e = this.rgba).r, g: 255 - e.g, b: 255 - e.b, a: e.a });
    var e;
  }, i.prototype.saturate = function(e) {
    return e === void 0 && (e = 0.1), ht(Oc(this.rgba, e));
  }, i.prototype.desaturate = function(e) {
    return e === void 0 && (e = 0.1), ht(Oc(this.rgba, -e));
  }, i.prototype.grayscale = function() {
    return ht(Oc(this.rgba, -1));
  }, i.prototype.lighten = function(e) {
    return e === void 0 && (e = 0.1), ht(Yu(this.rgba, e));
  }, i.prototype.darken = function(e) {
    return e === void 0 && (e = 0.1), ht(Yu(this.rgba, -e));
  }, i.prototype.rotate = function(e) {
    return e === void 0 && (e = 15), this.hue(this.hue() + e);
  }, i.prototype.alpha = function(e) {
    return typeof e == "number" ? ht({ r: (t = this.rgba).r, g: t.g, b: t.b, a: e }) : Te(this.rgba.a, 3);
    var t;
  }, i.prototype.hue = function(e) {
    var t = Yi(this.rgba);
    return typeof e == "number" ? ht({ h: e, s: t.s, l: t.l, a: t.a }) : Te(t.h);
  }, i.prototype.isEqual = function(e) {
    return this.toHex() === ht(e).toHex();
  }, i;
})(), ht = function(i) {
  return i instanceof Mh ? i : new Mh(i);
}, Xu = [], Hb = function(i) {
  i.forEach(function(e) {
    Xu.indexOf(e) < 0 && (e(Mh, Fh), Xu.push(e));
  });
};
function Wb(i, e) {
  var t = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, s = {};
  for (var r in t) s[t[r]] = r;
  var n = {};
  i.prototype.toName = function(o) {
    if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
    var a, l, c = s[this.toHex()];
    if (c) return c;
    if (o?.closest) {
      var h = this.toRgb(), u = 1 / 0, d = "black";
      if (!n.length) for (var f in t) n[f] = new i(t[f]).toRgb();
      for (var m in t) {
        var g = (a = h, l = n[m], Math.pow(a.r - l.r, 2) + Math.pow(a.g - l.g, 2) + Math.pow(a.b - l.b, 2));
        g < u && (u = g, d = m);
      }
      return d;
    }
  }, e.string.push([function(o) {
    var a = o.toLowerCase(), l = a === "transparent" ? "#0000" : t[a];
    return l ? new i(l).toRgb() : null;
  }, "name"]);
}
Hb([Wb]);
const ui = class Bi {
  /**
   * @param {ColorSource} value - Optional value to use, if not provided, white is used.
   */
  constructor(e = 16777215) {
    this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = e;
  }
  /**
   * Get the red component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('red');
   * console.log(color.red); // 1
   *
   * const green = new Color('#00ff00');
   * console.log(green.red); // 0
   * ```
   */
  get red() {
    return this._components[0];
  }
  /**
   * Get the green component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('lime');
   * console.log(color.green); // 1
   *
   * const red = new Color('#ff0000');
   * console.log(red.green); // 0
   * ```
   */
  get green() {
    return this._components[1];
  }
  /**
   * Get the blue component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('blue');
   * console.log(color.blue); // 1
   *
   * const yellow = new Color('#ffff00');
   * console.log(yellow.blue); // 0
   * ```
   */
  get blue() {
    return this._components[2];
  }
  /**
   * Get the alpha component of the color, normalized between 0 and 1.
   * @example
   * ```ts
   * const color = new Color('red');
   * console.log(color.alpha); // 1 (fully opaque)
   *
   * const transparent = new Color('rgba(255, 0, 0, 0.5)');
   * console.log(transparent.alpha); // 0.5 (semi-transparent)
   * ```
   */
  get alpha() {
    return this._components[3];
  }
  /**
   * Sets the color value and returns the instance for chaining.
   *
   * This is a chainable version of setting the `value` property.
   * @param value - The color to set. Accepts various formats:
   * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)
   * - RGB/RGBA values (arrays, objects)
   * - CSS color names
   * - HSL/HSLA values
   * - HSV/HSVA values
   * @returns The Color instance for chaining
   * @example
   * ```ts
   * // Basic usage
   * const color = new Color();
   * color.setValue('#ff0000')
   *     .setAlpha(0.5)
   *     .premultiply(0.8);
   *
   * // Different formats
   * color.setValue(0xff0000);          // Hex number
   * color.setValue('#ff0000');         // Hex string
   * color.setValue([1, 0, 0]);         // RGB array
   * color.setValue([1, 0, 0, 0.5]);    // RGBA array
   * color.setValue({ r: 1, g: 0, b: 0 }); // RGB object
   *
   * // Copy from another color
   * const red = new Color('red');
   * color.setValue(red);
   * ```
   * @throws {Error} If the color value is invalid or null
   * @see {@link Color.value} For the underlying value property
   */
  setValue(e) {
    return this.value = e, this;
  }
  /**
   * The current color source. This property allows getting and setting the color value
   * while preserving the original format where possible.
   * @remarks
   * When setting:
   * - Setting to a `Color` instance copies its source and components
   * - Setting to other valid sources normalizes and stores the value
   * - Setting to `null` throws an Error
   * - The color remains unchanged if normalization fails
   *
   * When getting:
   * - Returns `null` if color was modified by {@link Color.multiply} or {@link Color.premultiply}
   * - Otherwise returns the original color source
   * @example
   * ```ts
   * // Setting different color formats
   * const color = new Color();
   *
   * color.value = 0xff0000;         // Hex number
   * color.value = '#ff0000';        // Hex string
   * color.value = [1, 0, 0];        // RGB array
   * color.value = [1, 0, 0, 0.5];   // RGBA array
   * color.value = { r: 1, g: 0, b: 0 }; // RGB object
   *
   * // Copying from another color
   * const red = new Color('red');
   * color.value = red;  // Copies red's components
   *
   * // Getting the value
   * console.log(color.value);  // Returns original format
   *
   * // After modifications
   * color.multiply([0.5, 0.5, 0.5]);
   * console.log(color.value);  // Returns null
   * ```
   * @throws {Error} When attempting to set `null`
   */
  set value(e) {
    if (e instanceof Bi)
      this._value = this._cloneSource(e._value), this._int = e._int, this._components.set(e._components);
    else {
      if (e === null)
        throw new Error("Cannot set Color#value to null");
      (this._value === null || !this._isSourceEqual(this._value, e)) && (this._value = this._cloneSource(e), this._normalize(this._value));
    }
  }
  get value() {
    return this._value;
  }
  /**
   * Copy a color source internally.
   * @param value - Color source
   */
  _cloneSource(e) {
    return typeof e == "string" || typeof e == "number" || e instanceof Number || e === null ? e : Array.isArray(e) || ArrayBuffer.isView(e) ? e.slice(0) : typeof e == "object" && e !== null ? { ...e } : e;
  }
  /**
   * Equality check for color sources.
   * @param value1 - First color source
   * @param value2 - Second color source
   * @returns `true` if the color sources are equal, `false` otherwise.
   */
  _isSourceEqual(e, t) {
    const s = typeof e;
    if (s !== typeof t)
      return !1;
    if (s === "number" || s === "string" || e instanceof Number)
      return e === t;
    if (Array.isArray(e) && Array.isArray(t) || ArrayBuffer.isView(e) && ArrayBuffer.isView(t))
      return e.length !== t.length ? !1 : e.every((n, o) => n === t[o]);
    if (e !== null && t !== null) {
      const n = Object.keys(e), o = Object.keys(t);
      return n.length !== o.length ? !1 : n.every((a) => e[a] === t[a]);
    }
    return e === t;
  }
  /**
   * Convert to a RGBA color object with normalized components (0-1).
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert colors to RGBA objects
   * new Color('white').toRgba();     // returns { r: 1, g: 1, b: 1, a: 1 }
   * new Color('#ff0000').toRgba();   // returns { r: 1, g: 0, b: 0, a: 1 }
   *
   * // With transparency
   * new Color('rgba(255,0,0,0.5)').toRgba(); // returns { r: 1, g: 0, b: 0, a: 0.5 }
   * ```
   * @returns An RGBA object with normalized components
   */
  toRgba() {
    const [e, t, s, r] = this._components;
    return { r: e, g: t, b: s, a: r };
  }
  /**
   * Convert to a RGB color object with normalized components (0-1).
   *
   * Alpha component is omitted in the output.
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert colors to RGB objects
   * new Color('white').toRgb();     // returns { r: 1, g: 1, b: 1 }
   * new Color('#ff0000').toRgb();   // returns { r: 1, g: 0, b: 0 }
   *
   * // Alpha is ignored
   * new Color('rgba(255,0,0,0.5)').toRgb(); // returns { r: 1, g: 0, b: 0 }
   * ```
   * @returns An RGB object with normalized components
   */
  toRgb() {
    const [e, t, s] = this._components;
    return { r: e, g: t, b: s };
  }
  /**
   * Convert to a CSS-style rgba string representation.
   *
   * RGB components are scaled to 0-255 range, alpha remains 0-1.
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert colors to RGBA strings
   * new Color('white').toRgbaString();     // returns "rgba(255,255,255,1)"
   * new Color('#ff0000').toRgbaString();   // returns "rgba(255,0,0,1)"
   *
   * // With transparency
   * new Color([1, 0, 0, 0.5]).toRgbaString(); // returns "rgba(255,0,0,0.5)"
   * ```
   * @returns A CSS-compatible rgba string
   */
  toRgbaString() {
    const [e, t, s] = this.toUint8RgbArray();
    return `rgba(${e},${t},${s},${this.alpha})`;
  }
  /**
   * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).
   * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Optional output array. If not provided,
   * a cached array will be used and returned.
   * @returns Array containing RGB components as integers between 0-255
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]
   * new Color('#ff0000').toUint8RgbArray(); // returns [255, 0, 0]
   *
   * // Using custom output array
   * const rgb = new Uint8Array(3);
   * new Color('blue').toUint8RgbArray(rgb); // rgb is now [0, 0, 255]
   *
   * // Using different array types
   * new Color('red').toUint8RgbArray(new Uint8ClampedArray(3)); // [255, 0, 0]
   * new Color('red').toUint8RgbArray([]); // [255, 0, 0]
   * ```
   * @remarks
   * - Output values are always clamped between 0-255
   * - Alpha component is not included in output
   * - Reuses internal cache array if no output array provided
   */
  toUint8RgbArray(e) {
    const [t, s, r] = this._components;
    return this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb), e[0] = Math.round(t * 255), e[1] = Math.round(s * 255), e[2] = Math.round(r * 255), e;
  }
  /**
   * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).
   * @param {number[]|Float32Array} [out] - Optional output array. If not provided,
   * a cached array will be used and returned.
   * @returns Array containing RGBA components as floats between 0-1
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toArray();  // returns [1, 1, 1, 1]
   * new Color('red').toArray();    // returns [1, 0, 0, 1]
   *
   * // With alpha
   * new Color('rgba(255,0,0,0.5)').toArray(); // returns [1, 0, 0, 0.5]
   *
   * // Using custom output array
   * const rgba = new Float32Array(4);
   * new Color('blue').toArray(rgba); // rgba is now [0, 0, 1, 1]
   * ```
   * @remarks
   * - Output values are normalized between 0-1
   * - Includes alpha component as the fourth value
   * - Reuses internal cache array if no output array provided
   */
  toArray(e) {
    this._arrayRgba || (this._arrayRgba = []), e || (e = this._arrayRgba);
    const [t, s, r, n] = this._components;
    return e[0] = t, e[1] = s, e[2] = r, e[3] = n, e;
  }
  /**
   * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).
   * @param {number[]|Float32Array} [out] - Optional output array. If not provided,
   * a cached array will be used and returned.
   * @returns Array containing RGB components as floats between 0-1
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toRgbArray(); // returns [1, 1, 1]
   * new Color('red').toRgbArray();   // returns [1, 0, 0]
   *
   * // Using custom output array
   * const rgb = new Float32Array(3);
   * new Color('blue').toRgbArray(rgb); // rgb is now [0, 0, 1]
   * ```
   * @remarks
   * - Output values are normalized between 0-1
   * - Alpha component is omitted from output
   * - Reuses internal cache array if no output array provided
   */
  toRgbArray(e) {
    this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb);
    const [t, s, r] = this._components;
    return e[0] = t, e[1] = s, e[2] = r, e;
  }
  /**
   * Convert to a hexadecimal number.
   * @returns The color as a 24-bit RGB integer
   * @example
   * ```ts
   * // Basic usage
   * new Color('white').toNumber(); // returns 0xffffff
   * new Color('red').toNumber();   // returns 0xff0000
   *
   * // Store as hex
   * const color = new Color('blue');
   * const hex = color.toNumber(); // 0x0000ff
   * ```
   */
  toNumber() {
    return this._int;
  }
  /**
   * Convert to a BGR number.
   *
   * Useful for platforms that expect colors in BGR format.
   * @returns The color as a 24-bit BGR integer
   * @example
   * ```ts
   * // Convert RGB to BGR
   * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff
   *
   * // Common use case: platform-specific color format
   * const color = new Color('orange');
   * const bgrColor = color.toBgrNumber(); // Color with swapped R/B channels
   * ```
   * @remarks
   * This swaps the red and blue channels compared to the normal RGB format:
   * - RGB 0xRRGGBB becomes BGR 0xBBGGRR
   */
  toBgrNumber() {
    const [e, t, s] = this.toUint8RgbArray();
    return (s << 16) + (t << 8) + e;
  }
  /**
   * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).
   *
   * Useful for platforms that expect colors in little endian byte order.
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Convert RGB color to little endian format
   * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff
   *
   * // Common use cases:
   * const color = new Color('orange');
   * const leColor = color.toLittleEndianNumber(); // Swaps byte order for LE systems
   *
   * // Multiple conversions
   * const colors = {
   *     normal: 0xffcc99,
   *     littleEndian: new Color(0xffcc99).toLittleEndianNumber(), // 0x99ccff
   *     backToNormal: new Color(0x99ccff).toLittleEndianNumber()  // 0xffcc99
   * };
   * ```
   * @remarks
   * - Swaps R and B channels in the color value
   * - RGB 0xRRGGBB becomes 0xBBGGRR
   * - Useful for systems that use little endian byte order
   * - Can be used to convert back and forth between formats
   * @returns The color as a number in little endian format (BBGGRR)
   * @see {@link Color.toBgrNumber} For BGR format without byte swapping
   */
  toLittleEndianNumber() {
    const e = this._int;
    return (e >> 16) + (e & 65280) + ((e & 255) << 16);
  }
  /**
   * Multiply with another color.
   *
   * This action is destructive and modifies the original color.
   * @param {ColorSource} value - The color to multiply by. Accepts any valid color format:
   * - Hex strings/numbers (e.g., '#ff0000', 0xff0000)
   * - RGB/RGBA arrays ([1, 0, 0], [1, 0, 0, 1])
   * - Color objects ({ r: 1, g: 0, b: 0 })
   * - CSS color names ('red', 'blue')
   * @returns this - The Color instance for chaining
   * @example
   * ```ts
   * // Basic multiplication
   * const color = new Color('#ff0000');
   * color.multiply(0x808080); // 50% darker red
   *
   * // With transparency
   * color.multiply([1, 1, 1, 0.5]); // 50% transparent
   *
   * // Chain operations
   * color
   *     .multiply('#808080')
   *     .multiply({ r: 1, g: 1, b: 1, a: 0.5 });
   * ```
   * @remarks
   * - Multiplies each RGB component and alpha separately
   * - Values are clamped between 0-1
   * - Original color format is lost (value becomes null)
   * - Operation cannot be undone
   */
  multiply(e) {
    const [t, s, r, n] = Bi._temp.setValue(e)._components;
    return this._components[0] *= t, this._components[1] *= s, this._components[2] *= r, this._components[3] *= n, this._refreshInt(), this._value = null, this;
  }
  /**
   * Converts color to a premultiplied alpha format.
   *
   * This action is destructive and modifies the original color.
   * @param alpha - The alpha value to multiply by (0-1)
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels
   * @returns {Color} The Color instance for chaining
   * @example
   * ```ts
   * // Basic premultiplication
   * const color = new Color('red');
   * color.premultiply(0.5); // 50% transparent red with premultiplied RGB
   *
   * // Alpha only (RGB unchanged)
   * color.premultiply(0.5, false); // 50% transparent, original RGB
   *
   * // Chain with other operations
   * color
   *     .multiply(0x808080)
   *     .premultiply(0.5)
   *     .toNumber();
   * ```
   * @remarks
   * - RGB channels are multiplied by alpha when applyToRGB is true
   * - Alpha is always set to the provided value
   * - Values are clamped between 0-1
   * - Original color format is lost (value becomes null)
   * - Operation cannot be undone
   */
  premultiply(e, t = !0) {
    return t && (this._components[0] *= e, this._components[1] *= e, this._components[2] *= e), this._components[3] = e, this._refreshInt(), this._value = null, this;
  }
  /**
   * Returns the color as a 32-bit premultiplied alpha integer.
   *
   * Format: 0xAARRGGBB
   * @param {number} alpha - The alpha value to multiply by (0-1)
   * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels
   * @returns {number} The premultiplied color as a 32-bit integer
   * @example
   * ```ts
   * // Convert to premultiplied format
   * const color = new Color('red');
   *
   * // Full opacity (0xFFRRGGBB)
   * color.toPremultiplied(1.0); // 0xFFFF0000
   *
   * // 50% transparency with premultiplied RGB
   * color.toPremultiplied(0.5); // 0x7F7F0000
   *
   * // 50% transparency without RGB premultiplication
   * color.toPremultiplied(0.5, false); // 0x7FFF0000
   * ```
   * @remarks
   * - Returns full opacity (0xFF000000) when alpha is 1.0
   * - Returns 0 when alpha is 0.0 and applyToRGB is true
   * - RGB values are rounded during premultiplication
   */
  toPremultiplied(e, t = !0) {
    if (e === 1)
      return (255 << 24) + this._int;
    if (e === 0)
      return t ? 0 : this._int;
    let s = this._int >> 16 & 255, r = this._int >> 8 & 255, n = this._int & 255;
    return t && (s = s * e + 0.5 | 0, r = r * e + 0.5 | 0, n = n * e + 0.5 | 0), (e * 255 << 24) + (s << 16) + (r << 8) + n;
  }
  /**
   * Convert to a hexadecimal string (6 characters).
   * @returns A CSS-compatible hex color string (e.g., "#ff0000")
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Basic colors
   * new Color('red').toHex();    // returns "#ff0000"
   * new Color('white').toHex();  // returns "#ffffff"
   * new Color('black').toHex();  // returns "#000000"
   *
   * // From different formats
   * new Color(0xff0000).toHex(); // returns "#ff0000"
   * new Color([1, 0, 0]).toHex(); // returns "#ff0000"
   * new Color({ r: 1, g: 0, b: 0 }).toHex(); // returns "#ff0000"
   * ```
   * @remarks
   * - Always returns a 6-character hex string
   * - Includes leading "#" character
   * - Alpha channel is ignored
   * - Values are rounded to nearest hex value
   */
  toHex() {
    const e = this._int.toString(16);
    return `#${"000000".substring(0, 6 - e.length) + e}`;
  }
  /**
   * Convert to a hexadecimal string with alpha (8 characters).
   * @returns A CSS-compatible hex color string with alpha (e.g., "#ff0000ff")
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // Fully opaque colors
   * new Color('red').toHexa();   // returns "#ff0000ff"
   * new Color('white').toHexa(); // returns "#ffffffff"
   *
   * // With transparency
   * new Color('rgba(255, 0, 0, 0.5)').toHexa(); // returns "#ff00007f"
   * new Color([1, 0, 0, 0]).toHexa(); // returns "#ff000000"
   * ```
   * @remarks
   * - Returns an 8-character hex string
   * - Includes leading "#" character
   * - Alpha is encoded in last two characters
   * - Values are rounded to nearest hex value
   */
  toHexa() {
    const t = Math.round(this._components[3] * 255).toString(16);
    return this.toHex() + "00".substring(0, 2 - t.length) + t;
  }
  /**
   * Set alpha (transparency) value while preserving color components.
   *
   * Provides a chainable interface for setting alpha.
   * @param alpha - Alpha value between 0 (fully transparent) and 1 (fully opaque)
   * @returns The Color instance for chaining
   * @example
   * ```ts
   * // Basic alpha setting
   * const color = new Color('red');
   * color.setAlpha(0.5);  // 50% transparent red
   *
   * // Chain with other operations
   * color
   *     .setValue('#ff0000')
   *     .setAlpha(0.8)    // 80% opaque
   *     .premultiply(0.5); // Further modify alpha
   *
   * // Reset to fully opaque
   * color.setAlpha(1);
   * ```
   * @remarks
   * - Alpha value is clamped between 0-1
   * - Can be chained with other color operations
   */
  setAlpha(e) {
    return this._components[3] = this._clamp(e), this;
  }
  /**
   * Normalize the input value into rgba
   * @param value - Input value
   */
  _normalize(e) {
    let t, s, r, n;
    if ((typeof e == "number" || e instanceof Number) && e >= 0 && e <= 16777215) {
      const o = e;
      t = (o >> 16 & 255) / 255, s = (o >> 8 & 255) / 255, r = (o & 255) / 255, n = 1;
    } else if ((Array.isArray(e) || e instanceof Float32Array) && e.length >= 3 && e.length <= 4)
      e = this._clamp(e), [t, s, r, n = 1] = e;
    else if ((e instanceof Uint8Array || e instanceof Uint8ClampedArray) && e.length >= 3 && e.length <= 4)
      e = this._clamp(e, 0, 255), [t, s, r, n = 255] = e, t /= 255, s /= 255, r /= 255, n /= 255;
    else if (typeof e == "string" || typeof e == "object") {
      if (typeof e == "string") {
        const a = Bi.HEX_PATTERN.exec(e);
        a && (e = `#${a[2]}`);
      }
      const o = ht(e);
      o.isValid() && ({ r: t, g: s, b: r, a: n } = o.rgba, t /= 255, s /= 255, r /= 255);
    }
    if (t !== void 0)
      this._components[0] = t, this._components[1] = s, this._components[2] = r, this._components[3] = n, this._refreshInt();
    else
      throw new Error(`Unable to convert color ${e}`);
  }
  /** Refresh the internal color rgb number */
  _refreshInt() {
    this._clamp(this._components);
    const [e, t, s] = this._components;
    this._int = (e * 255 << 16) + (t * 255 << 8) + (s * 255 | 0);
  }
  /**
   * Clamps values to a range. Will override original values
   * @param value - Value(s) to clamp
   * @param min - Minimum value
   * @param max - Maximum value
   */
  _clamp(e, t = 0, s = 1) {
    return typeof e == "number" ? Math.min(Math.max(e, t), s) : (e.forEach((r, n) => {
      e[n] = Math.min(Math.max(r, t), s);
    }), e);
  }
  /**
   * Check if a value can be interpreted as a valid color format.
   * Supports all color formats that can be used with the Color class.
   * @param value - Value to check
   * @returns True if the value can be used as a color
   * @example
   * ```ts
   * import { Color } from 'pixi.js';
   *
   * // CSS colors and hex values
   * Color.isColorLike('red');          // true
   * Color.isColorLike('#ff0000');      // true
   * Color.isColorLike(0xff0000);       // true
   *
   * // Arrays (RGB/RGBA)
   * Color.isColorLike([1, 0, 0]);      // true
   * Color.isColorLike([1, 0, 0, 0.5]); // true
   *
   * // TypedArrays
   * Color.isColorLike(new Float32Array([1, 0, 0]));          // true
   * Color.isColorLike(new Uint8Array([255, 0, 0]));          // true
   * Color.isColorLike(new Uint8ClampedArray([255, 0, 0]));   // true
   *
   * // Object formats
   * Color.isColorLike({ r: 1, g: 0, b: 0 });            // true (RGB)
   * Color.isColorLike({ r: 1, g: 0, b: 0, a: 0.5 });    // true (RGBA)
   * Color.isColorLike({ h: 0, s: 100, l: 50 });         // true (HSL)
   * Color.isColorLike({ h: 0, s: 100, l: 50, a: 0.5 }); // true (HSLA)
   * Color.isColorLike({ h: 0, s: 100, v: 100 });        // true (HSV)
   * Color.isColorLike({ h: 0, s: 100, v: 100, a: 0.5 });// true (HSVA)
   *
   * // Color instances
   * Color.isColorLike(new Color('red')); // true
   *
   * // Invalid values
   * Color.isColorLike(null);           // false
   * Color.isColorLike(undefined);      // false
   * Color.isColorLike({});             // false
   * Color.isColorLike([]);             // false
   * Color.isColorLike('not-a-color');  // false
   * ```
   * @remarks
   * Checks for the following formats:
   * - Numbers (0x000000 to 0xffffff)
   * - CSS color strings
   * - RGB/RGBA arrays and objects
   * - HSL/HSLA objects
   * - HSV/HSVA objects
   * - TypedArrays (Float32Array, Uint8Array, Uint8ClampedArray)
   * - Color instances
   * @see {@link ColorSource} For supported color format types
   * @see {@link Color.setValue} For setting color values
   * @category utility
   */
  static isColorLike(e) {
    return typeof e == "number" || typeof e == "string" || e instanceof Number || e instanceof Bi || Array.isArray(e) || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Float32Array || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 && e.a !== void 0;
  }
};
ui.shared = new ui();
ui._temp = new ui();
ui.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let pe = ui;
const Vb = {
  cullArea: null,
  cullable: !1,
  cullableChildren: !0
};
let Lc = 0;
const qu = 500;
function se(...i) {
  Lc !== qu && (Lc++, Lc === qu ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...i));
}
const os = {
  /**
   * Set of registered pools and cleanable objects.
   * @private
   */
  _registeredResources: /* @__PURE__ */ new Set(),
  /**
   * Registers a pool or cleanable object for cleanup.
   * @param {Cleanable} pool - The pool or object to register.
   */
  register(i) {
    this._registeredResources.add(i);
  },
  /**
   * Unregisters a pool or cleanable object from cleanup.
   * @param {Cleanable} pool - The pool or object to unregister.
   */
  unregister(i) {
    this._registeredResources.delete(i);
  },
  /** Clears all registered pools and cleanable objects. This will call clear() on each registered item. */
  release() {
    this._registeredResources.forEach((i) => i.clear());
  },
  /**
   * Gets the number of registered pools and cleanable objects.
   * @returns {number} The count of registered items.
   */
  get registeredCount() {
    return this._registeredResources.size;
  },
  /**
   * Checks if a specific pool or cleanable object is registered.
   * @param {Cleanable} pool - The pool or object to check.
   * @returns {boolean} True if the item is registered, false otherwise.
   */
  isRegistered(i) {
    return this._registeredResources.has(i);
  },
  /**
   * Removes all registrations without clearing the pools.
   * Useful if you want to reset the collector without affecting the pools.
   */
  reset() {
    this._registeredResources.clear();
  }
};
class $b {
  /**
   * Constructs a new Pool.
   * @param ClassType - The constructor of the items in the pool.
   * @param {number} [initialSize] - The initial size of the pool.
   */
  constructor(e, t) {
    this._pool = [], this._count = 0, this._index = 0, this._classType = e, t && this.prepopulate(t);
  }
  /**
   * Prepopulates the pool with a given number of items.
   * @param total - The number of items to add to the pool.
   */
  prepopulate(e) {
    for (let t = 0; t < e; t++)
      this._pool[this._index++] = new this._classType();
    this._count += e;
  }
  /**
   * Gets an item from the pool. Calls the item's `init` method if it exists.
   * If there are no items left in the pool, a new one will be created.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */
  get(e) {
    let t;
    return this._index > 0 ? t = this._pool[--this._index] : (t = new this._classType(), this._count++), t.init?.(e), t;
  }
  /**
   * Returns an item to the pool. Calls the item's `reset` method if it exists.
   * @param {T} item - The item to return to the pool.
   */
  return(e) {
    e.reset?.(), this._pool[this._index++] = e;
  }
  /**
   * Gets the number of items in the pool.
   * @readonly
   */
  get totalSize() {
    return this._count;
  }
  /**
   * Gets the number of items in the pool that are free to use without needing to create more.
   * @readonly
   */
  get totalFree() {
    return this._index;
  }
  /**
   * Gets the number of items in the pool that are currently in use.
   * @readonly
   */
  get totalUsed() {
    return this._count - this._index;
  }
  /** clears the pool */
  clear() {
    if (this._pool.length > 0 && this._pool[0].destroy)
      for (let e = 0; e < this._index; e++)
        this._pool[e].destroy();
    this._pool.length = 0, this._count = 0, this._index = 0;
  }
}
class Yb {
  constructor() {
    this._poolsByClass = /* @__PURE__ */ new Map();
  }
  /**
   * Prepopulates a specific pool with a given number of items.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {number} total - The number of items to add to the pool.
   */
  prepopulate(e, t) {
    this.getPool(e).prepopulate(t);
  }
  /**
   * Gets an item from a specific pool.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.
   * @param {unknown} [data] - Optional data to pass to the item's constructor.
   * @returns {T} The item from the pool.
   */
  get(e, t) {
    return this.getPool(e).get(t);
  }
  /**
   * Returns an item to its respective pool.
   * @param {PoolItem} item - The item to return to the pool.
   */
  return(e) {
    this.getPool(e.constructor).return(e);
  }
  /**
   * Gets a specific pool based on the class type.
   * @template T The type of items in the pool. Must extend PoolItem.
   * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.
   * @returns {Pool<T>} The pool of the given class type.
   */
  getPool(e) {
    return this._poolsByClass.has(e) || this._poolsByClass.set(e, new $b(e)), this._poolsByClass.get(e);
  }
  /** gets the usage stats of each pool in the system */
  stats() {
    const e = {};
    return this._poolsByClass.forEach((t) => {
      const s = e[t._classType.name] ? t._classType.name + t._classType.ID : t._classType.name;
      e[s] = {
        free: t.totalFree,
        used: t.totalUsed,
        size: t.totalSize
      };
    }), e;
  }
  /** Clears all pools in the group. This will reset all pools and free their resources. */
  clear() {
    this._poolsByClass.forEach((e) => e.clear()), this._poolsByClass.clear();
  }
}
const Xe = new Yb();
os.register(Xe);
const Xb = {
  get isCachedAsTexture() {
    return !!this.renderGroup?.isCachedAsTexture;
  },
  cacheAsTexture(i) {
    typeof i == "boolean" && i === !1 ? this.disableRenderGroup() : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(i === !0 ? {} : i));
  },
  updateCacheTexture() {
    this.renderGroup?.updateCacheTexture();
  },
  get cacheAsBitmap() {
    return this.isCachedAsTexture;
  },
  set cacheAsBitmap(i) {
    N("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead."), this.cacheAsTexture(i);
  }
};
function qb(i, e, t) {
  const s = i.length;
  let r;
  if (e >= s || t === 0)
    return;
  t = e + t > s ? s - e : t;
  const n = s - t;
  for (r = e; r < n; ++r)
    i[r] = i[r + t];
  i.length = n;
}
const Zb = {
  allowChildren: !0,
  removeChildren(i = 0, e) {
    const t = e ?? this.children.length, s = t - i, r = [];
    if (s > 0 && s <= t) {
      for (let o = t - 1; o >= i; o--) {
        const a = this.children[o];
        a && (r.push(a), a.parent = null);
      }
      qb(this.children, i, t);
      const n = this.renderGroup || this.parentRenderGroup;
      n && n.removeChildren(r);
      for (let o = 0; o < r.length; ++o) {
        const a = r[o];
        a.parentRenderLayer?.detach(a), this.emit("childRemoved", a, this, o), r[o].emit("removed", this);
      }
      return r.length > 0 && this._didViewChangeTick++, r;
    } else if (s === 0 && this.children.length === 0)
      return r;
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  },
  removeChildAt(i) {
    const e = this.getChildAt(i);
    return this.removeChild(e);
  },
  getChildAt(i) {
    if (i < 0 || i >= this.children.length)
      throw new Error(`getChildAt: Index (${i}) does not exist.`);
    return this.children[i];
  },
  setChildIndex(i, e) {
    if (e < 0 || e >= this.children.length)
      throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`);
    this.getChildIndex(i), this.addChildAt(i, e);
  },
  getChildIndex(i) {
    const e = this.children.indexOf(i);
    if (e === -1)
      throw new Error("The supplied Container must be a child of the caller");
    return e;
  },
  addChildAt(i, e) {
    this.allowChildren || N(J, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
    const { children: t } = this;
    if (e < 0 || e > t.length)
      throw new Error(`${i}addChildAt: The index ${e} supplied is out of bounds ${t.length}`);
    if (i.parent) {
      const r = i.parent.children.indexOf(i);
      if (i.parent === this && r === e)
        return i;
      r !== -1 && i.parent.children.splice(r, 1);
    }
    e === t.length ? t.push(i) : t.splice(e, 0, i), i.parent = this, i.didChange = !0, i._updateFlags = 15;
    const s = this.renderGroup || this.parentRenderGroup;
    return s && s.addChild(i), this.sortableChildren && (this.sortDirty = !0), this.emit("childAdded", i, this, e), i.emit("added", this), i;
  },
  swapChildren(i, e) {
    if (i === e)
      return;
    const t = this.getChildIndex(i), s = this.getChildIndex(e);
    this.children[t] = e, this.children[s] = i;
    const r = this.renderGroup || this.parentRenderGroup;
    r && (r.structureDidChange = !0), this._didContainerChangeTick++;
  },
  removeFromParent() {
    this.parent?.removeChild(this);
  },
  reparentChild(...i) {
    return i.length === 1 ? this.reparentChildAt(i[0], this.children.length) : (i.forEach((e) => this.reparentChildAt(e, this.children.length)), i[0]);
  },
  reparentChildAt(i, e) {
    if (i.parent === this)
      return this.setChildIndex(i, e), i;
    const t = i.worldTransform.clone();
    i.removeFromParent(), this.addChildAt(i, e);
    const s = this.worldTransform.clone();
    return s.invert(), t.prepend(s), i.setFromMatrix(t), i;
  },
  replaceChild(i, e) {
    i.updateLocalTransform(), this.addChildAt(e, this.getChildIndex(i)), e.setFromMatrix(i.localTransform), e.updateLocalTransform(), this.removeChild(i);
  }
}, Kb = {
  collectRenderables(i, e, t) {
    this.parentRenderLayer && this.parentRenderLayer !== t || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(), this.isSimple ? this.collectRenderablesSimple(i, e, t) : this.renderGroup ? e.renderPipes.renderGroup.addRenderGroup(this.renderGroup, i) : this.collectRenderablesWithEffects(i, e, t));
  },
  collectRenderablesSimple(i, e, t) {
    const s = this.children, r = s.length;
    for (let n = 0; n < r; n++)
      s[n].collectRenderables(i, e, t);
  },
  collectRenderablesWithEffects(i, e, t) {
    const { renderPipes: s } = e;
    for (let r = 0; r < this.effects.length; r++) {
      const n = this.effects[r];
      s[n.pipe].push(n, this, i);
    }
    this.collectRenderablesSimple(i, e, t);
    for (let r = this.effects.length - 1; r >= 0; r--) {
      const n = this.effects[r];
      s[n.pipe].pop(n, this, i);
    }
  }
};
class Zu {
  constructor() {
    this.pipe = "filter", this.priority = 1;
  }
  destroy() {
    for (let e = 0; e < this.filters.length; e++)
      this.filters[e].destroy();
    this.filters = null, this.filterArea = null;
  }
}
class Jb {
  constructor() {
    this._effectClasses = [], this._tests = [], this._initialized = !1;
  }
  init() {
    this._initialized || (this._initialized = !0, this._effectClasses.forEach((e) => {
      this.add({
        test: e.test,
        maskClass: e
      });
    }));
  }
  add(e) {
    this._tests.push(e);
  }
  getMaskEffect(e) {
    this._initialized || this.init();
    for (let t = 0; t < this._tests.length; t++) {
      const s = this._tests[t];
      if (s.test(e))
        return Xe.get(s.maskClass, e);
    }
    return e;
  }
  returnMaskEffect(e) {
    Xe.return(e);
  }
}
const Eh = new Jb();
ke.handleByList(O.MaskEffect, Eh._effectClasses);
const jb = {
  _maskEffect: null,
  _maskOptions: {
    inverse: !1
  },
  _filterEffect: null,
  effects: [],
  _markStructureAsChanged() {
    const i = this.renderGroup || this.parentRenderGroup;
    i && (i.structureDidChange = !0);
  },
  addEffect(i) {
    this.effects.indexOf(i) === -1 && (this.effects.push(i), this.effects.sort((t, s) => t.priority - s.priority), this._markStructureAsChanged(), this._updateIsSimple());
  },
  removeEffect(i) {
    const e = this.effects.indexOf(i);
    e !== -1 && (this.effects.splice(e, 1), this._markStructureAsChanged(), this._updateIsSimple());
  },
  set mask(i) {
    const e = this._maskEffect;
    e?.mask !== i && (e && (this.removeEffect(e), Eh.returnMaskEffect(e), this._maskEffect = null), i != null && (this._maskEffect = Eh.getMaskEffect(i), this.addEffect(this._maskEffect)));
  },
  get mask() {
    return this._maskEffect?.mask;
  },
  setMask(i) {
    this._maskOptions = {
      ...this._maskOptions,
      ...i
    }, i.mask && (this.mask = i.mask), this._markStructureAsChanged();
  },
  set filters(i) {
    !Array.isArray(i) && i && (i = [i]);
    const e = this._filterEffect || (this._filterEffect = new Zu());
    i = i;
    const t = i?.length > 0, s = e.filters?.length > 0, r = t !== s;
    i = Array.isArray(i) ? i.slice(0) : i, e.filters = Object.freeze(i), r && (t ? this.addEffect(e) : (this.removeEffect(e), e.filters = i ?? null));
  },
  get filters() {
    return this._filterEffect?.filters;
  },
  set filterArea(i) {
    this._filterEffect || (this._filterEffect = new Zu()), this._filterEffect.filterArea = i;
  },
  get filterArea() {
    return this._filterEffect?.filterArea;
  }
}, Qb = {
  label: null,
  get name() {
    return N(J, "Container.name property has been removed, use Container.label instead"), this.label;
  },
  set name(i) {
    N(J, "Container.name property has been removed, use Container.label instead"), this.label = i;
  },
  getChildByName(i, e = !1) {
    return this.getChildByLabel(i, e);
  },
  getChildByLabel(i, e = !1) {
    const t = this.children;
    for (let s = 0; s < t.length; s++) {
      const r = t[s];
      if (r.label === i || i instanceof RegExp && i.test(r.label))
        return r;
    }
    if (e)
      for (let s = 0; s < t.length; s++) {
        const n = t[s].getChildByLabel(i, !0);
        if (n)
          return n;
      }
    return null;
  },
  getChildrenByLabel(i, e = !1, t = []) {
    const s = this.children;
    for (let r = 0; r < s.length; r++) {
      const n = s[r];
      (n.label === i || i instanceof RegExp && i.test(n.label)) && t.push(n);
    }
    if (e)
      for (let r = 0; r < s.length; r++)
        s[r].getChildrenByLabel(i, !0, t);
    return t;
  }
}, Ue = Xe.getPool(W), vt = Xe.getPool(it), e2 = new W(), t2 = {
  getFastGlobalBounds(i, e) {
    e || (e = new it()), e.clear(), this._getGlobalBoundsRecursive(!!i, e, this.parentRenderLayer), e.isValid || e.set(0, 0, 0, 0);
    const t = this.renderGroup || this.parentRenderGroup;
    return e.applyMatrix(t.worldTransform), e;
  },
  _getGlobalBoundsRecursive(i, e, t) {
    let s = e;
    if (i && this.parentRenderLayer && this.parentRenderLayer !== t || this.localDisplayStatus !== 7 || !this.measurable)
      return;
    const r = !!this.effects.length;
    if ((this.renderGroup || r) && (s = vt.get().clear()), this.boundsArea)
      e.addRect(this.boundsArea, this.worldTransform);
    else {
      if (this.renderPipeId) {
        const o = this.bounds;
        s.addFrame(
          o.minX,
          o.minY,
          o.maxX,
          o.maxY,
          this.groupTransform
        );
      }
      const n = this.children;
      for (let o = 0; o < n.length; o++)
        n[o]._getGlobalBoundsRecursive(i, s, t);
    }
    if (r) {
      let n = !1;
      const o = this.renderGroup || this.parentRenderGroup;
      for (let a = 0; a < this.effects.length; a++)
        this.effects[a].addBounds && (n || (n = !0, s.applyMatrix(o.worldTransform)), this.effects[a].addBounds(s, !0));
      n && s.applyMatrix(o.worldTransform.copyTo(e2).invert()), e.addBounds(s), vt.return(s);
    } else this.renderGroup && (e.addBounds(s, this.relativeGroupTransform), vt.return(s));
  }
};
function Cp(i, e, t) {
  t.clear();
  let s, r;
  return i.parent ? e ? s = i.parent.worldTransform : (r = Ue.get().identity(), s = ou(i, r)) : s = W.IDENTITY, Ap(i, t, s, e), r && Ue.return(r), t.isValid || t.set(0, 0, 0, 0), t;
}
function Ap(i, e, t, s) {
  if (!i.visible || !i.measurable)
    return;
  let r;
  s ? r = i.worldTransform : (i.updateLocalTransform(), r = Ue.get(), r.appendFrom(i.localTransform, t));
  const n = e, o = !!i.effects.length;
  if (o && (e = vt.get().clear()), i.boundsArea)
    e.addRect(i.boundsArea, r);
  else {
    const a = i.bounds;
    a && !a.isEmpty() && (e.matrix = r, e.addBounds(a));
    for (let l = 0; l < i.children.length; l++)
      Ap(i.children[l], e, r, s);
  }
  if (o) {
    for (let a = 0; a < i.effects.length; a++)
      i.effects[a].addBounds?.(e);
    n.addBounds(e, W.IDENTITY), vt.return(e);
  }
  s || Ue.return(r);
}
function ou(i, e) {
  const t = i.parent;
  return t && (ou(t, e), t.updateLocalTransform(), e.append(t.localTransform)), e;
}
function Ip(i, e) {
  if (i === 16777215 || !e)
    return e;
  if (e === 16777215 || !i)
    return i;
  const t = i >> 16 & 255, s = i >> 8 & 255, r = i & 255, n = e >> 16 & 255, o = e >> 8 & 255, a = e & 255, l = t * n / 255 | 0, c = s * o / 255 | 0, h = r * a / 255 | 0;
  return (l << 16) + (c << 8) + h;
}
const Ku = 16777215;
function Ju(i, e) {
  return i === Ku ? e : e === Ku ? i : Ip(i, e);
}
function Vs(i) {
  return ((i & 255) << 16) + (i & 65280) + (i >> 16 & 255);
}
const i2 = {
  getGlobalAlpha(i) {
    if (i)
      return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha;
    let e = this.alpha, t = this.parent;
    for (; t; )
      e *= t.alpha, t = t.parent;
    return e;
  },
  getGlobalTransform(i = new W(), e) {
    if (e)
      return i.copyFrom(this.worldTransform);
    this.updateLocalTransform();
    const t = ou(this, Ue.get().identity());
    return i.appendFrom(this.localTransform, t), Ue.return(t), i;
  },
  getGlobalTint(i) {
    if (i)
      return this.renderGroup ? Vs(this.renderGroup.worldColor) : this.parentRenderGroup ? Vs(
        Ju(this.localColor, this.parentRenderGroup.worldColor)
      ) : this.tint;
    let e = this.localColor, t = this.parent;
    for (; t; )
      e = Ju(e, t.localColor), t = t.parent;
    return Vs(e);
  }
};
function kp(i, e, t) {
  return e.clear(), t || (t = W.IDENTITY), Fp(i, e, t, i, !0), e.isValid || e.set(0, 0, 0, 0), e;
}
function Fp(i, e, t, s, r) {
  let n;
  if (r)
    n = Ue.get(), n = t.copyTo(n);
  else {
    if (!i.visible || !i.measurable)
      return;
    i.updateLocalTransform();
    const l = i.localTransform;
    n = Ue.get(), n.appendFrom(l, t);
  }
  const o = e, a = !!i.effects.length;
  if (a && (e = vt.get().clear()), i.boundsArea)
    e.addRect(i.boundsArea, n);
  else {
    i.renderPipeId && (e.matrix = n, e.addBounds(i.bounds));
    const l = i.children;
    for (let c = 0; c < l.length; c++)
      Fp(l[c], e, n, s, !1);
  }
  if (a) {
    for (let l = 0; l < i.effects.length; l++)
      i.effects[l].addLocalBounds?.(e, s);
    o.addBounds(e, W.IDENTITY), vt.return(e);
  }
  Ue.return(n);
}
function Mp(i, e) {
  const t = i.children;
  for (let s = 0; s < t.length; s++) {
    const r = t[s], n = r.uid, o = (r._didViewChangeTick & 65535) << 16 | r._didContainerChangeTick & 65535, a = e.index;
    (e.data[a] !== n || e.data[a + 1] !== o) && (e.data[e.index] = n, e.data[e.index + 1] = o, e.didChange = !0), e.index = a + 2, r.children.length && Mp(r, e);
  }
  return e.didChange;
}
const s2 = new W(), r2 = {
  _localBoundsCacheId: -1,
  _localBoundsCacheData: null,
  _setWidth(i, e) {
    const t = Math.sign(this.scale.x) || 1;
    e !== 0 ? this.scale.x = i / e * t : this.scale.x = t;
  },
  _setHeight(i, e) {
    const t = Math.sign(this.scale.y) || 1;
    e !== 0 ? this.scale.y = i / e * t : this.scale.y = t;
  },
  getLocalBounds() {
    this._localBoundsCacheData || (this._localBoundsCacheData = {
      data: [],
      index: 1,
      didChange: !1,
      localBounds: new it()
    });
    const i = this._localBoundsCacheData;
    return i.index = 1, i.didChange = !1, i.data[0] !== this._didViewChangeTick && (i.didChange = !0, i.data[0] = this._didViewChangeTick), Mp(this, i), i.didChange && kp(this, i.localBounds, s2), i.localBounds;
  },
  getBounds(i, e) {
    return Cp(this, i, e || new it());
  }
}, n2 = {
  _onRender: null,
  set onRender(i) {
    const e = this.renderGroup || this.parentRenderGroup;
    if (!i) {
      this._onRender && e?.removeOnRender(this), this._onRender = null;
      return;
    }
    this._onRender || e?.addOnRender(this), this._onRender = i;
  },
  get onRender() {
    return this._onRender;
  }
}, o2 = {
  _zIndex: 0,
  sortDirty: !1,
  sortableChildren: !1,
  get zIndex() {
    return this._zIndex;
  },
  set zIndex(i) {
    this._zIndex !== i && (this._zIndex = i, this.depthOfChildModified());
  },
  depthOfChildModified() {
    this.parent && (this.parent.sortableChildren = !0, this.parent.sortDirty = !0), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0);
  },
  sortChildren() {
    this.sortDirty && (this.sortDirty = !1, this.children.sort(a2));
  }
};
function a2(i, e) {
  return i._zIndex - e._zIndex;
}
const l2 = {
  getGlobalPosition(i = new q(), e = !1) {
    return this.parent ? this.parent.toGlobal(this._position, i, e) : (i.x = this._position.x, i.y = this._position.y), i;
  },
  toGlobal(i, e, t = !1) {
    const s = this.getGlobalTransform(Ue.get(), t);
    return e = s.apply(i, e), Ue.return(s), e;
  },
  toLocal(i, e, t, s) {
    e && (i = e.toGlobal(i, t, s));
    const r = this.getGlobalTransform(Ue.get(), s);
    return t = r.applyInverse(i, t), Ue.return(r), t;
  }
};
class Ep {
  constructor() {
    this.uid = de("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.gcTick = 0;
  }
  /** reset the instruction set so it can be reused set size back to 0 */
  reset() {
    this.instructionSize = 0;
  }
  /**
   * Destroy the instruction set, clearing the instructions and renderables.
   * @internal
   */
  destroy() {
    this.instructions.length = 0, this.renderables.length = 0, this.renderPipes = null, this.gcTick = 0;
  }
  /**
   * Add an instruction to the set
   * @param instruction - add an instruction to the set
   */
  add(e) {
    this.instructions[this.instructionSize++] = e;
  }
  /**
   * Log the instructions to the console (for debugging)
   * @internal
   */
  log() {
    this.instructions.length = this.instructionSize, console.table(this.instructions, ["type", "action"]);
  }
}
let c2 = 0;
class h2 {
  /**
   * @param textureOptions - options that will be passed to BaseRenderTexture constructor
   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.
   */
  constructor(e) {
    this._poolKeyHash = /* @__PURE__ */ Object.create(null), this._texturePool = {}, this.textureOptions = e || {}, this.enableFullScreen = !1, this.textureStyle = new hi(this.textureOptions);
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param pixelWidth - Width of texture in pixels.
   * @param pixelHeight - Height of texture in pixels.
   * @param antialias
   */
  createTexture(e, t, s) {
    const r = new Ke({
      ...this.textureOptions,
      width: e,
      height: t,
      resolution: 1,
      antialias: s,
      autoGarbageCollect: !1
    });
    return new L({
      source: r,
      label: `texturePool_${c2++}`
    });
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param frameWidth - The minimum width of the render texture.
   * @param frameHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @param antialias
   * @returns The new render texture.
   */
  getOptimalTexture(e, t, s = 1, r) {
    let n = Math.ceil(e * s - 1e-6), o = Math.ceil(t * s - 1e-6);
    n = ci(n), o = ci(o);
    const a = (n << 17) + (o << 1) + (r ? 1 : 0);
    this._texturePool[a] || (this._texturePool[a] = []);
    let l = this._texturePool[a].pop();
    return l || (l = this.createTexture(n, o, r)), l.source._resolution = s, l.source.width = n / s, l.source.height = o / s, l.source.pixelWidth = n, l.source.pixelHeight = o, l.frame.x = 0, l.frame.y = 0, l.frame.width = e, l.frame.height = t, l.updateUvs(), this._poolKeyHash[l.uid] = a, l;
  }
  /**
   * Gets extra texture of the same size as input renderTexture
   * @param texture - The texture to check what size it is.
   * @param antialias - Whether to use antialias.
   * @returns A texture that is a power of two
   */
  getSameSizeTexture(e, t = !1) {
    const s = e.source;
    return this.getOptimalTexture(e.width, e.height, s._resolution, t);
  }
  /**
   * Place a render texture back into the pool. Optionally reset the style of the texture to the default texture style.
   * useful if you modified the style of the texture after getting it from the pool.
   * @param renderTexture - The renderTexture to free
   * @param resetStyle - Whether to reset the style of the texture to the default texture style
   */
  returnTexture(e, t = !1) {
    const s = this._poolKeyHash[e.uid];
    t && (e.source.style = this.textureStyle), this._texturePool[s].push(e);
  }
  /**
   * Clears the pool.
   * @param destroyTextures - Destroy all stored textures.
   */
  clear(e) {
    if (e = e !== !1, e)
      for (const t in this._texturePool) {
        const s = this._texturePool[t];
        if (s)
          for (let r = 0; r < s.length; r++)
            s[r].destroy(!0);
      }
    this._texturePool = {};
  }
}
const di = new h2();
os.register(di);
class u2 {
  constructor() {
    this.renderPipeId = "renderGroup", this.root = null, this.canBundle = !1, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new W(), this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = /* @__PURE__ */ Object.create(null), this.updateTick = 0, this.gcTick = 0, this.childrenRenderablesToUpdate = { list: [], index: 0 }, this.structureDidChange = !0, this.instructionSet = new Ep(), this._onRenderContainers = [], this.textureNeedsUpdate = !0, this.isCachedAsTexture = !1, this._matrixDirty = 7;
  }
  init(e) {
    this.root = e, e._onRender && this.addOnRender(e), e.didChange = !0;
    const t = e.children;
    for (let s = 0; s < t.length; s++) {
      const r = t[s];
      r._updateFlags = 15, this.addChild(r);
    }
  }
  enableCacheAsTexture(e = {}) {
    this.textureOptions = e, this.isCachedAsTexture = !0, this.textureNeedsUpdate = !0;
  }
  disableCacheAsTexture() {
    this.isCachedAsTexture = !1, this.texture && (di.returnTexture(this.texture, !0), this.texture = null);
  }
  updateCacheTexture() {
    this.textureNeedsUpdate = !0;
    const e = this._parentCacheAsTextureRenderGroup;
    e && !e.textureNeedsUpdate && e.updateCacheTexture();
  }
  reset() {
    this.renderGroupChildren.length = 0;
    for (const e in this.childrenToUpdate) {
      const t = this.childrenToUpdate[e];
      t.list.fill(null), t.index = 0;
    }
    this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = !0, this._onRenderContainers.length = 0, this.renderGroupParent = null, this.disableCacheAsTexture();
  }
  get localTransform() {
    return this.root.localTransform;
  }
  addRenderGroupChild(e) {
    e.renderGroupParent && e.renderGroupParent._removeRenderGroupChild(e), e.renderGroupParent = this, this.renderGroupChildren.push(e);
  }
  _removeRenderGroupChild(e) {
    const t = this.renderGroupChildren.indexOf(e);
    t > -1 && this.renderGroupChildren.splice(t, 1), e.renderGroupParent = null;
  }
  addChild(e) {
    if (this.structureDidChange = !0, e.parentRenderGroup = this, e.updateTick = -1, e.parent === this.root ? e.relativeRenderGroupDepth = 1 : e.relativeRenderGroupDepth = e.parent.relativeRenderGroupDepth + 1, e.didChange = !0, this.onChildUpdate(e), e.renderGroup) {
      this.addRenderGroupChild(e.renderGroup);
      return;
    }
    e._onRender && this.addOnRender(e);
    const t = e.children;
    for (let s = 0; s < t.length; s++)
      this.addChild(t[s]);
  }
  removeChild(e) {
    if (this.structureDidChange = !0, e._onRender && (e.renderGroup || this.removeOnRender(e)), e.parentRenderGroup = null, e.renderGroup) {
      this._removeRenderGroupChild(e.renderGroup);
      return;
    }
    const t = e.children;
    for (let s = 0; s < t.length; s++)
      this.removeChild(t[s]);
  }
  removeChildren(e) {
    for (let t = 0; t < e.length; t++)
      this.removeChild(e[t]);
  }
  onChildUpdate(e) {
    let t = this.childrenToUpdate[e.relativeRenderGroupDepth];
    t || (t = this.childrenToUpdate[e.relativeRenderGroupDepth] = {
      index: 0,
      list: []
    }), t.list[t.index++] = e;
  }
  updateRenderable(e) {
    e.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[e.renderPipeId].updateRenderable(e), e.didViewUpdate = !1);
  }
  onChildViewUpdate(e) {
    this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = e;
  }
  get isRenderable() {
    return this.root.localDisplayStatus === 7 && this.worldAlpha > 0;
  }
  /**
   * adding a container to the onRender list will make sure the user function
   * passed in to the user defined 'onRender` callBack
   * @param container - the container to add to the onRender list
   */
  addOnRender(e) {
    this._onRenderContainers.push(e);
  }
  removeOnRender(e) {
    this._onRenderContainers.splice(this._onRenderContainers.indexOf(e), 1);
  }
  runOnRender(e) {
    for (let t = 0; t < this._onRenderContainers.length; t++)
      this._onRenderContainers[t]._onRender(e);
  }
  destroy() {
    this.disableCacheAsTexture(), this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null;
  }
  getChildren(e = []) {
    const t = this.root.children;
    for (let s = 0; s < t.length; s++)
      this._getChildren(t[s], e);
    return e;
  }
  _getChildren(e, t = []) {
    if (t.push(e), e.renderGroup)
      return t;
    const s = e.children;
    for (let r = 0; r < s.length; r++)
      this._getChildren(s[r], t);
    return t;
  }
  invalidateMatrices() {
    this._matrixDirty = 7;
  }
  /**
   * Returns the inverse of the world transform matrix.
   * @returns {Matrix} The inverse of the world transform matrix.
   */
  get inverseWorldTransform() {
    return (this._matrixDirty & 1) === 0 ? this._inverseWorldTransform : (this._matrixDirty &= -2, this._inverseWorldTransform || (this._inverseWorldTransform = new W()), this._inverseWorldTransform.copyFrom(this.worldTransform).invert());
  }
  /**
   * Returns the inverse of the texture offset transform matrix.
   * @returns {Matrix} The inverse of the texture offset transform matrix.
   */
  get textureOffsetInverseTransform() {
    return (this._matrixDirty & 2) === 0 ? this._textureOffsetInverseTransform : (this._matrixDirty &= -3, this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new W()), this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(
      -this._textureBounds.x,
      -this._textureBounds.y
    ));
  }
  /**
   * Returns the inverse of the parent texture transform matrix.
   * This is used to properly transform coordinates when rendering into cached textures.
   * @returns {Matrix} The inverse of the parent texture transform matrix.
   */
  get inverseParentTextureTransform() {
    if ((this._matrixDirty & 4) === 0)
      return this._inverseParentTextureTransform;
    this._matrixDirty &= -5;
    const e = this._parentCacheAsTextureRenderGroup;
    return e ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new W()), this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(e.inverseWorldTransform).translate(
      -e._textureBounds.x,
      -e._textureBounds.y
    )) : this.worldTransform;
  }
  /**
   * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.
   * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.
   * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,
   * or null if no parent is cached as texture.
   */
  get cacheToLocalTransform() {
    return this.isCachedAsTexture ? this.textureOffsetInverseTransform : this._parentCacheAsTextureRenderGroup ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform : null;
  }
}
function d2(i, e, t = {}) {
  for (const s in e)
    !t[s] && e[s] !== void 0 && (i[s] = e[s]);
}
const Nc = new Ae(null), ys = new Ae(null), Gc = new Ae(null, 1, 1), vs = new Ae(null), ju = 1, f2 = 2, Hc = 4;
class oe extends rt {
  constructor(e = {}) {
    super(), this.uid = de("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = !1, this.didViewUpdate = !1, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = !0, this.measurable = !0, this.isSimple = !0, this.parentRenderLayer = null, this.updateTick = -1, this.localTransform = new W(), this.relativeGroupTransform = new W(), this.groupTransform = this.relativeGroupTransform, this.destroyed = !1, this._position = new Ae(this, 0, 0), this._scale = Gc, this._pivot = ys, this._origin = vs, this._skew = Nc, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didContainerChangeTick = 0, this._didViewChangeTick = 0, this._didLocalTransformChangeId = -1, this.effects = [], d2(this, e, {
      children: !0,
      parent: !0,
      effects: !0
    }), e.children?.forEach((t) => this.addChild(t)), e.parent?.addChild(this);
  }
  /**
   * Mixes all enumerable properties and methods from a source object to Container.
   * @param source - The source of properties and methods to mix in.
   * @deprecated since 8.8.0
   */
  static mixin(e) {
    N("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead."), ke.mixin(oe, e);
  }
  // = 'default';
  /**
   * We now use the _didContainerChangeTick and _didViewChangeTick to track changes
   * @deprecated since 8.2.6
   * @ignore
   */
  set _didChangeId(e) {
    this._didViewChangeTick = e >> 12 & 4095, this._didContainerChangeTick = e & 4095;
  }
  /** @ignore */
  get _didChangeId() {
    return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12;
  }
  /**
   * Adds one or more children to the container.
   * The children will be rendered as part of this container's display list.
   * @example
   * ```ts
   * // Add a single child
   * container.addChild(sprite);
   *
   * // Add multiple children
   * container.addChild(background, player, foreground);
   *
   * // Add with type checking
   * const sprite = container.addChild<Sprite>(new Sprite(texture));
   * sprite.tint = 'red';
   * ```
   * @param children - The Container(s) to add to the container
   * @returns The first child that was added
   * @see {@link Container#removeChild} For removing children
   * @see {@link Container#addChildAt} For adding at specific index
   */
  addChild(...e) {
    if (this.allowChildren || N(J, "addChild: Only Containers will be allowed to add children in v8.0.0"), e.length > 1) {
      for (let r = 0; r < e.length; r++)
        this.addChild(e[r]);
      return e[0];
    }
    const t = e[0], s = this.renderGroup || this.parentRenderGroup;
    return t.parent === this ? (this.children.splice(this.children.indexOf(t), 1), this.children.push(t), s && (s.structureDidChange = !0), t) : (t.parent && t.parent.removeChild(t), this.children.push(t), this.sortableChildren && (this.sortDirty = !0), t.parent = this, t.didChange = !0, t._updateFlags = 15, s && s.addChild(t), this.emit("childAdded", t, this, this.children.length - 1), t.emit("added", this), this._didViewChangeTick++, t._zIndex !== 0 && t.depthOfChildModified(), t);
  }
  /**
   * Removes one or more children from the container.
   * When removing multiple children, events will be triggered for each child in sequence.
   * @example
   * ```ts
   * // Remove a single child
   * const removed = container.removeChild(sprite);
   *
   * // Remove multiple children
   * const bg = container.removeChild(background, player, userInterface);
   *
   * // Remove with type checking
   * const sprite = container.removeChild<Sprite>(childSprite);
   * sprite.texture = newTexture;
   * ```
   * @param children - The Container(s) to remove
   * @returns The first child that was removed
   * @see {@link Container#addChild} For adding children
   * @see {@link Container#removeChildren} For removing multiple children
   */
  removeChild(...e) {
    if (e.length > 1) {
      for (let r = 0; r < e.length; r++)
        this.removeChild(e[r]);
      return e[0];
    }
    const t = e[0], s = this.children.indexOf(t);
    return s > -1 && (this._didViewChangeTick++, this.children.splice(s, 1), this.renderGroup ? this.renderGroup.removeChild(t) : this.parentRenderGroup && this.parentRenderGroup.removeChild(t), t.parentRenderLayer && t.parentRenderLayer.detach(t), t.parent = null, this.emit("childRemoved", t, this, s), t.emit("removed", this)), t;
  }
  /** @ignore */
  _onUpdate(e) {
    e && e === this._skew && this._updateSkew(), this._didContainerChangeTick++, !this.didChange && (this.didChange = !0, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this));
  }
  set isRenderGroup(e) {
    !!this.renderGroup !== e && (e ? this.enableRenderGroup() : this.disableRenderGroup());
  }
  /**
   * Returns true if this container is a render group.
   * This means that it will be rendered as a separate pass, with its own set of instructions
   * @advanced
   */
  get isRenderGroup() {
    return !!this.renderGroup;
  }
  /**
   * Calling this enables a render group for this container.
   * This means it will be rendered as a separate set of instructions.
   * The transform of the container will also be handled on the GPU rather than the CPU.
   * @advanced
   */
  enableRenderGroup() {
    if (this.renderGroup)
      return;
    const e = this.parentRenderGroup;
    e?.removeChild(this), this.renderGroup = Xe.get(u2, this), this.groupTransform = W.IDENTITY, e?.addChild(this), this._updateIsSimple();
  }
  /**
   * This will disable the render group for this container.
   * @advanced
   */
  disableRenderGroup() {
    if (!this.renderGroup)
      return;
    const e = this.parentRenderGroup;
    e?.removeChild(this), Xe.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, e?.addChild(this), this._updateIsSimple();
  }
  /** @ignore */
  _updateIsSimple() {
    this.isSimple = !this.renderGroup && this.effects.length === 0;
  }
  /**
   * Current transform of the object based on world (parent) factors.
   *
   * This matrix represents the absolute transformation in the scene graph.
   * @example
   * ```ts
   * // Get world position
   * const worldPos = container.worldTransform;
   * console.log(`World position: (${worldPos.tx}, ${worldPos.ty})`);
   * ```
   * @readonly
   * @see {@link Container#localTransform} For local space transform
   */
  get worldTransform() {
    return this._worldTransform || (this._worldTransform = new W()), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform;
  }
  /**
   * The position of the container on the x axis relative to the local coordinates of the parent.
   *
   * An alias to position.x
   * @example
   * ```ts
   * // Basic position
   * container.x = 100;
   * ```
   */
  get x() {
    return this._position.x;
  }
  set x(e) {
    this._position.x = e;
  }
  /**
   * The position of the container on the y axis relative to the local coordinates of the parent.
   *
   * An alias to position.y
   * @example
   * ```ts
   * // Basic position
   * container.y = 200;
   * ```
   */
  get y() {
    return this._position.y;
  }
  set y(e) {
    this._position.y = e;
  }
  /**
   * The coordinate of the object relative to the local coordinates of the parent.
   * @example
   * ```ts
   * // Basic position setting
   * container.position.set(100, 200);
   * container.position.set(100); // Sets both x and y to 100
   * // Using point data
   * container.position = { x: 50, y: 75 };
   * ```
   * @since 4.0.0
   */
  get position() {
    return this._position;
  }
  set position(e) {
    this._position.copyFrom(e);
  }
  /**
   * The rotation of the object in radians.
   *
   * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;
   * > rotation is in radians, angle is in degrees.
   * @example
   * ```ts
   * // Basic rotation
   * container.rotation = Math.PI / 4; // 45 degrees
   *
   * // Convert from degrees
   * const degrees = 45;
   * container.rotation = degrees * Math.PI / 180;
   *
   * // Rotate around center
   * container.pivot.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // 180 degrees
   *
   * // Rotate around center with origin
   * container.origin.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // 180 degrees
   * ```
   */
  get rotation() {
    return this._rotation;
  }
  set rotation(e) {
    this._rotation !== e && (this._rotation = e, this._onUpdate(this._skew));
  }
  /**
   * The angle of the object in degrees.
   *
   * > [!NOTE] 'rotation' and 'angle' have the same effect on a display object;
   * > rotation is in radians, angle is in degrees.
   * @example
   * ```ts
   * // Basic angle rotation
   * sprite.angle = 45; // 45 degrees
   *
   * // Rotate around center
   * sprite.pivot.set(sprite.width / 2, sprite.height / 2);
   * sprite.angle = 180; // Half rotation
   *
   * // Rotate around center with origin
   * sprite.origin.set(sprite.width / 2, sprite.height / 2);
   * sprite.angle = 180; // Half rotation
   *
   * // Reset rotation
   * sprite.angle = 0;
   * ```
   */
  get angle() {
    return this.rotation * Ab;
  }
  set angle(e) {
    this.rotation = e * Ib;
  }
  /**
   * The center of rotation, scaling, and skewing for this display object in its local space.
   * The `position` is the projection of `pivot` in the parent's local space.
   *
   * By default, the pivot is the origin (0, 0).
   * @example
   * ```ts
   * // Rotate around center
   * container.pivot.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // Rotates around center
   * ```
   * @since 4.0.0
   */
  get pivot() {
    return this._pivot === ys && (this._pivot = new Ae(this, 0, 0)), this._pivot;
  }
  set pivot(e) {
    this._pivot === ys && (this._pivot = new Ae(this, 0, 0), this._origin !== vs && se("Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.")), typeof e == "number" ? this._pivot.set(e) : this._pivot.copyFrom(e);
  }
  /**
   * The skew factor for the object in radians. Skewing is a transformation that distorts
   * the object by rotating it differently at each point, creating a non-uniform shape.
   * @example
   * ```ts
   * // Basic skewing
   * container.skew.set(0.5, 0); // Skew horizontally
   * container.skew.set(0, 0.5); // Skew vertically
   *
   * // Skew with point data
   * container.skew = { x: 0.3, y: 0.3 }; // Diagonal skew
   *
   * // Reset skew
   * container.skew.set(0, 0);
   *
   * // Animate skew
   * app.ticker.add(() => {
   *     // Create wave effect
   *     container.skew.x = Math.sin(Date.now() / 1000) * 0.3;
   * });
   *
   * // Combine with rotation
   * container.rotation = Math.PI / 4; // 45 degrees
   * container.skew.set(0.2, 0.2); // Skew the rotated object
   * ```
   * @since 4.0.0
   * @type {ObservablePoint} Point-like object with x/y properties in radians
   * @default {x: 0, y: 0}
   */
  get skew() {
    return this._skew === Nc && (this._skew = new Ae(this, 0, 0)), this._skew;
  }
  set skew(e) {
    this._skew === Nc && (this._skew = new Ae(this, 0, 0)), this._skew.copyFrom(e);
  }
  /**
   * The scale factors of this object along the local coordinate axes.
   *
   * The default scale is (1, 1).
   * @example
   * ```ts
   * // Basic scaling
   * container.scale.set(2, 2); // Scales to double size
   * container.scale.set(2); // Scales uniformly to double size
   * container.scale = 2; // Scales uniformly to double size
   * // Scale to a specific width and height
   * container.setSize(200, 100); // Sets width to 200 and height to 100
   * ```
   * @since 4.0.0
   */
  get scale() {
    return this._scale === Gc && (this._scale = new Ae(this, 1, 1)), this._scale;
  }
  set scale(e) {
    this._scale === Gc && (this._scale = new Ae(this, 0, 0)), typeof e == "string" && (e = parseFloat(e)), typeof e == "number" ? this._scale.set(e) : this._scale.copyFrom(e);
  }
  /**
   * @experimental
   * The origin point around which the container rotates and scales without affecting its position.
   * Unlike pivot, changing the origin will not move the container's position.
   * @example
   * ```ts
   * // Rotate around center point
   * container.origin.set(container.width / 2, container.height / 2);
   * container.rotation = Math.PI; // Rotates around center
   *
   * // Reset origin
   * container.origin.set(0, 0);
   * ```
   */
  get origin() {
    return this._origin === vs && (this._origin = new Ae(this, 0, 0)), this._origin;
  }
  set origin(e) {
    this._origin === vs && (this._origin = new Ae(this, 0, 0), this._pivot !== ys && se("Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.")), typeof e == "number" ? this._origin.set(e) : this._origin.copyFrom(e);
  }
  /**
   * The width of the Container, setting this will actually modify the scale to achieve the value set.
   * > [!NOTE] Changing the width will adjust the scale.x property of the container while maintaining its aspect ratio.
   * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}
   * as it is more optimized by not recalculating the local bounds twice.
   * @example
   * ```ts
   * // Basic width setting
   * container.width = 100;
   * // Optimized width setting
   * container.setSize(100, 100);
   * ```
   */
  get width() {
    return Math.abs(this.scale.x * this.getLocalBounds().width);
  }
  set width(e) {
    const t = this.getLocalBounds().width;
    this._setWidth(e, t);
  }
  /**
   * The height of the Container,
   * > [!NOTE] Changing the height will adjust the scale.y property of the container while maintaining its aspect ratio.
   * > [!NOTE] If you want to set both width and height at the same time, use {@link Container#setSize}
   * as it is more optimized by not recalculating the local bounds twice.
   * @example
   * ```ts
   * // Basic height setting
   * container.height = 200;
   * // Optimized height setting
   * container.setSize(100, 200);
   * ```
   */
  get height() {
    return Math.abs(this.scale.y * this.getLocalBounds().height);
  }
  set height(e) {
    const t = this.getLocalBounds().height;
    this._setHeight(e, t);
  }
  /**
   * Retrieves the size of the container as a [Size]{@link Size} object.
   *
   * This is faster than get the width and height separately.
   * @example
   * ```ts
   * // Basic size retrieval
   * const size = container.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * container.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in.
   * @returns The size of the container.
   */
  getSize(e) {
    e || (e = {});
    const t = this.getLocalBounds();
    return e.width = Math.abs(this.scale.x * t.width), e.height = Math.abs(this.scale.y * t.height), e;
  }
  /**
   * Sets the size of the container to the specified width and height.
   * This is more efficient than setting width and height separately as it only recalculates bounds once.
   * @example
   * ```ts
   * // Basic size setting
   * container.setSize(100, 200);
   *
   * // Set uniform size
   * container.setSize(100); // Sets both width and height to 100
   * ```
   * @param value - This can be either a number or a [Size]{@link Size} object.
   * @param height - The height to set. Defaults to the value of `width` if not provided.
   */
  setSize(e, t) {
    const s = this.getLocalBounds();
    typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, s.width), t !== void 0 && this._setHeight(t, s.height);
  }
  /** Called when the skew or the rotation changes. */
  _updateSkew() {
    const e = this._rotation, t = this._skew;
    this._cx = Math.cos(e + t._y), this._sx = Math.sin(e + t._y), this._cy = -Math.sin(e - t._x), this._sy = Math.cos(e - t._x);
  }
  /**
   * Updates the transform properties of the container.
   * Allows partial updates of transform properties for optimized manipulation.
   * @example
   * ```ts
   * // Basic transform update
   * container.updateTransform({
   *     x: 100,
   *     y: 200,
   *     rotation: Math.PI / 4
   * });
   *
   * // Scale and rotate around center
   * sprite.updateTransform({
   *     pivotX: sprite.width / 2,
   *     pivotY: sprite.height / 2,
   *     scaleX: 2,
   *     scaleY: 2,
   *     rotation: Math.PI
   * });
   *
   * // Update position only
   * button.updateTransform({
   *     x: button.x + 10, // Move right
   *     y: button.y      // Keep same y
   * });
   * ```
   * @param opts - Transform options to update
   * @param opts.x - The x position
   * @param opts.y - The y position
   * @param opts.scaleX - The x-axis scale factor
   * @param opts.scaleY - The y-axis scale factor
   * @param opts.rotation - The rotation in radians
   * @param opts.skewX - The x-axis skew factor
   * @param opts.skewY - The y-axis skew factor
   * @param opts.pivotX - The x-axis pivot point
   * @param opts.pivotY - The y-axis pivot point
   * @returns This container, for chaining
   * @see {@link Container#setFromMatrix} For matrix-based transforms
   * @see {@link Container#position} For direct position access
   */
  updateTransform(e) {
    return this.position.set(
      typeof e.x == "number" ? e.x : this.position.x,
      typeof e.y == "number" ? e.y : this.position.y
    ), this.scale.set(
      typeof e.scaleX == "number" ? e.scaleX || 1 : this.scale.x,
      typeof e.scaleY == "number" ? e.scaleY || 1 : this.scale.y
    ), this.rotation = typeof e.rotation == "number" ? e.rotation : this.rotation, this.skew.set(
      typeof e.skewX == "number" ? e.skewX : this.skew.x,
      typeof e.skewY == "number" ? e.skewY : this.skew.y
    ), this.pivot.set(
      typeof e.pivotX == "number" ? e.pivotX : this.pivot.x,
      typeof e.pivotY == "number" ? e.pivotY : this.pivot.y
    ), this.origin.set(
      typeof e.originX == "number" ? e.originX : this.origin.x,
      typeof e.originY == "number" ? e.originY : this.origin.y
    ), this;
  }
  /**
   * Updates the local transform properties by decomposing the given matrix.
   * Extracts position, scale, rotation, and skew from a transformation matrix.
   * @example
   * ```ts
   * // Basic matrix transform
   * const matrix = new Matrix()
   *     .translate(100, 100)
   *     .rotate(Math.PI / 4)
   *     .scale(2, 2);
   *
   * container.setFromMatrix(matrix);
   *
   * // Copy transform from another container
   * const source = new Container();
   * source.position.set(100, 100);
   * source.rotation = Math.PI / 2;
   *
   * target.setFromMatrix(source.localTransform);
   *
   * // Reset transform
   * container.setFromMatrix(Matrix.IDENTITY);
   * ```
   * @param matrix - The matrix to use for updating the transform
   * @see {@link Container#updateTransform} For property-based updates
   * @see {@link Matrix#decompose} For matrix decomposition details
   */
  setFromMatrix(e) {
    e.decompose(this);
  }
  /** Updates the local transform. */
  updateLocalTransform() {
    const e = this._didContainerChangeTick;
    if (this._didLocalTransformChangeId === e)
      return;
    this._didLocalTransformChangeId = e;
    const t = this.localTransform, s = this._scale, r = this._pivot, n = this._origin, o = this._position, a = s._x, l = s._y, c = r._x, h = r._y, u = -n._x, d = -n._y;
    t.a = this._cx * a, t.b = this._sx * a, t.c = this._cy * l, t.d = this._sy * l, t.tx = o._x - (c * t.a + h * t.c) + (u * t.a + d * t.c) - u, t.ty = o._y - (c * t.b + h * t.d) + (u * t.b + d * t.d) - d;
  }
  // / ///// color related stuff
  set alpha(e) {
    e !== this.localAlpha && (this.localAlpha = e, this._updateFlags |= ju, this._onUpdate());
  }
  /**
   * The opacity of the object relative to its parent's opacity.
   * Value ranges from 0 (fully transparent) to 1 (fully opaque).
   * @example
   * ```ts
   * // Basic transparency
   * sprite.alpha = 0.5; // 50% opacity
   *
   * // Inherited opacity
   * container.alpha = 0.5;
   * const child = new Sprite(texture);
   * child.alpha = 0.5;
   * container.addChild(child);
   * // child's effective opacity is 0.25 (0.5 * 0.5)
   * ```
   * @default 1
   * @see {@link Container#visible} For toggling visibility
   * @see {@link Container#renderable} For render control
   */
  get alpha() {
    return this.localAlpha;
  }
  set tint(e) {
    const s = pe.shared.setValue(e ?? 16777215).toBgrNumber();
    s !== this.localColor && (this.localColor = s, this._updateFlags |= ju, this._onUpdate());
  }
  /**
   * The tint applied to the sprite.
   *
   * This can be any valid {@link ColorSource}.
   * @example
   * ```ts
   * // Basic color tinting
   * container.tint = 0xff0000; // Red tint
   * container.tint = 'red';    // Same as above
   * container.tint = '#00ff00'; // Green
   * container.tint = 'rgb(0,0,255)'; // Blue
   *
   * // Remove tint
   * container.tint = 0xffffff; // White = no tint
   * container.tint = null;     // Also removes tint
   * ```
   * @default 0xFFFFFF
   * @see {@link Container#alpha} For transparency
   * @see {@link Container#visible} For visibility control
   */
  get tint() {
    return Vs(this.localColor);
  }
  // / //////////////// blend related stuff
  set blendMode(e) {
    this.localBlendMode !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= f2, this.localBlendMode = e, this._onUpdate());
  }
  /**
   * The blend mode to be applied to the sprite. Controls how pixels are blended when rendering.
   *
   * Setting to 'normal' will reset to default blending.
   * > [!NOTE] More blend modes are available after importing the `pixi.js/advanced-blend-modes` sub-export.
   * @example
   * ```ts
   * // Basic blend modes
   * sprite.blendMode = 'add';        // Additive blending
   * sprite.blendMode = 'multiply';   // Multiply colors
   * sprite.blendMode = 'screen';     // Screen blend
   *
   * // Reset blend mode
   * sprite.blendMode = 'normal';     // Normal blending
   * ```
   * @default 'normal'
   * @see {@link Container#alpha} For transparency
   * @see {@link Container#tint} For color adjustments
   */
  get blendMode() {
    return this.localBlendMode;
  }
  // / ///////// VISIBILITY / RENDERABLE /////////////////
  /**
   * The visibility of the object. If false the object will not be drawn,
   * and the transform will not be updated.
   * @example
   * ```ts
   * // Basic visibility toggle
   * sprite.visible = false; // Hide sprite
   * sprite.visible = true;  // Show sprite
   * ```
   * @default true
   * @see {@link Container#renderable} For render-only control
   * @see {@link Container#alpha} For transparency
   */
  get visible() {
    return !!(this.localDisplayStatus & 2);
  }
  set visible(e) {
    const t = e ? 2 : 0;
    (this.localDisplayStatus & 2) !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= Hc, this.localDisplayStatus ^= 2, this._onUpdate());
  }
  /** @ignore */
  get culled() {
    return !(this.localDisplayStatus & 4);
  }
  /** @ignore */
  set culled(e) {
    const t = e ? 0 : 4;
    (this.localDisplayStatus & 4) !== t && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= Hc, this.localDisplayStatus ^= 4, this._onUpdate());
  }
  /**
   * Controls whether this object can be rendered. If false the object will not be drawn,
   * but the transform will still be updated. This is different from visible, which skips
   * transform updates.
   * @example
   * ```ts
   * // Basic render control
   * sprite.renderable = false; // Skip rendering
   * sprite.renderable = true;  // Enable rendering
   * ```
   * @default true
   * @see {@link Container#visible} For skipping transform updates
   * @see {@link Container#alpha} For transparency
   */
  get renderable() {
    return !!(this.localDisplayStatus & 1);
  }
  set renderable(e) {
    const t = e ? 1 : 0;
    (this.localDisplayStatus & 1) !== t && (this._updateFlags |= Hc, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._onUpdate());
  }
  /**
   * Whether or not the object should be rendered.
   * @advanced
   */
  get isRenderable() {
    return this.localDisplayStatus === 7 && this.groupAlpha > 0;
  }
  /**
   * Removes all internal references and listeners as well as removes children from the display list.
   * Do not use a Container after calling `destroy`.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * ```ts
   * container.destroy();
   * container.destroy(true);
   * container.destroy({ children: true });
   * container.destroy({ children: true, texture: true, textureSource: true });
   * ```
   */
  destroy(e = !1) {
    if (this.destroyed)
      return;
    this.destroyed = !0;
    let t;
    if (this.children.length && (t = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._origin = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), (typeof e == "boolean" ? e : e?.children) && t)
      for (let r = 0; r < t.length; ++r)
        t[r].destroy(e);
    this.renderGroup?.destroy(), this.renderGroup = null;
  }
}
ke.mixin(
  oe,
  Zb,
  t2,
  l2,
  n2,
  r2,
  jb,
  Qb,
  o2,
  Vb,
  Xb,
  i2,
  Kb
);
class au extends oe {
  // eslint-disable-next-line @typescript-eslint/no-useless-constructor
  constructor(e) {
    super(e), this.canBundle = !0, this.allowChildren = !1, this._roundPixels = 0, this._lastUsed = -1, this._gpuData = /* @__PURE__ */ Object.create(null), this._bounds = new it(0, 1, 0, 0), this._boundsDirty = !0;
  }
  /**
   * The local bounds of the view in its own coordinate space.
   * Bounds are automatically updated when the view's content changes.
   * @example
   * ```ts
   * // Get bounds dimensions
   * const bounds = view.bounds;
   * console.log(`Width: ${bounds.maxX - bounds.minX}`);
   * console.log(`Height: ${bounds.maxY - bounds.minY}`);
   * ```
   * @returns The rectangular bounds of the view
   * @see {@link Bounds} For bounds operations
   */
  get bounds() {
    return this._boundsDirty ? (this.updateBounds(), this._boundsDirty = !1, this._bounds) : this._bounds;
  }
  /**
   * Whether or not to round the x/y position of the sprite.
   * @example
   * ```ts
   * // Enable pixel rounding for crisp rendering
   * view.roundPixels = true;
   * ```
   * @default false
   */
  get roundPixels() {
    return !!this._roundPixels;
  }
  set roundPixels(e) {
    this._roundPixels = e ? 1 : 0;
  }
  /**
   * Checks if the object contains the given point in local coordinates.
   * Uses the view's bounds for hit testing.
   * @example
   * ```ts
   * // Basic point check
   * const localPoint = { x: 50, y: 25 };
   * const contains = view.containsPoint(localPoint);
   * console.log('Point is inside:', contains);
   * ```
   * @param point - The point to check in local coordinates
   * @returns True if the point is within the view's bounds
   * @see {@link ViewContainer#bounds} For the bounds used in hit testing
   * @see {@link Container#toLocal} For converting global coordinates to local
   */
  containsPoint(e) {
    const t = this.bounds, { x: s, y: r } = e;
    return s >= t.minX && s <= t.maxX && r >= t.minY && r <= t.maxY;
  }
  /** @private */
  onViewUpdate() {
    if (this._didViewChangeTick++, this._boundsDirty = !0, this.didViewUpdate)
      return;
    this.didViewUpdate = !0;
    const e = this.renderGroup || this.parentRenderGroup;
    e && e.onChildViewUpdate(this);
  }
  destroy(e) {
    super.destroy(e), this._bounds = null;
    for (const t in this._gpuData)
      this._gpuData[t].destroy?.();
    this._gpuData = null;
  }
  /**
   * Collects renderables for the view container.
   * @param instructionSet - The instruction set to collect renderables for.
   * @param renderer - The renderer to collect renderables for.
   * @param currentLayer - The current render layer.
   * @internal
   */
  collectRenderablesSimple(e, t, s) {
    const { renderPipes: r } = t;
    r.blendMode.pushBlendMode(this, this.groupBlendMode, e), r[this.renderPipeId].addRenderable(this, e), this.didViewUpdate = !1;
    const o = this.children, a = o.length;
    for (let l = 0; l < a; l++)
      o[l].collectRenderables(e, t, s);
    r.blendMode.popBlendMode(e);
  }
}
class Me extends au {
  /**
   * @param options - The options for creating the sprite.
   */
  constructor(e = L.EMPTY) {
    e instanceof L && (e = { texture: e });
    const { texture: t = L.EMPTY, anchor: s, roundPixels: r, width: n, height: o, ...a } = e;
    super({
      label: "Sprite",
      ...a
    }), this.renderPipeId = "sprite", this.batched = !0, this._visualBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }, this._anchor = new Ae(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    ), s ? this.anchor = s : t.defaultAnchor && (this.anchor = t.defaultAnchor), this.texture = t, this.allowChildren = !1, this.roundPixels = r ?? !1, n !== void 0 && (this.width = n), o !== void 0 && (this.height = o);
  }
  /**
   * Creates a new sprite based on a source texture, image, video, or canvas element.
   * This is a convenience method that automatically creates and manages textures.
   * @example
   * ```ts
   * // Create from path or URL
   * const sprite = Sprite.from('assets/image.png');
   *
   * // Create from existing texture
   * const sprite = Sprite.from(texture);
   *
   * // Create from canvas
   * const canvas = document.createElement('canvas');
   * const sprite = Sprite.from(canvas, true); // Skip caching new texture
   * ```
   * @param source - The source to create the sprite from. Can be a path to an image, a texture,
   * or any valid texture source (canvas, video, etc.)
   * @param skipCache - Whether to skip adding to the texture cache when creating a new texture
   * @returns A new sprite based on the source
   * @see {@link Texture.from} For texture creation details
   * @see {@link Assets} For asset loading and management
   */
  static from(e, t = !1) {
    return e instanceof L ? new Me(e) : new Me(L.from(e, t));
  }
  set texture(e) {
    e || (e = L.EMPTY);
    const t = this._texture;
    t !== e && (t && t.dynamic && t.off("update", this.onViewUpdate, this), e.dynamic && e.on("update", this.onViewUpdate, this), this._texture = e, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate());
  }
  /**
   * The texture that is displayed by the sprite. When changed, automatically updates
   * the sprite dimensions and manages texture event listeners.
   * @example
   * ```ts
   * // Create sprite with texture
   * const sprite = new Sprite({
   *     texture: Texture.from('sprite.png')
   * });
   *
   * // Update texture
   * sprite.texture = Texture.from('newSprite.png');
   *
   * // Use texture from spritesheet
   * const sheet = await Assets.load('spritesheet.json');
   * sprite.texture = sheet.textures['frame1.png'];
   *
   * // Reset to empty texture
   * sprite.texture = Texture.EMPTY;
   * ```
   * @see {@link Texture} For texture creation and management
   * @see {@link Assets} For asset loading
   */
  get texture() {
    return this._texture;
  }
  /**
   * The bounds of the sprite, taking into account the texture's trim area.
   * @example
   * ```ts
   * const texture = new Texture({
   *     source: new TextureSource({ width: 300, height: 300 }),
   *     frame: new Rectangle(196, 66, 58, 56),
   *     trim: new Rectangle(4, 4, 58, 56),
   *     orig: new Rectangle(0, 0, 64, 64),
   *     rotate: 2,
   * });
   * const sprite = new Sprite(texture);
   * const visualBounds = sprite.visualBounds;
   * // console.log(visualBounds); // { minX: -4, maxX: 62, minY: -4, maxY: 60 }
   */
  get visualBounds() {
    return Rb(this._visualBounds, this._anchor, this._texture), this._visualBounds;
  }
  /**
   * @deprecated
   * @ignore
   */
  get sourceBounds() {
    return N("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead."), this.visualBounds;
  }
  /** @private */
  updateBounds() {
    const e = this._anchor, t = this._texture, s = this._bounds, { width: r, height: n } = t.orig;
    s.minX = -e._x * r, s.maxX = s.minX + r, s.minY = -e._y * n, s.maxY = s.minY + n;
  }
  /**
   * Destroys this sprite renderable and optionally its texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * sprite.destroy();
   * sprite.destroy(true);
   * sprite.destroy({ texture: true, textureSource: true });
   */
  destroy(e = !1) {
    if (super.destroy(e), typeof e == "boolean" ? e : e?.texture) {
      const s = typeof e == "boolean" ? e : e?.textureSource;
      this._texture.destroy(s);
    }
    this._texture = null, this._visualBounds = null, this._bounds = null, this._anchor = null, this._gpuData = null;
  }
  /**
   * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}
   * and passed to the constructor.
   *
   * - The default is `(0,0)`, this means the sprite's origin is the top left.
   * - Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
   * - Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
   *
   * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
   * @example
   * ```ts
   * // Center the anchor point
   * sprite.anchor = 0.5; // Sets both x and y to 0.5
   * sprite.position.set(400, 300); // Sprite will be centered at this position
   *
   * // Set specific x/y anchor points
   * sprite.anchor = {
   *     x: 1, // Right edge
   *     y: 0  // Top edge
   * };
   *
   * // Using individual coordinates
   * sprite.anchor.set(0.5, 1); // Center-bottom
   *
   * // For rotation around center
   * sprite.anchor.set(0.5);
   * sprite.rotation = Math.PI / 4; // 45 degrees around center
   *
   * // For scaling from center
   * sprite.anchor.set(0.5);
   * sprite.scale.set(2); // Scales from center point
   * ```
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(e) {
    typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
  }
  /**
   * The width of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set width directly
   * sprite.width = 200;
   * console.log(sprite.scale.x); // Scale adjusted to match width
   *
   * // Set width while preserving aspect ratio
   * const ratio = sprite.height / sprite.width;
   * sprite.width = 300;
   * sprite.height = 300 * ratio;
   *
   * // For better performance when setting both width and height
   * sprite.setSize(300, 400); // Avoids recalculating bounds twice
   *
   * // Reset to original texture size
   * sprite.width = sprite.texture.orig.width;
   * ```
   */
  get width() {
    return Math.abs(this.scale.x) * this._texture.orig.width;
  }
  set width(e) {
    this._setWidth(e, this._texture.orig.width), this._width = e;
  }
  /**
   * The height of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set height directly
   * sprite.height = 150;
   * console.log(sprite.scale.y); // Scale adjusted to match height
   *
   * // Set height while preserving aspect ratio
   * const ratio = sprite.width / sprite.height;
   * sprite.height = 200;
   * sprite.width = 200 * ratio;
   *
   * // For better performance when setting both width and height
   * sprite.setSize(300, 400); // Avoids recalculating bounds twice
   *
   * // Reset to original texture size
   * sprite.height = sprite.texture.orig.height;
   * ```
   */
  get height() {
    return Math.abs(this.scale.y) * this._texture.orig.height;
  }
  set height(e) {
    this._setHeight(e, this._texture.orig.height), this._height = e;
  }
  /**
   * Retrieves the size of the Sprite as a [Size]{@link Size} object based on the texture dimensions and scale.
   * This is faster than getting width and height separately as it only calculates the bounds once.
   * @example
   * ```ts
   * // Basic size retrieval
   * const sprite = new Sprite(Texture.from('sprite.png'));
   * const size = sprite.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * sprite.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in, to avoid allocating a new object
   * @returns The size of the Sprite
   * @see {@link Sprite#width} For getting just the width
   * @see {@link Sprite#height} For getting just the height
   * @see {@link Sprite#setSize} For setting both width and height
   */
  getSize(e) {
    return e || (e = {}), e.width = Math.abs(this.scale.x) * this._texture.orig.width, e.height = Math.abs(this.scale.y) * this._texture.orig.height, e;
  }
  /**
   * Sets the size of the Sprite to the specified width and height.
   * This is faster than setting width and height separately as it only recalculates bounds once.
   * @example
   * ```ts
   * // Basic size setting
   * const sprite = new Sprite(Texture.from('sprite.png'));
   * sprite.setSize(100, 200); // Width: 100, Height: 200
   *
   * // Set uniform size
   * sprite.setSize(100); // Sets both width and height to 100
   *
   * // Set size with object
   * sprite.setSize({
   *     width: 200,
   *     height: 300
   * });
   *
   * // Reset to texture size
   * sprite.setSize(
   *     sprite.texture.orig.width,
   *     sprite.texture.orig.height
   * );
   * ```
   * @param value - This can be either a number or a {@link Size} object
   * @param height - The height to set. Defaults to the value of `width` if not provided
   * @see {@link Sprite#width} For setting width only
   * @see {@link Sprite#height} For setting height only
   * @see {@link Sprite#texture} For the source dimensions
   */
  setSize(e, t) {
    typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, this._texture.orig.width), t !== void 0 && this._setHeight(t, this._texture.orig.height);
  }
}
const p2 = new it();
function Pp(i, e, t) {
  const s = p2;
  i.measurable = !0, Cp(i, t, s), e.addBoundsMask(s), i.measurable = !1;
}
function Up(i, e, t) {
  const s = vt.get();
  i.measurable = !0;
  const r = Ue.get().identity(), n = Rp(i, t, r);
  kp(i, s, n), i.measurable = !1, e.addBoundsMask(s), Ue.return(r), vt.return(s);
}
function Rp(i, e, t) {
  return i ? (i !== e && (Rp(i.parent, e, t), i.updateLocalTransform(), t.append(i.localTransform)), t) : (se("Mask bounds, renderable is not inside the root container"), t);
}
class Bp {
  constructor(e) {
    this.priority = 0, this.inverse = !1, this.pipe = "alphaMask", e?.mask && this.init(e.mask);
  }
  init(e) {
    this.mask = e, this.renderMaskToTexture = !(e instanceof Me), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = !1;
  }
  reset() {
    this.mask !== null && (this.mask.measurable = !0, this.mask = null);
  }
  addBounds(e, t) {
    this.inverse || Pp(this.mask, e, t);
  }
  addLocalBounds(e, t) {
    Up(this.mask, e, t);
  }
  containsPoint(e, t) {
    const s = this.mask;
    return t(s, e);
  }
  destroy() {
    this.reset();
  }
  static test(e) {
    return e instanceof Me;
  }
}
Bp.extension = O.MaskEffect;
class zp {
  constructor(e) {
    this.priority = 0, this.pipe = "colorMask", e?.mask && this.init(e.mask);
  }
  init(e) {
    this.mask = e;
  }
  destroy() {
  }
  static test(e) {
    return typeof e == "number";
  }
}
zp.extension = O.MaskEffect;
class Op {
  constructor(e) {
    this.priority = 0, this.pipe = "stencilMask", e?.mask && this.init(e.mask);
  }
  init(e) {
    this.mask = e, this.mask.includeInBuild = !1, this.mask.measurable = !1;
  }
  reset() {
    this.mask !== null && (this.mask.measurable = !0, this.mask.includeInBuild = !0, this.mask = null);
  }
  addBounds(e, t) {
    Pp(this.mask, e, t);
  }
  addLocalBounds(e, t) {
    Up(this.mask, e, t);
  }
  containsPoint(e, t) {
    const s = this.mask;
    return t(s, e);
  }
  destroy() {
    this.reset();
  }
  static test(e) {
    return e instanceof oe;
  }
}
Op.extension = O.MaskEffect;
const m2 = {
  createCanvas: (i, e) => {
    const t = document.createElement("canvas");
    return t.width = i, t.height = e, t;
  },
  createImage: () => new Image(),
  getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
  getWebGLRenderingContext: () => WebGLRenderingContext,
  getNavigator: () => navigator,
  getBaseUrl: () => document.baseURI ?? window.location.href,
  getFontFaceSet: () => document.fonts,
  fetch: (i, e) => fetch(i, e),
  parseXML: (i) => new DOMParser().parseFromString(i, "text/xml")
};
let Qu = m2;
const re = {
  /**
   * Returns the current adapter.
   * @returns {environment.Adapter} The current adapter.
   */
  get() {
    return Qu;
  },
  /**
   * Sets the current adapter.
   * @param adapter - The new adapter.
   */
  set(i) {
    Qu = i;
  }
};
class Dp extends Ke {
  constructor(e) {
    e.resource || (e.resource = re.get().createCanvas()), e.width || (e.width = e.resource.width, e.autoDensity || (e.width /= e.resolution)), e.height || (e.height = e.resource.height, e.autoDensity || (e.height /= e.resolution)), super(e), this.uploadMethodId = "image", this.autoDensity = e.autoDensity, this.resizeCanvas(), this.transparent = !!e.transparent;
  }
  resizeCanvas() {
    this.autoDensity && "style" in this.resource && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight);
  }
  resize(e = this.width, t = this.height, s = this._resolution) {
    const r = super.resize(e, t, s);
    return r && this.resizeCanvas(), r;
  }
  static test(e) {
    return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && e instanceof OffscreenCanvas;
  }
  /**
   * Returns the 2D rendering context for the canvas.
   * Caches the context after creating it.
   * @returns The 2D rendering context of the canvas.
   */
  get context2D() {
    return this._context2D || (this._context2D = this.resource.getContext("2d"));
  }
}
Dp.extension = O.TextureSource;
class ft extends Ke {
  constructor(e) {
    super(e), this.uploadMethodId = "image", this.autoGarbageCollect = !0;
  }
  static test(e) {
    return globalThis.HTMLImageElement && e instanceof HTMLImageElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap || globalThis.VideoFrame && e instanceof VideoFrame;
  }
}
ft.extension = O.TextureSource;
var Ph = /* @__PURE__ */ ((i) => (i[i.INTERACTION = 50] = "INTERACTION", i[i.HIGH = 25] = "HIGH", i[i.NORMAL = 0] = "NORMAL", i[i.LOW = -25] = "LOW", i[i.UTILITY = -50] = "UTILITY", i))(Ph || {});
class Wc {
  /**
   * Constructor
   * @private
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting
   * @param once - If the handler should fire once
   */
  constructor(e, t = null, s = 0, r = !1) {
    this.next = null, this.previous = null, this._destroyed = !1, this._fn = e, this._context = t, this.priority = s, this._once = r;
  }
  /**
   * Simple compare function to figure out if a function and context match.
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @returns `true` if the listener match the arguments
   */
  match(e, t = null) {
    return this._fn === e && this._context === t;
  }
  /**
   * Emit by calling the current function.
   * @param ticker - The ticker emitting.
   * @returns Next ticker
   */
  emit(e) {
    this._fn && (this._context ? this._fn.call(this._context, e) : this._fn(e));
    const t = this.next;
    return this._once && this.destroy(!0), this._destroyed && (this.next = null), t;
  }
  /**
   * Connect to the list.
   * @param previous - Input node, previous listener
   */
  connect(e) {
    this.previous = e, e.next && (e.next.previous = this), this.next = e.next, e.next = this;
  }
  /**
   * Destroy and don't use after this.
   * @param hard - `true` to remove the `next` reference, this
   *        is considered a hard destroy. Soft destroy maintains the next reference.
   * @returns The listener to redirect while emitting or removing.
   */
  destroy(e = !1) {
    this._destroyed = !0, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
    const t = this.next;
    return this.next = e ? null : t, this.previous = null, t;
  }
}
const Lp = class Le {
  constructor() {
    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new Wc(null, null, 1 / 0), this.deltaMS = 1 / Le.targetFPMS, this.elapsedMS = 1 / Le.targetFPMS, this._tick = (e) => {
      this._requestId = null, this.started && (this.update(e), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
    };
  }
  /**
   * Conditionally requests a new animation frame.
   * If a frame has not already been requested, and if the internal
   * emitter has listeners, a new frame is requested.
   */
  _requestIfNeeded() {
    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
  }
  /** Conditionally cancels a pending animation frame. */
  _cancelIfNeeded() {
    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
  }
  /**
   * Conditionally requests a new animation frame.
   * If the ticker has been started it checks if a frame has not already
   * been requested, and if the internal emitter has listeners. If these
   * conditions are met, a new frame is requested. If the ticker has not
   * been started, but autoStart is `true`, then the ticker starts now,
   * and continues with the previous conditions to request a new frame.
   */
  _startIfPossible() {
    this.started ? this._requestIfNeeded() : this.autoStart && this.start();
  }
  /**
   * Register a handler for tick events.
   * @param fn - The listener function to add. Receives the Ticker instance as parameter
   * @param context - The context for the listener
   * @param priority - The priority of the listener
   * @example
   * ```ts
   * // Access time properties through the ticker parameter
   * ticker.add((ticker) => {
   *     // Use deltaTime (dimensionless scalar) for frame-independent animations
   *     sprite.rotation += 0.1 * ticker.deltaTime;
   *
   *     // Use deltaMS (milliseconds) for time-based calculations
   *     const progress = ticker.deltaMS / animationDuration;
   *
   *     // Use elapsedMS for raw timing measurements
   *     console.log(`Raw frame time: ${ticker.elapsedMS}ms`);
   * });
   * ```
   */
  add(e, t, s = Ph.NORMAL) {
    return this._addListener(new Wc(e, t, s));
  }
  /**
   * Add a handler for the tick event which is only executed once on the next frame.
   * @example
   * ```ts
   * // Basic one-time update
   * ticker.addOnce(() => {
   *     console.log('Runs next frame only');
   * });
   *
   * // With specific context
   * const game = {
   *     init(ticker) {
   *         this.loadResources();
   *         console.log('Game initialized');
   *     }
   * };
   * ticker.addOnce(game.init, game);
   *
   * // With priority
   * ticker.addOnce(
   *     () => {
   *         // High priority one-time setup
   *         physics.init();
   *     },
   *     undefined,
   *     UPDATE_PRIORITY.HIGH
   * );
   * ```
   * @param fn - The listener function to be added for one update
   * @param context - The listener context
   * @param priority - The priority for emitting (default: UPDATE_PRIORITY.NORMAL)
   * @returns This instance of a ticker
   * @see {@link Ticker#add} For continuous updates
   * @see {@link Ticker#remove} For removing handlers
   */
  addOnce(e, t, s = Ph.NORMAL) {
    return this._addListener(new Wc(e, t, s, !0));
  }
  /**
   * Internally adds the event handler so that it can be sorted by priority.
   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
   * before the rendering.
   * @private
   * @param listener - Current listener being added.
   * @returns This instance of a ticker
   */
  _addListener(e) {
    let t = this._head.next, s = this._head;
    if (!t)
      e.connect(s);
    else {
      for (; t; ) {
        if (e.priority > t.priority) {
          e.connect(s);
          break;
        }
        s = t, t = t.next;
      }
      e.previous || e.connect(s);
    }
    return this._startIfPossible(), this;
  }
  /**
   * Removes any handlers matching the function and context parameters.
   * If no handlers are left after removing, then it cancels the animation frame.
   * @example
   * ```ts
   * // Basic removal
   * const onTick = () => {
   *     sprite.rotation += 0.1;
   * };
   * ticker.add(onTick);
   * ticker.remove(onTick);
   *
   * // Remove with context
   * const game = {
   *     update(ticker) {
   *         this.physics.update(ticker.deltaTime);
   *     }
   * };
   * ticker.add(game.update, game);
   * ticker.remove(game.update, game);
   *
   * // Remove all matching handlers
   * // (if same function was added multiple times)
   * ticker.add(onTick);
   * ticker.add(onTick);
   * ticker.remove(onTick); // Removes all instances
   * ```
   * @param fn - The listener function to be removed
   * @param context - The listener context to be removed
   * @returns This instance of a ticker
   * @see {@link Ticker#add} For adding handlers
   * @see {@link Ticker#addOnce} For one-time handlers
   */
  remove(e, t) {
    let s = this._head.next;
    for (; s; )
      s.match(e, t) ? s = s.destroy() : s = s.next;
    return this._head.next || this._cancelIfNeeded(), this;
  }
  /**
   * The number of listeners on this ticker, calculated by walking through linked list.
   * @example
   * ```ts
   * // Check number of active listeners
   * const ticker = new Ticker();
   * console.log(ticker.count); // 0
   *
   * // Add some listeners
   * ticker.add(() => {});
   * ticker.add(() => {});
   * console.log(ticker.count); // 2
   *
   * // Check after cleanup
   * ticker.destroy();
   * console.log(ticker.count); // 0
   * ```
   * @readonly
   * @see {@link Ticker#add} For adding listeners
   * @see {@link Ticker#remove} For removing listeners
   */
  get count() {
    if (!this._head)
      return 0;
    let e = 0, t = this._head;
    for (; t = t.next; )
      e++;
    return e;
  }
  /**
   * Starts the ticker. If the ticker has listeners a new animation frame is requested at this point.
   * @example
   * ```ts
   * // Basic manual start
   * const ticker = new Ticker();
   * ticker.add(() => {
   *     // Animation code here
   * });
   * ticker.start();
   * ```
   * @see {@link Ticker#stop} For stopping the ticker
   * @see {@link Ticker#autoStart} For automatic starting
   * @see {@link Ticker#started} For checking ticker state
   */
  start() {
    this.started || (this.started = !0, this._requestIfNeeded());
  }
  /**
   * Stops the ticker. If the ticker has requested an animation frame it is canceled at this point.
   * @example
   * ```ts
   * // Basic stop
   * const ticker = new Ticker();
   * ticker.stop();
   * ```
   * @see {@link Ticker#start} For starting the ticker
   * @see {@link Ticker#started} For checking ticker state
   * @see {@link Ticker#destroy} For cleaning up the ticker
   */
  stop() {
    this.started && (this.started = !1, this._cancelIfNeeded());
  }
  /**
   * Destroy the ticker and don't use after this. Calling this method removes all references to internal events.
   * @example
   * ```ts
   * // Clean up with active listeners
   * const ticker = new Ticker();
   * ticker.add(() => {});
   * ticker.destroy(); // Removes all listeners
   * ```
   * @see {@link Ticker#stop} For stopping without destroying
   * @see {@link Ticker#remove} For removing specific listeners
   */
  destroy() {
    if (!this._protected) {
      this.stop();
      let e = this._head.next;
      for (; e; )
        e = e.destroy(!0);
      this._head.destroy(), this._head = null;
    }
  }
  /**
   * Triggers an update.
   *
   * An update entails setting the
   * current {@link Ticker#elapsedMS|elapsedMS},
   * the current {@link Ticker#deltaTime|deltaTime},
   * invoking all listeners with current deltaTime,
   * and then finally setting {@link Ticker#lastTime|lastTime}
   * with the value of currentTime that was provided.
   *
   * This method will be called automatically by animation
   * frame callbacks if the ticker instance has been started
   * and listeners are added.
   * @example
   * ```ts
   * // Basic manual update
   * const ticker = new Ticker();
   * ticker.update(performance.now());
   * ```
   * @param currentTime - The current time of execution (defaults to performance.now())
   * @see {@link Ticker#deltaTime} For frame delta value
   * @see {@link Ticker#elapsedMS} For raw elapsed time
   */
  update(e = performance.now()) {
    let t;
    if (e > this.lastTime) {
      if (t = this.elapsedMS = e - this.lastTime, t > this._maxElapsedMS && (t = this._maxElapsedMS), t *= this.speed, this._minElapsedMS) {
        const n = e - this._lastFrame | 0;
        if (n < this._minElapsedMS)
          return;
        this._lastFrame = e - n % this._minElapsedMS;
      }
      this.deltaMS = t, this.deltaTime = this.deltaMS * Le.targetFPMS;
      const s = this._head;
      let r = s.next;
      for (; r; )
        r = r.emit(this);
      s.next || this._cancelIfNeeded();
    } else
      this.deltaTime = this.deltaMS = this.elapsedMS = 0;
    this.lastTime = e;
  }
  /**
   * The frames per second at which this ticker is running.
   * The default is approximately 60 in most modern browsers.
   * > [!NOTE] This does not factor in the value of
   * > {@link Ticker#speed|speed}, which is specific
   * > to scaling {@link Ticker#deltaTime|deltaTime}.
   * @example
   * ```ts
   * // Basic FPS monitoring
   * ticker.add(() => {
   *     console.log(`Current FPS: ${Math.round(ticker.FPS)}`);
   * });
   * ```
   * @readonly
   */
  get FPS() {
    return 1e3 / this.elapsedMS;
  }
  /**
   * Manages the maximum amount of milliseconds allowed to
   * elapse between invoking {@link Ticker#update|update}.
   *
   * This value is used to cap {@link Ticker#deltaTime|deltaTime},
   * but does not effect the measured value of {@link Ticker#FPS|FPS}.
   *
   * When setting this property it is clamped to a value between
   * `0` and `Ticker.targetFPMS * 1000`.
   * @example
   * ```ts
   * // Set minimum acceptable frame rate
   * const ticker = new Ticker();
   * ticker.minFPS = 30; // Never go below 30 FPS
   *
   * // Use with maxFPS for frame rate clamping
   * ticker.minFPS = 30;
   * ticker.maxFPS = 60;
   *
   * // Monitor delta capping
   * ticker.add(() => {
   *     // Delta time will be capped based on minFPS
   *     console.log(`Delta time: ${ticker.deltaTime}`);
   * });
   * ```
   * @default 10
   */
  get minFPS() {
    return 1e3 / this._maxElapsedMS;
  }
  set minFPS(e) {
    const t = Math.min(this.maxFPS, e), s = Math.min(Math.max(0, t) / 1e3, Le.targetFPMS);
    this._maxElapsedMS = 1 / s;
  }
  /**
   * Manages the minimum amount of milliseconds required to
   * elapse between invoking {@link Ticker#update|update}.
   *
   * This will effect the measured value of {@link Ticker#FPS|FPS}.
   *
   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
   * Otherwise it will be at least `minFPS`
   * @example
   * ```ts
   * // Set minimum acceptable frame rate
   * const ticker = new Ticker();
   * ticker.maxFPS = 60; // Never go above 60 FPS
   *
   * // Use with maxFPS for frame rate clamping
   * ticker.minFPS = 30;
   * ticker.maxFPS = 60;
   *
   * // Monitor delta capping
   * ticker.add(() => {
   *     // Delta time will be capped based on maxFPS
   *     console.log(`Delta time: ${ticker.deltaTime}`);
   * });
   * ```
   * @default 0
   */
  get maxFPS() {
    return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
  }
  set maxFPS(e) {
    if (e === 0)
      this._minElapsedMS = 0;
    else {
      const t = Math.max(this.minFPS, e);
      this._minElapsedMS = 1 / (t / 1e3);
    }
  }
  /**
   * The shared ticker instance used by {@link AnimatedSprite} and by
   * {@link VideoSource} to update animation frames / video textures.
   *
   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.
   *
   * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.
   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
   * @example
   * import { Ticker } from 'pixi.js';
   *
   * const ticker = Ticker.shared;
   * // Set this to prevent starting this ticker when listeners are added.
   * // By default this is true only for the Ticker.shared instance.
   * ticker.autoStart = false;
   *
   * // FYI, call this to ensure the ticker is stopped. It should be stopped
   * // if you have not attempted to render anything yet.
   * ticker.stop();
   *
   * // Call this when you are ready for a running shared ticker.
   * ticker.start();
   * @example
   * import { autoDetectRenderer, Container } from 'pixi.js';
   *
   * // You may use the shared ticker to render...
   * const renderer = autoDetectRenderer();
   * const stage = new Container();
   * document.body.appendChild(renderer.view);
   * ticker.add((time) => renderer.render(stage));
   *
   * // Or you can just update it manually.
   * ticker.autoStart = false;
   * ticker.stop();
   * const animate = (time) => {
   *     ticker.update(time);
   *     renderer.render(stage);
   *     requestAnimationFrame(animate);
   * };
   * animate(performance.now());
   * @type {Ticker}
   * @readonly
   */
  static get shared() {
    if (!Le._shared) {
      const e = Le._shared = new Le();
      e.autoStart = !0, e._protected = !0;
    }
    return Le._shared;
  }
  /**
   * The system ticker instance used by {@link PrepareBase} for core timing
   * functionality that shouldn't usually need to be paused, unlike the `shared`
   * ticker which drives visual animations and rendering which may want to be paused.
   *
   * The property {@link Ticker#autoStart|autoStart} is set to `true` for this instance.
   * @type {Ticker}
   * @readonly
   * @advanced
   */
  static get system() {
    if (!Le._system) {
      const e = Le._system = new Le();
      e.autoStart = !0, e._protected = !0;
    }
    return Le._system;
  }
};
Lp.targetFPMS = 0.06;
let zi = Lp, Vc;
async function Np() {
  return Vc ?? (Vc = (async () => {
    const e = re.get().createCanvas(1, 1).getContext("webgl");
    if (!e)
      return "premultiply-alpha-on-upload";
    const t = await new Promise((o) => {
      const a = document.createElement("video");
      a.onloadeddata = () => o(a), a.onerror = () => o(null), a.autoplay = !1, a.crossOrigin = "anonymous", a.preload = "auto", a.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", a.load();
    });
    if (!t)
      return "premultiply-alpha-on-upload";
    const s = e.createTexture();
    e.bindTexture(e.TEXTURE_2D, s);
    const r = e.createFramebuffer();
    e.bindFramebuffer(e.FRAMEBUFFER, r), e.framebufferTexture2D(
      e.FRAMEBUFFER,
      e.COLOR_ATTACHMENT0,
      e.TEXTURE_2D,
      s,
      0
    ), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t);
    const n = new Uint8Array(4);
    return e.readPixels(0, 0, 1, 1, e.RGBA, e.UNSIGNED_BYTE, n), e.deleteFramebuffer(r), e.deleteTexture(s), e.getExtension("WEBGL_lose_context")?.loseContext(), n[0] <= n[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload";
  })()), Vc;
}
const fr = class Gp extends Ke {
  constructor(e) {
    super(e), this.isReady = !1, this.uploadMethodId = "video", e = {
      ...Gp.defaultOptions,
      ...e
    }, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = e.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = e.autoPlay !== !1, this.alphaMode = e.alphaMode ?? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), e.autoLoad !== !1 && this.load();
  }
  /** Update the video frame if the source is not destroyed and meets certain conditions. */
  updateFrame() {
    if (!this.destroyed) {
      if (this._updateFPS) {
        const e = zi.shared.elapsedMS * this.resource.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - e);
      }
      (!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update();
    }
  }
  /** Callback to update the video frame and potentially request the next frame update. */
  _videoFrameRequestCallback() {
    this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
      this._videoFrameRequestCallback
    );
  }
  /**
   * Checks if the resource has valid dimensions.
   * @returns {boolean} True if width and height are set, otherwise false.
   */
  get isValid() {
    return !!this.resource.videoWidth && !!this.resource.videoHeight;
  }
  /**
   * Start preloading the video resource.
   * @returns {Promise<this>} Handle the validate event
   */
  async load() {
    if (this._load)
      return this._load;
    const e = this.resource, t = this.options;
    return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener("play", this._onPlayStart), e.addEventListener("pause", this._onPlayStop), e.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (t.preload || e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlayThrough), e.addEventListener("error", this._onError, !0)), this.alphaMode = await Np(), this._load = new Promise((s, r) => {
      this.isValid ? s(this) : (this._resolve = s, this._reject = r, t.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(() => {
        this._onError(new ErrorEvent(`Preload exceeded timeout of ${t.preloadTimeoutMs}ms`));
      })), e.load());
    }), this._load;
  }
  /**
   * Handle video error events.
   * @param event - The error event
   */
  _onError(e) {
    this.resource.removeEventListener("error", this._onError, !0), this.emit("error", e), this._reject && (this._reject(e), this._reject = null, this._resolve = null);
  }
  /**
   * Checks if the underlying source is playing.
   * @returns True if playing.
   */
  _isSourcePlaying() {
    const e = this.resource;
    return !e.paused && !e.ended;
  }
  /**
   * Checks if the underlying source is ready for playing.
   * @returns True if ready.
   */
  _isSourceReady() {
    return this.resource.readyState > 2;
  }
  /** Runs the update loop when the video is ready to play. */
  _onPlayStart() {
    this.isValid || this._mediaReady(), this._configureAutoUpdate();
  }
  /** Stops the update loop when a pause event is triggered. */
  _onPlayStop() {
    this._configureAutoUpdate();
  }
  /** Handles behavior when the video completes seeking to the current playback position. */
  _onSeeked() {
    this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0);
  }
  _onCanPlay() {
    this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady();
  }
  _onCanPlayThrough() {
    this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady();
  }
  /** Fired when the video is loaded and ready to play. */
  _mediaReady() {
    const e = this.resource;
    this.isValid && (this.isReady = !0, this.resize(e.videoWidth, e.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
  }
  /** Cleans up resources and event listeners associated with this texture. */
  destroy() {
    this._configureAutoUpdate();
    const e = this.resource;
    e && (e.removeEventListener("play", this._onPlayStart), e.removeEventListener("pause", this._onPlayStop), e.removeEventListener("seeked", this._onSeeked), e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlayThrough), e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), super.destroy();
  }
  /** Should the base texture automatically update itself, set to true by default. */
  get autoUpdate() {
    return this._autoUpdate;
  }
  set autoUpdate(e) {
    e !== this._autoUpdate && (this._autoUpdate = e, this._configureAutoUpdate());
  }
  /**
   * How many times a second to update the texture from the video.
   * Leave at 0 to update at every render.
   * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
   */
  get updateFPS() {
    return this._updateFPS;
  }
  set updateFPS(e) {
    e !== this._updateFPS && (this._updateFPS = e, this._configureAutoUpdate());
  }
  /**
   * Configures the updating mechanism based on the current state and settings.
   *
   * This method decides between using the browser's native video frame callback or a custom ticker
   * for updating the video frame. It ensures optimal performance and responsiveness
   * based on the video's state, playback status, and the desired frames-per-second setting.
   *
   * - If `_autoUpdate` is enabled and the video source is playing:
   *   - It will prefer the native video frame callback if available and no specific FPS is set.
   *   - Otherwise, it will use a custom ticker for manual updates.
   * - If `_autoUpdate` is disabled or the video isn't playing, any active update mechanisms are halted.
   */
  _configureAutoUpdate() {
    this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (zi.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(
      this._videoFrameRequestCallback
    ))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (zi.shared.add(this.updateFrame, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (zi.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0));
  }
  static test(e) {
    return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement;
  }
};
fr.extension = O.TextureSource;
fr.defaultOptions = {
  ...Ke.defaultOptions,
  /** If true, the video will start loading immediately. */
  autoLoad: !0,
  /** If true, the video will start playing as soon as it is loaded. */
  autoPlay: !0,
  /** The number of times a second to update the texture from the video. Leave at 0 to update at every render. */
  updateFPS: 0,
  /** If true, the video will be loaded with the `crossorigin` attribute. */
  crossorigin: !0,
  /** If true, the video will loop when it ends. */
  loop: !1,
  /** If true, the video will be muted. */
  muted: !0,
  /** If true, the video will play inline. */
  playsinline: !0,
  /** If true, the video will be preloaded. */
  preload: !1
};
fr.MIME_TYPES = {
  ogv: "video/ogg",
  mov: "video/quicktime",
  m4v: "video/mp4"
};
let Xi = fr;
const Qe = (i, e, t = !1) => (Array.isArray(i) || (i = [i]), e ? i.map((s) => typeof s == "string" || t ? e(s) : s) : i);
class g2 {
  constructor() {
    this._parsers = [], this._cache = /* @__PURE__ */ new Map(), this._cacheMap = /* @__PURE__ */ new Map();
  }
  /** Clear all entries. */
  reset() {
    this._cacheMap.clear(), this._cache.clear();
  }
  /**
   * Check if the key exists
   * @param key - The key to check
   */
  has(e) {
    return this._cache.has(e);
  }
  /**
   * Fetch entry by key
   * @param key - The key of the entry to get
   */
  get(e) {
    const t = this._cache.get(e);
    return t || se(`[Assets] Asset id ${e} was not found in the Cache`), t;
  }
  /**
   * Set a value by key or keys name
   * @param key - The key or keys to set
   * @param value - The value to store in the cache or from which cacheable assets will be derived.
   */
  set(e, t) {
    const s = Qe(e);
    let r;
    for (let l = 0; l < this.parsers.length; l++) {
      const c = this.parsers[l];
      if (c.test(t)) {
        r = c.getCacheableAssets(s, t);
        break;
      }
    }
    const n = new Map(Object.entries(r || {}));
    r || s.forEach((l) => {
      n.set(l, t);
    });
    const o = [...n.keys()], a = {
      cacheKeys: o,
      keys: s
    };
    s.forEach((l) => {
      this._cacheMap.set(l, a);
    }), o.forEach((l) => {
      const c = r ? r[l] : t;
      this._cache.has(l) && this._cache.get(l) !== c && se("[Cache] already has key:", l), this._cache.set(l, n.get(l));
    });
  }
  /**
   * Remove entry by key
   *
   * This function will also remove any associated alias from the cache also.
   * @param key - The key of the entry to remove
   */
  remove(e) {
    if (!this._cacheMap.has(e)) {
      se(`[Assets] Asset id ${e} was not found in the Cache`);
      return;
    }
    const t = this._cacheMap.get(e);
    t.cacheKeys.forEach((r) => {
      this._cache.delete(r);
    }), t.keys.forEach((r) => {
      this._cacheMap.delete(r);
    });
  }
  /**
   * All loader parsers registered
   * @advanced
   */
  get parsers() {
    return this._parsers;
  }
}
const ne = new g2(), Uh = [];
ke.handleByList(O.TextureSource, Uh);
function Hp(i = {}) {
  const e = i && i.resource, t = e ? i.resource : i, s = e ? i : { resource: i };
  for (let r = 0; r < Uh.length; r++) {
    const n = Uh[r];
    if (n.test(t))
      return new n(s);
  }
  throw new Error(`Could not find a source type for resource: ${s.resource}`);
}
function x2(i = {}, e = !1) {
  const t = i && i.resource, s = t ? i.resource : i, r = t ? i : { resource: i };
  if (!e && ne.has(s))
    return ne.get(s);
  const n = new L({ source: Hp(r) });
  return n.on("destroy", () => {
    ne.has(s) && ne.remove(s);
  }), e || ne.set(s, n), n;
}
function y2(i, e = !1) {
  return typeof i == "string" ? ne.get(i) : i instanceof Ke ? new L({ source: i }) : x2(i, e);
}
L.from = y2;
Ke.from = Hp;
ke.add(Bp, zp, Op, Xi, ft, Dp, nu);
var Et = /* @__PURE__ */ ((i) => (i[i.Low = 0] = "Low", i[i.Normal = 1] = "Normal", i[i.High = 2] = "High", i))(Et || {});
function je(i) {
  if (typeof i != "string")
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(i)}`);
}
function Si(i) {
  return i.split("?")[0].split("#")[0];
}
function v2(i) {
  return i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function _2(i, e, t) {
  return i.replace(new RegExp(v2(e), "g"), t);
}
function b2(i, e) {
  let t = "", s = 0, r = -1, n = 0, o = -1;
  for (let a = 0; a <= i.length; ++a) {
    if (a < i.length)
      o = i.charCodeAt(a);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(r === a - 1 || n === 1)) if (r !== a - 1 && n === 2) {
        if (t.length < 2 || s !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {
          if (t.length > 2) {
            const l = t.lastIndexOf("/");
            if (l !== t.length - 1) {
              l === -1 ? (t = "", s = 0) : (t = t.slice(0, l), s = t.length - 1 - t.lastIndexOf("/")), r = a, n = 0;
              continue;
            }
          } else if (t.length === 2 || t.length === 1) {
            t = "", s = 0, r = a, n = 0;
            continue;
          }
        }
      } else
        t.length > 0 ? t += `/${i.slice(r + 1, a)}` : t = i.slice(r + 1, a), s = a - r - 1;
      r = a, n = 0;
    } else o === 46 && n !== -1 ? ++n : n = -1;
  }
  return t;
}
const He = {
  /**
   * Converts a path to posix format.
   * @param path - The path to convert to posix
   * @example
   * ```ts
   * // Convert a Windows path to POSIX format
   * path.toPosix('C:\\Users\\User\\Documents\\file.txt');
   * // -> 'C:/Users/User/Documents/file.txt'
   * ```
   */
  toPosix(i) {
    return _2(i, "\\", "/");
  },
  /**
   * Checks if the path is a URL e.g. http://, https://
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path is a URL
   * path.isUrl('http://www.example.com');
   * // -> true
   * path.isUrl('C:/Users/User/Documents/file.txt');
   * // -> false
   * ```
   */
  isUrl(i) {
    return /^https?:/.test(this.toPosix(i));
  },
  /**
   * Checks if the path is a data URL
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path is a data URL
   * path.isDataUrl('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUA...');
   * // -> true
   * ```
   */
  isDataUrl(i) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(i);
  },
  /**
   * Checks if the path is a blob URL
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path is a blob URL
   * path.isBlobUrl('blob:http://www.example.com/12345678-1234-1234-1234-123456789012');
   * // -> true
   * ```
   */
  isBlobUrl(i) {
    return i.startsWith("blob:");
  },
  /**
   * Checks if the path has a protocol e.g. http://, https://, file:///, data:, blob:, C:/
   * This will return true for windows file paths
   * @param path - The path to check
   * @example
   * ```ts
   * // Check if a path has a protocol
   * path.hasProtocol('http://www.example.com');
   * // -> true
   * path.hasProtocol('C:/Users/User/Documents/file.txt');
   * // -> true
   * ```
   */
  hasProtocol(i) {
    return /^[^/:]+:/.test(this.toPosix(i));
  },
  /**
   * Returns the protocol of the path e.g. http://, https://, file:///, data:, blob:, C:/
   * @param path - The path to get the protocol from
   * @example
   * ```ts
   * // Get the protocol from a URL
   * path.getProtocol('http://www.example.com/path/to/resource');
   * // -> 'http://'
   * // Get the protocol from a file path
   * path.getProtocol('C:/Users/User/Documents/file.txt');
   * // -> 'C:/'
   * ```
   */
  getProtocol(i) {
    je(i), i = this.toPosix(i);
    const e = /^file:\/\/\//.exec(i);
    if (e)
      return e[0];
    const t = /^[^/:]+:\/{0,2}/.exec(i);
    return t ? t[0] : "";
  },
  /**
   * Converts URL to an absolute path.
   * When loading from a Web Worker, we must use absolute paths.
   * If the URL is already absolute we return it as is
   * If it's not, we convert it
   * @param url - The URL to test
   * @param customBaseUrl - The base URL to use
   * @param customRootUrl - The root URL to use
   * @example
   * ```ts
   * // Convert a relative URL to an absolute path
   * path.toAbsolute('images/texture.png', 'http://example.com/assets/');
   * // -> 'http://example.com/assets/images/texture.png'
   * ```
   */
  toAbsolute(i, e, t) {
    if (je(i), this.isDataUrl(i) || this.isBlobUrl(i))
      return i;
    const s = Si(this.toPosix(e ?? re.get().getBaseUrl())), r = Si(this.toPosix(t ?? this.rootname(s)));
    return i = this.toPosix(i), i.startsWith("/") ? He.join(r, i.slice(1)) : this.isAbsolute(i) ? i : this.join(s, i);
  },
  /**
   * Normalizes the given path, resolving '..' and '.' segments
   * @param path - The path to normalize
   * @example
   * ```ts
   * // Normalize a path with relative segments
   * path.normalize('http://www.example.com/foo/bar/../baz');
   * // -> 'http://www.example.com/foo/baz'
   * // Normalize a file path with relative segments
   * path.normalize('C:\\Users\\User\\Documents\\..\\file.txt');
   * // -> 'C:/Users/User/file.txt'
   * ```
   */
  normalize(i) {
    if (je(i), i.length === 0)
      return ".";
    if (this.isDataUrl(i) || this.isBlobUrl(i))
      return i;
    i = this.toPosix(i);
    let e = "";
    const t = i.startsWith("/");
    this.hasProtocol(i) && (e = this.rootname(i), i = i.slice(e.length));
    const s = i.endsWith("/");
    return i = b2(i), i.length > 0 && s && (i += "/"), t ? `/${i}` : e + i;
  },
  /**
   * Determines if path is an absolute path.
   * Absolute paths can be urls, data urls, or paths on disk
   * @param path - The path to test
   * @example
   * ```ts
   * // Check if a path is absolute
   * path.isAbsolute('http://www.example.com/foo/bar');
   * // -> true
   * path.isAbsolute('C:/Users/User/Documents/file.txt');
   * // -> true
   * ```
   */
  isAbsolute(i) {
    return je(i), i = this.toPosix(i), this.hasProtocol(i) ? !0 : i.startsWith("/");
  },
  /**
   * Joins all given path segments together using the platform-specific separator as a delimiter,
   * then normalizes the resulting path
   * @param segments - The segments of the path to join
   * @example
   * ```ts
   * // Join multiple path segments
   * path.join('assets', 'images', 'sprite.png');
   * // -> 'assets/images/sprite.png'
   * // Join with relative segments
   * path.join('assets', 'images', '../textures', 'sprite.png');
   * // -> 'assets/textures/sprite.png'
   * ```
   */
  join(...i) {
    if (i.length === 0)
      return ".";
    let e;
    for (let t = 0; t < i.length; ++t) {
      const s = i[t];
      if (je(s), s.length > 0)
        if (e === void 0)
          e = s;
        else {
          const r = i[t - 1] ?? "";
          this.joinExtensions.includes(this.extname(r).toLowerCase()) ? e += `/../${s}` : e += `/${s}`;
        }
    }
    return e === void 0 ? "." : this.normalize(e);
  },
  /**
   * Returns the directory name of a path
   * @param path - The path to parse
   * @example
   * ```ts
   * // Get the directory name of a path
   * path.dirname('http://www.example.com/foo/bar/baz.png');
   * // -> 'http://www.example.com/foo/bar'
   * // Get the directory name of a file path
   * path.dirname('C:/Users/User/Documents/file.txt');
   * // -> 'C:/Users/User/Documents'
   * ```
   */
  dirname(i) {
    if (je(i), i.length === 0)
      return ".";
    i = this.toPosix(i);
    let e = i.charCodeAt(0);
    const t = e === 47;
    let s = -1, r = !0;
    const n = this.getProtocol(i), o = i;
    i = i.slice(n.length);
    for (let a = i.length - 1; a >= 1; --a)
      if (e = i.charCodeAt(a), e === 47) {
        if (!r) {
          s = a;
          break;
        }
      } else
        r = !1;
    return s === -1 ? t ? "/" : this.isUrl(o) ? n + i : n : t && s === 1 ? "//" : n + i.slice(0, s);
  },
  /**
   * Returns the root of the path e.g. /, C:/, file:///, http://domain.com/
   * @param path - The path to parse
   * @example
   * ```ts
   * // Get the root of a URL
   * path.rootname('http://www.example.com/foo/bar/baz.png');
   * // -> 'http://www.example.com/'
   * // Get the root of a file path
   * path.rootname('C:/Users/User/Documents/file.txt');
   * // -> 'C:/'
   * ```
   */
  rootname(i) {
    je(i), i = this.toPosix(i);
    let e = "";
    if (i.startsWith("/") ? e = "/" : e = this.getProtocol(i), this.isUrl(i)) {
      const t = i.indexOf("/", e.length);
      t !== -1 ? e = i.slice(0, t) : e = i, e.endsWith("/") || (e += "/");
    }
    return e;
  },
  /**
   * Returns the last portion of a path
   * @param path - The path to test
   * @param ext - Optional extension to remove
   * @example
   * ```ts
   * // Get the basename of a URL
   * path.basename('http://www.example.com/foo/bar/baz.png');
   * // -> 'baz.png'
   * // Get the basename of a file path
   * path.basename('C:/Users/User/Documents/file.txt');
   * // -> 'file.txt'
   * ```
   */
  basename(i, e) {
    je(i), e && je(e), i = Si(this.toPosix(i));
    let t = 0, s = -1, r = !0, n;
    if (e !== void 0 && e.length > 0 && e.length <= i.length) {
      if (e.length === i.length && e === i)
        return "";
      let o = e.length - 1, a = -1;
      for (n = i.length - 1; n >= 0; --n) {
        const l = i.charCodeAt(n);
        if (l === 47) {
          if (!r) {
            t = n + 1;
            break;
          }
        } else
          a === -1 && (r = !1, a = n + 1), o >= 0 && (l === e.charCodeAt(o) ? --o === -1 && (s = n) : (o = -1, s = a));
      }
      return t === s ? s = a : s === -1 && (s = i.length), i.slice(t, s);
    }
    for (n = i.length - 1; n >= 0; --n)
      if (i.charCodeAt(n) === 47) {
        if (!r) {
          t = n + 1;
          break;
        }
      } else s === -1 && (r = !1, s = n + 1);
    return s === -1 ? "" : i.slice(t, s);
  },
  /**
   * Returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last
   * portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than
   * the first character of the basename of path, an empty string is returned.
   * @param path - The path to parse
   * @example
   * ```ts
   * // Get the extension of a URL
   * path.extname('http://www.example.com/foo/bar/baz.png');
   * // -> '.png'
   * // Get the extension of a file path
   * path.extname('C:/Users/User/Documents/file.txt');
   * // -> '.txt'
   * ```
   */
  extname(i) {
    je(i), i = Si(this.toPosix(i));
    let e = -1, t = 0, s = -1, r = !0, n = 0;
    for (let o = i.length - 1; o >= 0; --o) {
      const a = i.charCodeAt(o);
      if (a === 47) {
        if (!r) {
          t = o + 1;
          break;
        }
        continue;
      }
      s === -1 && (r = !1, s = o + 1), a === 46 ? e === -1 ? e = o : n !== 1 && (n = 1) : e !== -1 && (n = -1);
    }
    return e === -1 || s === -1 || n === 0 || n === 1 && e === s - 1 && e === t + 1 ? "" : i.slice(e, s);
  },
  /**
   * Parses a path into an object containing the 'root', `dir`, `base`, `ext`, and `name` properties.
   * @param path - The path to parse
   * @example
   * ```ts
   * // Parse a URL
   * const parsed = path.parse('http://www.example.com/foo/bar/baz.png');
   * // -> {
   * //   root: 'http://www.example.com/',
   * //   dir: 'http://www.example.com/foo/bar',
   * //   base: 'baz.png',
   * //   ext: '.png',
   * //   name: 'baz'
   * // }
   * // Parse a file path
   * const parsedFile = path.parse('C:/Users/User/Documents/file.txt');
   * // -> {
   * //   root: 'C:/',
   * //   dir: 'C:/Users/User/Documents',
   * //   base: 'file.txt',
   * //   ext: '.txt',
   * //   name: 'file'
   * // }
   * ```
   */
  parse(i) {
    je(i);
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (i.length === 0)
      return e;
    i = Si(this.toPosix(i));
    let t = i.charCodeAt(0);
    const s = this.isAbsolute(i);
    let r;
    e.root = this.rootname(i), s || this.hasProtocol(i) ? r = 1 : r = 0;
    let n = -1, o = 0, a = -1, l = !0, c = i.length - 1, h = 0;
    for (; c >= r; --c) {
      if (t = i.charCodeAt(c), t === 47) {
        if (!l) {
          o = c + 1;
          break;
        }
        continue;
      }
      a === -1 && (l = !1, a = c + 1), t === 46 ? n === -1 ? n = c : h !== 1 && (h = 1) : n !== -1 && (h = -1);
    }
    return n === -1 || a === -1 || h === 0 || h === 1 && n === a - 1 && n === o + 1 ? a !== -1 && (o === 0 && s ? e.base = e.name = i.slice(1, a) : e.base = e.name = i.slice(o, a)) : (o === 0 && s ? (e.name = i.slice(1, n), e.base = i.slice(1, a)) : (e.name = i.slice(o, n), e.base = i.slice(o, a)), e.ext = i.slice(n, a)), e.dir = this.dirname(i), e;
  },
  sep: "/",
  delimiter: ":",
  joinExtensions: [".html"]
};
function Wp(i, e, t, s, r) {
  const n = e[t];
  for (let o = 0; o < n.length; o++) {
    const a = n[o];
    t < e.length - 1 ? Wp(i.replace(s[t], a), e, t + 1, s, r) : r.push(i.replace(s[t], a));
  }
}
function w2(i) {
  const e = /\{(.*?)\}/g, t = i.match(e), s = [];
  if (t) {
    const r = [];
    t.forEach((n) => {
      const o = n.substring(1, n.length - 1).split(",");
      r.push(o);
    }), Wp(i, r, 0, t, s);
  } else
    s.push(i);
  return s;
}
const sr = (i) => !Array.isArray(i);
class gi {
  constructor() {
    this._defaultBundleIdentifierOptions = {
      connector: "-",
      createBundleAssetId: (e, t) => `${e}${this._bundleIdConnector}${t}`,
      extractAssetIdFromBundle: (e, t) => t.replace(`${e}${this._bundleIdConnector}`, "")
    }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {};
  }
  /**
   * Override how the resolver deals with generating bundle ids.
   * must be called before any bundles are added
   * @param bundleIdentifier - the bundle identifier options
   */
  setBundleIdentifier(e) {
    if (this._bundleIdConnector = e.connector ?? this._bundleIdConnector, this._createBundleAssetId = e.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = e.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar")
      throw new Error("[Resolver] GenerateBundleAssetId are not working correctly");
  }
  /**
   * Let the resolver know which assets you prefer to use when resolving assets.
   * Multiple prefer user defined rules can be added.
   * @example
   * resolver.prefer({
   *     // first look for something with the correct format, and then then correct resolution
   *     priority: ['format', 'resolution'],
   *     params:{
   *         format:'webp', // prefer webp images
   *         resolution: 2, // prefer a resolution of 2
   *     }
   * })
   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);
   * resolver.resolveUrl('foo') // => 'bar@2x.webp'
   * @param preferOrders - the prefer options
   */
  prefer(...e) {
    e.forEach((t) => {
      this._preferredOrder.push(t), t.priority || (t.priority = Object.keys(t.params));
    }), this._resolverHash = {};
  }
  /**
   * Set the base path to prepend to all urls when resolving
   * @example
   * resolver.basePath = 'https://home.com/';
   * resolver.add('foo', 'bar.ong');
   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'
   * @param basePath - the base path to use
   */
  set basePath(e) {
    this._basePath = e;
  }
  get basePath() {
    return this._basePath;
  }
  /**
   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the
   * default value for browsers is `window.location.origin`
   * @example
   * // Application hosted on https://home.com/some-path/index.html
   * resolver.basePath = 'https://home.com/some-path/';
   * resolver.rootPath = 'https://home.com/';
   * resolver.add('foo', '/bar.png');
   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'
   * @param rootPath - the root path to use
   */
  set rootPath(e) {
    this._rootPath = e;
  }
  get rootPath() {
    return this._rootPath;
  }
  /**
   * All the active URL parsers that help the parser to extract information and create
   * an asset object-based on parsing the URL itself.
   *
   * Can be added using the extensions API
   * @example
   * resolver.add('foo', [
   *     {
   *         resolution: 2,
   *         format: 'png',
   *         src: 'image@2x.png',
   *     },
   *     {
   *         resolution:1,
   *         format:'png',
   *         src: 'image.png',
   *     },
   * ]);
   *
   * // With a url parser the information such as resolution and file format could extracted from the url itself:
   * extensions.add({
   *     extension: ExtensionType.ResolveParser,
   *     test: loadTextures.test, // test if url ends in an image
   *     parse: (value: string) =>
   *     ({
   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),
   *         format: value.split('.').pop(),
   *         src: value,
   *     }),
   * });
   *
   * // Now resolution and format can be extracted from the url
   * resolver.add('foo', [
   *     'image@2x.png',
   *     'image.png',
   * ]);
   */
  get parsers() {
    return this._parsers;
  }
  /** Used for testing, this resets the resolver to its initial state */
  reset() {
    this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null;
  }
  /**
   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.
   * @param searchParams - the default url parameters to append when resolving urls
   */
  setDefaultSearchParams(e) {
    if (typeof e == "string")
      this._defaultSearchParams = e;
    else {
      const t = e;
      this._defaultSearchParams = Object.keys(t).map((s) => `${encodeURIComponent(s)}=${encodeURIComponent(t[s])}`).join("&");
    }
  }
  /**
   * Returns the aliases for a given asset
   * @param asset - the asset to get the aliases for
   */
  getAlias(e) {
    const { alias: t, src: s } = e;
    return Qe(
      t || s,
      (n) => typeof n == "string" ? n : Array.isArray(n) ? n.map((o) => o?.src ?? o) : n?.src ? n.src : n,
      !0
    );
  }
  /**
   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.
   * generally a manifest would be built using a tool.
   * @param manifest - the manifest to add to the resolver
   */
  addManifest(e) {
    this._manifest && se("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = e, e.bundles.forEach((t) => {
      this.addBundle(t.name, t.assets);
    });
  }
  /**
   * This adds a bundle of assets in one go so that you can resolve them as a group.
   * For example you could add a bundle for each screen in you pixi app
   * @example
   * resolver.addBundle('animals', [
   *  { alias: 'bunny', src: 'bunny.png' },
   *  { alias: 'chicken', src: 'chicken.png' },
   *  { alias: 'thumper', src: 'thumper.png' },
   * ]);
   * // or
   * resolver.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * const resolvedAssets = await resolver.resolveBundle('animals');
   * @param bundleId - The id of the bundle to add
   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key
   */
  addBundle(e, t) {
    const s = [];
    let r = t;
    Array.isArray(t) || (r = Object.entries(t).map(([n, o]) => typeof o == "string" || Array.isArray(o) ? { alias: n, src: o } : { alias: n, ...o })), r.forEach((n) => {
      const o = n.src, a = n.alias;
      let l;
      if (typeof a == "string") {
        const c = this._createBundleAssetId(e, a);
        s.push(c), l = [a, c];
      } else {
        const c = a.map((h) => this._createBundleAssetId(e, h));
        s.push(...c), l = [...a, ...c];
      }
      this.add({
        ...n,
        alias: l,
        src: o
      });
    }), this._bundles[e] = s;
  }
  /**
   * Tells the resolver what keys are associated with witch asset.
   * The most important thing the resolver does
   * @example
   * // Single key, single asset:
   * resolver.add({alias: 'foo', src: 'bar.png');
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Multiple keys, single asset:
   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});
   * resolver.resolveUrl('foo') // => 'bar.png'
   * resolver.resolveUrl('boo') // => 'bar.png'
   *
   * // Multiple keys, multiple assets:
   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});
   * resolver.resolveUrl('foo') // => 'bar.png'
   *
   * // Add custom data attached to the resolver
   * Resolver.add({
   *     alias: 'bunnyBooBooSmooth',
   *     src: 'bunny{png,webp}',
   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options
   * });
   *
   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }
   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver
   */
  add(e) {
    const t = [];
    Array.isArray(e) ? t.push(...e) : t.push(e);
    let s;
    s = (n) => {
      this.hasKey(n) && se(`[Resolver] already has key: ${n} overwriting`);
    }, Qe(t).forEach((n) => {
      const { src: o } = n;
      let {
        data: a,
        format: l,
        loadParser: c,
        parser: h
      } = n;
      const u = Qe(o).map((g) => typeof g == "string" ? w2(g) : Array.isArray(g) ? g : [g]), d = this.getAlias(n);
      Array.isArray(d) ? d.forEach(s) : s(d);
      const f = [], m = (g) => ({
        ...this._parsers.find((x) => x.test(g))?.parse(g),
        src: g
      });
      u.forEach((g) => {
        g.forEach((p) => {
          let x = {};
          if (typeof p != "object" ? x = m(p) : (a = p.data ?? a, l = p.format ?? l, (p.loadParser || p.parser) && (c = p.loadParser ?? c, h = p.parser ?? h), x = {
            ...m(p.src),
            ...p
          }), !d)
            throw new Error(`[Resolver] alias is undefined for this asset: ${x.src}`);
          x = this._buildResolvedAsset(x, {
            aliases: d,
            data: a,
            format: l,
            loadParser: c,
            parser: h,
            progressSize: n.progressSize
          }), f.push(x);
        });
      }), d.forEach((g) => {
        this._assetMap[g] = f;
      });
    });
  }
  // TODO: this needs an overload like load did in Assets
  /**
   * If the resolver has had a manifest set via setManifest, this will return the assets urls for
   * a given bundleId or bundleIds.
   * @example
   * // Manifest Example
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}',
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * resolver.setManifest(manifest);
   * const resolved = resolver.resolveBundle('load-screen');
   * @param bundleIds - The bundle ids to resolve
   * @returns All the bundles assets or a hash of assets for each bundle specified
   */
  resolveBundle(e) {
    const t = sr(e);
    e = Qe(e);
    const s = {};
    return e.forEach((r) => {
      const n = this._bundles[r];
      if (n) {
        const o = this.resolve(n), a = {};
        for (const l in o) {
          const c = o[l];
          a[this._extractAssetIdFromBundle(r, l)] = c;
        }
        s[r] = a;
      }
    }), t ? s[e[0]] : s;
  }
  /**
   * Does exactly what resolve does, but returns just the URL rather than the whole asset object
   * @param key - The key or keys to resolve
   * @returns - The URLs associated with the key(s)
   */
  resolveUrl(e) {
    const t = this.resolve(e);
    if (typeof e != "string") {
      const s = {};
      for (const r in t)
        s[r] = t[r].src;
      return s;
    }
    return t.src;
  }
  resolve(e) {
    const t = sr(e);
    e = Qe(e);
    const s = {};
    return e.forEach((r) => {
      if (!this._resolverHash[r])
        if (this._assetMap[r]) {
          let n = this._assetMap[r];
          const o = this._getPreferredOrder(n);
          o?.priority.forEach((a) => {
            o.params[a].forEach((l) => {
              const c = n.filter((h) => h[a] ? h[a] === l : !1);
              c.length && (n = c);
            });
          }), this._resolverHash[r] = n[0];
        } else
          this._resolverHash[r] = this._buildResolvedAsset({
            alias: [r],
            src: r
          }, {});
      s[r] = this._resolverHash[r];
    }), t ? s[e[0]] : s;
  }
  /**
   * Checks if an asset with a given key exists in the resolver
   * @param key - The key of the asset
   */
  hasKey(e) {
    return !!this._assetMap[e];
  }
  /**
   * Checks if a bundle with the given key exists in the resolver
   * @param key - The key of the bundle
   */
  hasBundle(e) {
    return !!this._bundles[e];
  }
  /**
   * Internal function for figuring out what prefer criteria an asset should use.
   * @param assets
   */
  _getPreferredOrder(e) {
    for (let t = 0; t < e.length; t++) {
      const s = e[t], r = this._preferredOrder.find((n) => n.params.format.includes(s.format));
      if (r)
        return r;
    }
    return this._preferredOrder[0];
  }
  /**
   * Appends the default url parameters to the url
   * @param url - The url to append the default parameters to
   * @returns - The url with the default parameters appended
   */
  _appendDefaultSearchParams(e) {
    if (!this._defaultSearchParams)
      return e;
    const t = /\?/.test(e) ? "&" : "?";
    return `${e}${t}${this._defaultSearchParams}`;
  }
  _buildResolvedAsset(e, t) {
    const { aliases: s, data: r, loadParser: n, parser: o, format: a, progressSize: l } = t;
    return (this._basePath || this._rootPath) && (e.src = He.toAbsolute(e.src, this._basePath, this._rootPath)), e.alias = s ?? e.alias ?? [e.src], e.src = this._appendDefaultSearchParams(e.src), e.data = { ...r || {}, ...e.data }, e.loadParser = n ?? e.loadParser, e.parser = o ?? e.parser, e.format = a ?? e.format ?? T2(e.src), l !== void 0 && (e.progressSize = l), e;
  }
}
gi.RETINA_PREFIX = /@([0-9\.]+)x/;
function T2(i) {
  return i.split(".").pop().split("?").shift().split("#").shift();
}
const Rh = (i, e) => {
  const t = e.split("?")[1];
  return t && (i += `?${t}`), i;
}, Vp = class Oi {
  constructor(e, t) {
    this.linkedSheets = [];
    let s = e;
    e?.source instanceof Ke && (s = {
      texture: e,
      data: t
    });
    const { texture: r, data: n, cachePrefix: o = "" } = s;
    this.cachePrefix = o, this._texture = r instanceof L ? r : null, this.textureSource = r.source, this.textures = {}, this.animations = {}, this.data = n;
    const a = parseFloat(n.meta.scale);
    a ? (this.resolution = a, r.source.resolution = this.resolution) : this.resolution = r.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
  }
  /**
   * Parser spritesheet from loaded data. This is done asynchronously
   * to prevent creating too many Texture within a single process.
   */
  parse() {
    return new Promise((e) => {
      this._callback = e, this._batchIndex = 0, this._frameKeys.length <= Oi.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
    });
  }
  /**
   * Process a batch of frames
   * @param initialFrameIndex - The index of frame to start.
   */
  _processFrames(e) {
    let t = e;
    const s = Oi.BATCH_SIZE;
    for (; t - e < s && t < this._frameKeys.length; ) {
      const r = this._frameKeys[t], n = this._frames[r], o = n.frame;
      if (o) {
        let a = null, l = null;
        const c = n.trimmed !== !1 && n.sourceSize ? n.sourceSize : n.frame, h = new G(
          0,
          0,
          Math.floor(c.w) / this.resolution,
          Math.floor(c.h) / this.resolution
        );
        n.rotated ? a = new G(
          Math.floor(o.x) / this.resolution,
          Math.floor(o.y) / this.resolution,
          Math.floor(o.h) / this.resolution,
          Math.floor(o.w) / this.resolution
        ) : a = new G(
          Math.floor(o.x) / this.resolution,
          Math.floor(o.y) / this.resolution,
          Math.floor(o.w) / this.resolution,
          Math.floor(o.h) / this.resolution
        ), n.trimmed !== !1 && n.spriteSourceSize && (l = new G(
          Math.floor(n.spriteSourceSize.x) / this.resolution,
          Math.floor(n.spriteSourceSize.y) / this.resolution,
          Math.floor(o.w) / this.resolution,
          Math.floor(o.h) / this.resolution
        )), this.textures[r] = new L({
          source: this.textureSource,
          frame: a,
          orig: h,
          trim: l,
          rotate: n.rotated ? 2 : 0,
          defaultAnchor: n.anchor,
          defaultBorders: n.borders,
          label: r.toString()
        });
      }
      t++;
    }
  }
  /** Parse animations config. */
  _processAnimations() {
    const e = this.data.animations || {};
    for (const t in e) {
      this.animations[t] = [];
      for (let s = 0; s < e[t].length; s++) {
        const r = e[t][s];
        this.animations[t].push(this.textures[r]);
      }
    }
  }
  /** The parse has completed. */
  _parseComplete() {
    const e = this._callback;
    this._callback = null, this._batchIndex = 0, e.call(this, this.textures);
  }
  /** Begin the next batch of textures. */
  _nextBatch() {
    this._processFrames(this._batchIndex * Oi.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
      this._batchIndex * Oi.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
    }, 0);
  }
  /**
   * Destroy Spritesheet and don't use after this.
   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well
   */
  destroy(e = !1) {
    for (const t in this.textures)
      this.textures[t].destroy();
    this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, e && (this._texture?.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = [];
  }
};
Vp.BATCH_SIZE = 1e3;
let ed = Vp;
const S2 = [
  "jpg",
  "png",
  "jpeg",
  "avif",
  "webp",
  "basis",
  "etc2",
  "bc7",
  "bc6h",
  "bc5",
  "bc4",
  "bc3",
  "bc2",
  "bc1",
  "eac",
  "astc"
];
function $p(i, e, t) {
  const s = {};
  if (i.forEach((r) => {
    s[r] = e;
  }), Object.keys(e.textures).forEach((r) => {
    s[`${e.cachePrefix}${r}`] = e.textures[r];
  }), !t) {
    const r = He.dirname(i[0]);
    e.linkedSheets.forEach((n, o) => {
      const a = $p([`${r}/${e.data.meta.related_multi_packs[o]}`], n, !0);
      Object.assign(s, a);
    });
  }
  return s;
}
const C2 = {
  extension: O.Asset,
  /** Handle the caching of the related Spritesheet Textures */
  cache: {
    test: (i) => i instanceof ed,
    getCacheableAssets: (i, e) => $p(i, e, !1)
  },
  /** Resolve the resolution of the asset. */
  resolver: {
    extension: {
      type: O.ResolveParser,
      name: "resolveSpritesheet"
    },
    test: (i) => {
      const t = i.split("?")[0].split("."), s = t.pop(), r = t.pop();
      return s === "json" && S2.includes(r);
    },
    parse: (i) => {
      const e = i.split(".");
      return {
        resolution: parseFloat(gi.RETINA_PREFIX.exec(i)?.[1] ?? "1"),
        format: e[e.length - 2],
        src: i
      };
    }
  },
  /**
   * Loader plugin that parses sprite sheets!
   * once the JSON has been loaded this checks to see if the JSON is spritesheet data.
   * If it is, we load the spritesheets image and parse the data into Spritesheet
   * All textures in the sprite sheet are then added to the cache
   */
  loader: {
    /** used for deprecation purposes */
    name: "spritesheetLoader",
    id: "spritesheet",
    extension: {
      type: O.LoadParser,
      priority: Et.Normal,
      name: "spritesheetLoader"
    },
    async testParse(i, e) {
      return He.extname(e.src).toLowerCase() === ".json" && !!i.frames;
    },
    async parse(i, e, t) {
      const {
        texture: s,
        // if user need to use preloaded texture
        imageFilename: r,
        // if user need to use custom filename (not from jsonFile.meta.image)
        textureOptions: n,
        // if user need to set texture options on texture
        cachePrefix: o
        // if user need to use custom cache prefix
      } = e?.data ?? {};
      let a = He.dirname(e.src);
      a && a.lastIndexOf("/") !== a.length - 1 && (a += "/");
      let l;
      if (s instanceof L)
        l = s;
      else {
        const u = Rh(a + (r ?? i.meta.image), e.src);
        l = (await t.load([{ src: u, data: n }]))[u];
      }
      const c = new ed({
        texture: l.source,
        data: i,
        cachePrefix: o
      });
      await c.parse();
      const h = i?.meta?.related_multi_packs;
      if (Array.isArray(h)) {
        const u = [];
        for (const f of h) {
          if (typeof f != "string")
            continue;
          let m = a + f;
          e.data?.ignoreMultiPack || (m = Rh(m, e.src), u.push(t.load({
            src: m,
            data: {
              textureOptions: n,
              ignoreMultiPack: !0
            }
          })));
        }
        const d = await Promise.all(u);
        c.linkedSheets = d, d.forEach((f) => {
          f.linkedSheets = [c].concat(c.linkedSheets.filter((m) => m !== f));
        });
      }
      return c;
    },
    async unload(i, e, t) {
      await t.unload(i.textureSource._sourceOrigin), i.destroy(!1);
    }
  }
};
ke.add(C2);
const $c = /* @__PURE__ */ Object.create(null), td = /* @__PURE__ */ Object.create(null);
function lu(i, e) {
  let t = td[i];
  return t === void 0 && ($c[e] === void 0 && ($c[e] = 1), td[i] = t = $c[e]++), t;
}
let _s;
function Yp() {
  return (!_s || _s?.isContextLost()) && (_s = re.get().createCanvas().getContext("webgl", {})), _s;
}
let bs;
function A2() {
  if (!bs) {
    bs = "mediump";
    const i = Yp();
    i && i.getShaderPrecisionFormat && (bs = i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision ? "highp" : "mediump");
  }
  return bs;
}
function I2(i, e, t) {
  return e ? i : t ? (i = i.replace("out vec4 finalColor;", ""), `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${i}
        `) : `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${i}
        `;
}
function k2(i, e, t) {
  const s = t ? e.maxSupportedFragmentPrecision : e.maxSupportedVertexPrecision;
  if (i.substring(0, 9) !== "precision") {
    let r = t ? e.requestedFragmentPrecision : e.requestedVertexPrecision;
    return r === "highp" && s !== "highp" && (r = "mediump"), `precision ${r} float;
${i}`;
  } else if (s !== "highp" && i.substring(0, 15) === "precision highp")
    return i.replace("precision highp", "precision mediump");
  return i;
}
function F2(i, e) {
  return e ? `#version 300 es
${i}` : i;
}
const M2 = {}, E2 = {};
function P2(i, { name: e = "pixi-program" }, t = !0) {
  e = e.replace(/\s+/g, "-"), e += t ? "-fragment" : "-vertex";
  const s = t ? M2 : E2;
  return s[e] ? (s[e]++, e += `-${s[e]}`) : s[e] = 1, i.indexOf("#define SHADER_NAME") !== -1 ? i : `${`#define SHADER_NAME ${e}`}
${i}`;
}
function U2(i, e) {
  return e ? i.replace("#version 300 es", "") : i;
}
const Yc = {
  // strips any version headers..
  stripVersion: U2,
  // adds precision string if not already present
  ensurePrecision: k2,
  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders
  addProgramDefines: I2,
  // add the program name to the shader
  setProgramName: P2,
  // add the version string to the shader header
  insertVersion: F2
}, Ci = /* @__PURE__ */ Object.create(null), Xp = class Bh {
  /**
   * Creates a shiny new GlProgram. Used by WebGL renderer.
   * @param options - The options for the program.
   */
  constructor(e) {
    e = { ...Bh.defaultOptions, ...e };
    const t = e.fragment.indexOf("#version 300 es") !== -1, s = {
      stripVersion: t,
      ensurePrecision: {
        requestedFragmentPrecision: e.preferredFragmentPrecision,
        requestedVertexPrecision: e.preferredVertexPrecision,
        maxSupportedVertexPrecision: "highp",
        maxSupportedFragmentPrecision: A2()
      },
      setProgramName: {
        name: e.name
      },
      addProgramDefines: t,
      insertVersion: t
    };
    let r = e.fragment, n = e.vertex;
    Object.keys(Yc).forEach((o) => {
      const a = s[o];
      r = Yc[o](r, a, !0), n = Yc[o](n, a, !1);
    }), this.fragment = r, this.vertex = n, this.transformFeedbackVaryings = e.transformFeedbackVaryings, this._key = lu(`${this.vertex}:${this.fragment}`, "gl-program");
  }
  /** destroys the program */
  destroy() {
    this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null, Ci[this._cacheKey] = null;
  }
  /**
   * Helper function that creates a program for a given source.
   * It will check the program cache if the program has already been created.
   * If it has that one will be returned, if not a new one will be created and cached.
   * @param options - The options for the program.
   * @returns A program using the same source
   */
  static from(e) {
    const t = `${e.vertex}:${e.fragment}`;
    return Ci[t] || (Ci[t] = new Bh(e), Ci[t]._cacheKey = t), Ci[t];
  }
};
Xp.defaultOptions = {
  preferredVertexPrecision: "highp",
  preferredFragmentPrecision: "mediump"
};
let xi = Xp;
const id = {
  uint8x2: { size: 2, stride: 2, normalised: !1 },
  uint8x4: { size: 4, stride: 4, normalised: !1 },
  sint8x2: { size: 2, stride: 2, normalised: !1 },
  sint8x4: { size: 4, stride: 4, normalised: !1 },
  unorm8x2: { size: 2, stride: 2, normalised: !0 },
  unorm8x4: { size: 4, stride: 4, normalised: !0 },
  snorm8x2: { size: 2, stride: 2, normalised: !0 },
  snorm8x4: { size: 4, stride: 4, normalised: !0 },
  uint16x2: { size: 2, stride: 4, normalised: !1 },
  uint16x4: { size: 4, stride: 8, normalised: !1 },
  sint16x2: { size: 2, stride: 4, normalised: !1 },
  sint16x4: { size: 4, stride: 8, normalised: !1 },
  unorm16x2: { size: 2, stride: 4, normalised: !0 },
  unorm16x4: { size: 4, stride: 8, normalised: !0 },
  snorm16x2: { size: 2, stride: 4, normalised: !0 },
  snorm16x4: { size: 4, stride: 8, normalised: !0 },
  float16x2: { size: 2, stride: 4, normalised: !1 },
  float16x4: { size: 4, stride: 8, normalised: !1 },
  float32: { size: 1, stride: 4, normalised: !1 },
  float32x2: { size: 2, stride: 8, normalised: !1 },
  float32x3: { size: 3, stride: 12, normalised: !1 },
  float32x4: { size: 4, stride: 16, normalised: !1 },
  uint32: { size: 1, stride: 4, normalised: !1 },
  uint32x2: { size: 2, stride: 8, normalised: !1 },
  uint32x3: { size: 3, stride: 12, normalised: !1 },
  uint32x4: { size: 4, stride: 16, normalised: !1 },
  sint32: { size: 1, stride: 4, normalised: !1 },
  sint32x2: { size: 2, stride: 8, normalised: !1 },
  sint32x3: { size: 3, stride: 12, normalised: !1 },
  sint32x4: { size: 4, stride: 16, normalised: !1 }
};
function R2(i) {
  return id[i] ?? id.float32;
}
const B2 = {
  f32: "float32",
  "vec2<f32>": "float32x2",
  "vec3<f32>": "float32x3",
  "vec4<f32>": "float32x4",
  vec2f: "float32x2",
  vec3f: "float32x3",
  vec4f: "float32x4",
  i32: "sint32",
  "vec2<i32>": "sint32x2",
  "vec3<i32>": "sint32x3",
  "vec4<i32>": "sint32x4",
  u32: "uint32",
  "vec2<u32>": "uint32x2",
  "vec3<u32>": "uint32x3",
  "vec4<u32>": "uint32x4",
  bool: "uint32",
  "vec2<bool>": "uint32x2",
  "vec3<bool>": "uint32x3",
  "vec4<bool>": "uint32x4"
};
function z2({ source: i, entryPoint: e }) {
  const t = {}, s = i.indexOf(`fn ${e}`);
  if (s !== -1) {
    const r = i.indexOf("->", s);
    if (r !== -1) {
      const n = i.substring(s, r), o = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
      let a;
      for (; (a = o.exec(n)) !== null; ) {
        const l = B2[a[3]] ?? "float32";
        t[a[2]] = {
          location: parseInt(a[1], 10),
          format: l,
          stride: R2(l).stride,
          offset: 0,
          instance: !1,
          start: 0
        };
      }
    }
  }
  return t;
}
function Xc(i) {
  const e = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g, t = /@group\((\d+)\)/, s = /@binding\((\d+)\)/, r = /var(<[^>]+>)? (\w+)/, n = /:\s*(\w+)/, o = /struct\s+(\w+)\s*{([^}]+)}/g, a = /(\w+)\s*:\s*([\w\<\>]+)/g, l = /struct\s+(\w+)/, c = i.match(e)?.map((u) => ({
    group: parseInt(u.match(t)[1], 10),
    binding: parseInt(u.match(s)[1], 10),
    name: u.match(r)[2],
    isUniform: u.match(r)[1] === "<uniform>",
    type: u.match(n)[1]
  }));
  if (!c)
    return {
      groups: [],
      structs: []
    };
  const h = i.match(o)?.map((u) => {
    const d = u.match(l)[1], f = u.match(a).reduce((m, g) => {
      const [p, x] = g.split(":");
      return m[p.trim()] = x.trim(), m;
    }, {});
    return f ? { name: d, members: f } : null;
  }).filter(({ name: u }) => c.some((d) => d.type === u)) ?? [];
  return {
    groups: c,
    structs: h
  };
}
var Di = /* @__PURE__ */ ((i) => (i[i.VERTEX = 1] = "VERTEX", i[i.FRAGMENT = 2] = "FRAGMENT", i[i.COMPUTE = 4] = "COMPUTE", i))(Di || {});
function O2({ groups: i }) {
  const e = [];
  for (let t = 0; t < i.length; t++) {
    const s = i[t];
    e[s.group] || (e[s.group] = []), s.isUniform ? e[s.group].push({
      binding: s.binding,
      visibility: Di.VERTEX | Di.FRAGMENT,
      buffer: {
        type: "uniform"
      }
    }) : s.type === "sampler" ? e[s.group].push({
      binding: s.binding,
      visibility: Di.FRAGMENT,
      sampler: {
        type: "filtering"
      }
    }) : s.type === "texture_2d" && e[s.group].push({
      binding: s.binding,
      visibility: Di.FRAGMENT,
      texture: {
        sampleType: "float",
        viewDimension: "2d",
        multisampled: !1
      }
    });
  }
  return e;
}
function D2({ groups: i }) {
  const e = [];
  for (let t = 0; t < i.length; t++) {
    const s = i[t];
    e[s.group] || (e[s.group] = {}), e[s.group][s.name] = s.binding;
  }
  return e;
}
function L2(i, e) {
  const t = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set(), r = [...i.structs, ...e.structs].filter((o) => t.has(o.name) ? !1 : (t.add(o.name), !0)), n = [...i.groups, ...e.groups].filter((o) => {
    const a = `${o.name}-${o.binding}`;
    return s.has(a) ? !1 : (s.add(a), !0);
  });
  return { structs: r, groups: n };
}
const Ai = /* @__PURE__ */ Object.create(null);
class yi {
  /**
   * Create a new GpuProgram
   * @param options - The options for the gpu program
   */
  constructor(e) {
    this._layoutKey = 0, this._attributeLocationsKey = 0;
    const { fragment: t, vertex: s, layout: r, gpuLayout: n, name: o } = e;
    if (this.name = o, this.fragment = t, this.vertex = s, t.source === s.source) {
      const a = Xc(t.source);
      this.structsAndGroups = a;
    } else {
      const a = Xc(s.source), l = Xc(t.source);
      this.structsAndGroups = L2(a, l);
    }
    this.layout = r ?? D2(this.structsAndGroups), this.gpuLayout = n ?? O2(this.structsAndGroups), this.autoAssignGlobalUniforms = this.layout[0]?.globalUniforms !== void 0, this.autoAssignLocalUniforms = this.layout[1]?.localUniforms !== void 0, this._generateProgramKey();
  }
  // TODO maker this pure
  _generateProgramKey() {
    const { vertex: e, fragment: t } = this, s = e.source + t.source + e.entryPoint + t.entryPoint;
    this._layoutKey = lu(s, "program");
  }
  get attributeData() {
    return this._attributeData ?? (this._attributeData = z2(this.vertex)), this._attributeData;
  }
  /** destroys the program */
  destroy() {
    this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null, Ai[this._cacheKey] = null;
  }
  /**
   * Helper function that creates a program for a given source.
   * It will check the program cache if the program has already been created.
   * If it has that one will be returned, if not a new one will be created and cached.
   * @param options - The options for the program.
   * @returns A program using the same source
   */
  static from(e) {
    const t = `${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;
    return Ai[t] || (Ai[t] = new yi(e), Ai[t]._cacheKey = t), Ai[t];
  }
}
const qp = [
  "f32",
  "i32",
  "vec2<f32>",
  "vec3<f32>",
  "vec4<f32>",
  "mat2x2<f32>",
  "mat3x3<f32>",
  "mat4x4<f32>",
  "mat3x2<f32>",
  "mat4x2<f32>",
  "mat2x3<f32>",
  "mat4x3<f32>",
  "mat2x4<f32>",
  "mat3x4<f32>",
  "vec2<i32>",
  "vec3<i32>",
  "vec4<i32>"
], N2 = qp.reduce((i, e) => (i[e] = !0, i), {});
function G2(i, e) {
  switch (i) {
    case "f32":
      return 0;
    case "vec2<f32>":
      return new Float32Array(2 * e);
    case "vec3<f32>":
      return new Float32Array(3 * e);
    case "vec4<f32>":
      return new Float32Array(4 * e);
    case "mat2x2<f32>":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3x3<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4x4<f32>":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
const Zp = class Kp {
  /**
   * Create a new Uniform group
   * @param uniformStructures - The structures of the uniform group
   * @param options - The optional parameters of this uniform group
   */
  constructor(e, t) {
    this._touched = 0, this.uid = de("uniform"), this._resourceType = "uniformGroup", this._resourceId = de("resource"), this.isUniformGroup = !0, this._dirtyId = 0, this.destroyed = !1, t = { ...Kp.defaultOptions, ...t }, this.uniformStructures = e;
    const s = {};
    for (const r in e) {
      const n = e[r];
      if (n.name = r, n.size = n.size ?? 1, !N2[n.type]) {
        const o = n.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);
        if (o) {
          const [, a, l] = o;
          throw new Error(
            `Uniform type ${n.type} is not supported. Use type: '${a}', size: ${l} instead.`
          );
        }
        throw new Error(`Uniform type ${n.type} is not supported. Supported uniform types are: ${qp.join(", ")}`);
      }
      n.value ?? (n.value = G2(n.type, n.size)), s[r] = n.value;
    }
    this.uniforms = s, this._dirtyId = 1, this.ubo = t.ubo, this.isStatic = t.isStatic, this._signature = lu(Object.keys(s).map(
      (r) => `${r}-${e[r].type}`
    ).join("-"), "uniform-group");
  }
  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */
  update() {
    this._dirtyId++;
  }
};
Zp.defaultOptions = {
  /** if true the UniformGroup is handled as an Uniform buffer object. */
  ubo: !1,
  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */
  isStatic: !1
};
let Jp = Zp;
class $s {
  /**
   * Create a new instance eof the Bind Group.
   * @param resources - The resources that are bound together for use by a shader.
   */
  constructor(e) {
    this.resources = /* @__PURE__ */ Object.create(null), this._dirty = !0;
    let t = 0;
    for (const s in e) {
      const r = e[s];
      this.setResource(r, t++);
    }
    this._updateKey();
  }
  /**
   * Updates the key if its flagged as dirty. This is used internally to
   * match this bind group to a WebGPU BindGroup.
   * @internal
   */
  _updateKey() {
    if (!this._dirty)
      return;
    this._dirty = !1;
    const e = [];
    let t = 0;
    for (const s in this.resources)
      e[t++] = this.resources[s]._resourceId;
    this._key = e.join("|");
  }
  /**
   * Set a resource at a given index. this function will
   * ensure that listeners will be removed from the current resource
   * and added to the new resource.
   * @param resource - The resource to set.
   * @param index - The index to set the resource at.
   */
  setResource(e, t) {
    const s = this.resources[t];
    e !== s && (s && e.off?.("change", this.onResourceChange, this), e.on?.("change", this.onResourceChange, this), this.resources[t] = e, this._dirty = !0);
  }
  /**
   * Returns the resource at the current specified index.
   * @param index - The index of the resource to get.
   * @returns - The resource at the specified index.
   */
  getResource(e) {
    return this.resources[e];
  }
  /**
   * Used internally to 'touch' each resource, to ensure that the GC
   * knows that all resources in this bind group are still being used.
   * @param tick - The current tick.
   * @internal
   */
  _touch(e) {
    const t = this.resources;
    for (const s in t)
      t[s]._touched = e;
  }
  /** Destroys this bind group and removes all listeners. */
  destroy() {
    const e = this.resources;
    for (const t in e)
      e[t]?.off?.("change", this.onResourceChange, this);
    this.resources = null;
  }
  onResourceChange(e) {
    if (this._dirty = !0, e.destroyed) {
      const t = this.resources;
      for (const s in t)
        t[s] === e && (t[s] = null);
    } else
      this._updateKey();
  }
}
var ji = /* @__PURE__ */ ((i) => (i[i.WEBGL = 1] = "WEBGL", i[i.WEBGPU = 2] = "WEBGPU", i[i.BOTH = 3] = "BOTH", i))(ji || {});
class pr extends rt {
  constructor(e) {
    super(), this.uid = de("shader"), this._uniformBindMap = /* @__PURE__ */ Object.create(null), this._ownedBindGroups = [], this._destroyed = !1;
    let {
      gpuProgram: t,
      glProgram: s,
      groups: r,
      resources: n,
      compatibleRenderers: o,
      groupMap: a
    } = e;
    this.gpuProgram = t, this.glProgram = s, o === void 0 && (o = 0, t && (o |= ji.WEBGPU), s && (o |= ji.WEBGL)), this.compatibleRenderers = o;
    const l = {};
    if (!n && !r && (n = {}), n && r)
      throw new Error("[Shader] Cannot have both resources and groups");
    if (!t && r && !a)
      throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
    if (!t && r && a)
      for (const c in a)
        for (const h in a[c]) {
          const u = a[c][h];
          l[u] = {
            group: c,
            binding: h,
            name: u
          };
        }
    else if (t && r && !a) {
      const c = t.structsAndGroups.groups;
      a = {}, c.forEach((h) => {
        a[h.group] = a[h.group] || {}, a[h.group][h.binding] = h.name, l[h.name] = h;
      });
    } else if (n) {
      r = {}, a = {}, t && t.structsAndGroups.groups.forEach((u) => {
        a[u.group] = a[u.group] || {}, a[u.group][u.binding] = u.name, l[u.name] = u;
      });
      let c = 0;
      for (const h in n)
        l[h] || (r[99] || (r[99] = new $s(), this._ownedBindGroups.push(r[99])), l[h] = { group: 99, binding: c, name: h }, a[99] = a[99] || {}, a[99][c] = h, c++);
      for (const h in n) {
        const u = h;
        let d = n[h];
        !d.source && !d._resourceType && (d = new Jp(d));
        const f = l[u];
        f && (r[f.group] || (r[f.group] = new $s(), this._ownedBindGroups.push(r[f.group])), r[f.group].setResource(d, f.binding));
      }
    }
    this.groups = r, this._uniformBindMap = a, this.resources = this._buildResourceAccessor(r, l);
  }
  /**
   * Sometimes a resource group will be provided later (for example global uniforms)
   * In such cases, this method can be used to let the shader know about the group.
   * @param name - the name of the resource group
   * @param groupIndex - the index of the group (should match the webGPU shader group location)
   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)
   */
  addResource(e, t, s) {
    var r, n;
    (r = this._uniformBindMap)[t] || (r[t] = {}), (n = this._uniformBindMap[t])[s] || (n[s] = e), this.groups[t] || (this.groups[t] = new $s(), this._ownedBindGroups.push(this.groups[t]));
  }
  _buildResourceAccessor(e, t) {
    const s = {};
    for (const r in t) {
      const n = t[r];
      Object.defineProperty(s, n.name, {
        get() {
          return e[n.group].getResource(n.binding);
        },
        set(o) {
          e[n.group].setResource(o, n.binding);
        }
      });
    }
    return s;
  }
  /**
   * Use to destroy the shader when its not longer needed.
   * It will destroy the resources and remove listeners.
   * @param destroyPrograms - if the programs should be destroyed as well.
   * Make sure its not being used by other shaders!
   */
  destroy(e = !1) {
    this._destroyed || (this._destroyed = !0, this.emit("destroy", this), e && (this.gpuProgram?.destroy(), this.glProgram?.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach((t) => {
      t.destroy();
    }), this._ownedBindGroups = null, this.resources = null, this.groups = null);
  }
  static from(e) {
    const { gpu: t, gl: s, ...r } = e;
    let n, o;
    return t && (n = yi.from(t)), s && (o = xi.from(s)), new pr({
      gpuProgram: n,
      glProgram: o,
      ...r
    });
  }
}
const H2 = {
  normal: 0,
  add: 1,
  multiply: 2,
  screen: 3,
  overlay: 4,
  erase: 5,
  "normal-npm": 6,
  "add-npm": 7,
  "screen-npm": 8,
  min: 9,
  max: 10
}, qc = 0, Zc = 1, Kc = 2, Jc = 3, jc = 4, Qc = 5, zh = class jp {
  constructor() {
    this.data = 0, this.blendMode = "normal", this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;
  }
  /**
   * Activates blending of the computed fragment color values.
   * @default true
   */
  get blend() {
    return !!(this.data & 1 << qc);
  }
  set blend(e) {
    !!(this.data & 1 << qc) !== e && (this.data ^= 1 << qc);
  }
  /**
   * Activates adding an offset to depth values of polygon's fragments
   * @default false
   */
  get offsets() {
    return !!(this.data & 1 << Zc);
  }
  set offsets(e) {
    !!(this.data & 1 << Zc) !== e && (this.data ^= 1 << Zc);
  }
  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */
  set cullMode(e) {
    if (e === "none") {
      this.culling = !1;
      return;
    }
    this.culling = !0, this.clockwiseFrontFace = e === "front";
  }
  get cullMode() {
    return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none";
  }
  /**
   * Activates culling of polygons.
   * @default false
   */
  get culling() {
    return !!(this.data & 1 << Kc);
  }
  set culling(e) {
    !!(this.data & 1 << Kc) !== e && (this.data ^= 1 << Kc);
  }
  /**
   * Activates depth comparisons and updates to the depth buffer.
   * @default false
   */
  get depthTest() {
    return !!(this.data & 1 << Jc);
  }
  set depthTest(e) {
    !!(this.data & 1 << Jc) !== e && (this.data ^= 1 << Jc);
  }
  /**
   * Enables or disables writing to the depth buffer.
   * @default true
   */
  get depthMask() {
    return !!(this.data & 1 << Qc);
  }
  set depthMask(e) {
    !!(this.data & 1 << Qc) !== e && (this.data ^= 1 << Qc);
  }
  /**
   * Specifies whether or not front or back-facing polygons can be culled.
   * @default false
   */
  get clockwiseFrontFace() {
    return !!(this.data & 1 << jc);
  }
  set clockwiseFrontFace(e) {
    !!(this.data & 1 << jc) !== e && (this.data ^= 1 << jc);
  }
  /**
   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.
   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
   * @default 'normal'
   */
  get blendMode() {
    return this._blendMode;
  }
  set blendMode(e) {
    this.blend = e !== "none", this._blendMode = e, this._blendModeId = H2[e] || 0;
  }
  /**
   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
   * @default 0
   */
  get polygonOffset() {
    return this._polygonOffset;
  }
  set polygonOffset(e) {
    this.offsets = !!e, this._polygonOffset = e;
  }
  toString() {
    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
  }
  /**
   * A quickly getting an instance of a State that is configured for 2d rendering.
   * @returns a new State with values set for 2d rendering
   */
  static for2d() {
    const e = new jp();
    return e.depthTest = !1, e.blend = !0, e;
  }
};
zh.default2d = zh.for2d();
let W2 = zh;
const Qp = class Oh extends pr {
  /**
   * @param options - The optional parameters of this filter.
   */
  constructor(e) {
    e = { ...Oh.defaultOptions, ...e }, super(e), this.enabled = !0, this._state = W2.for2d(), this.blendMode = e.blendMode, this.padding = e.padding, typeof e.antialias == "boolean" ? this.antialias = e.antialias ? "on" : "off" : this.antialias = e.antialias, this.resolution = e.resolution, this.blendRequired = e.blendRequired, this.clipToViewport = e.clipToViewport, this.addResource("uTexture", 0, 1), e.blendRequired && this.addResource("uBackTexture", 0, 3);
  }
  /**
   * Applies the filter
   * @param filterManager - The renderer to retrieve the filter from
   * @param input - The input render target.
   * @param output - The target to output to.
   * @param clearMode - Should the output be cleared before rendering to it
   */
  apply(e, t, s, r) {
    e.applyFilter(this, t, s, r);
  }
  /**
   * Get the blend mode of the filter.
   * @default "normal"
   */
  get blendMode() {
    return this._state.blendMode;
  }
  /** Sets the blend mode of the filter. */
  set blendMode(e) {
    this._state.blendMode = e;
  }
  /**
   * A short hand function to create a filter based of a vertex and fragment shader src.
   * @param options
   * @returns A shiny new PixiJS filter!
   */
  static from(e) {
    const { gpu: t, gl: s, ...r } = e;
    let n, o;
    return t && (n = yi.from(t)), s && (o = xi.from(s)), new Oh({
      gpuProgram: n,
      glProgram: o,
      ...r
    });
  }
};
Qp.defaultOptions = {
  blendMode: "normal",
  resolution: 1,
  padding: 0,
  antialias: "off",
  blendRequired: !1,
  clipToViewport: !0
};
let mr = Qp;
const Dh = [];
ke.handleByNamedList(O.Environment, Dh);
async function V2(i) {
  if (!i)
    for (let e = 0; e < Dh.length; e++) {
      const t = Dh[e];
      if (t.value.test()) {
        await t.value.load();
        return;
      }
    }
}
let Ii;
function $2() {
  if (typeof Ii == "boolean")
    return Ii;
  try {
    Ii = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({ a: "b" }, "a", "b") === !0;
  } catch {
    Ii = !1;
  }
  return Ii;
}
function sd(i, e, t = 2) {
  const s = e && e.length, r = s ? e[0] * t : i.length;
  let n = em(i, 0, r, t, !0);
  const o = [];
  if (!n || n.next === n.prev) return o;
  let a, l, c;
  if (s && (n = K2(i, e, n, t)), i.length > 80 * t) {
    a = i[0], l = i[1];
    let h = a, u = l;
    for (let d = t; d < r; d += t) {
      const f = i[d], m = i[d + 1];
      f < a && (a = f), m < l && (l = m), f > h && (h = f), m > u && (u = m);
    }
    c = Math.max(h - a, u - l), c = c !== 0 ? 32767 / c : 0;
  }
  return Qi(n, o, t, a, l, c, 0), o;
}
function em(i, e, t, s, r) {
  let n;
  if (r === a1(i, e, t, s) > 0)
    for (let o = e; o < t; o += s) n = rd(o / s | 0, i[o], i[o + 1], n);
  else
    for (let o = t - s; o >= e; o -= s) n = rd(o / s | 0, i[o], i[o + 1], n);
  return n && fi(n, n.next) && (ts(n), n = n.next), n;
}
function Vt(i, e) {
  if (!i) return i;
  e || (e = i);
  let t = i, s;
  do
    if (s = !1, !t.steiner && (fi(t, t.next) || he(t.prev, t, t.next) === 0)) {
      if (ts(t), t = e = t.prev, t === t.next) break;
      s = !0;
    } else
      t = t.next;
  while (s || t !== e);
  return e;
}
function Qi(i, e, t, s, r, n, o) {
  if (!i) return;
  !o && n && t1(i, s, r, n);
  let a = i;
  for (; i.prev !== i.next; ) {
    const l = i.prev, c = i.next;
    if (n ? X2(i, s, r, n) : Y2(i)) {
      e.push(l.i, i.i, c.i), ts(i), i = c.next, a = c.next;
      continue;
    }
    if (i = c, i === a) {
      o ? o === 1 ? (i = q2(Vt(i), e), Qi(i, e, t, s, r, n, 2)) : o === 2 && Z2(i, e, t, s, r, n) : Qi(Vt(i), e, t, s, r, n, 1);
      break;
    }
  }
}
function Y2(i) {
  const e = i.prev, t = i, s = i.next;
  if (he(e, t, s) >= 0) return !1;
  const r = e.x, n = t.x, o = s.x, a = e.y, l = t.y, c = s.y, h = Math.min(r, n, o), u = Math.min(a, l, c), d = Math.max(r, n, o), f = Math.max(a, l, c);
  let m = s.next;
  for (; m !== e; ) {
    if (m.x >= h && m.x <= d && m.y >= u && m.y <= f && Li(r, a, n, l, o, c, m.x, m.y) && he(m.prev, m, m.next) >= 0) return !1;
    m = m.next;
  }
  return !0;
}
function X2(i, e, t, s) {
  const r = i.prev, n = i, o = i.next;
  if (he(r, n, o) >= 0) return !1;
  const a = r.x, l = n.x, c = o.x, h = r.y, u = n.y, d = o.y, f = Math.min(a, l, c), m = Math.min(h, u, d), g = Math.max(a, l, c), p = Math.max(h, u, d), x = Lh(f, m, e, t, s), y = Lh(g, p, e, t, s);
  let v = i.prevZ, _ = i.nextZ;
  for (; v && v.z >= x && _ && _.z <= y; ) {
    if (v.x >= f && v.x <= g && v.y >= m && v.y <= p && v !== r && v !== o && Li(a, h, l, u, c, d, v.x, v.y) && he(v.prev, v, v.next) >= 0 || (v = v.prevZ, _.x >= f && _.x <= g && _.y >= m && _.y <= p && _ !== r && _ !== o && Li(a, h, l, u, c, d, _.x, _.y) && he(_.prev, _, _.next) >= 0)) return !1;
    _ = _.nextZ;
  }
  for (; v && v.z >= x; ) {
    if (v.x >= f && v.x <= g && v.y >= m && v.y <= p && v !== r && v !== o && Li(a, h, l, u, c, d, v.x, v.y) && he(v.prev, v, v.next) >= 0) return !1;
    v = v.prevZ;
  }
  for (; _ && _.z <= y; ) {
    if (_.x >= f && _.x <= g && _.y >= m && _.y <= p && _ !== r && _ !== o && Li(a, h, l, u, c, d, _.x, _.y) && he(_.prev, _, _.next) >= 0) return !1;
    _ = _.nextZ;
  }
  return !0;
}
function q2(i, e) {
  let t = i;
  do {
    const s = t.prev, r = t.next.next;
    !fi(s, r) && im(s, t, t.next, r) && es(s, r) && es(r, s) && (e.push(s.i, t.i, r.i), ts(t), ts(t.next), t = i = r), t = t.next;
  } while (t !== i);
  return Vt(t);
}
function Z2(i, e, t, s, r, n) {
  let o = i;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && r1(o, a)) {
        let l = sm(o, a);
        o = Vt(o, o.next), l = Vt(l, l.next), Qi(o, e, t, s, r, n, 0), Qi(l, e, t, s, r, n, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== i);
}
function K2(i, e, t, s) {
  const r = [];
  for (let n = 0, o = e.length; n < o; n++) {
    const a = e[n] * s, l = n < o - 1 ? e[n + 1] * s : i.length, c = em(i, a, l, s, !1);
    c === c.next && (c.steiner = !0), r.push(s1(c));
  }
  r.sort(J2);
  for (let n = 0; n < r.length; n++)
    t = j2(r[n], t);
  return t;
}
function J2(i, e) {
  let t = i.x - e.x;
  if (t === 0 && (t = i.y - e.y, t === 0)) {
    const s = (i.next.y - i.y) / (i.next.x - i.x), r = (e.next.y - e.y) / (e.next.x - e.x);
    t = s - r;
  }
  return t;
}
function j2(i, e) {
  const t = Q2(i, e);
  if (!t)
    return e;
  const s = sm(t, i);
  return Vt(s, s.next), Vt(t, t.next);
}
function Q2(i, e) {
  let t = e;
  const s = i.x, r = i.y;
  let n = -1 / 0, o;
  if (fi(i, t)) return t;
  do {
    if (fi(i, t.next)) return t.next;
    if (r <= t.y && r >= t.next.y && t.next.y !== t.y) {
      const u = t.x + (r - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (u <= s && u > n && (n = u, o = t.x < t.next.x ? t : t.next, u === s))
        return o;
    }
    t = t.next;
  } while (t !== e);
  if (!o) return null;
  const a = o, l = o.x, c = o.y;
  let h = 1 / 0;
  t = o;
  do {
    if (s >= t.x && t.x >= l && s !== t.x && tm(r < c ? s : n, r, l, c, r < c ? n : s, r, t.x, t.y)) {
      const u = Math.abs(r - t.y) / (s - t.x);
      es(t, i) && (u < h || u === h && (t.x > o.x || t.x === o.x && e1(o, t))) && (o = t, h = u);
    }
    t = t.next;
  } while (t !== a);
  return o;
}
function e1(i, e) {
  return he(i.prev, i, e.prev) < 0 && he(e.next, i, i.next) < 0;
}
function t1(i, e, t, s) {
  let r = i;
  do
    r.z === 0 && (r.z = Lh(r.x, r.y, e, t, s)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== i);
  r.prevZ.nextZ = null, r.prevZ = null, i1(r);
}
function i1(i) {
  let e, t = 1;
  do {
    let s = i, r;
    i = null;
    let n = null;
    for (e = 0; s; ) {
      e++;
      let o = s, a = 0;
      for (let c = 0; c < t && (a++, o = o.nextZ, !!o); c++)
        ;
      let l = t;
      for (; a > 0 || l > 0 && o; )
        a !== 0 && (l === 0 || !o || s.z <= o.z) ? (r = s, s = s.nextZ, a--) : (r = o, o = o.nextZ, l--), n ? n.nextZ = r : i = r, r.prevZ = n, n = r;
      s = o;
    }
    n.nextZ = null, t *= 2;
  } while (e > 1);
  return i;
}
function Lh(i, e, t, s, r) {
  return i = (i - t) * r | 0, e = (e - s) * r | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, i | e << 1;
}
function s1(i) {
  let e = i, t = i;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== i);
  return t;
}
function tm(i, e, t, s, r, n, o, a) {
  return (r - o) * (e - a) >= (i - o) * (n - a) && (i - o) * (s - a) >= (t - o) * (e - a) && (t - o) * (n - a) >= (r - o) * (s - a);
}
function Li(i, e, t, s, r, n, o, a) {
  return !(i === o && e === a) && tm(i, e, t, s, r, n, o, a);
}
function r1(i, e) {
  return i.next.i !== e.i && i.prev.i !== e.i && !n1(i, e) && // doesn't intersect other edges
  (es(i, e) && es(e, i) && o1(i, e) && // locally visible
  (he(i.prev, i, e.prev) || he(i, e.prev, e)) || // does not create opposite-facing sectors
  fi(i, e) && he(i.prev, i, i.next) > 0 && he(e.prev, e, e.next) > 0);
}
function he(i, e, t) {
  return (e.y - i.y) * (t.x - e.x) - (e.x - i.x) * (t.y - e.y);
}
function fi(i, e) {
  return i.x === e.x && i.y === e.y;
}
function im(i, e, t, s) {
  const r = Ts(he(i, e, t)), n = Ts(he(i, e, s)), o = Ts(he(t, s, i)), a = Ts(he(t, s, e));
  return !!(r !== n && o !== a || r === 0 && ws(i, t, e) || n === 0 && ws(i, s, e) || o === 0 && ws(t, i, s) || a === 0 && ws(t, e, s));
}
function ws(i, e, t) {
  return e.x <= Math.max(i.x, t.x) && e.x >= Math.min(i.x, t.x) && e.y <= Math.max(i.y, t.y) && e.y >= Math.min(i.y, t.y);
}
function Ts(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function n1(i, e) {
  let t = i;
  do {
    if (t.i !== i.i && t.next.i !== i.i && t.i !== e.i && t.next.i !== e.i && im(t, t.next, i, e)) return !0;
    t = t.next;
  } while (t !== i);
  return !1;
}
function es(i, e) {
  return he(i.prev, i, i.next) < 0 ? he(i, e, i.next) >= 0 && he(i, i.prev, e) >= 0 : he(i, e, i.prev) < 0 || he(i, i.next, e) < 0;
}
function o1(i, e) {
  let t = i, s = !1;
  const r = (i.x + e.x) / 2, n = (i.y + e.y) / 2;
  do
    t.y > n != t.next.y > n && t.next.y !== t.y && r < (t.next.x - t.x) * (n - t.y) / (t.next.y - t.y) + t.x && (s = !s), t = t.next;
  while (t !== i);
  return s;
}
function sm(i, e) {
  const t = Nh(i.i, i.x, i.y), s = Nh(e.i, e.x, e.y), r = i.next, n = e.prev;
  return i.next = e, e.prev = i, t.next = r, r.prev = t, s.next = t, t.prev = s, n.next = s, s.prev = n, s;
}
function rd(i, e, t, s) {
  const r = Nh(i, e, t);
  return s ? (r.next = s.next, r.prev = s, s.next.prev = r, s.next = r) : (r.prev = r, r.next = r), r;
}
function ts(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function Nh(i, e, t) {
  return {
    i,
    // vertex index in coordinates array
    x: e,
    y: t,
    // vertex coordinates
    prev: null,
    // previous and next vertex nodes in a polygon ring
    next: null,
    z: 0,
    // z-order curve value
    prevZ: null,
    // previous and next nodes in z-order
    nextZ: null,
    steiner: !1
    // indicates whether this is a steiner point
  };
}
function a1(i, e, t, s) {
  let r = 0;
  for (let n = e, o = t - s; n < t; n += s)
    r += (i[o] - i[n]) * (i[n + 1] + i[o + 1]), o = n;
  return r;
}
const l1 = sd.default || sd;
var rm = /* @__PURE__ */ ((i) => (i[i.NONE = 0] = "NONE", i[i.COLOR = 16384] = "COLOR", i[i.STENCIL = 1024] = "STENCIL", i[i.DEPTH = 256] = "DEPTH", i[i.COLOR_DEPTH = 16640] = "COLOR_DEPTH", i[i.COLOR_STENCIL = 17408] = "COLOR_STENCIL", i[i.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", i[i.ALL = 17664] = "ALL", i))(rm || {});
class c1 {
  /**
   * @param name - The function name that will be executed on the listeners added to this Runner.
   */
  constructor(e) {
    this.items = [], this._name = e;
  }
  /* jsdoc/check-param-names */
  /**
   * Dispatch/Broadcast Runner to all listeners added to the queue.
   * @param {...any} params - (optional) parameters to pass to each listener
   */
  /* jsdoc/check-param-names */
  emit(e, t, s, r, n, o, a, l) {
    const { name: c, items: h } = this;
    for (let u = 0, d = h.length; u < d; u++)
      h[u][c](e, t, s, r, n, o, a, l);
    return this;
  }
  /**
   * Add a listener to the Runner
   *
   * Runners do not need to have scope or functions passed to them.
   * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
   * as the name provided to the Runner when it was created.
   *
   * Eg A listener passed to this Runner will require a 'complete' function.
   *
   * ```ts
   * import { Runner } from 'pixi.js';
   *
   * const complete = new Runner('complete');
   * ```
   *
   * The scope used will be the object itself.
   * @param {any} item - The object that will be listening.
   */
  add(e) {
    return e[this._name] && (this.remove(e), this.items.push(e)), this;
  }
  /**
   * Remove a single listener from the dispatch queue.
   * @param {any} item - The listener that you would like to remove.
   */
  remove(e) {
    const t = this.items.indexOf(e);
    return t !== -1 && this.items.splice(t, 1), this;
  }
  /**
   * Check to see if the listener is already in the Runner
   * @param {any} item - The listener that you would like to check.
   */
  contains(e) {
    return this.items.indexOf(e) !== -1;
  }
  /** Remove all listeners from the Runner */
  removeAll() {
    return this.items.length = 0, this;
  }
  /** Remove all references, don't use after this. */
  destroy() {
    this.removeAll(), this.items = null, this._name = null;
  }
  /**
   * `true` if there are no this Runner contains no listeners
   * @readonly
   */
  get empty() {
    return this.items.length === 0;
  }
  /**
   * The name of the runner.
   * @readonly
   */
  get name() {
    return this._name;
  }
}
const h1 = [
  "init",
  "destroy",
  "contextChange",
  "resolutionChange",
  "resetState",
  "renderEnd",
  "renderStart",
  "render",
  "update",
  "postrender",
  "prerender"
], nm = class om extends rt {
  /**
   * Set up a system with a collection of SystemClasses and runners.
   * Systems are attached dynamically to this class when added.
   * @param config - the config for the system manager
   */
  constructor(e) {
    super(), this.uid = de("renderer"), this.runners = /* @__PURE__ */ Object.create(null), this.renderPipes = /* @__PURE__ */ Object.create(null), this._initOptions = {}, this._systemsHash = /* @__PURE__ */ Object.create(null), this.type = e.type, this.name = e.name, this.config = e;
    const t = [...h1, ...this.config.runners ?? []];
    this._addRunners(...t), this._unsafeEvalCheck();
  }
  /**
   * Initialize the renderer.
   * @param options - The options to use to create the renderer.
   */
  async init(e = {}) {
    const t = e.skipExtensionImports === !0 ? !0 : e.manageImports === !1;
    await V2(t), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
    for (const s in this._systemsHash)
      e = { ...this._systemsHash[s].constructor.defaultOptions, ...e };
    e = { ...om.defaultOptions, ...e }, this._roundPixels = e.roundPixels ? 1 : 0;
    for (let s = 0; s < this.runners.init.items.length; s++)
      await this.runners.init.items[s].init(e);
    this._initOptions = e;
  }
  render(e, t) {
    let s = e;
    if (s instanceof oe && (s = { container: s }, t && (N(J, "passing a second argument is deprecated, please use render options instead"), s.target = t.renderTexture)), s.target || (s.target = this.view.renderTarget), s.target === this.view.renderTarget && (this._lastObjectRendered = s.container, s.clearColor ?? (s.clearColor = this.background.colorRgba), s.clear ?? (s.clear = this.background.clearBeforeRender)), s.clearColor) {
      const r = Array.isArray(s.clearColor) && s.clearColor.length === 4;
      s.clearColor = r ? s.clearColor : pe.shared.setValue(s.clearColor).toArray();
    }
    s.transform || (s.container.updateLocalTransform(), s.transform = s.container.localTransform), s.container.visible && (s.container.enableRenderGroup(), this.runners.prerender.emit(s), this.runners.renderStart.emit(s), this.runners.render.emit(s), this.runners.renderEnd.emit(s), this.runners.postrender.emit(s));
  }
  /**
   * Resizes the WebGL view to the specified width and height.
   * @param desiredScreenWidth - The desired width of the screen.
   * @param desiredScreenHeight - The desired height of the screen.
   * @param resolution - The resolution / device pixel ratio of the renderer.
   */
  resize(e, t, s) {
    const r = this.view.resolution;
    this.view.resize(e, t, s), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), s !== void 0 && s !== r && this.runners.resolutionChange.emit(s);
  }
  /**
   * Clears the render target.
   * @param options - The options to use when clearing the render target.
   * @param options.target - The render target to clear.
   * @param options.clearColor - The color to clear with.
   * @param options.clear - The clear mode to use.
   * @advanced
   */
  clear(e = {}) {
    const t = this;
    e.target || (e.target = t.renderTarget.renderTarget), e.clearColor || (e.clearColor = this.background.colorRgba), e.clear ?? (e.clear = rm.ALL);
    const { clear: s, clearColor: r, target: n } = e;
    pe.shared.setValue(r ?? this.background.colorRgba), t.renderTarget.clear(n, s, pe.shared.toArray());
  }
  /** The resolution / device pixel ratio of the renderer. */
  get resolution() {
    return this.view.resolution;
  }
  set resolution(e) {
    this.view.resolution = e, this.runners.resolutionChange.emit(e);
  }
  /**
   * Same as view.width, actual number of pixels in the canvas by horizontal.
   * @type {number}
   * @readonly
   * @default 800
   */
  get width() {
    return this.view.texture.frame.width;
  }
  /**
   * Same as view.height, actual number of pixels in the canvas by vertical.
   * @default 600
   */
  get height() {
    return this.view.texture.frame.height;
  }
  // NOTE: this was `view` in v7
  /**
   * The canvas element that everything is drawn to.
   * @type {environment.ICanvas}
   */
  get canvas() {
    return this.view.canvas;
  }
  /**
   * the last object rendered by the renderer. Useful for other plugins like interaction managers
   * @readonly
   */
  get lastObjectRendered() {
    return this._lastObjectRendered;
  }
  /**
   * Flag if we are rendering to the screen vs renderTexture
   * @readonly
   * @default true
   */
  get renderingToScreen() {
    return this.renderTarget.renderingToScreen;
  }
  /**
   * Measurements of the screen. (0, 0, screenWidth, screenHeight).
   *
   * Its safe to use as filterArea or hitArea for the whole stage.
   */
  get screen() {
    return this.view.screen;
  }
  /**
   * Create a bunch of runners based of a collection of ids
   * @param runnerIds - the runner ids to add
   */
  _addRunners(...e) {
    e.forEach((t) => {
      this.runners[t] = new c1(t);
    });
  }
  _addSystems(e) {
    let t;
    for (t in e) {
      const s = e[t];
      this._addSystem(s.value, s.name);
    }
  }
  /**
   * Add a new system to the renderer.
   * @param ClassRef - Class reference
   * @param name - Property name for system, if not specified
   *        will use a static `name` property on the class itself. This
   *        name will be assigned as s property on the Renderer so make
   *        sure it doesn't collide with properties on Renderer.
   * @returns Return instance of renderer
   */
  _addSystem(e, t) {
    const s = new e(this);
    if (this[t])
      throw new Error(`Whoops! The name "${t}" is already in use`);
    this[t] = s, this._systemsHash[t] = s;
    for (const r in this.runners)
      this.runners[r].add(s);
    return this;
  }
  _addPipes(e, t) {
    const s = t.reduce((r, n) => (r[n.name] = n.value, r), {});
    e.forEach((r) => {
      const n = r.value, o = r.name, a = s[o];
      this.renderPipes[o] = new n(
        this,
        a ? new a() : null
      ), this.runners.destroy.add(this.renderPipes[o]);
    });
  }
  destroy(e = !1) {
    this.runners.destroy.items.reverse(), this.runners.destroy.emit(e), (e === !0 || typeof e == "object" && e.releaseGlobalResources) && os.release(), Object.values(this.runners).forEach((t) => {
      t.destroy();
    }), this._systemsHash = null, this.renderPipes = null;
  }
  /**
   * Generate a texture from a container.
   * @param options - options or container target to use when generating the texture
   * @returns a texture
   */
  generateTexture(e) {
    return this.textureGenerator.generateTexture(e);
  }
  /**
   * Whether the renderer will round coordinates to whole pixels when rendering.
   * Can be overridden on a per scene item basis.
   */
  get roundPixels() {
    return !!this._roundPixels;
  }
  /**
   * Overridable function by `pixi.js/unsafe-eval` to silence
   * throwing an error if platform doesn't support unsafe-evals.
   * @private
   * @ignore
   */
  _unsafeEvalCheck() {
    if (!$2())
      throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
  }
  /**
   * Resets the rendering state of the renderer.
   * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state
   * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi
   * render will reset all internal caches and ensure it executes correctly.
   *
   * This is particularly useful when combining PixiJS with other rendering engines like Three.js:
   * ```js
   * // Reset Three.js state
   * threeRenderer.resetState();
   *
   * // Render a Three.js scene
   * threeRenderer.render(threeScene, threeCamera);
   *
   * // Reset PixiJS state since Three.js modified the WebGL context
   * pixiRenderer.resetState();
   *
   * // Now render Pixi content
   * pixiRenderer.render(pixiScene);
   * ```
   * @advanced
   */
  resetState() {
    this.runners.resetState.emit();
  }
};
nm.defaultOptions = {
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @default 1
   */
  resolution: 1,
  /**
   * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`
   * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be
   * performance issues when using WebGL.
   *
   * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many
   * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or
   * driver version blacklisted by the
   * browser.
   *
   * If your application requires high performance rendering, you may wish to set this to false.
   * We recommend one of two options if you decide to set this flag to false:
   *
   * 1: Use the Canvas renderer as a fallback in case high performance WebGL is
   *    not supported.
   *
   * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a
   *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their
   *    device & browser combination does not support high performance WebGL.
   *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.
   * @default false
   */
  failIfMajorPerformanceCaveat: !1,
  /**
   * Should round pixels be forced when rendering?
   * @default false
   */
  roundPixels: !1
};
let am = nm, Ss;
function u1(i) {
  return Ss !== void 0 || (Ss = (() => {
    const e = {
      stencil: !0,
      failIfMajorPerformanceCaveat: i ?? am.defaultOptions.failIfMajorPerformanceCaveat
    };
    try {
      if (!re.get().getWebGLRenderingContext())
        return !1;
      let s = re.get().createCanvas().getContext("webgl", e);
      const r = !!s?.getContextAttributes()?.stencil;
      if (s) {
        const n = s.getExtension("WEBGL_lose_context");
        n && n.loseContext();
      }
      return s = null, r;
    } catch {
      return !1;
    }
  })()), Ss;
}
let Cs;
async function d1(i = {}) {
  return Cs !== void 0 || (Cs = await (async () => {
    const e = re.get().getNavigator().gpu;
    if (!e)
      return !1;
    try {
      return await (await e.requestAdapter(i)).requestDevice(), !0;
    } catch {
      return !1;
    }
  })()), Cs;
}
const nd = ["webgl", "webgpu", "canvas"];
async function f1(i) {
  let e = [];
  i.preference ? (e.push(i.preference), nd.forEach((n) => {
    n !== i.preference && e.push(n);
  })) : e = nd.slice();
  let t, s = {};
  for (let n = 0; n < e.length; n++) {
    const o = e[n];
    if (o === "webgpu" && await d1()) {
      const { WebGPURenderer: a } = await import("./WebGPURenderer-Bb_9YgXL.js");
      t = a, s = { ...i, ...i.webgpu };
      break;
    } else if (o === "webgl" && u1(
      i.failIfMajorPerformanceCaveat ?? am.defaultOptions.failIfMajorPerformanceCaveat
    )) {
      const { WebGLRenderer: a } = await import("./WebGLRenderer-DQQ5n9CS.js");
      t = a, s = { ...i, ...i.webgl };
      break;
    } else if (o === "canvas")
      throw s = { ...i }, new Error("CanvasRenderer is not yet implemented");
  }
  if (delete s.webgpu, delete s.webgl, !t)
    throw new Error("No available renderer for the current environment");
  const r = new t();
  return await r.init(s), r;
}
const lm = "8.14.3";
class cm {
  static init() {
    globalThis.__PIXI_APP_INIT__?.(this, lm);
  }
  static destroy() {
  }
}
cm.extension = O.Application;
class p1 {
  constructor(e) {
    this._renderer = e;
  }
  init() {
    globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, lm);
  }
  destroy() {
    this._renderer = null;
  }
}
p1.extension = {
  type: [
    O.WebGLSystem,
    O.WebGPUSystem
  ],
  name: "initHook",
  priority: -10
};
const hm = class Gh {
  constructor(...e) {
    this.stage = new oe(), e[0] !== void 0 && N(J, "Application constructor options are deprecated, please use Application.init() instead.");
  }
  /**
   * Initializes the PixiJS application with the specified options.
   *
   * This method must be called after creating a new Application instance.
   * @param options - Configuration options for the application and renderer
   * @returns A promise that resolves when initialization is complete
   * @example
   * ```js
   * const app = new Application();
   *
   * // Initialize with custom options
   * await app.init({
   *     width: 800,
   *     height: 600,
   *     backgroundColor: 0x1099bb,
   *     preference: 'webgl', // or 'webgpu'
   * });
   * ```
   */
  async init(e) {
    e = { ...e }, this.stage || (this.stage = new oe()), this.renderer = await f1(e), Gh._plugins.forEach((t) => {
      t.init.call(this, e);
    });
  }
  /**
   * Renders the current stage to the screen.
   *
   * When using the default setup with {@link TickerPlugin} (enabled by default), you typically don't need to call
   * this method directly as rendering is handled automatically.
   *
   * Only use this method if you've disabled the {@link TickerPlugin} or need custom
   * render timing control.
   * @example
   * ```js
   * // Example 1: Default setup (TickerPlugin handles rendering)
   * const app = new Application();
   * await app.init();
   * // No need to call render() - TickerPlugin handles it
   *
   * // Example 2: Custom rendering loop (if TickerPlugin is disabled)
   * const app = new Application();
   * await app.init({ autoStart: false }); // Disable automatic rendering
   *
   * function animate() {
   *     app.render();
   *     requestAnimationFrame(animate);
   * }
   * animate();
   * ```
   */
  render() {
    this.renderer.render({ container: this.stage });
  }
  /**
   * Reference to the renderer's canvas element. This is the HTML element
   * that displays your application's graphics.
   * @readonly
   * @type {HTMLCanvasElement}
   * @example
   * ```js
   * // Create a new application
   * const app = new Application();
   * // Initialize the application
   * await app.init({...});
   * // Add canvas to the page
   * document.body.appendChild(app.canvas);
   *
   * // Access the canvas directly
   * console.log(app.canvas); // HTMLCanvasElement
   * ```
   */
  get canvas() {
    return this.renderer.canvas;
  }
  /**
   * Reference to the renderer's canvas element.
   * @type {HTMLCanvasElement}
   * @deprecated since 8.0.0
   * @see {@link Application#canvas}
   */
  get view() {
    return N(J, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas;
  }
  /**
   * Reference to the renderer's screen rectangle. This represents the visible area of your application.
   *
   * It's commonly used for:
   * - Setting filter areas for full-screen effects
   * - Defining hit areas for screen-wide interaction
   * - Determining the visible bounds of your application
   * @readonly
   * @example
   * ```js
   * // Use as filter area for a full-screen effect
   * const blurFilter = new BlurFilter();
   * sprite.filterArea = app.screen;
   *
   * // Use as hit area for screen-wide interaction
   * const screenSprite = new Sprite();
   * screenSprite.hitArea = app.screen;
   *
   * // Get screen dimensions
   * console.log(app.screen.width, app.screen.height);
   * ```
   * @see {@link Rectangle} For all available properties and methods
   */
  get screen() {
    return this.renderer.screen;
  }
  /**
   * Destroys the application and all of its resources.
   *
   * This method should be called when you want to completely
   * clean up the application and free all associated memory.
   * @param rendererDestroyOptions - Options for destroying the renderer:
   *  - `false` or `undefined`: Preserves the canvas element (default)
   *  - `true`: Removes the canvas element
   *  - `{ removeView: boolean }`: Object with removeView property to control canvas removal
   * @param options - Options for destroying the application:
   *  - `false` or `undefined`: Basic cleanup (default)
   *  - `true`: Complete cleanup including children
   *  - Detailed options object:
   *    - `children`: Remove children
   *    - `texture`: Destroy textures
   *    - `textureSource`: Destroy texture sources
   *    - `context`: Destroy WebGL context
   * @example
   * ```js
   * // Basic cleanup
   * app.destroy();
   *
   * // Remove canvas and do complete cleanup
   * app.destroy(true, true);
   *
   * // Remove canvas with explicit options
   * app.destroy({ removeView: true }, true);
   *
   * // Detailed cleanup with specific options
   * app.destroy(
   *     { removeView: true },
   *     {
   *         children: true,
   *         texture: true,
   *         textureSource: true,
   *         context: true
   *     }
   * );
   * ```
   * > [!WARNING] After calling destroy, the application instance should no longer be used.
   * > All properties will be null and further operations will throw errors.
   */
  destroy(e = !1, t = !1) {
    const s = Gh._plugins.slice(0);
    s.reverse(), s.forEach((r) => {
      r.destroy.call(this);
    }), this.stage.destroy(t), this.stage = null, this.renderer.destroy(e), this.renderer = null;
  }
};
hm._plugins = [];
let cu = hm;
ke.handleByList(O.Application, cu._plugins);
ke.add(cm);
class um extends rt {
  constructor() {
    super(...arguments), this.chars = /* @__PURE__ */ Object.create(null), this.lineHeight = 0, this.fontFamily = "", this.fontMetrics = { fontSize: 0, ascent: 0, descent: 0 }, this.baseLineOffset = 0, this.distanceField = { type: "none", range: 0 }, this.pages = [], this.applyFillAsTint = !0, this.baseMeasurementFontSize = 100, this.baseRenderedFontSize = 100;
  }
  /**
   * The name of the font face.
   * @deprecated since 8.0.0 Use `fontFamily` instead.
   */
  get font() {
    return N(J, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."), this.fontFamily;
  }
  /**
   * The map of base page textures (i.e., sheets of glyphs).
   * @deprecated since 8.0.0 Use `pages` instead.
   */
  get pageTextures() {
    return N(J, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
  }
  /**
   * The size of the font face in pixels.
   * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.
   */
  get size() {
    return N(J, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."), this.fontMetrics.fontSize;
  }
  /**
   * The kind of distance field for this font or "none".
   * @deprecated since 8.0.0 Use `distanceField.type` instead.
   */
  get distanceFieldRange() {
    return N(J, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."), this.distanceField.range;
  }
  /**
   * The range of the distance field in pixels.
   * @deprecated since 8.0.0 Use `distanceField.range` instead.
   */
  get distanceFieldType() {
    return N(J, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."), this.distanceField.type;
  }
  destroy(e = !1) {
    this.emit("destroy", this), this.removeAllListeners();
    for (const t in this.chars)
      this.chars[t].texture?.destroy();
    this.chars = null, e && (this.pages.forEach((t) => t.texture.destroy(!0)), this.pages = null);
  }
}
class m1 {
  /**
   * Creates a new LRU cache instance.
   * Note: Constructor does not validate parameters. Use lru() factory function for parameter validation.
   *
   * @constructor
   * @param {number} [max=0] - Maximum number of items to store. 0 means unlimited.
   * @param {number} [ttl=0] - Time to live in milliseconds. 0 means no expiration.
   * @param {boolean} [resetTtl=false] - Whether to reset TTL when accessing existing items via get().
   * @example
   * const cache = new LRU(1000, 60000, true); // 1000 items, 1 minute TTL, reset on access
   * @see {@link lru} For parameter validation
   * @since 1.0.0
   */
  constructor(e = 0, t = 0, s = !1) {
    this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.max = e, this.resetTtl = s, this.size = 0, this.ttl = t;
  }
  /**
   * Removes all items from the cache.
   *
   * @method clear
   * @memberof LRU
   * @returns {LRU} The LRU instance for method chaining.
   * @example
   * cache.clear();
   * console.log(cache.size); // 0
   * @since 1.0.0
   */
  clear() {
    return this.first = null, this.items = /* @__PURE__ */ Object.create(null), this.last = null, this.size = 0, this;
  }
  /**
   * Removes an item from the cache by key.
   *
   * @method delete
   * @memberof LRU
   * @param {string} key - The key of the item to delete.
   * @returns {LRU} The LRU instance for method chaining.
   * @example
   * cache.set('key1', 'value1');
   * cache.delete('key1');
   * console.log(cache.has('key1')); // false
   * @see {@link LRU#has}
   * @see {@link LRU#clear}
   * @since 1.0.0
   */
  delete(e) {
    if (this.has(e)) {
      const t = this.items[e];
      delete this.items[e], this.size--, t.prev !== null && (t.prev.next = t.next), t.next !== null && (t.next.prev = t.prev), this.first === t && (this.first = t.next), this.last === t && (this.last = t.prev);
    }
    return this;
  }
  /**
   * Returns an array of [key, value] pairs for the specified keys.
   * Order follows LRU order (least to most recently used).
   *
   * @method entries
   * @memberof LRU
   * @param {string[]} [keys=this.keys()] - Array of keys to get entries for. Defaults to all keys.
   * @returns {Array<Array<*>>} Array of [key, value] pairs in LRU order.
   * @example
   * cache.set('a', 1).set('b', 2);
   * console.log(cache.entries()); // [['a', 1], ['b', 2]]
   * console.log(cache.entries(['a'])); // [['a', 1]]
   * @see {@link LRU#keys}
   * @see {@link LRU#values}
   * @since 11.1.0
   */
  entries(e = this.keys()) {
    return e.map((t) => [t, this.get(t)]);
  }
  /**
   * Removes the least recently used item from the cache.
   *
   * @method evict
   * @memberof LRU
   * @param {boolean} [bypass=false] - Whether to force eviction even when cache is empty.
   * @returns {LRU} The LRU instance for method chaining.
   * @example
   * cache.set('old', 'value').set('new', 'value');
   * cache.evict(); // Removes 'old' item
   * @see {@link LRU#setWithEvicted}
   * @since 1.0.0
   */
  evict(e = !1) {
    if (e || this.size > 0) {
      const t = this.first;
      delete this.items[t.key], --this.size === 0 ? (this.first = null, this.last = null) : (this.first = t.next, this.first.prev = null);
    }
    return this;
  }
  /**
   * Returns the expiration timestamp for a given key.
   *
   * @method expiresAt
   * @memberof LRU
   * @param {string} key - The key to check expiration for.
   * @returns {number|undefined} The expiration timestamp in milliseconds, or undefined if key doesn't exist.
   * @example
   * const cache = new LRU(100, 5000); // 5 second TTL
   * cache.set('key1', 'value1');
   * console.log(cache.expiresAt('key1')); // timestamp 5 seconds from now
   * @see {@link LRU#get}
   * @see {@link LRU#has}
   * @since 1.0.0
   */
  expiresAt(e) {
    let t;
    return this.has(e) && (t = this.items[e].expiry), t;
  }
  /**
   * Retrieves a value from the cache by key. Updates the item's position to most recently used.
   *
   * @method get
   * @memberof LRU
   * @param {string} key - The key to retrieve.
   * @returns {*} The value associated with the key, or undefined if not found or expired.
   * @example
   * cache.set('key1', 'value1');
   * console.log(cache.get('key1')); // 'value1'
   * console.log(cache.get('nonexistent')); // undefined
   * @see {@link LRU#set}
   * @see {@link LRU#has}
   * @since 1.0.0
   */
  get(e) {
    const t = this.items[e];
    if (t !== void 0) {
      if (this.ttl > 0 && t.expiry <= Date.now()) {
        this.delete(e);
        return;
      }
      return this.moveToEnd(t), t.value;
    }
  }
  /**
   * Checks if a key exists in the cache.
   *
   * @method has
   * @memberof LRU
   * @param {string} key - The key to check for.
   * @returns {boolean} True if the key exists, false otherwise.
   * @example
   * cache.set('key1', 'value1');
   * console.log(cache.has('key1')); // true
   * console.log(cache.has('nonexistent')); // false
   * @see {@link LRU#get}
   * @see {@link LRU#delete}
   * @since 9.0.0
   */
  has(e) {
    return e in this.items;
  }
  /**
   * Efficiently moves an item to the end of the LRU list (most recently used position).
   * This is an internal optimization method that avoids the overhead of the full set() operation
   * when only LRU position needs to be updated.
   *
   * @method moveToEnd
   * @memberof LRU
   * @param {Object} item - The cache item with prev/next pointers to reposition.
   * @private
   * @since 11.3.5
   */
  moveToEnd(e) {
    this.last !== e && (e.prev !== null && (e.prev.next = e.next), e.next !== null && (e.next.prev = e.prev), this.first === e && (this.first = e.next), e.prev = this.last, e.next = null, this.last !== null && (this.last.next = e), this.last = e, this.first === null && (this.first = e));
  }
  /**
   * Returns an array of all keys in the cache, ordered from least to most recently used.
   *
   * @method keys
   * @memberof LRU
   * @returns {string[]} Array of keys in LRU order.
   * @example
   * cache.set('a', 1).set('b', 2);
   * cache.get('a'); // Move 'a' to most recent
   * console.log(cache.keys()); // ['b', 'a']
   * @see {@link LRU#values}
   * @see {@link LRU#entries}
   * @since 9.0.0
   */
  keys() {
    const e = [];
    let t = this.first;
    for (; t !== null; )
      e.push(t.key), t = t.next;
    return e;
  }
  /**
   * Sets a value in the cache and returns any evicted item.
   *
   * @method setWithEvicted
   * @memberof LRU
   * @param {string} key - The key to set.
   * @param {*} value - The value to store.
   * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.
   * @returns {Object|null} The evicted item (if any) with shape {key, value, expiry, prev, next}, or null.
   * @example
   * const cache = new LRU(2);
   * cache.set('a', 1).set('b', 2);
   * const evicted = cache.setWithEvicted('c', 3); // evicted = {key: 'a', value: 1, ...}
   * @see {@link LRU#set}
   * @see {@link LRU#evict}
   * @since 11.3.0
   */
  setWithEvicted(e, t, s = this.resetTtl) {
    let r = null;
    if (this.has(e))
      this.set(e, t, !0, s);
    else {
      this.max > 0 && this.size === this.max && (r = { ...this.first }, this.evict(!0));
      let n = this.items[e] = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key: e,
        prev: this.last,
        next: null,
        value: t
      };
      ++this.size === 1 ? this.first = n : this.last.next = n, this.last = n;
    }
    return r;
  }
  /**
   * Sets a value in the cache. Updates the item's position to most recently used.
   *
   * @method set
   * @memberof LRU
   * @param {string} key - The key to set.
   * @param {*} value - The value to store.
   * @param {boolean} [bypass=false] - Internal parameter for setWithEvicted method.
   * @param {boolean} [resetTtl=this.resetTtl] - Whether to reset the TTL for this operation.
   * @returns {LRU} The LRU instance for method chaining.
   * @example
   * cache.set('key1', 'value1')
   *      .set('key2', 'value2')
   *      .set('key3', 'value3');
   * @see {@link LRU#get}
   * @see {@link LRU#setWithEvicted}
   * @since 1.0.0
   */
  set(e, t, s = !1, r = this.resetTtl) {
    let n = this.items[e];
    return s || n !== void 0 ? (n.value = t, s === !1 && r && (n.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl), this.moveToEnd(n)) : (this.max > 0 && this.size === this.max && this.evict(!0), n = this.items[e] = {
      expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
      key: e,
      prev: this.last,
      next: null,
      value: t
    }, ++this.size === 1 ? this.first = n : this.last.next = n, this.last = n), this;
  }
  /**
   * Returns an array of all values in the cache for the specified keys.
   * Order follows LRU order (least to most recently used).
   *
   * @method values
   * @memberof LRU
   * @param {string[]} [keys=this.keys()] - Array of keys to get values for. Defaults to all keys.
   * @returns {Array<*>} Array of values corresponding to the keys in LRU order.
   * @example
   * cache.set('a', 1).set('b', 2);
   * console.log(cache.values()); // [1, 2]
   * console.log(cache.values(['a'])); // [1]
   * @see {@link LRU#keys}
   * @see {@link LRU#entries}
   * @since 11.1.0
   */
  values(e = this.keys()) {
    return e.map((t) => this.get(t));
  }
}
function dm(i = 1e3, e = 0, t = !1) {
  if (isNaN(i) || i < 0)
    throw new TypeError("Invalid max value");
  if (isNaN(e) || e < 0)
    throw new TypeError("Invalid ttl value");
  if (typeof t != "boolean")
    throw new TypeError("Invalid resetTtl value");
  return new m1(i, e, t);
}
const g1 = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
];
function rr(i) {
  const e = typeof i.fontSize == "number" ? `${i.fontSize}px` : i.fontSize;
  let t = i.fontFamily;
  Array.isArray(i.fontFamily) || (t = i.fontFamily.split(","));
  for (let s = t.length - 1; s >= 0; s--) {
    let r = t[s].trim();
    !/([\"\'])[^\'\"]+\1/.test(r) && !g1.includes(r) && (r = `"${r}"`), t[s] = r;
  }
  return `${i.fontStyle} ${i.fontVariant} ${i.fontWeight} ${e} ${t.join(",")}`;
}
const eh = {
  // TextMetrics requires getImageData readback for measuring fonts.
  willReadFrequently: !0
}, nt = class z {
  /**
   * Checking that we can use modern canvas 2D API.
   *
   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.
   * @see TextMetrics.experimentalLetterSpacing
   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing
   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441
   */
  static get experimentalLetterSpacingSupported() {
    let e = z._experimentalLetterSpacingSupported;
    if (e === void 0) {
      const t = re.get().getCanvasRenderingContext2D().prototype;
      e = z._experimentalLetterSpacingSupported = "letterSpacing" in t || "textLetterSpacing" in t;
    }
    return e;
  }
  /**
   * @param text - the text that was measured
   * @param style - the style that was measured
   * @param width - the measured width of the text
   * @param height - the measured height of the text
   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style
   * @param lineWidths - an array of the line widths for each line matched to `lines`
   * @param lineHeight - the measured line height for this style
   * @param maxLineWidth - the maximum line width for all measured lines
   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont
   */
  constructor(e, t, s, r, n, o, a, l, c) {
    this.text = e, this.style = t, this.width = s, this.height = r, this.lines = n, this.lineWidths = o, this.lineHeight = a, this.maxLineWidth = l, this.fontProperties = c;
  }
  /**
   * Measures the supplied string of text and returns a Rectangle.
   * @param text - The text to measure.
   * @param style - The text style to use for measuring
   * @param canvas - optional specification of the canvas to use for measuring.
   * @param wordWrap
   * @returns Measured width and height of the text.
   */
  static measureText(e = " ", t, s = z._canvas, r = t.wordWrap) {
    const n = `${e}-${t.styleKey}-wordWrap-${r}`;
    if (z._measurementCache.has(n))
      return z._measurementCache.get(n);
    const o = rr(t), a = z.measureFont(o);
    a.fontSize === 0 && (a.fontSize = t.fontSize, a.ascent = t.fontSize);
    const l = z.__context;
    l.font = o;
    const h = (r ? z._wordWrap(e, t, s) : e).split(/(?:\r\n|\r|\n)/), u = new Array(h.length);
    let d = 0;
    for (let y = 0; y < h.length; y++) {
      const v = z._measureText(h[y], t.letterSpacing, l);
      u[y] = v, d = Math.max(d, v);
    }
    const f = t._stroke?.width || 0;
    let m = d + f;
    t.dropShadow && (m += t.dropShadow.distance);
    const g = t.lineHeight || a.fontSize;
    let p = Math.max(g, a.fontSize + f) + (h.length - 1) * (g + t.leading);
    t.dropShadow && (p += t.dropShadow.distance);
    const x = new z(
      e,
      t,
      m,
      p,
      h,
      u,
      g + t.leading,
      d,
      a
    );
    return z._measurementCache.set(n, x), x;
  }
  static _measureText(e, t, s) {
    let r = !1;
    z.experimentalLetterSpacingSupported && (z.experimentalLetterSpacing ? (s.letterSpacing = `${t}px`, s.textLetterSpacing = `${t}px`, r = !0) : (s.letterSpacing = "0px", s.textLetterSpacing = "0px"));
    const n = s.measureText(e);
    let o = n.width;
    const a = -n.actualBoundingBoxLeft;
    let c = n.actualBoundingBoxRight - a;
    if (o > 0)
      if (r)
        o -= t, c -= t;
      else {
        const h = (z.graphemeSegmenter(e).length - 1) * t;
        o += h, c += h;
      }
    return Math.max(o, c);
  }
  /**
   * Applies newlines to a string to have it optimally fit into the horizontal
   * bounds set by the Text object's wordWrapWidth property.
   * @param text - String to apply word wrapping to
   * @param style - the style to use when wrapping
   * @param canvas - optional specification of the canvas to use for measuring.
   * @returns New string with new lines applied where required
   */
  static _wordWrap(e, t, s = z._canvas) {
    const r = s.getContext("2d", eh);
    let n = 0, o = "", a = "";
    const l = /* @__PURE__ */ Object.create(null), { letterSpacing: c, whiteSpace: h } = t, u = z._collapseSpaces(h), d = z._collapseNewlines(h);
    let f = !u;
    const m = t.wordWrapWidth + c, g = z._tokenize(e);
    for (let p = 0; p < g.length; p++) {
      let x = g[p];
      if (z._isNewline(x)) {
        if (!d) {
          a += z._addLine(o), f = !u, o = "", n = 0;
          continue;
        }
        x = " ";
      }
      if (u) {
        const v = z.isBreakingSpace(x), _ = z.isBreakingSpace(o[o.length - 1]);
        if (v && _)
          continue;
      }
      const y = z._getFromCache(x, c, l, r);
      if (y > m)
        if (o !== "" && (a += z._addLine(o), o = "", n = 0), z.canBreakWords(x, t.breakWords)) {
          const v = z.wordWrapSplit(x);
          for (let _ = 0; _ < v.length; _++) {
            let b = v[_], T = b, w = 1;
            for (; v[_ + w]; ) {
              const k = v[_ + w];
              if (!z.canBreakChars(T, k, x, _, t.breakWords))
                b += k;
              else
                break;
              T = k, w++;
            }
            _ += w - 1;
            const A = z._getFromCache(b, c, l, r);
            A + n > m && (a += z._addLine(o), f = !1, o = "", n = 0), o += b, n += A;
          }
        } else {
          o.length > 0 && (a += z._addLine(o), o = "", n = 0);
          const v = p === g.length - 1;
          a += z._addLine(x, !v), f = !1, o = "", n = 0;
        }
      else
        y + n > m && (f = !1, a += z._addLine(o), o = "", n = 0), (o.length > 0 || !z.isBreakingSpace(x) || f) && (o += x, n += y);
    }
    return a += z._addLine(o, !1), a;
  }
  /**
   * Convenience function for logging each line added during the wordWrap method.
   * @param line    - The line of text to add
   * @param newLine - Add new line character to end
   * @returns A formatted line
   */
  static _addLine(e, t = !0) {
    return e = z._trimRight(e), e = t ? `${e}
` : e, e;
  }
  /**
   * Gets & sets the widths of calculated characters in a cache object
   * @param key            - The key
   * @param letterSpacing  - The letter spacing
   * @param cache          - The cache
   * @param context        - The canvas context
   * @returns The from cache.
   */
  static _getFromCache(e, t, s, r) {
    let n = s[e];
    return typeof n != "number" && (n = z._measureText(e, t, r) + t, s[e] = n), n;
  }
  /**
   * Determines whether we should collapse breaking spaces.
   * @param whiteSpace - The TextStyle property whiteSpace
   * @returns Should collapse
   */
  static _collapseSpaces(e) {
    return e === "normal" || e === "pre-line";
  }
  /**
   * Determines whether we should collapse newLine chars.
   * @param whiteSpace - The white space
   * @returns should collapse
   */
  static _collapseNewlines(e) {
    return e === "normal";
  }
  /**
   * Trims breaking whitespaces from string.
   * @param text - The text
   * @returns Trimmed string
   */
  static _trimRight(e) {
    if (typeof e != "string")
      return "";
    for (let t = e.length - 1; t >= 0; t--) {
      const s = e[t];
      if (!z.isBreakingSpace(s))
        break;
      e = e.slice(0, -1);
    }
    return e;
  }
  /**
   * Determines if char is a newline.
   * @param char - The character
   * @returns True if newline, False otherwise.
   */
  static _isNewline(e) {
    return typeof e != "string" ? !1 : z._newlines.includes(e.charCodeAt(0));
  }
  /**
   * Determines if char is a breaking whitespace.
   *
   * It allows one to determine whether char should be a breaking whitespace
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param char - The character
   * @param [_nextChar] - The next character
   * @returns True if whitespace, False otherwise.
   */
  static isBreakingSpace(e, t) {
    return typeof e != "string" ? !1 : z._breakingSpaces.includes(e.charCodeAt(0));
  }
  /**
   * Splits a string into words, breaking-spaces and newLine characters
   * @param text - The text
   * @returns A tokenized array
   */
  static _tokenize(e) {
    const t = [];
    let s = "";
    if (typeof e != "string")
      return t;
    for (let r = 0; r < e.length; r++) {
      const n = e[r], o = e[r + 1];
      if (z.isBreakingSpace(n, o) || z._isNewline(n)) {
        s !== "" && (t.push(s), s = ""), n === "\r" && o === `
` ? (t.push(`\r
`), r++) : t.push(n);
        continue;
      }
      s += n;
    }
    return s !== "" && t.push(s), t;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to customise which words should break
   * Examples are if the token is CJK or numbers.
   * It must return a boolean.
   * @param _token - The token
   * @param breakWords - The style attr break words
   * @returns Whether to break word or not
   */
  static canBreakWords(e, t) {
    return t;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It allows one to determine whether a pair of characters
   * should be broken by newlines
   * For example certain characters in CJK langs or numbers.
   * It must return a boolean.
   * @param _char - The character
   * @param _nextChar - The next character
   * @param _token - The token/word the characters are from
   * @param _index - The index in the token of the char
   * @param _breakWords - The style attr break words
   * @returns whether to break word or not
   */
  static canBreakChars(e, t, s, r, n) {
    return !0;
  }
  /**
   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.
   *
   * It is called when a token (usually a word) has to be split into separate pieces
   * in order to determine the point to break a word.
   * It must return an array of characters.
   * @param token - The token to split
   * @returns The characters of the token
   * @see CanvasTextMetrics.graphemeSegmenter
   */
  static wordWrapSplit(e) {
    return z.graphemeSegmenter(e);
  }
  /**
   * Calculates the ascent, descent and fontSize of a given font-style
   * @param font - String representing the style of the font
   * @returns Font properties object
   */
  static measureFont(e) {
    if (z._fonts[e])
      return z._fonts[e];
    const t = z._context;
    t.font = e;
    const s = t.measureText(z.METRICS_STRING + z.BASELINE_SYMBOL), r = {
      ascent: s.actualBoundingBoxAscent,
      descent: s.actualBoundingBoxDescent,
      fontSize: s.actualBoundingBoxAscent + s.actualBoundingBoxDescent
    };
    return z._fonts[e] = r, r;
  }
  /**
   * Clear font metrics in metrics cache.
   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
   */
  static clearMetrics(e = "") {
    e ? delete z._fonts[e] : z._fonts = {};
  }
  /**
   * Cached canvas element for measuring text
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _canvas() {
    if (!z.__canvas) {
      let e;
      try {
        const t = new OffscreenCanvas(0, 0);
        if (t.getContext("2d", eh)?.measureText)
          return z.__canvas = t, t;
        e = re.get().createCanvas();
      } catch {
        e = re.get().createCanvas();
      }
      e.width = e.height = 10, z.__canvas = e;
    }
    return z.__canvas;
  }
  /**
   * TODO: this should be private, but isn't because of backward compat, will fix later.
   * @ignore
   */
  static get _context() {
    return z.__context || (z.__context = z._canvas.getContext("2d", eh)), z.__context;
  }
};
nt.METRICS_STRING = "|q";
nt.BASELINE_SYMBOL = "M";
nt.BASELINE_MULTIPLIER = 1.4;
nt.HEIGHT_MULTIPLIER = 2;
nt.graphemeSegmenter = (() => {
  if (typeof Intl?.Segmenter == "function") {
    const i = new Intl.Segmenter();
    return (e) => {
      const t = i.segment(e), s = [];
      let r = 0;
      for (const n of t)
        s[r++] = n.segment;
      return s;
    };
  }
  return (i) => [...i];
})();
nt.experimentalLetterSpacing = !1;
nt._fonts = {};
nt._newlines = [
  10,
  // line feed
  13
  // carriage return
];
nt._breakingSpaces = [
  9,
  // character tabulation
  32,
  // space
  8192,
  // en quad
  8193,
  // em quad
  8194,
  // en space
  8195,
  // em space
  8196,
  // three-per-em space
  8197,
  // four-per-em space
  8198,
  // six-per-em space
  8200,
  // punctuation space
  8201,
  // thin space
  8202,
  // hair space
  8287,
  // medium mathematical space
  12288
  // ideographic space
];
nt._measurementCache = dm(1e3);
let Ge = nt;
const od = [{ offset: 0, color: "white" }, { offset: 1, color: "black" }], hu = class Hh {
  constructor(...e) {
    this.uid = de("fillGradient"), this._tick = 0, this.type = "linear", this.colorStops = [];
    let t = x1(e);
    t = { ...t.type === "radial" ? Hh.defaultRadialOptions : Hh.defaultLinearOptions, ...xp(t) }, this._textureSize = t.textureSize, this._wrapMode = t.wrapMode, t.type === "radial" ? (this.center = t.center, this.outerCenter = t.outerCenter ?? this.center, this.innerRadius = t.innerRadius, this.outerRadius = t.outerRadius, this.scale = t.scale, this.rotation = t.rotation) : (this.start = t.start, this.end = t.end), this.textureSpace = t.textureSpace, this.type = t.type, t.colorStops.forEach((r) => {
      this.addColorStop(r.offset, r.color);
    });
  }
  /**
   * Adds a color stop to the gradient
   * @param offset - Position of the stop (0-1)
   * @param color - Color of the stop
   * @returns This gradient instance for chaining
   */
  addColorStop(e, t) {
    return this.colorStops.push({ offset: e, color: pe.shared.setValue(t).toHexa() }), this;
  }
  /**
   * Builds the internal texture and transform for the gradient.
   * Called automatically when the gradient is first used.
   * @internal
   */
  buildLinearGradient() {
    if (this.texture)
      return;
    let { x: e, y: t } = this.start, { x: s, y: r } = this.end, n = s - e, o = r - t;
    const a = n < 0 || o < 0;
    if (this._wrapMode === "clamp-to-edge") {
      if (n < 0) {
        const p = e;
        e = s, s = p, n *= -1;
      }
      if (o < 0) {
        const p = t;
        t = r, r = p, o *= -1;
      }
    }
    const l = this.colorStops.length ? this.colorStops : od, c = this._textureSize, { canvas: h, context: u } = ld(c, 1), d = a ? u.createLinearGradient(this._textureSize, 0, 0, 0) : u.createLinearGradient(0, 0, this._textureSize, 0);
    ad(d, l), u.fillStyle = d, u.fillRect(0, 0, c, 1), this.texture = new L({
      source: new ft({
        resource: h,
        addressMode: this._wrapMode
      })
    });
    const f = Math.sqrt(n * n + o * o), m = Math.atan2(o, n), g = new W();
    g.scale(f / c, 1), g.rotate(m), g.translate(e, t), this.textureSpace === "local" && g.scale(c, c), this.transform = g;
  }
  /**
   * Builds the internal texture and transform for the gradient.
   * Called automatically when the gradient is first used.
   * @internal
   */
  buildGradient() {
    this.texture || this._tick++, this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient();
  }
  /**
   * Builds the internal texture and transform for the radial gradient.
   * Called automatically when the gradient is first used.
   * @internal
   */
  buildRadialGradient() {
    if (this.texture)
      return;
    const e = this.colorStops.length ? this.colorStops : od, t = this._textureSize, { canvas: s, context: r } = ld(t, t), { x: n, y: o } = this.center, { x: a, y: l } = this.outerCenter, c = this.innerRadius, h = this.outerRadius, u = a - h, d = l - h, f = t / (h * 2), m = (n - u) * f, g = (o - d) * f, p = r.createRadialGradient(
      m,
      g,
      c * f,
      (a - u) * f,
      (l - d) * f,
      h * f
    );
    ad(p, e), r.fillStyle = e[e.length - 1].color, r.fillRect(0, 0, t, t), r.fillStyle = p, r.translate(m, g), r.rotate(this.rotation), r.scale(1, this.scale), r.translate(-m, -g), r.fillRect(0, 0, t, t), this.texture = new L({
      source: new ft({
        resource: s,
        addressMode: this._wrapMode
      })
    });
    const x = new W();
    x.scale(1 / f, 1 / f), x.translate(u, d), this.textureSpace === "local" && x.scale(t, t), this.transform = x;
  }
  /** Destroys the gradient, releasing resources. This will also destroy the internal texture. */
  destroy() {
    this.texture?.destroy(!0), this.texture = null, this.transform = null, this.colorStops = [], this.start = null, this.end = null, this.center = null, this.outerCenter = null;
  }
  /**
   * Returns a unique key for this gradient instance.
   * This key is used for caching and texture management.
   * @returns {string} Unique key for the gradient
   */
  get styleKey() {
    return `fill-gradient-${this.uid}-${this._tick}`;
  }
};
hu.defaultLinearOptions = {
  start: { x: 0, y: 0 },
  end: { x: 0, y: 1 },
  colorStops: [],
  textureSpace: "local",
  type: "linear",
  textureSize: 256,
  wrapMode: "clamp-to-edge"
};
hu.defaultRadialOptions = {
  center: { x: 0.5, y: 0.5 },
  innerRadius: 0,
  outerRadius: 0.5,
  colorStops: [],
  scale: 1,
  textureSpace: "local",
  type: "radial",
  textureSize: 256,
  wrapMode: "clamp-to-edge"
};
let qe = hu;
function ad(i, e) {
  for (let t = 0; t < e.length; t++) {
    const s = e[t];
    i.addColorStop(s.offset, s.color);
  }
}
function ld(i, e) {
  const t = re.get().createCanvas(i, e), s = t.getContext("2d");
  return { canvas: t, context: s };
}
function x1(i) {
  let e = i[0] ?? {};
  return (typeof e == "number" || i[1]) && (N("8.5.2", "use options object instead"), e = {
    type: "linear",
    start: { x: i[0], y: i[1] },
    end: { x: i[2], y: i[3] },
    textureSpace: i[4],
    textureSize: i[5] ?? qe.defaultLinearOptions.textureSize
  }), e;
}
const cd = {
  repeat: {
    addressModeU: "repeat",
    addressModeV: "repeat"
  },
  "repeat-x": {
    addressModeU: "repeat",
    addressModeV: "clamp-to-edge"
  },
  "repeat-y": {
    addressModeU: "clamp-to-edge",
    addressModeV: "repeat"
  },
  "no-repeat": {
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  }
};
class gr {
  constructor(e, t) {
    this.uid = de("fillPattern"), this._tick = 0, this.transform = new W(), this.texture = e, this.transform.scale(
      1 / e.frame.width,
      1 / e.frame.height
    ), t && (e.source.style.addressModeU = cd[t].addressModeU, e.source.style.addressModeV = cd[t].addressModeV);
  }
  /**
   * Sets the transform for the pattern
   * @param transform - The transform matrix to apply to the pattern.
   * If not provided, the pattern will use the default transform.
   */
  setTransform(e) {
    const t = this.texture;
    this.transform.copyFrom(e), this.transform.invert(), this.transform.scale(
      1 / t.frame.width,
      1 / t.frame.height
    ), this._tick++;
  }
  /** Internal texture used to render the gradient */
  get texture() {
    return this._texture;
  }
  set texture(e) {
    this._texture !== e && (this._texture = e, this._tick++);
  }
  /**
   * Returns a unique key for this instance.
   * This key is used for caching.
   * @returns {string} Unique key for the instance
   */
  get styleKey() {
    return `fill-pattern-${this.uid}-${this._tick}`;
  }
  /** Destroys the fill pattern, releasing resources. This will also destroy the internal texture. */
  destroy() {
    this.texture.destroy(!0), this.texture = null;
  }
}
var th, hd;
function y1() {
  if (hd) return th;
  hd = 1, th = t;
  var i = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, e = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
  function t(n) {
    var o = [];
    return n.replace(e, function(a, l, c) {
      var h = l.toLowerCase();
      for (c = r(c), h == "m" && c.length > 2 && (o.push([l].concat(c.splice(0, 2))), h = "l", l = l == "m" ? "l" : "L"); ; ) {
        if (c.length == i[h])
          return c.unshift(l), o.push(c);
        if (c.length < i[h]) throw new Error("malformed path data");
        o.push([l].concat(c.splice(0, i[h])));
      }
    }), o;
  }
  var s = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
  function r(n) {
    var o = n.match(s);
    return o ? o.map(Number) : [];
  }
  return th;
}
var v1 = y1();
const _1 = /* @__PURE__ */ ru(v1);
function b1(i, e) {
  const t = _1(i), s = [];
  let r = null, n = 0, o = 0;
  for (let a = 0; a < t.length; a++) {
    const l = t[a], c = l[0], h = l;
    switch (c) {
      case "M":
        n = h[1], o = h[2], e.moveTo(n, o);
        break;
      case "m":
        n += h[1], o += h[2], e.moveTo(n, o);
        break;
      case "H":
        n = h[1], e.lineTo(n, o);
        break;
      case "h":
        n += h[1], e.lineTo(n, o);
        break;
      case "V":
        o = h[1], e.lineTo(n, o);
        break;
      case "v":
        o += h[1], e.lineTo(n, o);
        break;
      case "L":
        n = h[1], o = h[2], e.lineTo(n, o);
        break;
      case "l":
        n += h[1], o += h[2], e.lineTo(n, o);
        break;
      case "C":
        n = h[5], o = h[6], e.bezierCurveTo(
          h[1],
          h[2],
          // First control point
          h[3],
          h[4],
          // Second control point
          n,
          o
          // End point
        );
        break;
      case "c":
        e.bezierCurveTo(
          n + h[1],
          o + h[2],
          // First control point
          n + h[3],
          o + h[4],
          // Second control point
          n + h[5],
          o + h[6]
          // End point
        ), n += h[5], o += h[6];
        break;
      case "S":
        n = h[3], o = h[4], e.bezierCurveToShort(
          h[1],
          h[2],
          // Control point
          n,
          o
          // End point
        );
        break;
      case "s":
        e.bezierCurveToShort(
          n + h[1],
          o + h[2],
          // Control point
          n + h[3],
          o + h[4]
          // End point
        ), n += h[3], o += h[4];
        break;
      case "Q":
        n = h[3], o = h[4], e.quadraticCurveTo(
          h[1],
          h[2],
          // Control point
          n,
          o
          // End point
        );
        break;
      case "q":
        e.quadraticCurveTo(
          n + h[1],
          o + h[2],
          // Control point
          n + h[3],
          o + h[4]
          // End point
        ), n += h[3], o += h[4];
        break;
      case "T":
        n = h[1], o = h[2], e.quadraticCurveToShort(
          n,
          o
          // End point
        );
        break;
      case "t":
        n += h[1], o += h[2], e.quadraticCurveToShort(
          n,
          o
          // End point
        );
        break;
      case "A":
        n = h[6], o = h[7], e.arcToSvg(
          h[1],
          // rx
          h[2],
          // ry
          h[3],
          // x-axis-rotation
          h[4],
          // large-arc-flag
          h[5],
          // sweep-flag
          n,
          o
          // End point
        );
        break;
      case "a":
        n += h[6], o += h[7], e.arcToSvg(
          h[1],
          // rx
          h[2],
          // ry
          h[3],
          // x-axis-rotation
          h[4],
          // large-arc-flag
          h[5],
          // sweep-flag
          n,
          o
          // End point
        );
        break;
      case "Z":
      case "z":
        e.closePath(), s.length > 0 && (r = s.pop(), r ? (n = r.startX, o = r.startY) : (n = 0, o = 0)), r = null;
        break;
      default:
        se(`Unknown SVG path command: ${c}`);
    }
    c !== "Z" && c !== "z" && r === null && (r = { startX: n, startY: o }, s.push(r));
  }
  return e;
}
class xr {
  /**
   * @param x - The X coordinate of the center of this circle
   * @param y - The Y coordinate of the center of this circle
   * @param radius - The radius of the circle
   */
  constructor(e = 0, t = 0, s = 0) {
    this.type = "circle", this.x = e, this.y = t, this.radius = s;
  }
  /**
   * Creates a clone of this Circle instance.
   * @example
   * ```ts
   * // Basic circle cloning
   * const original = new Circle(100, 100, 50);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.radius = 75;
   *
   * // Verify independence
   * console.log(original.radius); // 50
   * console.log(modified.radius); // 75
   * ```
   * @returns A copy of the Circle
   * @see {@link Circle.copyFrom} For copying into existing circle
   * @see {@link Circle.copyTo} For copying to another circle
   */
  clone() {
    return new xr(this.x, this.y, this.radius);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle.
   *
   * Uses the distance formula to determine if a point is inside the circle's radius.
   *
   * Commonly used for hit testing in PixiJS events and graphics.
   * @example
   * ```ts
   * // Basic containment check
   * const circle = new Circle(100, 100, 50);
   * const isInside = circle.contains(120, 120);
   *
   * // Check mouse position
   * const circle = new Circle(0, 0, 100);
   * container.hitArea = circle;
   * container.on('pointermove', (e) => {
   *     // only called if pointer is within circle
   * });
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Circle
   * @see {@link Circle.strokeContains} For checking stroke intersection
   * @see {@link Circle.getBounds} For getting bounding box
   */
  contains(e, t) {
    if (this.radius <= 0)
      return !1;
    const s = this.radius * this.radius;
    let r = this.x - e, n = this.y - t;
    return r *= r, n *= n, r + n <= s;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this circle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const circle = new Circle(100, 100, 50);
   * const isOnStroke = circle.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = circle.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = circle.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = circle.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param width - The width of the line to check
   * @param alignment - The alignment of the stroke, 0.5 by default
   * @returns Whether the x/y coordinates are within this Circle's stroke
   * @see {@link Circle.contains} For checking fill containment
   * @see {@link Circle.getBounds} For getting stroke bounds
   */
  strokeContains(e, t, s, r = 0.5) {
    if (this.radius === 0)
      return !1;
    const n = this.x - e, o = this.y - t, a = this.radius, l = (1 - r) * s, c = Math.sqrt(n * n + o * o);
    return c <= a + l && c > a - (s - l);
  }
  /**
   * Returns the framing rectangle of the circle as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const circle = new Circle(100, 100, 50);
   * const bounds = circle.getBounds();
   * // bounds: x=50, y=50, width=100, height=100
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * circle.getBounds(rect);
   * ```
   * @param out - Optional Rectangle object to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Circle.contains} For point containment
   */
  getBounds(e) {
    return e || (e = new G()), e.x = this.x - this.radius, e.y = this.y - this.radius, e.width = this.radius * 2, e.height = this.radius * 2, e;
  }
  /**
   * Copies another circle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Circle(100, 100, 50);
   * const target = new Circle();
   * target.copyFrom(source);
   * ```
   * @param circle - The circle to copy from
   * @returns Returns itself
   * @see {@link Circle.copyTo} For copying to another circle
   * @see {@link Circle.clone} For creating new circle copy
   */
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.radius = e.radius, this;
  }
  /**
   * Copies this circle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Circle(100, 100, 50);
   * const target = new Circle();
   * source.copyTo(target);
   * ```
   * @param circle - The circle to copy to
   * @returns Returns given parameter
   * @see {@link Circle.copyFrom} For copying from another circle
   * @see {@link Circle.clone} For creating new circle copy
   */
  copyTo(e) {
    return e.copyFrom(this), e;
  }
  toString() {
    return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
  }
}
class uu {
  /**
   * @param x - The X coordinate of the center of this ellipse
   * @param y - The Y coordinate of the center of this ellipse
   * @param halfWidth - The half width of this ellipse
   * @param halfHeight - The half height of this ellipse
   */
  constructor(e = 0, t = 0, s = 0, r = 0) {
    this.type = "ellipse", this.x = e, this.y = t, this.halfWidth = s, this.halfHeight = r;
  }
  /**
   * Creates a clone of this Ellipse instance.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Ellipse(100, 100, 50, 25);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.halfWidth *= 2;
   * modified.halfHeight *= 2;
   *
   * // Verify independence
   * console.log(original.halfWidth);  // 50
   * console.log(modified.halfWidth);  // 100
   * ```
   * @returns A copy of the ellipse
   * @see {@link Ellipse.copyFrom} For copying into existing ellipse
   * @see {@link Ellipse.copyTo} For copying to another ellipse
   */
  clone() {
    return new uu(this.x, this.y, this.halfWidth, this.halfHeight);
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse.
   * Uses normalized coordinates and the ellipse equation to determine containment.
   * @example
   * ```ts
   * // Basic containment check
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const isInside = ellipse.contains(120, 110);
   * ```
   * @remarks
   * - Uses ellipse equation (x/a + y/b  1)
   * - Returns false if dimensions are 0 or negative
   * - Normalized to center (0,0) for calculation
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coords are within this ellipse
   * @see {@link Ellipse.strokeContains} For checking stroke intersection
   * @see {@link Ellipse.getBounds} For getting containing rectangle
   */
  contains(e, t) {
    if (this.halfWidth <= 0 || this.halfHeight <= 0)
      return !1;
    let s = (e - this.x) / this.halfWidth, r = (t - this.y) / this.halfHeight;
    return s *= s, r *= r, s + r <= 1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this ellipse including stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const isOnStroke = ellipse.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = ellipse.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = ellipse.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = ellipse.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @remarks
   * - Uses normalized ellipse equations
   * - Considers stroke alignment
   * - Returns false if dimensions are 0
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coords are within this ellipse's stroke
   * @see {@link Ellipse.contains} For checking fill containment
   * @see {@link Ellipse.getBounds} For getting stroke bounds
   */
  strokeContains(e, t, s, r = 0.5) {
    const { halfWidth: n, halfHeight: o } = this;
    if (n <= 0 || o <= 0)
      return !1;
    const a = s * (1 - r), l = s - a, c = n - l, h = o - l, u = n + a, d = o + a, f = e - this.x, m = t - this.y, g = f * f / (c * c) + m * m / (h * h), p = f * f / (u * u) + m * m / (d * d);
    return g > 1 && p <= 1;
  }
  /**
   * Returns the framing rectangle of the ellipse as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const ellipse = new Ellipse(100, 100, 50, 25);
   * const bounds = ellipse.getBounds();
   * // bounds: x=50, y=75, width=100, height=50
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * ellipse.getBounds(rect);
   * ```
   * @remarks
   * - Creates Rectangle if none provided
   * - Top-left is (x-halfWidth, y-halfHeight)
   * - Width is halfWidth * 2
   * - Height is halfHeight * 2
   * @param out - Optional Rectangle object to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Ellipse.contains} For checking if a point is inside
   */
  getBounds(e) {
    return e || (e = new G()), e.x = this.x - this.halfWidth, e.y = this.y - this.halfHeight, e.width = this.halfWidth * 2, e.height = this.halfHeight * 2, e;
  }
  /**
   * Copies another ellipse to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Ellipse(100, 100, 50, 25);
   * const target = new Ellipse();
   * target.copyFrom(source);
   * ```
   * @param ellipse - The ellipse to copy from
   * @returns Returns itself
   * @see {@link Ellipse.copyTo} For copying to another ellipse
   * @see {@link Ellipse.clone} For creating new ellipse copy
   */
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.halfWidth = e.halfWidth, this.halfHeight = e.halfHeight, this;
  }
  /**
   * Copies this ellipse to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Ellipse(100, 100, 50, 25);
   * const target = new Ellipse();
   * source.copyTo(target);
   * ```
   * @param ellipse - The ellipse to copy to
   * @returns Returns given parameter
   * @see {@link Ellipse.copyFrom} For copying from another ellipse
   * @see {@link Ellipse.clone} For creating new ellipse copy
   */
  copyTo(e) {
    return e.copyFrom(this), e;
  }
  toString() {
    return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
  }
}
function w1(i, e, t, s, r, n) {
  const o = i - t, a = e - s, l = r - t, c = n - s, h = o * l + a * c, u = l * l + c * c;
  let d = -1;
  u !== 0 && (d = h / u);
  let f, m;
  d < 0 ? (f = t, m = s) : d > 1 ? (f = r, m = n) : (f = t + d * l, m = s + d * c);
  const g = i - f, p = e - m;
  return g * g + p * p;
}
let T1, S1;
class qi {
  /**
   * @param points - This can be an array of Points
   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or
   *  the arguments passed can be all the points of the polygon e.g.
   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat
   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.
   */
  constructor(...e) {
    this.type = "polygon";
    let t = Array.isArray(e[0]) ? e[0] : e;
    if (typeof t[0] != "number") {
      const s = [];
      for (let r = 0, n = t.length; r < n; r++)
        s.push(t[r].x, t[r].y);
      t = s;
    }
    this.points = t, this.closePath = !0;
  }
  /**
   * Determines whether the polygon's points are arranged in a clockwise direction.
   * Uses the shoelace formula (surveyor's formula) to calculate the signed area.
   *
   * A positive area indicates clockwise winding, while negative indicates counter-clockwise.
   *
   * The formula sums up the cross products of adjacent vertices:
   * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)
   * The final sum divided by 2 gives the signed area - positive for clockwise.
   * @example
   * ```ts
   * // Check polygon winding
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * console.log(polygon.isClockwise()); // Check direction
   *
   * // Use in path construction
   * const hole = new Polygon([25, 25, 75, 25, 75, 75, 25, 75]);
   * if (hole.isClockwise() === shape.isClockwise()) {
   *     hole.points.reverse(); // Reverse for proper hole winding
   * }
   * ```
   * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise
   */
  isClockwise() {
    let e = 0;
    const t = this.points, s = t.length;
    for (let r = 0; r < s; r += 2) {
      const n = t[r], o = t[r + 1], a = t[(r + 2) % s], l = t[(r + 3) % s];
      e += (a - n) * (l + o);
    }
    return e < 0;
  }
  /**
   * Checks if this polygon completely contains another polygon.
   * Used for detecting holes in shapes, like when parsing SVG paths.
   * @example
   * ```ts
   * // Basic containment check
   * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square
   * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside
   *
   * outerSquare.containsPolygon(innerSquare); // Returns true
   * innerSquare.containsPolygon(outerSquare); // Returns false
   * ```
   * @remarks
   * - Uses bounds check for quick rejection
   * - Tests all points for containment
   * @param polygon - The polygon to test for containment
   * @returns True if this polygon completely contains the other polygon
   * @see {@link Polygon.contains} For single point testing
   * @see {@link Polygon.getBounds} For bounds calculation
   */
  containsPolygon(e) {
    const t = this.getBounds(T1), s = e.getBounds(S1);
    if (!t.containsRect(s))
      return !1;
    const r = e.points;
    for (let n = 0; n < r.length; n += 2) {
      const o = r[n], a = r[n + 1];
      if (!this.contains(o, a))
        return !1;
    }
    return !0;
  }
  /**
   * Creates a clone of this polygon.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new Polygon([0, 0, 100, 0, 50, 100]);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.points[0] = 10; // Modify first x coordinate
   * ```
   * @returns A copy of the polygon
   * @see {@link Polygon.copyFrom} For copying into existing polygon
   * @see {@link Polygon.copyTo} For copying to another polygon
   */
  clone() {
    const e = this.points.slice(), t = new qi(e);
    return t.closePath = this.closePath, t;
  }
  /**
   * Checks whether the x and y coordinates passed to this function are contained within this polygon.
   * Uses raycasting algorithm for point-in-polygon testing.
   * @example
   * ```ts
   * // Basic containment check
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const isInside = polygon.contains(25, 25); // true
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this polygon
   * @see {@link Polygon.strokeContains} For checking stroke intersection
   * @see {@link Polygon.containsPolygon} For polygon-in-polygon testing
   */
  contains(e, t) {
    let s = !1;
    const r = this.points.length / 2;
    for (let n = 0, o = r - 1; n < r; o = n++) {
      const a = this.points[n * 2], l = this.points[n * 2 + 1], c = this.points[o * 2], h = this.points[o * 2 + 1];
      l > t != h > t && e < (c - a) * ((t - l) / (h - l)) + a && (s = !s);
    }
    return s;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const isOnStroke = polygon.strokeContains(25, 25, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = polygon.strokeContains(25, 25, 4, 1);   // Inside
   * const centerStroke = polygon.strokeContains(25, 25, 4, 0.5); // Centered
   * const outerStroke = polygon.strokeContains(25, 25, 4, 0);   // Outside
   * ```
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this polygon's stroke
   * @see {@link Polygon.contains} For checking fill containment
   * @see {@link Polygon.getBounds} For getting stroke bounds
   */
  strokeContains(e, t, s, r = 0.5) {
    const n = s * s, o = n * (1 - r), a = n - o, { points: l } = this, c = l.length - (this.closePath ? 0 : 2);
    for (let h = 0; h < c; h += 2) {
      const u = l[h], d = l[h + 1], f = l[(h + 2) % l.length], m = l[(h + 3) % l.length], g = w1(e, t, u, d, f, m), p = Math.sign((f - u) * (t - d) - (m - d) * (e - u));
      if (g <= (p < 0 ? a : o))
        return !0;
    }
    return !1;
  }
  /**
   * Returns the framing rectangle of the polygon as a Rectangle object.
   * @example
   * ```ts
   * // Basic bounds calculation
   * const polygon = new Polygon([0, 0, 100, 0, 50, 100]);
   * const bounds = polygon.getBounds();
   * // bounds: x=0, y=0, width=100, height=100
   *
   * // Reuse existing rectangle
   * const rect = new Rectangle();
   * polygon.getBounds(rect);
   * ```
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link Polygon.contains} For checking if a point is inside
   */
  getBounds(e) {
    e || (e = new G());
    const t = this.points;
    let s = 1 / 0, r = -1 / 0, n = 1 / 0, o = -1 / 0;
    for (let a = 0, l = t.length; a < l; a += 2) {
      const c = t[a], h = t[a + 1];
      s = c < s ? c : s, r = c > r ? c : r, n = h < n ? h : n, o = h > o ? h : o;
    }
    return e.x = s, e.width = r - s, e.y = n, e.height = o - n, e;
  }
  /**
   * Copies another polygon to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Polygon([0, 0, 100, 0, 50, 100]);
   * const target = new Polygon();
   * target.copyFrom(source);
   * ```
   * @param polygon - The polygon to copy from
   * @returns Returns itself
   * @see {@link Polygon.copyTo} For copying to another polygon
   * @see {@link Polygon.clone} For creating new polygon copy
   */
  copyFrom(e) {
    return this.points = e.points.slice(), this.closePath = e.closePath, this;
  }
  /**
   * Copies this polygon to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new Polygon([0, 0, 100, 0, 50, 100]);
   * const target = new Polygon();
   * source.copyTo(target);
   * ```
   * @param polygon - The polygon to copy to
   * @returns Returns given parameter
   * @see {@link Polygon.copyFrom} For copying from another polygon
   * @see {@link Polygon.clone} For creating new polygon copy
   */
  copyTo(e) {
    return e.copyFrom(this), e;
  }
  toString() {
    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((e, t) => `${e}, ${t}`, "")}]`;
  }
  /**
   * Get the last X coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.lastX); // 300
   * ```
   * @readonly
   * @returns The x-coordinate of the last vertex
   * @see {@link Polygon.lastY} For last Y coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get lastX() {
    return this.points[this.points.length - 2];
  }
  /**
   * Get the last Y coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.lastY); // 400
   * ```
   * @readonly
   * @returns The y-coordinate of the last vertex
   * @see {@link Polygon.lastX} For last X coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get lastY() {
    return this.points[this.points.length - 1];
  }
  /**
   * Get the last X coordinate of the polygon.
   * @readonly
   * @deprecated since 8.11.0, use {@link Polygon.lastX} instead.
   */
  get x() {
    return N("8.11.0", "Polygon.lastX is deprecated, please use Polygon.lastX instead."), this.points[this.points.length - 2];
  }
  /**
   * Get the last Y coordinate of the polygon.
   * @readonly
   * @deprecated since 8.11.0, use {@link Polygon.lastY} instead.
   */
  get y() {
    return N("8.11.0", "Polygon.y is deprecated, please use Polygon.lastY instead."), this.points[this.points.length - 1];
  }
  /**
   * Get the first X coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.x); // 0
   * ```
   * @readonly
   * @returns The x-coordinate of the first vertex
   * @see {@link Polygon.startY} For first Y coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get startX() {
    return this.points[0];
  }
  /**
   * Get the first Y coordinate of the polygon.
   * @example
   * ```ts
   * // Basic coordinate access
   * const polygon = new Polygon([0, 0, 100, 200, 300, 400]);
   * console.log(polygon.y); // 0
   * ```
   * @readonly
   * @returns The y-coordinate of the first vertex
   * @see {@link Polygon.startX} For first X coordinate
   * @see {@link Polygon.points} For raw points array
   */
  get startY() {
    return this.points[1];
  }
}
const As = (i, e, t, s, r, n, o) => {
  const a = i - t, l = e - s, c = Math.sqrt(a * a + l * l);
  return c >= r - n && c <= r + o;
};
class du {
  /**
   * @param x - The X coordinate of the upper-left corner of the rounded rectangle
   * @param y - The Y coordinate of the upper-left corner of the rounded rectangle
   * @param width - The overall width of this rounded rectangle
   * @param height - The overall height of this rounded rectangle
   * @param radius - Controls the radius of the rounded corners
   */
  constructor(e = 0, t = 0, s = 0, r = 0, n = 20) {
    this.type = "roundedRectangle", this.x = e, this.y = t, this.width = s, this.height = r, this.radius = n;
  }
  /**
   * Returns the framing rectangle of the rounded rectangle as a Rectangle object
   * @example
   * ```ts
   * // Basic bounds calculation
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const bounds = rect.getBounds();
   * // bounds: x=100, y=100, width=200, height=150
   *
   * // Reuse existing rectangle
   * const out = new Rectangle();
   * rect.getBounds(out);
   * ```
   * @remarks
   * - Rectangle matches outer dimensions
   * - Ignores corner radius
   * @param out - Optional rectangle to store the result
   * @returns The framing rectangle
   * @see {@link Rectangle} For rectangle properties
   * @see {@link RoundedRectangle.contains} For checking if a point is inside
   */
  getBounds(e) {
    return e || (e = new G()), e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e;
  }
  /**
   * Creates a clone of this Rounded Rectangle.
   * @example
   * ```ts
   * // Basic cloning
   * const original = new RoundedRectangle(100, 100, 200, 150, 20);
   * const copy = original.clone();
   *
   * // Clone and modify
   * const modified = original.clone();
   * modified.radius = 30;
   * modified.width *= 2;
   *
   * // Verify independence
   * console.log(original.radius);  // 20
   * console.log(modified.radius);  // 30
   * ```
   * @returns A copy of the rounded rectangle
   * @see {@link RoundedRectangle.copyFrom} For copying into existing rectangle
   * @see {@link RoundedRectangle.copyTo} For copying to another rectangle
   */
  clone() {
    return new du(this.x, this.y, this.width, this.height, this.radius);
  }
  /**
   * Copies another rectangle to this one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new RoundedRectangle(100, 100, 200, 150, 20);
   * const target = new RoundedRectangle();
   * target.copyFrom(source);
   *
   * // Chain with other operations
   * const rect = new RoundedRectangle()
   *     .copyFrom(source)
   *     .getBounds(rect);
   * ```
   * @param rectangle - The rectangle to copy from
   * @returns Returns itself
   * @see {@link RoundedRectangle.copyTo} For copying to another rectangle
   * @see {@link RoundedRectangle.clone} For creating new rectangle copy
   */
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
  }
  /**
   * Copies this rectangle to another one.
   * @example
   * ```ts
   * // Basic copying
   * const source = new RoundedRectangle(100, 100, 200, 150, 20);
   * const target = new RoundedRectangle();
   * source.copyTo(target);
   *
   * // Chain with other operations
   * const result = source
   *     .copyTo(new RoundedRectangle())
   *     .getBounds();
   * ```
   * @param rectangle - The rectangle to copy to
   * @returns Returns given parameter
   * @see {@link RoundedRectangle.copyFrom} For copying from another rectangle
   * @see {@link RoundedRectangle.clone} For creating new rectangle copy
   */
  copyTo(e) {
    return e.copyFrom(this), e;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
   * @example
   * ```ts
   * // Basic containment check
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const isInside = rect.contains(150, 125); // true
   * // Check corner radius
   * const corner = rect.contains(100, 100); // false if within corner curve
   * ```
   * @remarks
   * - Returns false if width/height is 0 or negative
   * - Handles rounded corners with radius check
   * @param x - The X coordinate of the point to test
   * @param y - The Y coordinate of the point to test
   * @returns Whether the x/y coordinates are within this Rounded Rectangle
   * @see {@link RoundedRectangle.strokeContains} For checking stroke intersection
   * @see {@link RoundedRectangle.getBounds} For getting containing rectangle
   */
  contains(e, t) {
    if (this.width <= 0 || this.height <= 0)
      return !1;
    if (e >= this.x && e <= this.x + this.width && t >= this.y && t <= this.y + this.height) {
      const s = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
      if (t >= this.y + s && t <= this.y + this.height - s || e >= this.x + s && e <= this.x + this.width - s)
        return !0;
      let r = e - (this.x + s), n = t - (this.y + s);
      const o = s * s;
      if (r * r + n * n <= o || (r = e - (this.x + this.width - s), r * r + n * n <= o) || (n = t - (this.y + this.height - s), r * r + n * n <= o) || (r = e - (this.x + s), r * r + n * n <= o))
        return !0;
    }
    return !1;
  }
  /**
   * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.
   * @example
   * ```ts
   * // Basic stroke check
   * const rect = new RoundedRectangle(100, 100, 200, 150, 20);
   * const isOnStroke = rect.strokeContains(150, 100, 4); // 4px line width
   *
   * // Check with different alignments
   * const innerStroke = rect.strokeContains(150, 100, 4, 1);   // Inside
   * const centerStroke = rect.strokeContains(150, 100, 4, 0.5); // Centered
   * const outerStroke = rect.strokeContains(150, 100, 4, 0);   // Outside
   * ```
   * @param pX - The X coordinate of the point to test
   * @param pY - The Y coordinate of the point to test
   * @param strokeWidth - The width of the line to check
   * @param alignment - The alignment of the stroke (1 = inner, 0.5 = centered, 0 = outer)
   * @returns Whether the x/y coordinates are within this rectangle's stroke
   * @see {@link RoundedRectangle.contains} For checking fill containment
   * @see {@link RoundedRectangle.getBounds} For getting stroke bounds
   */
  strokeContains(e, t, s, r = 0.5) {
    const { x: n, y: o, width: a, height: l, radius: c } = this, h = s * (1 - r), u = s - h, d = n + c, f = o + c, m = a - c * 2, g = l - c * 2, p = n + a, x = o + l;
    return (e >= n - h && e <= n + u || e >= p - u && e <= p + h) && t >= f && t <= f + g || (t >= o - h && t <= o + u || t >= x - u && t <= x + h) && e >= d && e <= d + m ? !0 : (
      // Top-left
      e < d && t < f && As(
        e,
        t,
        d,
        f,
        c,
        u,
        h
      ) || e > p - c && t < f && As(
        e,
        t,
        p - c,
        f,
        c,
        u,
        h
      ) || e > p - c && t > x - c && As(
        e,
        t,
        p - c,
        x - c,
        c,
        u,
        h
      ) || e < d && t > x - c && As(
        e,
        t,
        d,
        x - c,
        c,
        u,
        h
      )
    );
  }
  toString() {
    return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
  }
}
const fm = {};
function C1(i, e, t) {
  let s = 2166136261;
  for (let r = 0; r < e; r++)
    s ^= i[r].uid, s = Math.imul(s, 16777619), s >>>= 0;
  return fm[s] || A1(i, e, s, t);
}
function A1(i, e, t, s) {
  const r = {};
  let n = 0;
  for (let a = 0; a < s; a++) {
    const l = a < e ? i[a] : L.EMPTY.source;
    r[n++] = l.source, r[n++] = l.style;
  }
  const o = new $s(r);
  return fm[t] = o, o;
}
class ud {
  constructor(e) {
    typeof e == "number" ? this.rawBinaryData = new ArrayBuffer(e) : e instanceof Uint8Array ? this.rawBinaryData = e.buffer : this.rawBinaryData = e, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength;
  }
  /** View on the raw binary data as a `Int8Array`. */
  get int8View() {
    return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
  }
  /** View on the raw binary data as a `Uint8Array`. */
  get uint8View() {
    return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
  }
  /**  View on the raw binary data as a `Int16Array`. */
  get int16View() {
    return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
  }
  /** View on the raw binary data as a `Int32Array`. */
  get int32View() {
    return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
  }
  /** View on the raw binary data as a `Float64Array`. */
  get float64View() {
    return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array;
  }
  /** View on the raw binary data as a `BigUint64Array`. */
  get bigUint64View() {
    return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array;
  }
  /**
   * Returns the view of the given type.
   * @param type - One of `int8`, `uint8`, `int16`,
   *    `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - typed array of given type
   */
  view(e) {
    return this[`${e}View`];
  }
  /** Destroys all buffer references. Do not use after calling this. */
  destroy() {
    this.rawBinaryData = null, this.uint32View = null, this.float32View = null, this.uint16View = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._int32View = null, this._float64Array = null, this._bigUint64Array = null;
  }
  /**
   * Returns the size of the given type in bytes.
   * @param type - One of `int8`, `uint8`, `int16`,
   *   `uint16`, `int32`, `uint32`, and `float32`.
   * @returns - size of the type in bytes
   */
  static sizeOf(e) {
    switch (e) {
      case "int8":
      case "uint8":
        return 1;
      case "int16":
      case "uint16":
        return 2;
      case "int32":
      case "uint32":
      case "float32":
        return 4;
      default:
        throw new Error(`${e} isn't a valid view type`);
    }
  }
}
function dd(i, e) {
  const t = i.byteLength / 8 | 0, s = new Float64Array(i, 0, t);
  new Float64Array(e, 0, t).set(s);
  const n = i.byteLength - t * 8;
  if (n > 0) {
    const o = new Uint8Array(i, t * 8, n);
    new Uint8Array(e, t * 8, n).set(o);
  }
}
const I1 = {
  normal: "normal-npm",
  add: "add-npm",
  screen: "screen-npm"
};
var k1 = /* @__PURE__ */ ((i) => (i[i.DISABLED = 0] = "DISABLED", i[i.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", i[i.MASK_ACTIVE = 2] = "MASK_ACTIVE", i[i.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", i[i.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", i[i.NONE = 5] = "NONE", i))(k1 || {});
function fd(i, e) {
  return e.alphaMode === "no-premultiply-alpha" && I1[i] || i;
}
const F1 = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function M1(i) {
  let e = "";
  for (let t = 0; t < i; ++t)
    t > 0 && (e += `
else `), t < i - 1 && (e += `if(test == ${t}.0){}`);
  return e;
}
function E1(i, e) {
  if (i === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  const t = e.createShader(e.FRAGMENT_SHADER);
  try {
    for (; ; ) {
      const s = F1.replace(/%forloop%/gi, M1(i));
      if (e.shaderSource(t, s), e.compileShader(t), !e.getShaderParameter(t, e.COMPILE_STATUS))
        i = i / 2 | 0;
      else
        break;
    }
  } finally {
    e.deleteShader(t);
  }
  return i;
}
let qt = null;
function P1() {
  if (qt)
    return qt;
  const i = Yp();
  return qt = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), qt = E1(
    qt,
    i
  ), i.getExtension("WEBGL_lose_context")?.loseContext(), qt;
}
class U1 {
  constructor() {
    this.ids = /* @__PURE__ */ Object.create(null), this.textures = [], this.count = 0;
  }
  /** Clear the textures and their locations. */
  clear() {
    for (let e = 0; e < this.count; e++) {
      const t = this.textures[e];
      this.textures[e] = null, this.ids[t.uid] = null;
    }
    this.count = 0;
  }
}
class R1 {
  constructor() {
    this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new U1(), this.blendMode = "normal", this.topology = "triangle-strip", this.canBundle = !0;
  }
  destroy() {
    this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null;
  }
}
const Zi = [];
let nr = 0;
os.register({
  clear: () => {
    if (Zi.length > 0)
      for (const i of Zi)
        i && i.destroy();
    Zi.length = 0, nr = 0;
  }
});
function pd() {
  return nr > 0 ? Zi[--nr] : new R1();
}
function md(i) {
  Zi[nr++] = i;
}
let ki = 0;
const pm = class mm {
  constructor(e) {
    this.uid = de("batcher"), this.dirty = !0, this.batchIndex = 0, this.batches = [], this._elements = [], e = { ...mm.defaultOptions, ...e }, e.maxTextures || (N("v8.8.0", "maxTextures is a required option for Batcher now, please pass it in the options"), e.maxTextures = P1());
    const { maxTextures: t, attributesInitialSize: s, indicesInitialSize: r } = e;
    this.attributeBuffer = new ud(s * 4), this.indexBuffer = new Uint16Array(r), this.maxTextures = t;
  }
  begin() {
    this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
    for (let e = 0; e < this.batchIndex; e++)
      md(this.batches[e]);
    this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = !0;
  }
  add(e) {
    this._elements[this.elementSize++] = e, e._indexStart = this.indexSize, e._attributeStart = this.attributeSize, e._batcher = this, this.indexSize += e.indexSize, this.attributeSize += e.attributeSize * this.vertexSize;
  }
  checkAndUpdateTexture(e, t) {
    const s = e._batch.textures.ids[t._source.uid];
    return !s && s !== 0 ? !1 : (e._textureId = s, e.texture = t, !0);
  }
  updateElement(e) {
    this.dirty = !0;
    const t = this.attributeBuffer;
    e.packAsQuad ? this.packQuadAttributes(
      e,
      t.float32View,
      t.uint32View,
      e._attributeStart,
      e._textureId
    ) : this.packAttributes(
      e,
      t.float32View,
      t.uint32View,
      e._attributeStart,
      e._textureId
    );
  }
  /**
   * breaks the batcher. This happens when a batch gets too big,
   * or we need to switch to a different type of rendering (a filter for example)
   * @param instructionSet
   */
  break(e) {
    const t = this._elements;
    if (!t[this.elementStart])
      return;
    let s = pd(), r = s.textures;
    r.clear();
    const n = t[this.elementStart];
    let o = fd(n.blendMode, n.texture._source), a = n.topology;
    this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
    const l = this.attributeBuffer.float32View, c = this.attributeBuffer.uint32View, h = this.indexBuffer;
    let u = this._batchIndexSize, d = this._batchIndexStart, f = "startBatch";
    const m = this.maxTextures;
    for (let g = this.elementStart; g < this.elementSize; ++g) {
      const p = t[g];
      t[g] = null;
      const y = p.texture._source, v = fd(p.blendMode, y), _ = o !== v || a !== p.topology;
      if (y._batchTick === ki && !_) {
        p._textureId = y._textureBindLocation, u += p.indexSize, p.packAsQuad ? (this.packQuadAttributes(
          p,
          l,
          c,
          p._attributeStart,
          p._textureId
        ), this.packQuadIndex(
          h,
          p._indexStart,
          p._attributeStart / this.vertexSize
        )) : (this.packAttributes(
          p,
          l,
          c,
          p._attributeStart,
          p._textureId
        ), this.packIndex(
          p,
          h,
          p._indexStart,
          p._attributeStart / this.vertexSize
        )), p._batch = s;
        continue;
      }
      y._batchTick = ki, (r.count >= m || _) && (this._finishBatch(
        s,
        d,
        u - d,
        r,
        o,
        a,
        e,
        f
      ), f = "renderBatch", d = u, o = v, a = p.topology, s = pd(), r = s.textures, r.clear(), ++ki), p._textureId = y._textureBindLocation = r.count, r.ids[y.uid] = r.count, r.textures[r.count++] = y, p._batch = s, u += p.indexSize, p.packAsQuad ? (this.packQuadAttributes(
        p,
        l,
        c,
        p._attributeStart,
        p._textureId
      ), this.packQuadIndex(
        h,
        p._indexStart,
        p._attributeStart / this.vertexSize
      )) : (this.packAttributes(
        p,
        l,
        c,
        p._attributeStart,
        p._textureId
      ), this.packIndex(
        p,
        h,
        p._indexStart,
        p._attributeStart / this.vertexSize
      ));
    }
    r.count > 0 && (this._finishBatch(
      s,
      d,
      u - d,
      r,
      o,
      a,
      e,
      f
    ), d = u, ++ki), this.elementStart = this.elementSize, this._batchIndexStart = d, this._batchIndexSize = u;
  }
  _finishBatch(e, t, s, r, n, o, a, l) {
    e.gpuBindGroup = null, e.bindGroup = null, e.action = l, e.batcher = this, e.textures = r, e.blendMode = n, e.topology = o, e.start = t, e.size = s, ++ki, this.batches[this.batchIndex++] = e, a.add(e);
  }
  finish(e) {
    this.break(e);
  }
  /**
   * Resizes the attribute buffer to the given size (1 = 1 float32)
   * @param size - the size in vertices to ensure (not bytes!)
   */
  ensureAttributeBuffer(e) {
    e * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(e * 4);
  }
  /**
   * Resizes the index buffer to the given size (1 = 1 float32)
   * @param size - the size in vertices to ensure (not bytes!)
   */
  ensureIndexBuffer(e) {
    e <= this.indexBuffer.length || this._resizeIndexBuffer(e);
  }
  _resizeAttributeBuffer(e) {
    const t = Math.max(e, this.attributeBuffer.size * 2), s = new ud(t);
    dd(this.attributeBuffer.rawBinaryData, s.rawBinaryData), this.attributeBuffer = s;
  }
  _resizeIndexBuffer(e) {
    const t = this.indexBuffer;
    let s = Math.max(e, t.length * 1.5);
    s += s % 2;
    const r = s > 65535 ? new Uint32Array(s) : new Uint16Array(s);
    if (r.BYTES_PER_ELEMENT !== t.BYTES_PER_ELEMENT)
      for (let n = 0; n < t.length; n++)
        r[n] = t[n];
    else
      dd(t.buffer, r.buffer);
    this.indexBuffer = r;
  }
  packQuadIndex(e, t, s) {
    e[t] = s + 0, e[t + 1] = s + 1, e[t + 2] = s + 2, e[t + 3] = s + 0, e[t + 4] = s + 2, e[t + 5] = s + 3;
  }
  packIndex(e, t, s, r) {
    const n = e.indices, o = e.indexSize, a = e.indexOffset, l = e.attributeOffset;
    for (let c = 0; c < o; c++)
      t[s++] = r + n[c + a] - l;
  }
  /**
   * Destroys the batch and its resources.
   * @param options - destruction options
   * @param options.shader - whether to destroy the associated shader
   */
  destroy(e = {}) {
    if (this.batches !== null) {
      for (let t = 0; t < this.batches.length; t++)
        md(this.batches[t]);
      this.batches = null, this.geometry.destroy(!0), this.geometry = null, e.shader && (this.shader?.destroy(), this.shader = null);
      for (let t = 0; t < this._elements.length; t++)
        this._elements[t] && (this._elements[t]._batch = null);
      this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null;
    }
  }
};
pm.defaultOptions = {
  maxTextures: null,
  attributesInitialSize: 4,
  indicesInitialSize: 6
};
let B1 = pm;
var ze = /* @__PURE__ */ ((i) => (i[i.MAP_READ = 1] = "MAP_READ", i[i.MAP_WRITE = 2] = "MAP_WRITE", i[i.COPY_SRC = 4] = "COPY_SRC", i[i.COPY_DST = 8] = "COPY_DST", i[i.INDEX = 16] = "INDEX", i[i.VERTEX = 32] = "VERTEX", i[i.UNIFORM = 64] = "UNIFORM", i[i.STORAGE = 128] = "STORAGE", i[i.INDIRECT = 256] = "INDIRECT", i[i.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", i[i.STATIC = 1024] = "STATIC", i))(ze || {});
class is extends rt {
  /**
   * Creates a new Buffer with the given options
   * @param options - the options for the buffer
   */
  constructor(e) {
    let { data: t, size: s } = e;
    const { usage: r, label: n, shrinkToFit: o } = e;
    super(), this.uid = de("buffer"), this._resourceType = "buffer", this._resourceId = de("resource"), this._touched = 0, this._updateID = 1, this._dataInt32 = null, this.shrinkToFit = !0, this.destroyed = !1, t instanceof Array && (t = new Float32Array(t)), this._data = t, s ?? (s = t?.byteLength);
    const a = !!t;
    this.descriptor = {
      size: s,
      usage: r,
      mappedAtCreation: a,
      label: n
    }, this.shrinkToFit = o ?? !0;
  }
  /** the data in the buffer */
  get data() {
    return this._data;
  }
  set data(e) {
    this.setDataWithSize(e, e.length, !0);
  }
  get dataInt32() {
    return this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)), this._dataInt32;
  }
  /** whether the buffer is static or not */
  get static() {
    return !!(this.descriptor.usage & ze.STATIC);
  }
  set static(e) {
    e ? this.descriptor.usage |= ze.STATIC : this.descriptor.usage &= ~ze.STATIC;
  }
  /**
   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.
   * If you only want to update a subset of the buffer, you can pass in the size of the data.
   * @param value - the data to set
   * @param size - the size of the data in bytes
   * @param syncGPU - should the buffer be updated on the GPU immediately?
   */
  setDataWithSize(e, t, s) {
    if (this._updateID++, this._updateSize = t * e.BYTES_PER_ELEMENT, this._data === e) {
      s && this.emit("update", this);
      return;
    }
    const r = this._data;
    if (this._data = e, this._dataInt32 = null, !r || r.length !== e.length) {
      !this.shrinkToFit && r && e.byteLength < r.byteLength ? s && this.emit("update", this) : (this.descriptor.size = e.byteLength, this._resourceId = de("resource"), this.emit("change", this));
      return;
    }
    s && this.emit("update", this);
  }
  /**
   * updates the buffer on the GPU to reflect the data in the buffer.
   * By default it will update the entire buffer. If you only want to update a subset of the buffer,
   * you can pass in the size of the buffer to update.
   * @param sizeInBytes - the new size of the buffer in bytes
   */
  update(e) {
    this._updateSize = e ?? this._updateSize, this._updateID++, this.emit("update", this);
  }
  /** Destroys the buffer */
  destroy() {
    this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners();
  }
}
function gm(i, e) {
  if (!(i instanceof is)) {
    let t = e ? ze.INDEX : ze.VERTEX;
    i instanceof Array && (e ? (i = new Uint32Array(i), t = ze.INDEX | ze.COPY_DST) : (i = new Float32Array(i), t = ze.VERTEX | ze.COPY_DST)), i = new is({
      data: i,
      label: e ? "index-mesh-buffer" : "vertex-mesh-buffer",
      usage: t
    });
  }
  return i;
}
function z1(i, e, t) {
  const s = i.getAttribute(e);
  if (!s)
    return t.minX = 0, t.minY = 0, t.maxX = 0, t.maxY = 0, t;
  const r = s.buffer.data;
  let n = 1 / 0, o = 1 / 0, a = -1 / 0, l = -1 / 0;
  const c = r.BYTES_PER_ELEMENT, h = (s.offset || 0) / c, u = (s.stride || 8) / c;
  for (let d = h; d < r.length; d += u) {
    const f = r[d], m = r[d + 1];
    f > a && (a = f), m > l && (l = m), f < n && (n = f), m < o && (o = m);
  }
  return t.minX = n, t.minY = o, t.maxX = a, t.maxY = l, t;
}
function O1(i) {
  return (i instanceof is || Array.isArray(i) || i.BYTES_PER_ELEMENT) && (i = {
    buffer: i
  }), i.buffer = gm(i.buffer, !1), i;
}
class D1 extends rt {
  /**
   * Create a new instance of a geometry
   * @param options - The options for the geometry.
   */
  constructor(e = {}) {
    super(), this.uid = de("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new it(), this._boundsDirty = !0;
    const { attributes: t, indexBuffer: s, topology: r } = e;
    if (this.buffers = [], this.attributes = {}, t)
      for (const n in t)
        this.addAttribute(n, t[n]);
    this.instanceCount = e.instanceCount ?? 1, s && this.addIndex(s), this.topology = r || "triangle-list";
  }
  onBufferUpdate() {
    this._boundsDirty = !0, this.emit("update", this);
  }
  /**
   * Returns the requested attribute.
   * @param id - The name of the attribute required
   * @returns - The attribute requested.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Returns the index buffer
   * @returns - The index buffer.
   */
  getIndex() {
    return this.indexBuffer;
  }
  /**
   * Returns the requested buffer.
   * @param id - The name of the buffer required.
   * @returns - The buffer requested.
   */
  getBuffer(e) {
    return this.getAttribute(e).buffer;
  }
  /**
   * Used to figure out how many vertices there are in this geometry
   * @returns the number of vertices in the geometry
   */
  getSize() {
    for (const e in this.attributes) {
      const t = this.attributes[e];
      return t.buffer.data.length / (t.stride / 4 || t.size);
    }
    return 0;
  }
  /**
   * Adds an attribute to the geometry.
   * @param name - The name of the attribute to add.
   * @param attributeOption - The attribute option to add.
   */
  addAttribute(e, t) {
    const s = O1(t);
    this.buffers.indexOf(s.buffer) === -1 && (this.buffers.push(s.buffer), s.buffer.on("update", this.onBufferUpdate, this), s.buffer.on("change", this.onBufferUpdate, this)), this.attributes[e] = s;
  }
  /**
   * Adds an index buffer to the geometry.
   * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.
   */
  addIndex(e) {
    this.indexBuffer = gm(e, !0), this.buffers.push(this.indexBuffer);
  }
  /** Returns the bounds of the geometry. */
  get bounds() {
    return this._boundsDirty ? (this._boundsDirty = !1, z1(this, "aPosition", this._bounds)) : this._bounds;
  }
  /**
   * destroys the geometry.
   * @param destroyBuffers - destroy the buffers associated with this geometry
   */
  destroy(e = !1) {
    this.emit("destroy", this), this.removeAllListeners(), e && this.buffers.forEach((t) => t.destroy()), this.indexBuffer?.destroy(), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null;
  }
}
const L1 = new Float32Array(1), N1 = new Uint32Array(1);
class G1 extends D1 {
  constructor() {
    const t = new is({
      data: L1,
      label: "attribute-batch-buffer",
      usage: ze.VERTEX | ze.COPY_DST,
      shrinkToFit: !1
    }), s = new is({
      data: N1,
      label: "index-batch-buffer",
      usage: ze.INDEX | ze.COPY_DST,
      // | BufferUsage.STATIC,
      shrinkToFit: !1
    }), r = 24;
    super({
      attributes: {
        aPosition: {
          buffer: t,
          format: "float32x2",
          stride: r,
          offset: 0
        },
        aUV: {
          buffer: t,
          format: "float32x2",
          stride: r,
          offset: 8
        },
        aColor: {
          buffer: t,
          format: "unorm8x4",
          stride: r,
          offset: 16
        },
        aTextureIdAndRound: {
          buffer: t,
          format: "uint16x2",
          stride: r,
          offset: 20
        }
      },
      indexBuffer: s
    });
  }
}
function gd(i, e, t) {
  if (i)
    for (const s in i) {
      const r = s.toLocaleLowerCase(), n = e[r];
      if (n) {
        let o = i[s];
        s === "header" && (o = o.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), t && n.push(`//----${t}----//`), n.push(o);
      } else
        se(`${s} placement hook does not exist in shader`);
    }
}
const H1 = /\{\{(.*?)\}\}/g;
function xd(i) {
  const e = {};
  return (i.match(H1)?.map((s) => s.replace(/[{()}]/g, "")) ?? []).forEach((s) => {
    e[s] = [];
  }), e;
}
function yd(i, e) {
  let t;
  const s = /@in\s+([^;]+);/g;
  for (; (t = s.exec(i)) !== null; )
    e.push(t[1]);
}
function vd(i, e, t = !1) {
  const s = [];
  yd(e, s), i.forEach((a) => {
    a.header && yd(a.header, s);
  });
  const r = s;
  t && r.sort();
  const n = r.map((a, l) => `       @location(${l}) ${a},`).join(`
`);
  let o = e.replace(/@in\s+[^;]+;\s*/g, "");
  return o = o.replace("{{in}}", `
${n}
`), o;
}
function _d(i, e) {
  let t;
  const s = /@out\s+([^;]+);/g;
  for (; (t = s.exec(i)) !== null; )
    e.push(t[1]);
}
function W1(i) {
  const t = /\b(\w+)\s*:/g.exec(i);
  return t ? t[1] : "";
}
function V1(i) {
  const e = /@.*?\s+/g;
  return i.replace(e, "");
}
function $1(i, e) {
  const t = [];
  _d(e, t), i.forEach((l) => {
    l.header && _d(l.header, t);
  });
  let s = 0;
  const r = t.sort().map((l) => l.indexOf("builtin") > -1 ? l : `@location(${s++}) ${l}`).join(`,
`), n = t.sort().map((l) => `       var ${V1(l)};`).join(`
`), o = `return VSOutput(
            ${t.sort().map((l) => ` ${W1(l)}`).join(`,
`)});`;
  let a = e.replace(/@out\s+[^;]+;\s*/g, "");
  return a = a.replace("{{struct}}", `
${r}
`), a = a.replace("{{start}}", `
${n}
`), a = a.replace("{{return}}", `
${o}
`), a;
}
function bd(i, e) {
  let t = i;
  for (const s in e) {
    const r = e[s];
    r.join(`
`).length ? t = t.replace(`{{${s}}}`, `//-----${s} START-----//
${r.join(`
`)}
//----${s} FINISH----//`) : t = t.replace(`{{${s}}}`, "");
  }
  return t;
}
const It = /* @__PURE__ */ Object.create(null), ih = /* @__PURE__ */ new Map();
let Y1 = 0;
function X1({
  template: i,
  bits: e
}) {
  const t = xm(i, e);
  if (It[t])
    return It[t];
  const { vertex: s, fragment: r } = Z1(i, e);
  return It[t] = ym(s, r, e), It[t];
}
function q1({
  template: i,
  bits: e
}) {
  const t = xm(i, e);
  return It[t] || (It[t] = ym(i.vertex, i.fragment, e)), It[t];
}
function Z1(i, e) {
  const t = e.map((o) => o.vertex).filter((o) => !!o), s = e.map((o) => o.fragment).filter((o) => !!o);
  let r = vd(t, i.vertex, !0);
  r = $1(t, r);
  const n = vd(s, i.fragment, !0);
  return {
    vertex: r,
    fragment: n
  };
}
function xm(i, e) {
  return e.map((t) => (ih.has(t) || ih.set(t, Y1++), ih.get(t))).sort((t, s) => t - s).join("-") + i.vertex + i.fragment;
}
function ym(i, e, t) {
  const s = xd(i), r = xd(e);
  return t.forEach((n) => {
    gd(n.vertex, s, n.name), gd(n.fragment, r, n.name);
  }), {
    vertex: bd(i, s),
    fragment: bd(e, r)
  };
}
const K1 = (
  /* wgsl */
  `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}

        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);

        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`
), J1 = (
  /* wgsl */
  `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;

    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {

        {{start}}

        var outColor:vec4<f32>;

        {{main}}

        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`
), j1 = (
  /* glsl */
  `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;

        {{start}}

        vColor = vec4(1.);

        {{main}}

        vUV = uv;

        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`
), Q1 = (
  /* glsl */
  `

    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {

        {{start}}

        vec4 outColor;

        {{main}}

        finalColor = outColor * vColor;

        {{end}}
    }
`
), ew = {
  name: "global-uniforms-bit",
  vertex: {
    header: (
      /* wgsl */
      `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
    )
  }
}, tw = {
  name: "global-uniforms-bit",
  vertex: {
    header: (
      /* glsl */
      `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
    )
  }
};
function iw({ bits: i, name: e }) {
  const t = X1({
    template: {
      fragment: J1,
      vertex: K1
    },
    bits: [
      ew,
      ...i
    ]
  });
  return yi.from({
    name: e,
    vertex: {
      source: t.vertex,
      entryPoint: "main"
    },
    fragment: {
      source: t.fragment,
      entryPoint: "main"
    }
  });
}
function sw({ bits: i, name: e }) {
  return new xi({
    name: e,
    ...q1({
      template: {
        vertex: j1,
        fragment: Q1
      },
      bits: [
        tw,
        ...i
      ]
    })
  });
}
const rw = {
  name: "color-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            @in aColor: vec4<f32>;
        `
    ),
    main: (
      /* wgsl */
      `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
    )
  }
}, nw = {
  name: "color-bit",
  vertex: {
    header: (
      /* glsl */
      `
            in vec4 aColor;
        `
    ),
    main: (
      /* glsl */
      `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
    )
  }
}, sh = {};
function ow(i) {
  const e = [];
  if (i === 1)
    e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), e.push("@group(1) @binding(1) var textureSampler1: sampler;");
  else {
    let t = 0;
    for (let s = 0; s < i; s++)
      e.push(`@group(1) @binding(${t++}) var textureSource${s + 1}: texture_2d<f32>;`), e.push(`@group(1) @binding(${t++}) var textureSampler${s + 1}: sampler;`);
  }
  return e.join(`
`);
}
function aw(i) {
  const e = [];
  if (i === 1)
    e.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
  else {
    e.push("switch vTextureId {");
    for (let t = 0; t < i; t++)
      t === i - 1 ? e.push("  default:{") : e.push(`  case ${t}:{`), e.push(`      outColor = textureSampleGrad(textureSource${t + 1}, textureSampler${t + 1}, vUV, uvDx, uvDy);`), e.push("      break;}");
    e.push("}");
  }
  return e.join(`
`);
}
function lw(i) {
  return sh[i] || (sh[i] = {
    name: "texture-batch-bit",
    vertex: {
      header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
      main: `
                vTextureId = aTextureIdAndRound.y;
            `,
      end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
    },
    fragment: {
      header: `
                @in @interpolate(flat) vTextureId: u32;

                ${ow(i)}
            `,
      main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${aw(i)}
            `
    }
  }), sh[i];
}
const rh = {};
function cw(i) {
  const e = [];
  for (let t = 0; t < i; t++)
    t > 0 && e.push("else"), t < i - 1 && e.push(`if(vTextureId < ${t}.5)`), e.push("{"), e.push(`	outColor = texture(uTextures[${t}], vUV);`), e.push("}");
  return e.join(`
`);
}
function hw(i) {
  return rh[i] || (rh[i] = {
    name: "texture-batch-bit",
    vertex: {
      header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
      main: `
                vTextureId = aTextureIdAndRound.y;
            `,
      end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
    },
    fragment: {
      header: `
                in float vTextureId;

                uniform sampler2D uTextures[${i}];

            `,
      main: `

                ${cw(i)}
            `
    }
  }), rh[i];
}
const uw = {
  name: "round-pixels-bit",
  vertex: {
    header: (
      /* wgsl */
      `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    )
  }
}, dw = {
  name: "round-pixels-bit",
  vertex: {
    header: (
      /* glsl */
      `
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
    )
  }
}, wd = {};
function fw(i) {
  let e = wd[i];
  if (e)
    return e;
  const t = new Int32Array(i);
  for (let s = 0; s < i; s++)
    t[s] = s;
  return e = wd[i] = new Jp({
    uTextures: { value: t, type: "i32", size: i }
  }, { isStatic: !0 }), e;
}
class Td extends pr {
  constructor(e) {
    const t = sw({
      name: "batch",
      bits: [
        nw,
        hw(e),
        dw
      ]
    }), s = iw({
      name: "batch",
      bits: [
        rw,
        lw(e),
        uw
      ]
    });
    super({
      glProgram: t,
      gpuProgram: s,
      resources: {
        batchSamplers: fw(e)
      }
    }), this.maxTextures = e;
  }
}
let Fi = null;
const vm = class _m extends B1 {
  constructor(e) {
    super(e), this.geometry = new G1(), this.name = _m.extension.name, this.vertexSize = 6, Fi ?? (Fi = new Td(e.maxTextures)), this.shader = Fi;
  }
  /**
   * Packs the attributes of a DefaultBatchableMeshElement into the provided views.
   * @param element - The DefaultBatchableMeshElement to pack.
   * @param float32View - The Float32Array view to pack into.
   * @param uint32View - The Uint32Array view to pack into.
   * @param index - The starting index in the views.
   * @param textureId - The texture ID to use.
   */
  packAttributes(e, t, s, r, n) {
    const o = n << 16 | e.roundPixels & 65535, a = e.transform, l = a.a, c = a.b, h = a.c, u = a.d, d = a.tx, f = a.ty, { positions: m, uvs: g } = e, p = e.color, x = e.attributeOffset, y = x + e.attributeSize;
    for (let v = x; v < y; v++) {
      const _ = v * 2, b = m[_], T = m[_ + 1];
      t[r++] = l * b + h * T + d, t[r++] = u * T + c * b + f, t[r++] = g[_], t[r++] = g[_ + 1], s[r++] = p, s[r++] = o;
    }
  }
  /**
   * Packs the attributes of a DefaultBatchableQuadElement into the provided views.
   * @param element - The DefaultBatchableQuadElement to pack.
   * @param float32View - The Float32Array view to pack into.
   * @param uint32View - The Uint32Array view to pack into.
   * @param index - The starting index in the views.
   * @param textureId - The texture ID to use.
   */
  packQuadAttributes(e, t, s, r, n) {
    const o = e.texture, a = e.transform, l = a.a, c = a.b, h = a.c, u = a.d, d = a.tx, f = a.ty, m = e.bounds, g = m.maxX, p = m.minX, x = m.maxY, y = m.minY, v = o.uvs, _ = e.color, b = n << 16 | e.roundPixels & 65535;
    t[r + 0] = l * p + h * y + d, t[r + 1] = u * y + c * p + f, t[r + 2] = v.x0, t[r + 3] = v.y0, s[r + 4] = _, s[r + 5] = b, t[r + 6] = l * g + h * y + d, t[r + 7] = u * y + c * g + f, t[r + 8] = v.x1, t[r + 9] = v.y1, s[r + 10] = _, s[r + 11] = b, t[r + 12] = l * g + h * x + d, t[r + 13] = u * x + c * g + f, t[r + 14] = v.x2, t[r + 15] = v.y2, s[r + 16] = _, s[r + 17] = b, t[r + 18] = l * p + h * x + d, t[r + 19] = u * x + c * p + f, t[r + 20] = v.x3, t[r + 21] = v.y3, s[r + 22] = _, s[r + 23] = b;
  }
  /**
   * Updates the maximum number of textures that can be used in the shader.
   * @param maxTextures - The maximum number of textures that can be used in the shader.
   * @internal
   */
  _updateMaxTextures(e) {
    this.shader.maxTextures !== e && (Fi = new Td(e), this.shader = Fi);
  }
  destroy() {
    this.shader = null, super.destroy();
  }
};
vm.extension = {
  type: [
    O.Batcher
  ],
  name: "default"
};
let pw = vm;
function mw(i, e, t, s, r, n, o, a = null) {
  let l = 0;
  t *= e, r *= n;
  const c = a.a, h = a.b, u = a.c, d = a.d, f = a.tx, m = a.ty;
  for (; l < o; ) {
    const g = i[t], p = i[t + 1];
    s[r] = c * g + u * p + f, s[r + 1] = h * g + d * p + m, r += n, t += e, l++;
  }
}
function gw(i, e, t, s) {
  let r = 0;
  for (e *= t; r < s; )
    i[e] = 0, i[e + 1] = 0, e += t, r++;
}
function bm(i, e, t, s, r) {
  const n = e.a, o = e.b, a = e.c, l = e.d, c = e.tx, h = e.ty;
  t || (t = 0), s || (s = 2), r || (r = i.length / s - t);
  let u = t * s;
  for (let d = 0; d < r; d++) {
    const f = i[u], m = i[u + 1];
    i[u] = n * f + a * m + c, i[u + 1] = o * f + l * m + h, u += s;
  }
}
const xw = new W();
class wm {
  constructor() {
    this.packAsQuad = !1, this.batcherName = "default", this.topology = "triangle-list", this.applyTransform = !0, this.roundPixels = 0, this._batcher = null, this._batch = null;
  }
  get uvs() {
    return this.geometryData.uvs;
  }
  get positions() {
    return this.geometryData.vertices;
  }
  get indices() {
    return this.geometryData.indices;
  }
  get blendMode() {
    return this.renderable && this.applyTransform ? this.renderable.groupBlendMode : "normal";
  }
  get color() {
    const e = this.baseColor, t = e >> 16 | e & 65280 | (e & 255) << 16, s = this.renderable;
    return s ? Ip(t, s.groupColor) + (this.alpha * s.groupAlpha * 255 << 24) : t + (this.alpha * 255 << 24);
  }
  get transform() {
    return this.renderable?.groupTransform || xw;
  }
  copyTo(e) {
    e.indexOffset = this.indexOffset, e.indexSize = this.indexSize, e.attributeOffset = this.attributeOffset, e.attributeSize = this.attributeSize, e.baseColor = this.baseColor, e.alpha = this.alpha, e.texture = this.texture, e.geometryData = this.geometryData, e.topology = this.topology;
  }
  reset() {
    this.applyTransform = !0, this.renderable = null, this.topology = "triangle-list";
  }
  destroy() {
    this.renderable = null, this.texture = null, this.geometryData = null, this._batcher = null, this._batch = null;
  }
}
const ss = {
  extension: {
    type: O.ShapeBuilder,
    name: "circle"
  },
  build(i, e) {
    let t, s, r, n, o, a;
    if (i.type === "circle") {
      const _ = i;
      if (o = a = _.radius, o <= 0)
        return !1;
      t = _.x, s = _.y, r = n = 0;
    } else if (i.type === "ellipse") {
      const _ = i;
      if (o = _.halfWidth, a = _.halfHeight, o <= 0 || a <= 0)
        return !1;
      t = _.x, s = _.y, r = n = 0;
    } else {
      const _ = i, b = _.width / 2, T = _.height / 2;
      t = _.x + b, s = _.y + T, o = a = Math.max(0, Math.min(_.radius, Math.min(b, T))), r = b - o, n = T - a;
    }
    if (r < 0 || n < 0)
      return !1;
    const l = Math.ceil(2.3 * Math.sqrt(o + a)), c = l * 8 + (r ? 4 : 0) + (n ? 4 : 0);
    if (c === 0)
      return !1;
    if (l === 0)
      return e[0] = e[6] = t + r, e[1] = e[3] = s + n, e[2] = e[4] = t - r, e[5] = e[7] = s - n, !0;
    let h = 0, u = l * 4 + (r ? 2 : 0) + 2, d = u, f = c, m = r + o, g = n, p = t + m, x = t - m, y = s + g;
    if (e[h++] = p, e[h++] = y, e[--u] = y, e[--u] = x, n) {
      const _ = s - g;
      e[d++] = x, e[d++] = _, e[--f] = _, e[--f] = p;
    }
    for (let _ = 1; _ < l; _++) {
      const b = Math.PI / 2 * (_ / l), T = r + Math.cos(b) * o, w = n + Math.sin(b) * a, A = t + T, k = t - T, S = s + w, C = s - w;
      e[h++] = A, e[h++] = S, e[--u] = S, e[--u] = k, e[d++] = k, e[d++] = C, e[--f] = C, e[--f] = A;
    }
    m = r, g = n + a, p = t + m, x = t - m, y = s + g;
    const v = s - g;
    return e[h++] = p, e[h++] = y, e[--f] = v, e[--f] = p, r && (e[h++] = x, e[h++] = y, e[--f] = v, e[--f] = x), !0;
  },
  triangulate(i, e, t, s, r, n) {
    if (i.length === 0)
      return;
    let o = 0, a = 0;
    for (let h = 0; h < i.length; h += 2)
      o += i[h], a += i[h + 1];
    o /= i.length / 2, a /= i.length / 2;
    let l = s;
    e[l * t] = o, e[l * t + 1] = a;
    const c = l++;
    for (let h = 0; h < i.length; h += 2)
      e[l * t] = i[h], e[l * t + 1] = i[h + 1], h > 0 && (r[n++] = l, r[n++] = c, r[n++] = l - 1), l++;
    r[n++] = c + 1, r[n++] = c, r[n++] = l - 1;
  }
}, yw = { ...ss, extension: { ...ss.extension, name: "ellipse" } }, vw = { ...ss, extension: { ...ss.extension, name: "roundedRectangle" } }, Tm = 1e-4, Sd = 1e-4;
function _w(i) {
  const e = i.length;
  if (e < 6)
    return 1;
  let t = 0;
  for (let s = 0, r = i[e - 2], n = i[e - 1]; s < e; s += 2) {
    const o = i[s], a = i[s + 1];
    t += (o - r) * (a + n), r = o, n = a;
  }
  return t < 0 ? -1 : 1;
}
function Cd(i, e, t, s, r, n, o, a) {
  const l = i - t * r, c = e - s * r, h = i + t * n, u = e + s * n;
  let d, f;
  o ? (d = s, f = -t) : (d = -s, f = t);
  const m = l + d, g = c + f, p = h + d, x = u + f;
  return a.push(m, g), a.push(p, x), 2;
}
function Rt(i, e, t, s, r, n, o, a) {
  const l = t - i, c = s - e;
  let h = Math.atan2(l, c), u = Math.atan2(r - i, n - e);
  a && h < u ? h += Math.PI * 2 : !a && h > u && (u += Math.PI * 2);
  let d = h;
  const f = u - h, m = Math.abs(f), g = Math.sqrt(l * l + c * c), p = (15 * m * Math.sqrt(g) / Math.PI >> 0) + 1, x = f / p;
  if (d += x, a) {
    o.push(i, e), o.push(t, s);
    for (let y = 1, v = d; y < p; y++, v += x)
      o.push(i, e), o.push(
        i + Math.sin(v) * g,
        e + Math.cos(v) * g
      );
    o.push(i, e), o.push(r, n);
  } else {
    o.push(t, s), o.push(i, e);
    for (let y = 1, v = d; y < p; y++, v += x)
      o.push(
        i + Math.sin(v) * g,
        e + Math.cos(v) * g
      ), o.push(i, e);
    o.push(r, n), o.push(i, e);
  }
  return p * 2;
}
function bw(i, e, t, s, r, n) {
  const o = Tm;
  if (i.length === 0)
    return;
  const a = e;
  let l = a.alignment;
  if (e.alignment !== 0.5) {
    let B = _w(i);
    l = (l - 0.5) * B + 0.5;
  }
  const c = new q(i[0], i[1]), h = new q(i[i.length - 2], i[i.length - 1]), u = s, d = Math.abs(c.x - h.x) < o && Math.abs(c.y - h.y) < o;
  if (u) {
    i = i.slice(), d && (i.pop(), i.pop(), h.set(i[i.length - 2], i[i.length - 1]));
    const B = (c.x + h.x) * 0.5, X = (h.y + c.y) * 0.5;
    i.unshift(B, X), i.push(B, X);
  }
  const f = r, m = i.length / 2;
  let g = i.length;
  const p = f.length / 2, x = a.width / 2, y = x * x, v = a.miterLimit * a.miterLimit;
  let _ = i[0], b = i[1], T = i[2], w = i[3], A = 0, k = 0, S = -(b - w), C = _ - T, U = 0, R = 0, H = Math.sqrt(S * S + C * C);
  S /= H, C /= H, S *= x, C *= x;
  const ae = l, M = (1 - ae) * 2, E = ae * 2;
  u || (a.cap === "round" ? g += Rt(
    _ - S * (M - E) * 0.5,
    b - C * (M - E) * 0.5,
    _ - S * M,
    b - C * M,
    _ + S * E,
    b + C * E,
    f,
    !0
  ) + 2 : a.cap === "square" && (g += Cd(_, b, S, C, M, E, !0, f))), f.push(
    _ - S * M,
    b - C * M
  ), f.push(
    _ + S * E,
    b + C * E
  );
  for (let B = 1; B < m - 1; ++B) {
    _ = i[(B - 1) * 2], b = i[(B - 1) * 2 + 1], T = i[B * 2], w = i[B * 2 + 1], A = i[(B + 1) * 2], k = i[(B + 1) * 2 + 1], S = -(b - w), C = _ - T, H = Math.sqrt(S * S + C * C), S /= H, C /= H, S *= x, C *= x, U = -(w - k), R = T - A, H = Math.sqrt(U * U + R * R), U /= H, R /= H, U *= x, R *= x;
    const X = T - _, me = b - w, ee = T - A, ve = k - w, Ce = X * ee + me * ve, D = me * ee - ve * X, V = D < 0;
    if (Math.abs(D) < 1e-3 * Math.abs(Ce)) {
      f.push(
        T - S * M,
        w - C * M
      ), f.push(
        T + S * E,
        w + C * E
      ), Ce >= 0 && (a.join === "round" ? g += Rt(
        T,
        w,
        T - S * M,
        w - C * M,
        T - U * M,
        w - R * M,
        f,
        !1
      ) + 4 : g += 2, f.push(
        T - U * E,
        w - R * E
      ), f.push(
        T + U * M,
        w + R * M
      ));
      continue;
    }
    const le = (-S + _) * (-C + w) - (-S + T) * (-C + b), _e = (-U + A) * (-R + w) - (-U + T) * (-R + k), Xt = (X * _e - ee * le) / D, wt = (ve * le - me * _e) / D, ot = (Xt - T) * (Xt - T) + (wt - w) * (wt - w), Be = T + (Xt - T) * M, Je = w + (wt - w) * M, Pt = T - (Xt - T) * E, Ut = w - (wt - w) * E, ig = Math.min(X * X + me * me, ee * ee + ve * ve), _u = V ? M : E, sg = ig + _u * _u * y;
    ot <= sg ? a.join === "bevel" || ot / y > v ? (V ? (f.push(Be, Je), f.push(T + S * E, w + C * E), f.push(Be, Je), f.push(T + U * E, w + R * E)) : (f.push(T - S * M, w - C * M), f.push(Pt, Ut), f.push(T - U * M, w - R * M), f.push(Pt, Ut)), g += 2) : a.join === "round" ? V ? (f.push(Be, Je), f.push(T + S * E, w + C * E), g += Rt(
      T,
      w,
      T + S * E,
      w + C * E,
      T + U * E,
      w + R * E,
      f,
      !0
    ) + 4, f.push(Be, Je), f.push(T + U * E, w + R * E)) : (f.push(T - S * M, w - C * M), f.push(Pt, Ut), g += Rt(
      T,
      w,
      T - S * M,
      w - C * M,
      T - U * M,
      w - R * M,
      f,
      !1
    ) + 4, f.push(T - U * M, w - R * M), f.push(Pt, Ut)) : (f.push(Be, Je), f.push(Pt, Ut)) : (f.push(T - S * M, w - C * M), f.push(T + S * E, w + C * E), a.join === "round" ? V ? g += Rt(
      T,
      w,
      T + S * E,
      w + C * E,
      T + U * E,
      w + R * E,
      f,
      !0
    ) + 2 : g += Rt(
      T,
      w,
      T - S * M,
      w - C * M,
      T - U * M,
      w - R * M,
      f,
      !1
    ) + 2 : a.join === "miter" && ot / y <= v && (V ? (f.push(Pt, Ut), f.push(Pt, Ut)) : (f.push(Be, Je), f.push(Be, Je)), g += 2), f.push(T - U * M, w - R * M), f.push(T + U * E, w + R * E), g += 2);
  }
  _ = i[(m - 2) * 2], b = i[(m - 2) * 2 + 1], T = i[(m - 1) * 2], w = i[(m - 1) * 2 + 1], S = -(b - w), C = _ - T, H = Math.sqrt(S * S + C * C), S /= H, C /= H, S *= x, C *= x, f.push(T - S * M, w - C * M), f.push(T + S * E, w + C * E), u || (a.cap === "round" ? g += Rt(
    T - S * (M - E) * 0.5,
    w - C * (M - E) * 0.5,
    T - S * M,
    w - C * M,
    T + S * E,
    w + C * E,
    f,
    !1
  ) + 2 : a.cap === "square" && (g += Cd(T, w, S, C, M, E, !1, f)));
  const j = Sd * Sd;
  for (let B = p; B < g + p - 2; ++B)
    _ = f[B * 2], b = f[B * 2 + 1], T = f[(B + 1) * 2], w = f[(B + 1) * 2 + 1], A = f[(B + 2) * 2], k = f[(B + 2) * 2 + 1], !(Math.abs(_ * (w - k) + T * (k - b) + A * (b - w)) < j) && n.push(B, B + 1, B + 2);
}
function ww(i, e, t, s) {
  const r = Tm;
  if (i.length === 0)
    return;
  const n = i[0], o = i[1], a = i[i.length - 2], l = i[i.length - 1], c = e || Math.abs(n - a) < r && Math.abs(o - l) < r, h = t, u = i.length / 2, d = h.length / 2;
  for (let f = 0; f < u; f++)
    h.push(i[f * 2]), h.push(i[f * 2 + 1]);
  for (let f = 0; f < u - 1; f++)
    s.push(d + f, d + f + 1);
  c && s.push(d + u - 1, d);
}
function Sm(i, e, t, s, r, n, o) {
  const a = l1(i, e, 2);
  if (!a)
    return;
  for (let c = 0; c < a.length; c += 3)
    n[o++] = a[c] + r, n[o++] = a[c + 1] + r, n[o++] = a[c + 2] + r;
  let l = r * s;
  for (let c = 0; c < i.length; c += 2)
    t[l] = i[c], t[l + 1] = i[c + 1], l += s;
}
const Tw = [], Sw = {
  extension: {
    type: O.ShapeBuilder,
    name: "polygon"
  },
  build(i, e) {
    for (let t = 0; t < i.points.length; t++)
      e[t] = i.points[t];
    return !0;
  },
  triangulate(i, e, t, s, r, n) {
    Sm(i, Tw, e, t, s, r, n);
  }
}, Cw = {
  extension: {
    type: O.ShapeBuilder,
    name: "rectangle"
  },
  build(i, e) {
    const t = i, s = t.x, r = t.y, n = t.width, o = t.height;
    return n > 0 && o > 0 ? (e[0] = s, e[1] = r, e[2] = s + n, e[3] = r, e[4] = s + n, e[5] = r + o, e[6] = s, e[7] = r + o, !0) : !1;
  },
  triangulate(i, e, t, s, r, n) {
    let o = 0;
    s *= t, e[s + o] = i[0], e[s + o + 1] = i[1], o += t, e[s + o] = i[2], e[s + o + 1] = i[3], o += t, e[s + o] = i[6], e[s + o + 1] = i[7], o += t, e[s + o] = i[4], e[s + o + 1] = i[5], o += t;
    const a = s / t;
    r[n++] = a, r[n++] = a + 1, r[n++] = a + 2, r[n++] = a + 1, r[n++] = a + 3, r[n++] = a + 2;
  }
}, Aw = {
  extension: {
    type: O.ShapeBuilder,
    name: "triangle"
  },
  build(i, e) {
    return e[0] = i.x, e[1] = i.y, e[2] = i.x2, e[3] = i.y2, e[4] = i.x3, e[5] = i.y3, !0;
  },
  triangulate(i, e, t, s, r, n) {
    let o = 0;
    s *= t, e[s + o] = i[0], e[s + o + 1] = i[1], o += t, e[s + o] = i[2], e[s + o + 1] = i[3], o += t, e[s + o] = i[4], e[s + o + 1] = i[5];
    const a = s / t;
    r[n++] = a, r[n++] = a + 1, r[n++] = a + 2;
  }
}, Iw = new W(), kw = new G();
function Fw(i, e, t, s) {
  const r = e.matrix ? i.copyFrom(e.matrix).invert() : i.identity();
  if (e.textureSpace === "local") {
    const o = t.getBounds(kw);
    e.width && o.pad(e.width);
    const { x: a, y: l } = o, c = 1 / o.width, h = 1 / o.height, u = -a * c, d = -l * h, f = r.a, m = r.b, g = r.c, p = r.d;
    r.a *= c, r.b *= c, r.c *= h, r.d *= h, r.tx = u * f + d * g + r.tx, r.ty = u * m + d * p + r.ty;
  } else
    r.translate(e.texture.frame.x, e.texture.frame.y), r.scale(1 / e.texture.source.width, 1 / e.texture.source.height);
  const n = e.texture.source.style;
  return !(e.fill instanceof qe) && n.addressMode === "clamp-to-edge" && (n.addressMode = "repeat", n.update()), s && r.append(Iw.copyFrom(s).invert()), r;
}
const yr = {};
ke.handleByMap(O.ShapeBuilder, yr);
ke.add(Cw, Sw, Aw, ss, yw, vw);
const Mw = new G(), Ew = new W();
function Pw(i, e) {
  const { geometryData: t, batches: s } = e;
  s.length = 0, t.indices.length = 0, t.vertices.length = 0, t.uvs.length = 0;
  for (let r = 0; r < i.instructions.length; r++) {
    const n = i.instructions[r];
    if (n.action === "texture")
      Uw(n.data, s, t);
    else if (n.action === "fill" || n.action === "stroke") {
      const o = n.action === "stroke", a = n.data.path.shapePath, l = n.data.style, c = n.data.hole;
      o && c && Ad(c.shapePath, l, !0, s, t), c && (a.shapePrimitives[a.shapePrimitives.length - 1].holes = c.shapePath.shapePrimitives), Ad(a, l, o, s, t);
    }
  }
}
function Uw(i, e, t) {
  const s = [], r = yr.rectangle, n = Mw;
  n.x = i.dx, n.y = i.dy, n.width = i.dw, n.height = i.dh;
  const o = i.transform;
  if (!r.build(n, s))
    return;
  const { vertices: a, uvs: l, indices: c } = t, h = c.length, u = a.length / 2;
  o && bm(s, o), r.triangulate(s, a, 2, u, c, h);
  const d = i.image, f = d.uvs;
  l.push(
    f.x0,
    f.y0,
    f.x1,
    f.y1,
    f.x3,
    f.y3,
    f.x2,
    f.y2
  );
  const m = Xe.get(wm);
  m.indexOffset = h, m.indexSize = c.length - h, m.attributeOffset = u, m.attributeSize = a.length / 2 - u, m.baseColor = i.style, m.alpha = i.alpha, m.texture = d, m.geometryData = t, e.push(m);
}
function Ad(i, e, t, s, r) {
  const { vertices: n, uvs: o, indices: a } = r;
  i.shapePrimitives.forEach(({ shape: l, transform: c, holes: h }) => {
    const u = [], d = yr[l.type];
    if (!d.build(l, u))
      return;
    const f = a.length, m = n.length / 2;
    let g = "triangle-list";
    if (c && bm(u, c), t) {
      const v = l.closePath ?? !0, _ = e;
      _.pixelLine ? (ww(u, v, n, a), g = "line-list") : bw(u, _, !1, v, n, a);
    } else if (h) {
      const v = [], _ = u.slice();
      Rw(h).forEach((T) => {
        v.push(_.length / 2), _.push(...T);
      }), Sm(_, v, n, 2, m, a, f);
    } else
      d.triangulate(u, n, 2, m, a, f);
    const p = o.length / 2, x = e.texture;
    if (x !== L.WHITE) {
      const v = Fw(Ew, e, l, c);
      mw(n, 2, m, o, p, 2, n.length / 2 - m, v);
    } else
      gw(o, p, 2, n.length / 2 - m);
    const y = Xe.get(wm);
    y.indexOffset = f, y.indexSize = a.length - f, y.attributeOffset = m, y.attributeSize = n.length / 2 - m, y.baseColor = e.color, y.alpha = e.alpha, y.texture = x, y.geometryData = r, y.topology = g, s.push(y);
  });
}
function Rw(i) {
  const e = [];
  for (let t = 0; t < i.length; t++) {
    const s = i[t].shape, r = [];
    yr[s.type].build(s, r) && e.push(r);
  }
  return e;
}
class Bw {
  constructor() {
    this.batches = [], this.geometryData = {
      vertices: [],
      uvs: [],
      indices: []
    };
  }
}
class zw {
  constructor() {
    this.instructions = new Ep();
  }
  init(e) {
    const t = e.maxTextures;
    this.batcher ? this.batcher._updateMaxTextures(t) : this.batcher = new pw({ maxTextures: t }), this.instructions.reset();
  }
  /**
   * @deprecated since version 8.0.0
   * Use `batcher.geometry` instead.
   * @see {Batcher#geometry}
   */
  get geometry() {
    return N(Eb, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry;
  }
  destroy() {
    this.batcher.destroy(), this.instructions.destroy(), this.batcher = null, this.instructions = null;
  }
}
const fu = class Wh {
  constructor(e) {
    this._gpuContextHash = {}, this._graphicsDataContextHash = /* @__PURE__ */ Object.create(null), this._renderer = e, e.renderableGC.addManagedHash(this, "_gpuContextHash"), e.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
  }
  /**
   * Runner init called, update the default options
   * @ignore
   */
  init(e) {
    Wh.defaultOptions.bezierSmoothness = e?.bezierSmoothness ?? Wh.defaultOptions.bezierSmoothness;
  }
  /**
   * Returns the render data for a given GraphicsContext.
   * @param context - The GraphicsContext to get the render data for.
   * @internal
   */
  getContextRenderData(e) {
    return this._graphicsDataContextHash[e.uid] || this._initContextRenderData(e);
  }
  /**
   * Updates the GPU context for a given GraphicsContext.
   * If the context is dirty, it will rebuild the batches and geometry data.
   * @param context - The GraphicsContext to update.
   * @returns The updated GpuGraphicsContext.
   * @internal
   */
  updateGpuContext(e) {
    let t = this._gpuContextHash[e.uid] || this._initContext(e);
    if (e.dirty) {
      t ? this._cleanGraphicsContextData(e) : t = this._initContext(e), Pw(e, t);
      const s = e.batchMode;
      e.customShader || s === "no-batch" ? t.isBatchable = !1 : s === "auto" ? t.isBatchable = t.geometryData.vertices.length < 400 : t.isBatchable = !0, e.dirty = !1;
    }
    return t;
  }
  /**
   * Returns the GpuGraphicsContext for a given GraphicsContext.
   * If it does not exist, it will initialize a new one.
   * @param context - The GraphicsContext to get the GpuGraphicsContext for.
   * @returns The GpuGraphicsContext for the given GraphicsContext.
   * @internal
   */
  getGpuContext(e) {
    return this._gpuContextHash[e.uid] || this._initContext(e);
  }
  _initContextRenderData(e) {
    const t = Xe.get(zw, {
      maxTextures: this._renderer.limits.maxBatchableTextures
    }), { batches: s, geometryData: r } = this._gpuContextHash[e.uid], n = r.vertices.length, o = r.indices.length;
    for (let h = 0; h < s.length; h++)
      s[h].applyTransform = !1;
    const a = t.batcher;
    a.ensureAttributeBuffer(n), a.ensureIndexBuffer(o), a.begin();
    for (let h = 0; h < s.length; h++) {
      const u = s[h];
      a.add(u);
    }
    a.finish(t.instructions);
    const l = a.geometry;
    l.indexBuffer.setDataWithSize(a.indexBuffer, a.indexSize, !0), l.buffers[0].setDataWithSize(a.attributeBuffer.float32View, a.attributeSize, !0);
    const c = a.batches;
    for (let h = 0; h < c.length; h++) {
      const u = c[h];
      u.bindGroup = C1(
        u.textures.textures,
        u.textures.count,
        this._renderer.limits.maxBatchableTextures
      );
    }
    return this._graphicsDataContextHash[e.uid] = t, t;
  }
  _initContext(e) {
    const t = new Bw();
    return t.context = e, this._gpuContextHash[e.uid] = t, e.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid];
  }
  onGraphicsContextDestroy(e) {
    this._cleanGraphicsContextData(e), e.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid] = null;
  }
  _cleanGraphicsContextData(e) {
    const t = this._gpuContextHash[e.uid];
    t.isBatchable || this._graphicsDataContextHash[e.uid] && (Xe.return(this.getContextRenderData(e)), this._graphicsDataContextHash[e.uid] = null), t.batches && t.batches.forEach((s) => {
      Xe.return(s);
    });
  }
  destroy() {
    for (const e in this._gpuContextHash)
      this._gpuContextHash[e] && this.onGraphicsContextDestroy(this._gpuContextHash[e].context);
    this._gpuContextHash = {}, this._graphicsDataContextHash = {}, this._renderer = null;
  }
};
fu.extension = {
  type: [
    O.WebGLSystem,
    O.WebGPUSystem,
    O.CanvasSystem
  ],
  name: "graphicsContext"
};
fu.defaultOptions = {
  /**
   * A value from 0 to 1 that controls the smoothness of bezier curves (the higher the smoother)
   * @default 0.5
   */
  bezierSmoothness: 0.5
};
let Cm = fu;
const Ow = 8, Is = 11920929e-14, Dw = 1;
function Am(i, e, t, s, r, n, o, a, l, c) {
  const u = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, c ?? Cm.defaultOptions.bezierSmoothness)
  );
  let d = (Dw - u) / 1;
  return d *= d, Lw(e, t, s, r, n, o, a, l, i, d), i;
}
function Lw(i, e, t, s, r, n, o, a, l, c) {
  Vh(i, e, t, s, r, n, o, a, l, c, 0), l.push(o, a);
}
function Vh(i, e, t, s, r, n, o, a, l, c, h) {
  if (h > Ow)
    return;
  const u = (i + t) / 2, d = (e + s) / 2, f = (t + r) / 2, m = (s + n) / 2, g = (r + o) / 2, p = (n + a) / 2, x = (u + f) / 2, y = (d + m) / 2, v = (f + g) / 2, _ = (m + p) / 2, b = (x + v) / 2, T = (y + _) / 2;
  if (h > 0) {
    let w = o - i, A = a - e;
    const k = Math.abs((t - o) * A - (s - a) * w), S = Math.abs((r - o) * A - (n - a) * w);
    if (k > Is && S > Is) {
      if ((k + S) * (k + S) <= c * (w * w + A * A)) {
        l.push(b, T);
        return;
      }
    } else if (k > Is) {
      if (k * k <= c * (w * w + A * A)) {
        l.push(b, T);
        return;
      }
    } else if (S > Is) {
      if (S * S <= c * (w * w + A * A)) {
        l.push(b, T);
        return;
      }
    } else if (w = b - (i + o) / 2, A = T - (e + a) / 2, w * w + A * A <= c) {
      l.push(b, T);
      return;
    }
  }
  Vh(i, e, u, d, x, y, b, T, l, c, h + 1), Vh(b, T, v, _, g, p, o, a, l, c, h + 1);
}
const Nw = 8, Gw = 11920929e-14, Hw = 1;
function Ww(i, e, t, s, r, n, o, a) {
  const c = Math.min(
    0.99,
    // a value of 1.0 actually inverts smoothing, so we cap it at 0.99
    Math.max(0, a ?? Cm.defaultOptions.bezierSmoothness)
  );
  let h = (Hw - c) / 1;
  return h *= h, Vw(e, t, s, r, n, o, i, h), i;
}
function Vw(i, e, t, s, r, n, o, a) {
  $h(o, i, e, t, s, r, n, a, 0), o.push(r, n);
}
function $h(i, e, t, s, r, n, o, a, l) {
  if (l > Nw)
    return;
  const c = (e + s) / 2, h = (t + r) / 2, u = (s + n) / 2, d = (r + o) / 2, f = (c + u) / 2, m = (h + d) / 2;
  let g = n - e, p = o - t;
  const x = Math.abs((s - n) * p - (r - o) * g);
  if (x > Gw) {
    if (x * x <= a * (g * g + p * p)) {
      i.push(f, m);
      return;
    }
  } else if (g = f - (e + n) / 2, p = m - (t + o) / 2, g * g + p * p <= a) {
    i.push(f, m);
    return;
  }
  $h(i, e, t, c, h, f, m, a, l + 1), $h(i, f, m, u, d, n, o, a, l + 1);
}
function Im(i, e, t, s, r, n, o, a) {
  let l = Math.abs(r - n);
  (!o && r > n || o && n > r) && (l = 2 * Math.PI - l), a || (a = Math.max(6, Math.floor(6 * Math.pow(s, 1 / 3) * (l / Math.PI)))), a = Math.max(a, 3);
  let c = l / a, h = r;
  c *= o ? -1 : 1;
  for (let u = 0; u < a + 1; u++) {
    const d = Math.cos(h), f = Math.sin(h), m = e + d * s, g = t + f * s;
    i.push(m, g), h += c;
  }
}
function $w(i, e, t, s, r, n) {
  const o = i[i.length - 2], l = i[i.length - 1] - t, c = o - e, h = r - t, u = s - e, d = Math.abs(l * u - c * h);
  if (d < 1e-8 || n === 0) {
    (i[i.length - 2] !== e || i[i.length - 1] !== t) && i.push(e, t);
    return;
  }
  const f = l * l + c * c, m = h * h + u * u, g = l * h + c * u, p = n * Math.sqrt(f) / d, x = n * Math.sqrt(m) / d, y = p * g / f, v = x * g / m, _ = p * u + x * c, b = p * h + x * l, T = c * (x + y), w = l * (x + y), A = u * (p + v), k = h * (p + v), S = Math.atan2(w - b, T - _), C = Math.atan2(k - b, A - _);
  Im(
    i,
    _ + e,
    b + t,
    n,
    S,
    C,
    c * h > u * l
  );
}
const Ki = Math.PI * 2, nh = {
  centerX: 0,
  centerY: 0,
  ang1: 0,
  ang2: 0
}, oh = ({ x: i, y: e }, t, s, r, n, o, a, l) => {
  i *= t, e *= s;
  const c = r * i - n * e, h = n * i + r * e;
  return l.x = c + o, l.y = h + a, l;
};
function Yw(i, e) {
  const t = e === -1.5707963267948966 ? -0.551915024494 : 1.3333333333333333 * Math.tan(e / 4), s = e === 1.5707963267948966 ? 0.551915024494 : t, r = Math.cos(i), n = Math.sin(i), o = Math.cos(i + e), a = Math.sin(i + e);
  return [
    {
      x: r - n * s,
      y: n + r * s
    },
    {
      x: o + a * s,
      y: a - o * s
    },
    {
      x: o,
      y: a
    }
  ];
}
const Id = (i, e, t, s) => {
  const r = i * s - e * t < 0 ? -1 : 1;
  let n = i * t + e * s;
  return n > 1 && (n = 1), n < -1 && (n = -1), r * Math.acos(n);
}, Xw = (i, e, t, s, r, n, o, a, l, c, h, u, d) => {
  const f = Math.pow(r, 2), m = Math.pow(n, 2), g = Math.pow(h, 2), p = Math.pow(u, 2);
  let x = f * m - f * p - m * g;
  x < 0 && (x = 0), x /= f * p + m * g, x = Math.sqrt(x) * (o === a ? -1 : 1);
  const y = x * r / n * u, v = x * -n / r * h, _ = c * y - l * v + (i + t) / 2, b = l * y + c * v + (e + s) / 2, T = (h - y) / r, w = (u - v) / n, A = (-h - y) / r, k = (-u - v) / n, S = Id(1, 0, T, w);
  let C = Id(T, w, A, k);
  a === 0 && C > 0 && (C -= Ki), a === 1 && C < 0 && (C += Ki), d.centerX = _, d.centerY = b, d.ang1 = S, d.ang2 = C;
};
function qw(i, e, t, s, r, n, o, a = 0, l = 0, c = 0) {
  if (n === 0 || o === 0)
    return;
  const h = Math.sin(a * Ki / 360), u = Math.cos(a * Ki / 360), d = u * (e - s) / 2 + h * (t - r) / 2, f = -h * (e - s) / 2 + u * (t - r) / 2;
  if (d === 0 && f === 0)
    return;
  n = Math.abs(n), o = Math.abs(o);
  const m = Math.pow(d, 2) / Math.pow(n, 2) + Math.pow(f, 2) / Math.pow(o, 2);
  m > 1 && (n *= Math.sqrt(m), o *= Math.sqrt(m)), Xw(
    e,
    t,
    s,
    r,
    n,
    o,
    l,
    c,
    h,
    u,
    d,
    f,
    nh
  );
  let { ang1: g, ang2: p } = nh;
  const { centerX: x, centerY: y } = nh;
  let v = Math.abs(p) / (Ki / 4);
  Math.abs(1 - v) < 1e-7 && (v = 1);
  const _ = Math.max(Math.ceil(v), 1);
  p /= _;
  let b = i[i.length - 2], T = i[i.length - 1];
  const w = { x: 0, y: 0 };
  for (let A = 0; A < _; A++) {
    const k = Yw(g, p), { x: S, y: C } = oh(k[0], n, o, u, h, x, y, w), { x: U, y: R } = oh(k[1], n, o, u, h, x, y, w), { x: H, y: ae } = oh(k[2], n, o, u, h, x, y, w);
    Am(
      i,
      b,
      T,
      S,
      C,
      U,
      R,
      H,
      ae
    ), b = H, T = ae, g += p;
  }
}
function Zw(i, e, t) {
  const s = (o, a) => {
    const l = a.x - o.x, c = a.y - o.y, h = Math.sqrt(l * l + c * c), u = l / h, d = c / h;
    return { len: h, nx: u, ny: d };
  }, r = (o, a) => {
    o === 0 ? i.moveTo(a.x, a.y) : i.lineTo(a.x, a.y);
  };
  let n = e[e.length - 1];
  for (let o = 0; o < e.length; o++) {
    const a = e[o % e.length], l = a.radius ?? t;
    if (l <= 0) {
      r(o, a), n = a;
      continue;
    }
    const c = e[(o + 1) % e.length], h = s(a, n), u = s(a, c);
    if (h.len < 1e-4 || u.len < 1e-4) {
      r(o, a), n = a;
      continue;
    }
    let d = Math.asin(h.nx * u.ny - h.ny * u.nx), f = 1, m = !1;
    h.nx * u.nx - h.ny * -u.ny < 0 ? d < 0 ? d = Math.PI + d : (d = Math.PI - d, f = -1, m = !0) : d > 0 && (f = -1, m = !0);
    const g = d / 2;
    let p, x = Math.abs(
      Math.cos(g) * l / Math.sin(g)
    );
    x > Math.min(h.len / 2, u.len / 2) ? (x = Math.min(h.len / 2, u.len / 2), p = Math.abs(x * Math.sin(g) / Math.cos(g))) : p = l;
    const y = a.x + u.nx * x + -u.ny * p * f, v = a.y + u.ny * x + u.nx * p * f, _ = Math.atan2(h.ny, h.nx) + Math.PI / 2 * f, b = Math.atan2(u.ny, u.nx) - Math.PI / 2 * f;
    o === 0 && i.moveTo(
      y + Math.cos(_) * p,
      v + Math.sin(_) * p
    ), i.arc(y, v, p, _, b, m), n = a;
  }
}
function Kw(i, e, t, s) {
  const r = (a, l) => Math.sqrt((a.x - l.x) ** 2 + (a.y - l.y) ** 2), n = (a, l, c) => ({
    x: a.x + (l.x - a.x) * c,
    y: a.y + (l.y - a.y) * c
  }), o = e.length;
  for (let a = 0; a < o; a++) {
    const l = e[(a + 1) % o], c = l.radius ?? t;
    if (c <= 0) {
      a === 0 ? i.moveTo(l.x, l.y) : i.lineTo(l.x, l.y);
      continue;
    }
    const h = e[a], u = e[(a + 2) % o], d = r(h, l);
    let f;
    if (d < 1e-4)
      f = l;
    else {
      const p = Math.min(d / 2, c);
      f = n(
        l,
        h,
        p / d
      );
    }
    const m = r(u, l);
    let g;
    if (m < 1e-4)
      g = l;
    else {
      const p = Math.min(m / 2, c);
      g = n(
        l,
        u,
        p / m
      );
    }
    a === 0 ? i.moveTo(f.x, f.y) : i.lineTo(f.x, f.y), i.quadraticCurveTo(l.x, l.y, g.x, g.y, s);
  }
}
const Jw = new G();
class jw {
  constructor(e) {
    this.shapePrimitives = [], this._currentPoly = null, this._bounds = new it(), this._graphicsPath2D = e, this.signed = e.checkForHoles;
  }
  /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */
  moveTo(e, t) {
    return this.startPoly(e, t), this;
  }
  /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */
  lineTo(e, t) {
    this._ensurePoly();
    const s = this._currentPoly.points, r = s[s.length - 2], n = s[s.length - 1];
    return (r !== e || n !== t) && s.push(e, t), this;
  }
  /**
   * Adds an arc to the path. The arc is centered at (x, y)
   *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The radius of the arc.
   * @param startAngle - The starting angle of the arc, in radians.
   * @param endAngle - The ending angle of the arc, in radians.
   * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.
   * @returns The instance of the current object for chaining.
   */
  arc(e, t, s, r, n, o) {
    this._ensurePoly(!1);
    const a = this._currentPoly.points;
    return Im(a, e, t, s, r, n, o), this;
  }
  /**
   * Adds an arc to the path with the arc tangent to the line joining two specified points.
   * The arc radius is specified by `radius`.
   * @param x1 - The x-coordinate of the first point.
   * @param y1 - The y-coordinate of the first point.
   * @param x2 - The x-coordinate of the second point.
   * @param y2 - The y-coordinate of the second point.
   * @param radius - The radius of the arc.
   * @returns The instance of the current object for chaining.
   */
  arcTo(e, t, s, r, n) {
    this._ensurePoly();
    const o = this._currentPoly.points;
    return $w(o, e, t, s, r, n), this;
  }
  /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */
  arcToSvg(e, t, s, r, n, o, a) {
    const l = this._currentPoly.points;
    return qw(
      l,
      this._currentPoly.lastX,
      this._currentPoly.lastY,
      o,
      a,
      e,
      t,
      s,
      r,
      n
    ), this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveTo(e, t, s, r, n, o, a) {
    this._ensurePoly();
    const l = this._currentPoly;
    return Am(
      this._currentPoly.points,
      l.lastX,
      l.lastY,
      e,
      t,
      s,
      r,
      n,
      o,
      a
    ), this;
  }
  /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the control point.
   * @param cp1y - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothing - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveTo(e, t, s, r, n) {
    this._ensurePoly();
    const o = this._currentPoly;
    return Ww(
      this._currentPoly.points,
      o.lastX,
      o.lastY,
      e,
      t,
      s,
      r,
      n
    ), this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    return this.endPoly(!0), this;
  }
  /**
   * Adds another path to the current path. This method allows for the combination of multiple paths into one.
   * @param path - The `GraphicsPath` object representing the path to add.
   * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.
   * @returns The instance of the current object for chaining.
   */
  addPath(e, t) {
    this.endPoly(), t && !t.isIdentity() && (e = e.clone(!0), e.transform(t));
    const s = this.shapePrimitives, r = s.length;
    for (let n = 0; n < e.instructions.length; n++) {
      const o = e.instructions[n];
      this[o.action](...o.data);
    }
    if (e.checkForHoles && s.length - r > 1) {
      let n = null;
      for (let o = r; o < s.length; o++) {
        const a = s[o];
        if (a.shape.type === "polygon") {
          const l = a.shape, c = n?.shape;
          c && c.containsPolygon(l) ? (n.holes || (n.holes = []), n.holes.push(a), s.copyWithin(o, o + 1), s.length--, o--) : n = a;
        }
      }
    }
    return this;
  }
  /**
   * Finalizes the drawing of the current path. Optionally, it can close the path.
   * @param closePath - A boolean indicating whether to close the path after finishing. False by default.
   */
  finish(e = !1) {
    this.endPoly(e);
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(e, t, s, r, n) {
    return this.drawShape(new G(e, t, s, r), n), this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(e, t, s, r) {
    return this.drawShape(new xr(e, t, s), r), this;
  }
  /**
   * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.
   * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  poly(e, t, s) {
    const r = new qi(e);
    return r.closePath = t, this.drawShape(r, s), this;
  }
  /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  regularPoly(e, t, s, r, n = 0, o) {
    r = Math.max(r | 0, 3);
    const a = -1 * Math.PI / 2 + n, l = Math.PI * 2 / r, c = [];
    for (let h = 0; h < r; h++) {
      const u = a - h * l;
      c.push(
        e + s * Math.cos(u),
        t + s * Math.sin(u)
      );
    }
    return this.poly(c, !0, o), this;
  }
  /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param smoothness - Optional parameter to adjust the smoothness of the rounding.
   * @returns The instance of the current object for chaining.
   */
  roundPoly(e, t, s, r, n, o = 0, a) {
    if (r = Math.max(r | 0, 3), n <= 0)
      return this.regularPoly(e, t, s, r, o);
    const l = s * Math.sin(Math.PI / r) - 1e-3;
    n = Math.min(n, l);
    const c = -1 * Math.PI / 2 + o, h = Math.PI * 2 / r, u = (r - 2) * Math.PI / r / 2;
    for (let d = 0; d < r; d++) {
      const f = d * h + c, m = e + s * Math.cos(f), g = t + s * Math.sin(f), p = f + Math.PI + u, x = f - Math.PI - u, y = m + n * Math.cos(p), v = g + n * Math.sin(p), _ = m + n * Math.cos(x), b = g + n * Math.sin(x);
      d === 0 ? this.moveTo(y, v) : this.lineTo(y, v), this.quadraticCurveTo(m, g, _, b, a);
    }
    return this.closePath();
  }
  /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */
  roundShape(e, t, s = !1, r) {
    return e.length < 3 ? this : (s ? Kw(this, e, t, r) : Zw(this, e, t), this.closePath());
  }
  /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */
  filletRect(e, t, s, r, n) {
    if (n === 0)
      return this.rect(e, t, s, r);
    const o = Math.min(s, r) / 2, a = Math.min(o, Math.max(-o, n)), l = e + s, c = t + r, h = a < 0 ? -a : 0, u = Math.abs(a);
    return this.moveTo(e, t + u).arcTo(e + h, t + h, e + u, t, u).lineTo(l - u, t).arcTo(l - h, t + h, l, t + u, u).lineTo(l, c - u).arcTo(l - h, c - h, e + s - u, c, u).lineTo(e + u, c).arcTo(e + h, c - h, e, c - u, u).closePath();
  }
  /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */
  chamferRect(e, t, s, r, n, o) {
    if (n <= 0)
      return this.rect(e, t, s, r);
    const a = Math.min(n, Math.min(s, r) / 2), l = e + s, c = t + r, h = [
      e + a,
      t,
      l - a,
      t,
      l,
      t + a,
      l,
      c - a,
      l - a,
      c,
      e + a,
      c,
      e,
      c - a,
      e,
      t + a
    ];
    for (let u = h.length - 1; u >= 2; u -= 2)
      h[u] === h[u - 2] && h[u - 1] === h[u - 3] && h.splice(u - 1, 2);
    return this.poly(h, !0, o);
  }
  /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.
   * @returns The instance of the current object for chaining.
   */
  ellipse(e, t, s, r, n) {
    return this.drawShape(new uu(e, t, s, r), n), this;
  }
  /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  roundRect(e, t, s, r, n, o) {
    return this.drawShape(new du(e, t, s, r, n), o), this;
  }
  /**
   * Draws a given shape on the canvas.
   * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.
   * An optional transformation matrix can be applied to the shape, allowing for complex transformations.
   * @param shape - The shape to draw, defined as a `ShapePrimitive` object.
   * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,
   * scaling, and translations.
   * @returns The instance of the current object for chaining.
   */
  drawShape(e, t) {
    return this.endPoly(), this.shapePrimitives.push({ shape: e, transform: t }), this;
  }
  /**
   * Starts a new polygon path from the specified starting point.
   * This method initializes a new polygon or ends the current one if it exists.
   * @param x - The x-coordinate of the starting point of the new polygon.
   * @param y - The y-coordinate of the starting point of the new polygon.
   * @returns The instance of the current object for chaining.
   */
  startPoly(e, t) {
    let s = this._currentPoly;
    return s && this.endPoly(), s = new qi(), s.points.push(e, t), this._currentPoly = s, this;
  }
  /**
   * Ends the current polygon path. If `closePath` is set to true,
   * the path is closed by connecting the last point to the first one.
   * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.
   * @param closePath - A boolean indicating whether to close the polygon by connecting the last point
   *  back to the starting point. False by default.
   * @returns The instance of the current object for chaining.
   */
  endPoly(e = !1) {
    const t = this._currentPoly;
    return t && t.points.length > 2 && (t.closePath = e, this.shapePrimitives.push({ shape: t })), this._currentPoly = null, this;
  }
  _ensurePoly(e = !0) {
    if (!this._currentPoly && (this._currentPoly = new qi(), e)) {
      const t = this.shapePrimitives[this.shapePrimitives.length - 1];
      if (t) {
        let s = t.shape.x, r = t.shape.y;
        if (t.transform && !t.transform.isIdentity()) {
          const n = t.transform, o = s;
          s = n.a * s + n.c * r + n.tx, r = n.b * o + n.d * r + n.ty;
        }
        this._currentPoly.points.push(s, r);
      } else
        this._currentPoly.points.push(0, 0);
    }
  }
  /** Builds the path. */
  buildPath() {
    const e = this._graphicsPath2D;
    this.shapePrimitives.length = 0, this._currentPoly = null;
    for (let t = 0; t < e.instructions.length; t++) {
      const s = e.instructions[t];
      this[s.action](...s.data);
    }
    this.finish();
  }
  /** Gets the bounds of the path. */
  get bounds() {
    const e = this._bounds;
    e.clear();
    const t = this.shapePrimitives;
    for (let s = 0; s < t.length; s++) {
      const r = t[s], n = r.shape.getBounds(Jw);
      r.transform ? e.addRect(n, r.transform) : e.addRect(n);
    }
    return e;
  }
}
class _t {
  /**
   * Creates a `GraphicsPath` instance optionally from an SVG path string or an array of `PathInstruction`.
   * @param instructions - An SVG path string or an array of `PathInstruction` objects.
   * @param signed
   */
  constructor(e, t = !1) {
    this.instructions = [], this.uid = de("graphicsPath"), this._dirty = !0, this.checkForHoles = t, typeof e == "string" ? b1(e, this) : this.instructions = e?.slice() ?? [];
  }
  /**
   * Provides access to the internal shape path, ensuring it is up-to-date with the current instructions.
   * @returns The `ShapePath` instance associated with this `GraphicsPath`.
   */
  get shapePath() {
    return this._shapePath || (this._shapePath = new jw(this)), this._dirty && (this._dirty = !1, this._shapePath.buildPath()), this._shapePath;
  }
  /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @param transform - An optional transformation to apply to the added path.
   * @returns The instance of the current object for chaining.
   */
  addPath(e, t) {
    return e = e.clone(), this.instructions.push({ action: "addPath", data: [e, t] }), this._dirty = !0, this;
  }
  arc(...e) {
    return this.instructions.push({ action: "arc", data: e }), this._dirty = !0, this;
  }
  arcTo(...e) {
    return this.instructions.push({ action: "arcTo", data: e }), this._dirty = !0, this;
  }
  arcToSvg(...e) {
    return this.instructions.push({ action: "arcToSvg", data: e }), this._dirty = !0, this;
  }
  bezierCurveTo(...e) {
    return this.instructions.push({ action: "bezierCurveTo", data: e }), this._dirty = !0, this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires two points: the second control point and the end point. The first control point is assumed to be
   * The starting point is the last point in the current path.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveToShort(e, t, s, r, n) {
    const o = this.instructions[this.instructions.length - 1], a = this.getLastPoint(q.shared);
    let l = 0, c = 0;
    if (!o || o.action !== "bezierCurveTo")
      l = a.x, c = a.y;
    else {
      l = o.data[2], c = o.data[3];
      const h = a.x, u = a.y;
      l = h + (h - l), c = u + (u - c);
    }
    return this.instructions.push({ action: "bezierCurveTo", data: [l, c, e, t, s, r, n] }), this._dirty = !0, this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    return this.instructions.push({ action: "closePath", data: [] }), this._dirty = !0, this;
  }
  ellipse(...e) {
    return this.instructions.push({ action: "ellipse", data: e }), this._dirty = !0, this;
  }
  lineTo(...e) {
    return this.instructions.push({ action: "lineTo", data: e }), this._dirty = !0, this;
  }
  moveTo(...e) {
    return this.instructions.push({ action: "moveTo", data: e }), this;
  }
  quadraticCurveTo(...e) {
    return this.instructions.push({ action: "quadraticCurveTo", data: e }), this._dirty = !0, this;
  }
  /**
   * Adds a quadratic curve to the path. It uses the previous point as the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveToShort(e, t, s) {
    const r = this.instructions[this.instructions.length - 1], n = this.getLastPoint(q.shared);
    let o = 0, a = 0;
    if (!r || r.action !== "quadraticCurveTo")
      o = n.x, a = n.y;
    else {
      o = r.data[0], a = r.data[1];
      const l = n.x, c = n.y;
      o = l + (l - o), a = c + (c - a);
    }
    return this.instructions.push({ action: "quadraticCurveTo", data: [o, a, e, t, s] }), this._dirty = !0, this;
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(e, t, s, r, n) {
    return this.instructions.push({ action: "rect", data: [e, t, s, r, n] }), this._dirty = !0, this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @param transform - An optional `Matrix` object to apply a transformation to the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(e, t, s, r) {
    return this.instructions.push({ action: "circle", data: [e, t, s, r] }), this._dirty = !0, this;
  }
  roundRect(...e) {
    return this.instructions.push({ action: "roundRect", data: e }), this._dirty = !0, this;
  }
  poly(...e) {
    return this.instructions.push({ action: "poly", data: e }), this._dirty = !0, this;
  }
  regularPoly(...e) {
    return this.instructions.push({ action: "regularPoly", data: e }), this._dirty = !0, this;
  }
  roundPoly(...e) {
    return this.instructions.push({ action: "roundPoly", data: e }), this._dirty = !0, this;
  }
  roundShape(...e) {
    return this.instructions.push({ action: "roundShape", data: e }), this._dirty = !0, this;
  }
  filletRect(...e) {
    return this.instructions.push({ action: "filletRect", data: e }), this._dirty = !0, this;
  }
  chamferRect(...e) {
    return this.instructions.push({ action: "chamferRect", data: e }), this._dirty = !0, this;
  }
  /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @param transform - An optional `Matrix` object to apply a transformation to the star.
   * This can include rotations, scaling, and translations.
   * @returns The instance of the current object for chaining further drawing commands.
   */
  // eslint-disable-next-line max-len
  star(e, t, s, r, n, o, a) {
    n || (n = r / 2);
    const l = -1 * Math.PI / 2 + o, c = s * 2, h = Math.PI * 2 / c, u = [];
    for (let d = 0; d < c; d++) {
      const f = d % 2 ? n : r, m = d * h + l;
      u.push(
        e + f * Math.cos(m),
        t + f * Math.sin(m)
      );
    }
    return this.poly(u, !0, a), this;
  }
  /**
   * Creates a copy of the current `GraphicsPath` instance. This method supports both shallow and deep cloning.
   * A shallow clone copies the reference of the instructions array, while a deep clone creates a new array and
   * copies each instruction individually, ensuring that modifications to the instructions of the cloned `GraphicsPath`
   * do not affect the original `GraphicsPath` and vice versa.
   * @param deep - A boolean flag indicating whether the clone should be deep.
   * @returns A new `GraphicsPath` instance that is a clone of the current instance.
   */
  clone(e = !1) {
    const t = new _t();
    if (t.checkForHoles = this.checkForHoles, !e)
      t.instructions = this.instructions.slice();
    else
      for (let s = 0; s < this.instructions.length; s++) {
        const r = this.instructions[s];
        t.instructions.push({ action: r.action, data: r.data.slice() });
      }
    return t;
  }
  clear() {
    return this.instructions.length = 0, this._dirty = !0, this;
  }
  /**
   * Applies a transformation matrix to all drawing instructions within the `GraphicsPath`.
   * This method enables the modification of the path's geometry according to the provided
   * transformation matrix, which can include translations, rotations, scaling, and skewing.
   *
   * Each drawing instruction in the path is updated to reflect the transformation,
   * ensuring the visual representation of the path is consistent with the applied matrix.
   *
   * Note: The transformation is applied directly to the coordinates and control points of the drawing instructions,
   * not to the path as a whole. This means the transformation's effects are baked into the individual instructions,
   * allowing for fine-grained control over the path's appearance.
   * @param matrix - A `Matrix` object representing the transformation to apply.
   * @returns The instance of the current object for chaining further operations.
   */
  transform(e) {
    if (e.isIdentity())
      return this;
    const t = e.a, s = e.b, r = e.c, n = e.d, o = e.tx, a = e.ty;
    let l = 0, c = 0, h = 0, u = 0, d = 0, f = 0, m = 0, g = 0;
    for (let p = 0; p < this.instructions.length; p++) {
      const x = this.instructions[p], y = x.data;
      switch (x.action) {
        case "moveTo":
        case "lineTo":
          l = y[0], c = y[1], y[0] = t * l + r * c + o, y[1] = s * l + n * c + a;
          break;
        case "bezierCurveTo":
          h = y[0], u = y[1], d = y[2], f = y[3], l = y[4], c = y[5], y[0] = t * h + r * u + o, y[1] = s * h + n * u + a, y[2] = t * d + r * f + o, y[3] = s * d + n * f + a, y[4] = t * l + r * c + o, y[5] = s * l + n * c + a;
          break;
        case "quadraticCurveTo":
          h = y[0], u = y[1], l = y[2], c = y[3], y[0] = t * h + r * u + o, y[1] = s * h + n * u + a, y[2] = t * l + r * c + o, y[3] = s * l + n * c + a;
          break;
        case "arcToSvg":
          l = y[5], c = y[6], m = y[0], g = y[1], y[0] = t * m + r * g, y[1] = s * m + n * g, y[5] = t * l + r * c + o, y[6] = s * l + n * c + a;
          break;
        case "circle":
          y[4] = Mi(y[3], e);
          break;
        case "rect":
          y[4] = Mi(y[4], e);
          break;
        case "ellipse":
          y[8] = Mi(y[8], e);
          break;
        case "roundRect":
          y[5] = Mi(y[5], e);
          break;
        case "addPath":
          y[0].transform(e);
          break;
        case "poly":
          y[2] = Mi(y[2], e);
          break;
        default:
          se("unknown transform action", x.action);
          break;
      }
    }
    return this._dirty = !0, this;
  }
  get bounds() {
    return this.shapePath.bounds;
  }
  /**
   * Retrieves the last point from the current drawing instructions in the `GraphicsPath`.
   * This method is useful for operations that depend on the path's current endpoint,
   * such as connecting subsequent shapes or paths. It supports various drawing instructions,
   * ensuring the last point's position is accurately determined regardless of the path's complexity.
   *
   * If the last instruction is a `closePath`, the method iterates backward through the instructions
   *  until it finds an actionable instruction that defines a point (e.g., `moveTo`, `lineTo`,
   * `quadraticCurveTo`, etc.). For compound paths added via `addPath`, it recursively retrieves
   * the last point from the nested path.
   * @param out - A `Point` object where the last point's coordinates will be stored.
   * This object is modified directly to contain the result.
   * @returns The `Point` object containing the last point's coordinates.
   */
  getLastPoint(e) {
    let t = this.instructions.length - 1, s = this.instructions[t];
    if (!s)
      return e.x = 0, e.y = 0, e;
    for (; s.action === "closePath"; ) {
      if (t--, t < 0)
        return e.x = 0, e.y = 0, e;
      s = this.instructions[t];
    }
    switch (s.action) {
      case "moveTo":
      case "lineTo":
        e.x = s.data[0], e.y = s.data[1];
        break;
      case "quadraticCurveTo":
        e.x = s.data[2], e.y = s.data[3];
        break;
      case "bezierCurveTo":
        e.x = s.data[4], e.y = s.data[5];
        break;
      case "arc":
      case "arcToSvg":
        e.x = s.data[5], e.y = s.data[6];
        break;
      case "addPath":
        s.data[0].getLastPoint(e);
        break;
    }
    return e;
  }
}
function Mi(i, e) {
  return i ? i.prepend(e) : e.clone();
}
function ue(i, e, t) {
  const s = i.getAttribute(e);
  return s ? Number(s) : t;
}
function Qw(i, e) {
  const t = i.querySelectorAll("defs");
  for (let s = 0; s < t.length; s++) {
    const r = t[s];
    for (let n = 0; n < r.children.length; n++) {
      const o = r.children[n];
      switch (o.nodeName.toLowerCase()) {
        case "lineargradient":
          e.defs[o.id] = eT(o);
          break;
        case "radialgradient":
          e.defs[o.id] = tT();
          break;
      }
    }
  }
}
function eT(i) {
  const e = ue(i, "x1", 0), t = ue(i, "y1", 0), s = ue(i, "x2", 1), r = ue(i, "y2", 0), n = i.getAttribute("gradientUnits") || "objectBoundingBox", o = new qe(
    e,
    t,
    s,
    r,
    n === "objectBoundingBox" ? "local" : "global"
  );
  for (let a = 0; a < i.children.length; a++) {
    const l = i.children[a], c = ue(l, "offset", 0), h = pe.shared.setValue(l.getAttribute("stop-color")).toNumber();
    o.addColorStop(c, h);
  }
  return o;
}
function tT(i) {
  return se("[SVG Parser] Radial gradients are not yet supported"), new qe(0, 0, 1, 0);
}
function kd(i) {
  const e = i.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
  return e ? e[1] : "";
}
const Fd = {
  // Fill properties
  fill: { type: "paint", default: 0 },
  // Fill color/gradient
  "fill-opacity": { type: "number", default: 1 },
  // Fill transparency
  // Stroke properties
  stroke: { type: "paint", default: 0 },
  // Stroke color/gradient
  "stroke-width": { type: "number", default: 1 },
  // Width of stroke
  "stroke-opacity": { type: "number", default: 1 },
  // Stroke transparency
  "stroke-linecap": { type: "string", default: "butt" },
  // End cap style: butt, round, square
  "stroke-linejoin": { type: "string", default: "miter" },
  // Join style: miter, round, bevel
  "stroke-miterlimit": { type: "number", default: 10 },
  // Limit on miter join sharpness
  "stroke-dasharray": { type: "string", default: "none" },
  // Dash pattern
  "stroke-dashoffset": { type: "number", default: 0 },
  // Offset for dash pattern
  // Global properties
  opacity: { type: "number", default: 1 }
  // Overall opacity
};
function km(i, e) {
  const t = i.getAttribute("style"), s = {}, r = {}, n = {
    strokeStyle: s,
    fillStyle: r,
    useFill: !1,
    useStroke: !1
  };
  for (const o in Fd) {
    const a = i.getAttribute(o);
    a && Md(e, n, o, a.trim());
  }
  if (t) {
    const o = t.split(";");
    for (let a = 0; a < o.length; a++) {
      const l = o[a].trim(), [c, h] = l.split(":");
      Fd[c] && Md(e, n, c, h.trim());
    }
  }
  return {
    strokeStyle: n.useStroke ? s : null,
    fillStyle: n.useFill ? r : null,
    useFill: n.useFill,
    useStroke: n.useStroke
  };
}
function Md(i, e, t, s) {
  switch (t) {
    case "stroke":
      if (s !== "none") {
        if (s.startsWith("url(")) {
          const r = kd(s);
          e.strokeStyle.fill = i.defs[r];
        } else
          e.strokeStyle.color = pe.shared.setValue(s).toNumber();
        e.useStroke = !0;
      }
      break;
    case "stroke-width":
      e.strokeStyle.width = Number(s);
      break;
    case "fill":
      if (s !== "none") {
        if (s.startsWith("url(")) {
          const r = kd(s);
          e.fillStyle.fill = i.defs[r];
        } else
          e.fillStyle.color = pe.shared.setValue(s).toNumber();
        e.useFill = !0;
      }
      break;
    case "fill-opacity":
      e.fillStyle.alpha = Number(s);
      break;
    case "stroke-opacity":
      e.strokeStyle.alpha = Number(s);
      break;
    case "opacity":
      e.fillStyle.alpha = Number(s), e.strokeStyle.alpha = Number(s);
      break;
  }
}
function iT(i) {
  if (i.length <= 2)
    return !0;
  const e = i.map((a) => a.area).sort((a, l) => l - a), [t, s] = e, r = e[e.length - 1], n = t / s, o = s / r;
  return !(n > 3 && o < 2);
}
function sT(i) {
  return i.split(/(?=[Mm])/).filter((s) => s.trim().length > 0);
}
function rT(i) {
  const e = i.match(/[-+]?[0-9]*\.?[0-9]+/g);
  if (!e || e.length < 4)
    return 0;
  const t = e.map(Number), s = [], r = [];
  for (let h = 0; h < t.length; h += 2)
    h + 1 < t.length && (s.push(t[h]), r.push(t[h + 1]));
  if (s.length === 0 || r.length === 0)
    return 0;
  const n = Math.min(...s), o = Math.max(...s), a = Math.min(...r), l = Math.max(...r);
  return (o - n) * (l - a);
}
function Ed(i, e) {
  const t = new _t(i, !1);
  for (const s of t.instructions)
    e.instructions.push(s);
}
function nT(i, e) {
  if (typeof i == "string") {
    const o = document.createElement("div");
    o.innerHTML = i.trim(), i = o.querySelector("svg");
  }
  const t = {
    context: e,
    defs: {},
    path: new _t()
  };
  Qw(i, t);
  const s = i.children, { fillStyle: r, strokeStyle: n } = km(i, t);
  for (let o = 0; o < s.length; o++) {
    const a = s[o];
    a.nodeName.toLowerCase() !== "defs" && Fm(a, t, r, n);
  }
  return e;
}
function Fm(i, e, t, s) {
  const r = i.children, { fillStyle: n, strokeStyle: o } = km(i, e);
  n && t ? t = { ...t, ...n } : n && (t = n), o && s ? s = { ...s, ...o } : o && (s = o);
  const a = !t && !s;
  a && (t = { color: 0 });
  let l, c, h, u, d, f, m, g, p, x, y, v, _, b, T, w, A;
  switch (i.nodeName.toLowerCase()) {
    case "path": {
      b = i.getAttribute("d");
      const k = i.getAttribute("fill-rule"), S = sT(b), C = k === "evenodd", U = S.length > 1;
      if (C && U) {
        const H = S.map((M) => ({
          path: M,
          area: rT(M)
        }));
        if (H.sort((M, E) => E.area - M.area), S.length > 3 || !iT(H))
          for (let M = 0; M < H.length; M++) {
            const E = H[M], j = M === 0;
            e.context.beginPath();
            const B = new _t(void 0, !0);
            Ed(E.path, B), e.context.path(B), j ? (t && e.context.fill(t), s && e.context.stroke(s)) : e.context.cut();
          }
        else
          for (let M = 0; M < H.length; M++) {
            const E = H[M], j = M % 2 === 1;
            e.context.beginPath();
            const B = new _t(void 0, !0);
            Ed(E.path, B), e.context.path(B), j ? e.context.cut() : (t && e.context.fill(t), s && e.context.stroke(s));
          }
      } else {
        const H = k ? k === "evenodd" : !0;
        T = new _t(b, H), e.context.path(T), t && e.context.fill(t), s && e.context.stroke(s);
      }
      break;
    }
    case "circle":
      m = ue(i, "cx", 0), g = ue(i, "cy", 0), p = ue(i, "r", 0), e.context.ellipse(m, g, p, p), t && e.context.fill(t), s && e.context.stroke(s);
      break;
    case "rect":
      l = ue(i, "x", 0), c = ue(i, "y", 0), w = ue(i, "width", 0), A = ue(i, "height", 0), x = ue(i, "rx", 0), y = ue(i, "ry", 0), x || y ? e.context.roundRect(l, c, w, A, x || y) : e.context.rect(l, c, w, A), t && e.context.fill(t), s && e.context.stroke(s);
      break;
    case "ellipse":
      m = ue(i, "cx", 0), g = ue(i, "cy", 0), x = ue(i, "rx", 0), y = ue(i, "ry", 0), e.context.beginPath(), e.context.ellipse(m, g, x, y), t && e.context.fill(t), s && e.context.stroke(s);
      break;
    case "line":
      h = ue(i, "x1", 0), u = ue(i, "y1", 0), d = ue(i, "x2", 0), f = ue(i, "y2", 0), e.context.beginPath(), e.context.moveTo(h, u), e.context.lineTo(d, f), s && e.context.stroke(s);
      break;
    case "polygon":
      _ = i.getAttribute("points"), v = _.match(/\d+/g).map((k) => parseInt(k, 10)), e.context.poly(v, !0), t && e.context.fill(t), s && e.context.stroke(s);
      break;
    case "polyline":
      _ = i.getAttribute("points"), v = _.match(/\d+/g).map((k) => parseInt(k, 10)), e.context.poly(v, !1), s && e.context.stroke(s);
      break;
    case "g":
    case "svg":
      break;
    default: {
      se(`[SVG parser] <${i.nodeName}> elements unsupported`);
      break;
    }
  }
  a && (t = null);
  for (let k = 0; k < r.length; k++)
    Fm(r[k], e, t, s);
}
function oT(i) {
  return pe.isColorLike(i);
}
function Pd(i) {
  return i instanceof gr;
}
function Ud(i) {
  return i instanceof qe;
}
function aT(i) {
  return i instanceof L;
}
function lT(i, e, t) {
  const s = pe.shared.setValue(e ?? 0);
  return i.color = s.toNumber(), i.alpha = s.alpha === 1 ? t.alpha : s.alpha, i.texture = L.WHITE, { ...t, ...i };
}
function cT(i, e, t) {
  return i.texture = e, { ...t, ...i };
}
function Rd(i, e, t) {
  return i.fill = e, i.color = 16777215, i.texture = e.texture, i.matrix = e.transform, { ...t, ...i };
}
function Bd(i, e, t) {
  return e.buildGradient(), i.fill = e, i.color = 16777215, i.texture = e.texture, i.matrix = e.transform, i.textureSpace = e.textureSpace, { ...t, ...i };
}
function hT(i, e) {
  const t = { ...e, ...i }, s = pe.shared.setValue(t.color);
  return t.alpha *= s.alpha, t.color = s.toNumber(), t;
}
function Gt(i, e) {
  if (i == null)
    return null;
  const t = {}, s = i;
  return oT(i) ? lT(t, i, e) : aT(i) ? cT(t, i, e) : Pd(i) ? Rd(t, i, e) : Ud(i) ? Bd(t, i, e) : s.fill && Pd(s.fill) ? Rd(s, s.fill, e) : s.fill && Ud(s.fill) ? Bd(s, s.fill, e) : hT(s, e);
}
function or(i, e) {
  const { width: t, alignment: s, miterLimit: r, cap: n, join: o, pixelLine: a, ...l } = e, c = Gt(i, l);
  return c ? {
    width: t,
    alignment: s,
    miterLimit: r,
    cap: n,
    join: o,
    pixelLine: a,
    ...c
  } : null;
}
const uT = new q(), zd = new W(), pu = class ut extends rt {
  constructor() {
    super(...arguments), this.uid = de("graphicsContext"), this.dirty = !0, this.batchMode = "auto", this.instructions = [], this._activePath = new _t(), this._transform = new W(), this._fillStyle = { ...ut.defaultFillStyle }, this._strokeStyle = { ...ut.defaultStrokeStyle }, this._stateStack = [], this._tick = 0, this._bounds = new it(), this._boundsDirty = !0;
  }
  /**
   * Creates a new GraphicsContext object that is a clone of this instance, copying all properties,
   * including the current drawing state, transformations, styles, and instructions.
   * @returns A new GraphicsContext instance with the same properties and state as this one.
   */
  clone() {
    const e = new ut();
    return e.batchMode = this.batchMode, e.instructions = this.instructions.slice(), e._activePath = this._activePath.clone(), e._transform = this._transform.clone(), e._fillStyle = { ...this._fillStyle }, e._strokeStyle = { ...this._strokeStyle }, e._stateStack = this._stateStack.slice(), e._bounds = this._bounds.clone(), e._boundsDirty = !0, e;
  }
  /**
   * The current fill style of the graphics context. This can be a color, gradient, pattern, or a more complex style defined by a FillStyle object.
   */
  get fillStyle() {
    return this._fillStyle;
  }
  set fillStyle(e) {
    this._fillStyle = Gt(e, ut.defaultFillStyle);
  }
  /**
   * The current stroke style of the graphics context. Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   */
  get strokeStyle() {
    return this._strokeStyle;
  }
  set strokeStyle(e) {
    this._strokeStyle = or(e, ut.defaultStrokeStyle);
  }
  /**
   * Sets the current fill style of the graphics context. The fill style can be a color, gradient,
   * pattern, or a more complex style defined by a FillStyle object.
   * @param style - The fill style to apply. This can be a simple color, a gradient or pattern object,
   *                or a FillStyle or ConvertedFillStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setFillStyle(e) {
    return this._fillStyle = Gt(e, ut.defaultFillStyle), this;
  }
  /**
   * Sets the current stroke style of the graphics context. Similar to fill styles, stroke styles can
   * encompass colors, gradients, patterns, or more detailed configurations via a StrokeStyle object.
   * @param style - The stroke style to apply. Can be defined as a color, a gradient or pattern,
   *                or a StrokeStyle or ConvertedStrokeStyle object.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  setStrokeStyle(e) {
    return this._strokeStyle = Gt(e, ut.defaultStrokeStyle), this;
  }
  texture(e, t, s, r, n, o) {
    return this.instructions.push({
      action: "texture",
      data: {
        image: e,
        dx: s || 0,
        dy: r || 0,
        dw: n || e.frame.width,
        dh: o || e.frame.height,
        transform: this._transform.clone(),
        alpha: this._fillStyle.alpha,
        style: t ? pe.shared.setValue(t).toNumber() : 16777215
      }
    }), this.onUpdate(), this;
  }
  /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  beginPath() {
    return this._activePath = new _t(), this;
  }
  fill(e, t) {
    let s;
    const r = this.instructions[this.instructions.length - 1];
    return this._tick === 0 && r?.action === "stroke" ? s = r.data.path : s = this._activePath.clone(), s ? (e != null && (t !== void 0 && typeof e == "number" && (N(J, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), e = { color: e, alpha: t }), this._fillStyle = Gt(e, ut.defaultFillStyle)), this.instructions.push({
      action: "fill",
      // TODO copy fill style!
      data: { style: this.fillStyle, path: s }
    }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
  }
  _initNextPathLocation() {
    const { x: e, y: t } = this._activePath.getLastPoint(q.shared);
    this._activePath.clear(), this._activePath.moveTo(e, t);
  }
  /**
   * Strokes the current path with the current stroke style. This method can take an optional
   * FillInput parameter to define the stroke's appearance, including its color, width, and other properties.
   * @param style - (Optional) The stroke style to apply. Can be defined as a simple color or a more complex style object. If omitted, uses the current stroke style.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  stroke(e) {
    let t;
    const s = this.instructions[this.instructions.length - 1];
    return this._tick === 0 && s?.action === "fill" ? t = s.data.path : t = this._activePath.clone(), t ? (e != null && (this._strokeStyle = or(e, ut.defaultStrokeStyle)), this.instructions.push({
      action: "stroke",
      // TODO copy fill style!
      data: { style: this.strokeStyle, path: t }
    }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this;
  }
  /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path. If a hole is not completely in a shape, it will
   * fail to cut correctly!
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  cut() {
    for (let e = 0; e < 2; e++) {
      const t = this.instructions[this.instructions.length - 1 - e], s = this._activePath.clone();
      if (t && (t.action === "stroke" || t.action === "fill"))
        if (t.data.hole)
          t.data.hole.addPath(s);
        else {
          t.data.hole = s;
          break;
        }
    }
    return this._initNextPathLocation(), this;
  }
  /**
   * Adds an arc to the current path, which is centered at (x, y) with the specified radius,
   * starting and ending angles, and direction.
   * @param x - The x-coordinate of the arc's center.
   * @param y - The y-coordinate of the arc's center.
   * @param radius - The arc's radius.
   * @param startAngle - The starting angle, in radians.
   * @param endAngle - The ending angle, in radians.
   * @param counterclockwise - (Optional) Specifies whether the arc is drawn counterclockwise (true) or clockwise (false). Defaults to false.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  arc(e, t, s, r, n, o) {
    this._tick++;
    const a = this._transform;
    return this._activePath.arc(
      a.a * e + a.c * t + a.tx,
      a.b * e + a.d * t + a.ty,
      s,
      r,
      n,
      o
    ), this;
  }
  /**
   * Adds an arc to the current path with the given control points and radius, connected to the previous point
   * by a straight line if necessary.
   * @param x1 - The x-coordinate of the first control point.
   * @param y1 - The y-coordinate of the first control point.
   * @param x2 - The x-coordinate of the second control point.
   * @param y2 - The y-coordinate of the second control point.
   * @param radius - The arc's radius.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  arcTo(e, t, s, r, n) {
    this._tick++;
    const o = this._transform;
    return this._activePath.arcTo(
      o.a * e + o.c * t + o.tx,
      o.b * e + o.d * t + o.ty,
      o.a * s + o.c * r + o.tx,
      o.b * s + o.d * r + o.ty,
      n
    ), this;
  }
  /**
   * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.
   * @param rx - The x-radius of the ellipse.
   * @param ry - The y-radius of the ellipse.
   * @param xAxisRotation - The rotation of the ellipse's x-axis relative
   * to the x-axis of the coordinate system, in degrees.
   * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.
   * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.
   * @param x - The x-coordinate of the arc's end point.
   * @param y - The y-coordinate of the arc's end point.
   * @returns The instance of the current object for chaining.
   */
  arcToSvg(e, t, s, r, n, o, a) {
    this._tick++;
    const l = this._transform;
    return this._activePath.arcToSvg(
      e,
      t,
      s,
      // should we rotate this with transform??
      r,
      n,
      l.a * o + l.c * a + l.tx,
      l.b * o + l.d * a + l.ty
    ), this;
  }
  /**
   * Adds a cubic Bezier curve to the path.
   * It requires three points: the first two are control points and the third one is the end point.
   * The starting point is the last point in the current path.
   * @param cp1x - The x-coordinate of the first control point.
   * @param cp1y - The y-coordinate of the first control point.
   * @param cp2x - The x-coordinate of the second control point.
   * @param cp2y - The y-coordinate of the second control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  bezierCurveTo(e, t, s, r, n, o, a) {
    this._tick++;
    const l = this._transform;
    return this._activePath.bezierCurveTo(
      l.a * e + l.c * t + l.tx,
      l.b * e + l.d * t + l.ty,
      l.a * s + l.c * r + l.tx,
      l.b * s + l.d * r + l.ty,
      l.a * n + l.c * o + l.tx,
      l.b * n + l.d * o + l.ty,
      a
    ), this;
  }
  /**
   * Closes the current path by drawing a straight line back to the start.
   * If the shape is already closed or there are no points in the path, this method does nothing.
   * @returns The instance of the current object for chaining.
   */
  closePath() {
    return this._tick++, this._activePath?.closePath(), this;
  }
  /**
   * Draws an ellipse at the specified location and with the given x and y radii.
   * An optional transformation can be applied, allowing for rotation, scaling, and translation.
   * @param x - The x-coordinate of the center of the ellipse.
   * @param y - The y-coordinate of the center of the ellipse.
   * @param radiusX - The horizontal radius of the ellipse.
   * @param radiusY - The vertical radius of the ellipse.
   * @returns The instance of the current object for chaining.
   */
  ellipse(e, t, s, r) {
    return this._tick++, this._activePath.ellipse(e, t, s, r, this._transform.clone()), this;
  }
  /**
   * Draws a circle shape. This method adds a new circle path to the current drawing.
   * @param x - The x-coordinate of the center of the circle.
   * @param y - The y-coordinate of the center of the circle.
   * @param radius - The radius of the circle.
   * @returns The instance of the current object for chaining.
   */
  circle(e, t, s) {
    return this._tick++, this._activePath.circle(e, t, s, this._transform.clone()), this;
  }
  /**
   * Adds another `GraphicsPath` to this path, optionally applying a transformation.
   * @param path - The `GraphicsPath` to add.
   * @returns The instance of the current object for chaining.
   */
  path(e) {
    return this._tick++, this._activePath.addPath(e, this._transform.clone()), this;
  }
  /**
   * Connects the current point to a new point with a straight line. This method updates the current path.
   * @param x - The x-coordinate of the new point to connect to.
   * @param y - The y-coordinate of the new point to connect to.
   * @returns The instance of the current object for chaining.
   */
  lineTo(e, t) {
    this._tick++;
    const s = this._transform;
    return this._activePath.lineTo(
      s.a * e + s.c * t + s.tx,
      s.b * e + s.d * t + s.ty
    ), this;
  }
  /**
   * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.
   * @param x - The x-coordinate for the starting point.
   * @param y - The y-coordinate for the starting point.
   * @returns The instance of the current object for chaining.
   */
  moveTo(e, t) {
    this._tick++;
    const s = this._transform, r = this._activePath.instructions, n = s.a * e + s.c * t + s.tx, o = s.b * e + s.d * t + s.ty;
    return r.length === 1 && r[0].action === "moveTo" ? (r[0].data[0] = n, r[0].data[1] = o, this) : (this._activePath.moveTo(
      n,
      o
    ), this);
  }
  /**
   * Adds a quadratic curve to the path. It requires two points: the control point and the end point.
   * The starting point is the last point in the current path.
   * @param cpx - The x-coordinate of the control point.
   * @param cpy - The y-coordinate of the control point.
   * @param x - The x-coordinate of the end point.
   * @param y - The y-coordinate of the end point.
   * @param smoothness - Optional parameter to adjust the smoothness of the curve.
   * @returns The instance of the current object for chaining.
   */
  quadraticCurveTo(e, t, s, r, n) {
    this._tick++;
    const o = this._transform;
    return this._activePath.quadraticCurveTo(
      o.a * e + o.c * t + o.tx,
      o.b * e + o.d * t + o.ty,
      o.a * s + o.c * r + o.tx,
      o.b * s + o.d * r + o.ty,
      n
    ), this;
  }
  /**
   * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @returns The instance of the current object for chaining.
   */
  rect(e, t, s, r) {
    return this._tick++, this._activePath.rect(e, t, s, r, this._transform.clone()), this;
  }
  /**
   * Draws a rectangle with rounded corners.
   * The corner radius can be specified to determine how rounded the corners should be.
   * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.
   * @param x - The x-coordinate of the top-left corner of the rectangle.
   * @param y - The y-coordinate of the top-left corner of the rectangle.
   * @param w - The width of the rectangle.
   * @param h - The height of the rectangle.
   * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.
   * @returns The instance of the current object for chaining.
   */
  roundRect(e, t, s, r, n) {
    return this._tick++, this._activePath.roundRect(e, t, s, r, n, this._transform.clone()), this;
  }
  /**
   * Draws a polygon shape by specifying a sequence of points. This method allows for the creation of complex polygons,
   * which can be both open and closed. An optional transformation can be applied, enabling the polygon to be scaled,
   * rotated, or translated as needed.
   * @param points - An array of numbers, or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]
   * representing the x and y coordinates, of the polygon's vertices, in sequence.
   * @param close - A boolean indicating whether to close the polygon path. True by default.
   */
  poly(e, t) {
    return this._tick++, this._activePath.poly(e, t, this._transform.clone()), this;
  }
  /**
   * Draws a regular polygon with a specified number of sides. All sides and angles are equal.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @param transform - An optional `Matrix` object to apply a transformation to the polygon.
   * @returns The instance of the current object for chaining.
   */
  regularPoly(e, t, s, r, n = 0, o) {
    return this._tick++, this._activePath.regularPoly(e, t, s, r, n, o), this;
  }
  /**
   * Draws a polygon with rounded corners.
   * Similar to `regularPoly` but with the ability to round the corners of the polygon.
   * @param x - The x-coordinate of the center of the polygon.
   * @param y - The y-coordinate of the center of the polygon.
   * @param radius - The radius of the circumscribed circle of the polygon.
   * @param sides - The number of sides of the polygon. Must be 3 or more.
   * @param corner - The radius of the rounding of the corners.
   * @param rotation - The rotation angle of the polygon, in radians. Zero by default.
   * @returns The instance of the current object for chaining.
   */
  roundPoly(e, t, s, r, n, o) {
    return this._tick++, this._activePath.roundPoly(e, t, s, r, n, o), this;
  }
  /**
   * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.
   * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.
   * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.
   * A minimum of 3 points is required.
   * @param radius - The default radius for the corners.
   * This radius is applied to all corners unless overridden in `points`.
   * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve
   *  method instead of an arc method. Defaults to false.
   * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.
   * Higher values make the curve smoother.
   * @returns The instance of the current object for chaining.
   */
  roundShape(e, t, s, r) {
    return this._tick++, this._activePath.roundShape(e, t, s, r), this;
  }
  /**
   * Draw Rectangle with fillet corners. This is much like rounded rectangle
   * however it support negative numbers as well for the corner radius.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param fillet - accept negative or positive values
   */
  filletRect(e, t, s, r, n) {
    return this._tick++, this._activePath.filletRect(e, t, s, r, n), this;
  }
  /**
   * Draw Rectangle with chamfer corners. These are angled corners.
   * @param x - Upper left corner of rect
   * @param y - Upper right corner of rect
   * @param width - Width of rect
   * @param height - Height of rect
   * @param chamfer - non-zero real number, size of corner cutout
   * @param transform
   */
  chamferRect(e, t, s, r, n, o) {
    return this._tick++, this._activePath.chamferRect(e, t, s, r, n, o), this;
  }
  /**
   * Draws a star shape centered at a specified location. This method allows for the creation
   *  of stars with a variable number of points, outer radius, optional inner radius, and rotation.
   * The star is drawn as a closed polygon with alternating outer and inner vertices to create the star's points.
   * An optional transformation can be applied to scale, rotate, or translate the star as needed.
   * @param x - The x-coordinate of the center of the star.
   * @param y - The y-coordinate of the center of the star.
   * @param points - The number of points of the star.
   * @param radius - The outer radius of the star (distance from the center to the outer points).
   * @param innerRadius - Optional. The inner radius of the star
   * (distance from the center to the inner points between the outer points).
   * If not provided, defaults to half of the `radius`.
   * @param rotation - Optional. The rotation of the star in radians, where 0 is aligned with the y-axis.
   * Defaults to 0, meaning one point is directly upward.
   * @returns The instance of the current object for chaining further drawing commands.
   */
  star(e, t, s, r, n = 0, o = 0) {
    return this._tick++, this._activePath.star(e, t, s, r, n, o, this._transform.clone()), this;
  }
  /**
   * Parses and renders an SVG string into the graphics context. This allows for complex shapes and paths
   * defined in SVG format to be drawn within the graphics context.
   * @param svg - The SVG string to be parsed and rendered.
   */
  svg(e) {
    return this._tick++, nT(e, this), this;
  }
  /**
   * Restores the most recently saved graphics state by popping the top of the graphics state stack.
   * This includes transformations, fill styles, and stroke styles.
   */
  restore() {
    const e = this._stateStack.pop();
    return e && (this._transform = e.transform, this._fillStyle = e.fillStyle, this._strokeStyle = e.strokeStyle), this;
  }
  /** Saves the current graphics state, including transformations, fill styles, and stroke styles, onto a stack. */
  save() {
    return this._stateStack.push({
      transform: this._transform.clone(),
      fillStyle: { ...this._fillStyle },
      strokeStyle: { ...this._strokeStyle }
    }), this;
  }
  /**
   * Returns the current transformation matrix of the graphics context.
   * @returns The current transformation matrix.
   */
  getTransform() {
    return this._transform;
  }
  /**
   * Resets the current transformation matrix to the identity matrix, effectively removing any transformations (rotation, scaling, translation) previously applied.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  resetTransform() {
    return this._transform.identity(), this;
  }
  /**
   * Applies a rotation transformation to the graphics context around the current origin.
   * @param angle - The angle of rotation in radians.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  rotate(e) {
    return this._transform.rotate(e), this;
  }
  /**
   * Applies a scaling transformation to the graphics context, scaling drawings by x horizontally and by y vertically.
   * @param x - The scale factor in the horizontal direction.
   * @param y - (Optional) The scale factor in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  scale(e, t = e) {
    return this._transform.scale(e, t), this;
  }
  setTransform(e, t, s, r, n, o) {
    return e instanceof W ? (this._transform.set(e.a, e.b, e.c, e.d, e.tx, e.ty), this) : (this._transform.set(e, t, s, r, n, o), this);
  }
  transform(e, t, s, r, n, o) {
    return e instanceof W ? (this._transform.append(e), this) : (zd.set(e, t, s, r, n, o), this._transform.append(zd), this);
  }
  /**
   * Applies a translation transformation to the graphics context, moving the origin by the specified amounts.
   * @param x - The amount to translate in the horizontal direction.
   * @param y - (Optional) The amount to translate in the vertical direction. If not specified, the x value is used for both directions.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  translate(e, t = e) {
    return this._transform.translate(e, t), this;
  }
  /**
   * Clears all drawing commands from the graphics context, effectively resetting it. This includes clearing the path,
   * and optionally resetting transformations to the identity matrix.
   * @returns The instance of the current GraphicsContext for method chaining.
   */
  clear() {
    return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this;
  }
  onUpdate() {
    this._boundsDirty = !0, !this.dirty && (this.emit("update", this, 16), this.dirty = !0);
  }
  /** The bounds of the graphic shape. */
  get bounds() {
    if (!this._boundsDirty)
      return this._bounds;
    this._boundsDirty = !1;
    const e = this._bounds;
    e.clear();
    for (let t = 0; t < this.instructions.length; t++) {
      const s = this.instructions[t], r = s.action;
      if (r === "fill") {
        const n = s.data;
        e.addBounds(n.path.bounds);
      } else if (r === "texture") {
        const n = s.data;
        e.addFrame(n.dx, n.dy, n.dx + n.dw, n.dy + n.dh, n.transform);
      }
      if (r === "stroke") {
        const n = s.data, o = n.style.alignment, a = n.style.width * (1 - o), l = n.path.bounds;
        e.addFrame(
          l.minX - a,
          l.minY - a,
          l.maxX + a,
          l.maxY + a
        );
      }
    }
    return e;
  }
  /**
   * Check to see if a point is contained within this geometry.
   * @param point - Point to check if it's contained.
   * @returns {boolean} `true` if the point is contained within geometry.
   */
  containsPoint(e) {
    if (!this.bounds.containsPoint(e.x, e.y))
      return !1;
    const t = this.instructions;
    let s = !1;
    for (let r = 0; r < t.length; r++) {
      const n = t[r], o = n.data, a = o.path;
      if (!n.action || !a)
        continue;
      const l = o.style, c = a.shapePath.shapePrimitives;
      for (let h = 0; h < c.length; h++) {
        const u = c[h].shape;
        if (!l || !u)
          continue;
        const d = c[h].transform, f = d ? d.applyInverse(e, uT) : e;
        if (n.action === "fill")
          s = u.contains(f.x, f.y);
        else {
          const g = l;
          s = u.strokeContains(f.x, f.y, g.width, g.alignment);
        }
        const m = o.hole;
        if (m) {
          const g = m.shapePath?.shapePrimitives;
          if (g)
            for (let p = 0; p < g.length; p++)
              g[p].shape.contains(f.x, f.y) && (s = !1);
        }
        if (s)
          return !0;
      }
    }
    return s;
  }
  /**
   * Destroys the GraphicsData object.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * context.destroy();
   * context.destroy(true);
   * context.destroy({ texture: true, textureSource: true });
   */
  destroy(e = !1) {
    if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof e == "boolean" ? e : e?.texture) {
      const s = typeof e == "boolean" ? e : e?.textureSource;
      this._fillStyle.texture && (this._fillStyle.fill && "uid" in this._fillStyle.fill ? this._fillStyle.fill.destroy() : this._fillStyle.texture.destroy(s)), this._strokeStyle.texture && (this._strokeStyle.fill && "uid" in this._strokeStyle.fill ? this._strokeStyle.fill.destroy() : this._strokeStyle.texture.destroy(s));
    }
    this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null;
  }
};
pu.defaultFillStyle = {
  /** The color to use for the fill. */
  color: 16777215,
  /** The alpha value to use for the fill. */
  alpha: 1,
  /** The texture to use for the fill. */
  texture: L.WHITE,
  /** The matrix to apply. */
  matrix: null,
  /** The fill pattern to use. */
  fill: null,
  /** Whether coordinates are 'global' or 'local' */
  textureSpace: "local"
};
pu.defaultStrokeStyle = {
  /** The width of the stroke. */
  width: 1,
  /** The color to use for the stroke. */
  color: 16777215,
  /** The alpha value to use for the stroke. */
  alpha: 1,
  /** The alignment of the stroke. */
  alignment: 0.5,
  /** The miter limit to use. */
  miterLimit: 10,
  /** The line cap style to use. */
  cap: "butt",
  /** The line join style to use. */
  join: "miter",
  /** The texture to use for the fill. */
  texture: L.WHITE,
  /** The matrix to apply. */
  matrix: null,
  /** The fill pattern to use. */
  fill: null,
  /** Whether coordinates are 'global' or 'local' */
  textureSpace: "local",
  /** If the stroke is a pixel line. */
  pixelLine: !1
};
let $e = pu;
const mu = class Qt extends rt {
  constructor(e = {}) {
    super(), this.uid = de("textStyle"), this._tick = 0, dT(e);
    const t = { ...Qt.defaultTextStyle, ...e };
    for (const s in t) {
      const r = s;
      this[r] = t[s];
    }
    this.update(), this._tick = 0;
  }
  /**
   * Alignment for multiline text, does not affect single line text.
   * @type {'left'|'center'|'right'|'justify'}
   */
  get align() {
    return this._align;
  }
  set align(e) {
    this._align !== e && (this._align = e, this.update());
  }
  /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
  get breakWords() {
    return this._breakWords;
  }
  set breakWords(e) {
    this._breakWords !== e && (this._breakWords = e, this.update());
  }
  /** Set a drop shadow for the text. */
  get dropShadow() {
    return this._dropShadow;
  }
  set dropShadow(e) {
    this._dropShadow !== e && (e !== null && typeof e == "object" ? this._dropShadow = this._createProxy({ ...Qt.defaultDropShadow, ...e }) : this._dropShadow = e ? this._createProxy({ ...Qt.defaultDropShadow }) : null, this.update());
  }
  /** The font family, can be a single font name, or a list of names where the first is the preferred font. */
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(e) {
    this._fontFamily !== e && (this._fontFamily = e, this.update());
  }
  /** The font size (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em') */
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(e) {
    this._fontSize !== e && (typeof e == "string" ? this._fontSize = parseInt(e, 10) : this._fontSize = e, this.update());
  }
  /**
   * The font style.
   * @type {'normal'|'italic'|'oblique'}
   */
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(e) {
    this._fontStyle !== e && (this._fontStyle = e.toLowerCase(), this.update());
  }
  /**
   * The font variant.
   * @type {'normal'|'small-caps'}
   */
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(e) {
    this._fontVariant !== e && (this._fontVariant = e, this.update());
  }
  /**
   * The font weight.
   * @type {'normal'|'bold'|'bolder'|'lighter'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900'}
   */
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(e) {
    this._fontWeight !== e && (this._fontWeight = e, this.update());
  }
  /** The space between lines. */
  get leading() {
    return this._leading;
  }
  set leading(e) {
    this._leading !== e && (this._leading = e, this.update());
  }
  /** The amount of spacing between letters, default is 0. */
  get letterSpacing() {
    return this._letterSpacing;
  }
  set letterSpacing(e) {
    this._letterSpacing !== e && (this._letterSpacing = e, this.update());
  }
  /** The line height, a number that represents the vertical space that a letter uses. */
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(e) {
    this._lineHeight !== e && (this._lineHeight = e, this.update());
  }
  /**
   * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
   * by adding padding to all sides of the text.
   * > [!NOTE] This will NOT affect the positioning or bounds of the text.
   */
  get padding() {
    return this._padding;
  }
  set padding(e) {
    this._padding !== e && (this._padding = e, this.update());
  }
  /**
   * An optional filter or array of filters to apply to the text, allowing for advanced visual effects.
   * These filters will be applied to the text as it is created, resulting in faster rendering for static text
   * compared to applying the filter directly to the text object (which would be applied at run time).
   * @default null
   */
  get filters() {
    return this._filters;
  }
  set filters(e) {
    this._filters !== e && (this._filters = Object.freeze(e), this.update());
  }
  /**
   * Trim transparent borders from the text texture.
   * > [!IMPORTANT] PERFORMANCE WARNING:
   * > This is a costly operation as it requires scanning pixel alpha values.
   * > Avoid using `trim: true` for dynamic text, as it could significantly impact performance.
   */
  get trim() {
    return this._trim;
  }
  set trim(e) {
    this._trim !== e && (this._trim = e, this.update());
  }
  /**
   * The baseline of the text that is rendered.
   * @type {'alphabetic'|'top'|'hanging'|'middle'|'ideographic'|'bottom'}
   */
  get textBaseline() {
    return this._textBaseline;
  }
  set textBaseline(e) {
    this._textBaseline !== e && (this._textBaseline = e, this.update());
  }
  /**
   * How newlines and spaces should be handled.
   * Default is 'pre' (preserve, preserve).
   *
   *  value       | New lines     |   Spaces
   *  ---         | ---           |   ---
   * 'normal'     | Collapse      |   Collapse
   * 'pre'        | Preserve      |   Preserve
   * 'pre-line'   | Preserve      |   Collapse
   * @type {'normal'|'pre'|'pre-line'}
   */
  get whiteSpace() {
    return this._whiteSpace;
  }
  set whiteSpace(e) {
    this._whiteSpace !== e && (this._whiteSpace = e, this.update());
  }
  /** Indicates if word wrap should be used. */
  get wordWrap() {
    return this._wordWrap;
  }
  set wordWrap(e) {
    this._wordWrap !== e && (this._wordWrap = e, this.update());
  }
  /** The width at which text will wrap, it needs wordWrap to be set to true. */
  get wordWrapWidth() {
    return this._wordWrapWidth;
  }
  set wordWrapWidth(e) {
    this._wordWrapWidth !== e && (this._wordWrapWidth = e, this.update());
  }
  /**
   * The fill style that will be used to color the text.
   * This can be:
   * - A color string like 'red', '#00FF00', or 'rgba(255,0,0,0.5)'
   * - A hex number like 0xff0000 for red
   * - A FillStyle object with properties like { color: 0xff0000, alpha: 0.5 }
   * - A FillGradient for gradient fills
   * - A FillPattern for pattern/texture fills
   *
   * When using a FillGradient, vertical gradients (angle of 90 degrees) are applied per line of text,
   * while gradients at any other angle are spread across the entire text body as a whole.
   * @example
   * // Vertical gradient applied per line
   * const verticalGradient = new FillGradient(0, 0, 0, 1)
   *     .addColorStop(0, 0xff0000)
   *     .addColorStop(1, 0x0000ff);
   *
   * const text = new Text({
   *     text: 'Line 1\nLine 2',
   *     style: { fill: verticalGradient }
   * });
   *
   * To manage the gradient in a global scope, set the textureSpace property of the FillGradient to 'global'.
   * @type {string|number|FillStyle|FillGradient|FillPattern}
   */
  get fill() {
    return this._originalFill;
  }
  set fill(e) {
    e !== this._originalFill && (this._originalFill = e, this._isFillStyle(e) && (this._originalFill = this._createProxy({ ...$e.defaultFillStyle, ...e }, () => {
      this._fill = Gt(
        { ...this._originalFill },
        $e.defaultFillStyle
      );
    })), this._fill = Gt(
      e === 0 ? "black" : e,
      $e.defaultFillStyle
    ), this.update());
  }
  /** A fillstyle that will be used on the text stroke, e.g., 'blue', '#FCFF00'. */
  get stroke() {
    return this._originalStroke;
  }
  set stroke(e) {
    e !== this._originalStroke && (this._originalStroke = e, this._isFillStyle(e) && (this._originalStroke = this._createProxy({ ...$e.defaultStrokeStyle, ...e }, () => {
      this._stroke = or(
        { ...this._originalStroke },
        $e.defaultStrokeStyle
      );
    })), this._stroke = or(e, $e.defaultStrokeStyle), this.update());
  }
  update() {
    this._tick++, this.emit("update", this);
  }
  /** Resets all properties to the default values */
  reset() {
    const e = Qt.defaultTextStyle;
    for (const t in e)
      this[t] = e[t];
  }
  /**
   * Returns a unique key for this instance.
   * This key is used for caching.
   * @returns {string} Unique key for the instance
   */
  get styleKey() {
    return `${this.uid}-${this._tick}`;
  }
  /**
   * Creates a new TextStyle object with the same values as this one.
   * @returns New cloned TextStyle object
   */
  clone() {
    return new Qt({
      align: this.align,
      breakWords: this.breakWords,
      dropShadow: this._dropShadow ? { ...this._dropShadow } : null,
      fill: this._fill,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontStyle: this.fontStyle,
      fontVariant: this.fontVariant,
      fontWeight: this.fontWeight,
      leading: this.leading,
      letterSpacing: this.letterSpacing,
      lineHeight: this.lineHeight,
      padding: this.padding,
      stroke: this._stroke,
      textBaseline: this.textBaseline,
      whiteSpace: this.whiteSpace,
      wordWrap: this.wordWrap,
      wordWrapWidth: this.wordWrapWidth,
      filters: this._filters ? [...this._filters] : void 0
    });
  }
  /**
   * Returns the final padding for the text style, taking into account any filters applied.
   * Used internally for correct measurements
   * @internal
   * @returns {number} The final padding for the text style.
   */
  _getFinalPadding() {
    let e = 0;
    if (this._filters)
      for (let t = 0; t < this._filters.length; t++)
        e += this._filters[t].padding;
    return Math.max(this._padding, e);
  }
  /**
   * Destroys this text style.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * // Destroy the text style and its textures
   * textStyle.destroy({ texture: true, textureSource: true });
   * textStyle.destroy(true);
   */
  destroy(e = !1) {
    if (this.removeAllListeners(), typeof e == "boolean" ? e : e?.texture) {
      const s = typeof e == "boolean" ? e : e?.textureSource;
      this._fill?.texture && this._fill.texture.destroy(s), this._originalFill?.texture && this._originalFill.texture.destroy(s), this._stroke?.texture && this._stroke.texture.destroy(s), this._originalStroke?.texture && this._originalStroke.texture.destroy(s);
    }
    this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null;
  }
  _createProxy(e, t) {
    return new Proxy(e, {
      set: (s, r, n) => (s[r] === n || (s[r] = n, t?.(r, n), this.update()), !0)
    });
  }
  _isFillStyle(e) {
    return (e ?? null) !== null && !(pe.isColorLike(e) || e instanceof qe || e instanceof gr);
  }
};
mu.defaultDropShadow = {
  alpha: 1,
  angle: Math.PI / 6,
  blur: 0,
  color: "black",
  distance: 5
};
mu.defaultTextStyle = {
  align: "left",
  breakWords: !1,
  dropShadow: null,
  fill: "black",
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  leading: 0,
  letterSpacing: 0,
  lineHeight: 0,
  padding: 0,
  stroke: null,
  textBaseline: "alphabetic",
  trim: !1,
  whiteSpace: "pre",
  wordWrap: !1,
  wordWrapWidth: 100
};
let Ze = mu;
function dT(i) {
  const e = i;
  if (typeof e.dropShadow == "boolean" && e.dropShadow) {
    const t = Ze.defaultDropShadow;
    i.dropShadow = {
      alpha: e.dropShadowAlpha ?? t.alpha,
      angle: e.dropShadowAngle ?? t.angle,
      blur: e.dropShadowBlur ?? t.blur,
      color: e.dropShadowColor ?? t.color,
      distance: e.dropShadowDistance ?? t.distance
    };
  }
  if (e.strokeThickness !== void 0) {
    N(J, "strokeThickness is now a part of stroke");
    const t = e.stroke;
    let s = {};
    if (pe.isColorLike(t))
      s.color = t;
    else if (t instanceof qe || t instanceof gr)
      s.fill = t;
    else if (Object.hasOwnProperty.call(t, "color") || Object.hasOwnProperty.call(t, "fill"))
      s = t;
    else
      throw new Error("Invalid stroke value.");
    i.stroke = {
      ...s,
      width: e.strokeThickness
    };
  }
  if (Array.isArray(e.fillGradientStops)) {
    if (N(J, "gradient fill is now a fill pattern: `new FillGradient(...)`"), !Array.isArray(e.fill) || e.fill.length === 0)
      throw new Error("Invalid fill value. Expected an array of colors for gradient fill.");
    e.fill.length !== e.fillGradientStops.length && se("The number of fill colors must match the number of fill gradient stops.");
    const t = new qe({
      start: { x: 0, y: 0 },
      end: { x: 0, y: 1 },
      textureSpace: "local"
    }), s = e.fillGradientStops.slice(), r = e.fill.map((n) => pe.shared.setValue(n).toNumber());
    s.forEach((n, o) => {
      t.addColorStop(n, r[o]);
    }), i.fill = {
      fill: t
    };
  }
}
class fT {
  constructor(e) {
    this._canvasPool = /* @__PURE__ */ Object.create(null), this.canvasOptions = e || {}, this.enableFullScreen = !1;
  }
  /**
   * Creates texture with params that were specified in pool constructor.
   * @param pixelWidth - Width of texture in pixels.
   * @param pixelHeight - Height of texture in pixels.
   */
  _createCanvasAndContext(e, t) {
    const s = re.get().createCanvas();
    s.width = e, s.height = t;
    const r = s.getContext("2d");
    return { canvas: s, context: r };
  }
  /**
   * Gets a Power-of-Two render texture or fullScreen texture
   * @param minWidth - The minimum width of the render texture.
   * @param minHeight - The minimum height of the render texture.
   * @param resolution - The resolution of the render texture.
   * @returns The new render texture.
   */
  getOptimalCanvasAndContext(e, t, s = 1) {
    e = Math.ceil(e * s - 1e-6), t = Math.ceil(t * s - 1e-6), e = ci(e), t = ci(t);
    const r = (e << 17) + (t << 1);
    this._canvasPool[r] || (this._canvasPool[r] = []);
    let n = this._canvasPool[r].pop();
    return n || (n = this._createCanvasAndContext(e, t)), n;
  }
  /**
   * Place a render texture back into the pool.
   * @param canvasAndContext
   */
  returnCanvasAndContext(e) {
    const t = e.canvas, { width: s, height: r } = t, n = (s << 17) + (r << 1);
    e.context.resetTransform(), e.context.clearRect(0, 0, s, r), this._canvasPool[n].push(e);
  }
  clear() {
    this._canvasPool = {};
  }
}
const rs = new fT();
os.register(rs);
const Od = 1e5;
function ar(i, e, t, s = 0) {
  if (i.texture === L.WHITE && !i.fill)
    return pe.shared.setValue(i.color).setAlpha(i.alpha ?? 1).toHexa();
  if (i.fill) {
    if (i.fill instanceof gr) {
      const r = i.fill, n = e.createPattern(r.texture.source.resource, "repeat"), o = r.transform.copyTo(W.shared);
      return o.scale(
        r.texture.frame.width,
        r.texture.frame.height
      ), n.setTransform(o), n;
    } else if (i.fill instanceof qe) {
      const r = i.fill, n = r.type === "linear", o = r.textureSpace === "local";
      let a = 1, l = 1;
      o && t && (a = t.width + s, l = t.height + s);
      let c, h = !1;
      if (n) {
        const { start: u, end: d } = r;
        c = e.createLinearGradient(
          u.x * a,
          u.y * l,
          d.x * a,
          d.y * l
        ), h = Math.abs(d.x - u.x) < Math.abs((d.y - u.y) * 0.1);
      } else {
        const { center: u, innerRadius: d, outerCenter: f, outerRadius: m } = r;
        c = e.createRadialGradient(
          u.x * a,
          u.y * l,
          d * a,
          f.x * a,
          f.y * l,
          m * a
        );
      }
      if (h && o && t) {
        const u = t.lineHeight / l;
        for (let d = 0; d < t.lines.length; d++) {
          const f = (d * t.lineHeight + s / 2) / l;
          r.colorStops.forEach((m) => {
            const g = f + m.offset * u;
            c.addColorStop(
              // fix to 5 decimal places to avoid floating point precision issues
              Math.floor(g * Od) / Od,
              pe.shared.setValue(m.color).toHex()
            );
          });
        }
      } else
        r.colorStops.forEach((u) => {
          c.addColorStop(u.offset, pe.shared.setValue(u.color).toHex());
        });
      return c;
    }
  } else {
    const r = e.createPattern(i.texture.source.resource, "repeat"), n = i.matrix.copyTo(W.shared);
    return n.scale(i.texture.frame.width, i.texture.frame.height), r.setTransform(n), r;
  }
  return se("FillStyle not recognised", i), "red";
}
const Mm = class Em extends um {
  /**
   * @param options - The options for the dynamic bitmap font.
   */
  constructor(e) {
    super(), this.resolution = 1, this.pages = [], this._padding = 0, this._measureCache = /* @__PURE__ */ Object.create(null), this._currentChars = [], this._currentX = 0, this._currentY = 0, this._currentMaxCharHeight = 0, this._currentPageIndex = -1, this._skipKerning = !1;
    const t = { ...Em.defaultOptions, ...e };
    this._textureSize = t.textureSize, this._mipmap = t.mipmap;
    const s = t.style.clone();
    t.overrideFill && (s._fill.color = 16777215, s._fill.alpha = 1, s._fill.texture = L.WHITE, s._fill.fill = null), this.applyFillAsTint = t.overrideFill;
    const r = s.fontSize;
    s.fontSize = this.baseMeasurementFontSize;
    const n = rr(s);
    t.overrideSize ? s._stroke && (s._stroke.width *= this.baseRenderedFontSize / r) : s.fontSize = this.baseRenderedFontSize = r, this._style = s, this._skipKerning = t.skipKerning ?? !1, this.resolution = t.resolution ?? 1, this._padding = t.padding ?? 4, t.textureStyle && (this._textureStyle = t.textureStyle instanceof hi ? t.textureStyle : new hi(t.textureStyle)), this.fontMetrics = Ge.measureFont(n), this.lineHeight = s.lineHeight || this.fontMetrics.fontSize || s.fontSize;
  }
  ensureCharacters(e) {
    const t = Ge.graphemeSegmenter(e).filter((p) => !this._currentChars.includes(p)).filter((p, x, y) => y.indexOf(p) === x);
    if (!t.length)
      return;
    this._currentChars = [...this._currentChars, ...t];
    let s;
    this._currentPageIndex === -1 ? s = this._nextPage() : s = this.pages[this._currentPageIndex];
    let { canvas: r, context: n } = s.canvasAndContext, o = s.texture.source;
    const a = this._style;
    let l = this._currentX, c = this._currentY, h = this._currentMaxCharHeight;
    const u = this.baseRenderedFontSize / this.baseMeasurementFontSize, d = this._padding * u;
    let f = !1;
    const m = r.width / this.resolution, g = r.height / this.resolution;
    for (let p = 0; p < t.length; p++) {
      const x = t[p], y = Ge.measureText(x, a, r, !1);
      y.lineHeight = y.height;
      const v = y.width * u, _ = Math.ceil((a.fontStyle === "italic" ? 2 : 1) * v), b = y.height * u, T = _ + d * 2, w = b + d * 2;
      if (f = !1, x !== `
` && x !== "\r" && x !== "	" && x !== " " && (f = !0, h = Math.ceil(Math.max(w, h))), l + T > m && (c += h, h = w, l = 0, c + h > g)) {
        o.update();
        const k = this._nextPage();
        r = k.canvasAndContext.canvas, n = k.canvasAndContext.context, o = k.texture.source, l = 0, c = 0, h = 0;
      }
      const A = v / u - (a.dropShadow?.distance ?? 0) - (a._stroke?.width ?? 0);
      if (this.chars[x] = {
        id: x.codePointAt(0),
        xOffset: -this._padding,
        yOffset: -this._padding,
        xAdvance: A,
        kerning: {}
      }, f) {
        this._drawGlyph(
          n,
          y,
          l + d,
          c + d,
          u,
          a
        );
        const k = o.width * u, S = o.height * u, C = new G(
          l / k * o.width,
          c / S * o.height,
          T / k * o.width,
          w / S * o.height
        );
        this.chars[x].texture = new L({
          source: o,
          frame: C
        }), l += Math.ceil(T);
      }
    }
    o.update(), this._currentX = l, this._currentY = c, this._currentMaxCharHeight = h, this._skipKerning && this._applyKerning(t, n);
  }
  /**
   * @deprecated since 8.0.0
   * The map of base page textures (i.e., sheets of glyphs).
   */
  get pageTextures() {
    return N(J, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages;
  }
  _applyKerning(e, t) {
    const s = this._measureCache;
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      for (let o = 0; o < this._currentChars.length; o++) {
        const a = this._currentChars[o];
        let l = s[n];
        l || (l = s[n] = t.measureText(n).width);
        let c = s[a];
        c || (c = s[a] = t.measureText(a).width);
        let h = t.measureText(n + a).width, u = h - (l + c);
        u && (this.chars[n].kerning[a] = u), h = t.measureText(n + a).width, u = h - (l + c), u && (this.chars[a].kerning[n] = u);
      }
    }
  }
  _nextPage() {
    this._currentPageIndex++;
    const e = this.resolution, t = rs.getOptimalCanvasAndContext(
      this._textureSize,
      this._textureSize,
      e
    );
    this._setupContext(t.context, this._style, e);
    const s = e * (this.baseRenderedFontSize / this.baseMeasurementFontSize), r = new L({
      source: new ft({
        resource: t.canvas,
        resolution: s,
        alphaMode: "premultiply-alpha-on-upload",
        autoGenerateMipmaps: this._mipmap
      })
    });
    this._textureStyle && (r.source.style = this._textureStyle);
    const n = {
      canvasAndContext: t,
      texture: r
    };
    return this.pages[this._currentPageIndex] = n, n;
  }
  // canvas style!
  _setupContext(e, t, s) {
    t.fontSize = this.baseRenderedFontSize, e.scale(s, s), e.font = rr(t), t.fontSize = this.baseMeasurementFontSize, e.textBaseline = t.textBaseline;
    const r = t._stroke, n = r?.width ?? 0;
    if (r && (e.lineWidth = n, e.lineJoin = r.join, e.miterLimit = r.miterLimit, e.strokeStyle = ar(r, e)), t._fill && (e.fillStyle = ar(t._fill, e)), t.dropShadow) {
      const o = t.dropShadow, a = pe.shared.setValue(o.color).toArray(), l = o.blur * s, c = o.distance * s;
      e.shadowColor = `rgba(${a[0] * 255},${a[1] * 255},${a[2] * 255},${o.alpha})`, e.shadowBlur = l, e.shadowOffsetX = Math.cos(o.angle) * c, e.shadowOffsetY = Math.sin(o.angle) * c;
    } else
      e.shadowColor = "black", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0;
  }
  _drawGlyph(e, t, s, r, n, o) {
    const a = t.text, l = t.fontProperties, h = (o._stroke?.width ?? 0) * n, u = s + h / 2, d = r - h / 2, f = l.descent * n, m = t.lineHeight * n;
    let g = !1;
    o.stroke && h && (g = !0, e.strokeText(a, u, d + m - f));
    const { shadowBlur: p, shadowOffsetX: x, shadowOffsetY: y } = e;
    o._fill && (g && (e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0), e.fillText(a, u, d + m - f)), g && (e.shadowBlur = p, e.shadowOffsetX = x, e.shadowOffsetY = y);
  }
  destroy() {
    super.destroy();
    for (let e = 0; e < this.pages.length; e++) {
      const { canvasAndContext: t, texture: s } = this.pages[e];
      rs.returnCanvasAndContext(t), s.destroy(!0);
    }
    this.pages = null;
  }
};
Mm.defaultOptions = {
  textureSize: 512,
  style: new Ze(),
  mipmap: !0
};
let Dd = Mm;
function Pm(i, e, t, s) {
  const r = {
    width: 0,
    height: 0,
    offsetY: 0,
    scale: e.fontSize / t.baseMeasurementFontSize,
    lines: [{
      width: 0,
      charPositions: [],
      spaceWidth: 0,
      spacesIndex: [],
      chars: []
    }]
  };
  r.offsetY = t.baseLineOffset;
  let n = r.lines[0], o = null, a = !0;
  const l = {
    width: 0,
    start: 0,
    index: 0,
    // use index to not modify the array as we use it a lot!
    positions: [],
    chars: []
  }, c = t.baseMeasurementFontSize / e.fontSize, h = e.letterSpacing * c, u = e.wordWrapWidth * c, d = e.lineHeight ? e.lineHeight * c : t.lineHeight, f = e.wordWrap && e.breakWords, m = (x) => {
    const y = n.width;
    for (let v = 0; v < l.index; v++) {
      const _ = x.positions[v];
      n.chars.push(x.chars[v]), n.charPositions.push(_ + y);
    }
    n.width += x.width, a = !1, l.width = 0, l.index = 0, l.chars.length = 0;
  }, g = () => {
    let x = n.chars.length - 1;
    if (s) {
      let y = n.chars[x];
      for (; y === " "; )
        n.width -= t.chars[y].xAdvance, y = n.chars[--x];
    }
    r.width = Math.max(r.width, n.width), n = {
      width: 0,
      charPositions: [],
      chars: [],
      spaceWidth: 0,
      spacesIndex: []
    }, a = !0, r.lines.push(n), r.height += d;
  }, p = (x) => x - h > u;
  for (let x = 0; x < i.length + 1; x++) {
    let y;
    const v = x === i.length;
    v || (y = i[x]);
    const _ = t.chars[y] || t.chars[" "];
    if (/(?:\s)/.test(y) || y === "\r" || y === `
` || v) {
      if (!a && e.wordWrap && p(n.width + l.width) ? (g(), m(l), v || n.charPositions.push(0)) : (l.start = n.width, m(l), v || n.charPositions.push(0)), y === "\r" || y === `
`)
        g();
      else if (!v) {
        const A = _.xAdvance + (_.kerning[o] || 0) + h;
        n.width += A, n.spaceWidth = A, n.spacesIndex.push(n.charPositions.length), n.chars.push(y);
      }
    } else {
      const w = _.kerning[o] || 0, A = _.xAdvance + w + h;
      f && p(n.width + l.width + A) && (m(l), g()), l.positions[l.index++] = l.width + w, l.chars.push(y), l.width += A;
    }
    o = y;
  }
  return g(), e.align === "center" ? pT(r) : e.align === "right" ? mT(r) : e.align === "justify" && gT(r), r;
}
function pT(i) {
  for (let e = 0; e < i.lines.length; e++) {
    const t = i.lines[e], s = i.width / 2 - t.width / 2;
    for (let r = 0; r < t.charPositions.length; r++)
      t.charPositions[r] += s;
  }
}
function mT(i) {
  for (let e = 0; e < i.lines.length; e++) {
    const t = i.lines[e], s = i.width - t.width;
    for (let r = 0; r < t.charPositions.length; r++)
      t.charPositions[r] += s;
  }
}
function gT(i) {
  const e = i.width;
  for (let t = 0; t < i.lines.length; t++) {
    const s = i.lines[t];
    let r = 0, n = s.spacesIndex[r++], o = 0;
    const a = s.spacesIndex.length, c = (e - s.width) / a;
    for (let h = 0; h < s.charPositions.length; h++)
      h === n && (n = s.spacesIndex[r++], o += c), s.charPositions[h] += o;
  }
}
function xT(i) {
  if (i === "")
    return [];
  typeof i == "string" && (i = [i]);
  const e = [];
  for (let t = 0, s = i.length; t < s; t++) {
    const r = i[t];
    if (Array.isArray(r)) {
      if (r.length !== 2)
        throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${r.length}.`);
      if (r[0].length === 0 || r[1].length === 0)
        throw new Error("[BitmapFont]: Invalid character delimiter.");
      const n = r[0].charCodeAt(0), o = r[1].charCodeAt(0);
      if (o < n)
        throw new Error("[BitmapFont]: Invalid character range.");
      for (let a = n, l = o; a <= l; a++)
        e.push(String.fromCharCode(a));
    } else
      e.push(...Array.from(r));
  }
  if (e.length === 0)
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  return e;
}
let ks = 0;
class yT {
  constructor() {
    this.ALPHA = [["a", "z"], ["A", "Z"], " "], this.NUMERIC = [["0", "9"]], this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], this.ASCII = [[" ", "~"]], this.defaultOptions = {
      chars: this.ALPHANUMERIC,
      resolution: 1,
      padding: 4,
      skipKerning: !1,
      textureStyle: null
    }, this.measureCache = dm(1e3);
  }
  /**
   * Get a font for the specified text and style.
   * @param text - The text to get the font for
   * @param style - The style to use
   */
  getFont(e, t) {
    let s = `${t.fontFamily}-bitmap`, r = !0;
    if (t._fill.fill && !t._stroke ? (s += t._fill.fill.styleKey, r = !1) : (t._stroke || t.dropShadow) && (s = `${t.styleKey}-bitmap`, r = !1), !ne.has(s)) {
      const o = Object.create(t);
      o.lineHeight = 0;
      const a = new Dd({
        style: o,
        overrideFill: r,
        overrideSize: !0,
        ...this.defaultOptions
      });
      ks++, ks > 50 && se("BitmapText", `You have dynamically created ${ks} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``), a.once("destroy", () => {
        ks--, ne.remove(s);
      }), ne.set(
        s,
        a
      );
    }
    const n = ne.get(s);
    return n.ensureCharacters?.(e), n;
  }
  /**
   * Get the layout of a text for the specified style.
   * @param text - The text to get the layout for
   * @param style - The style to use
   * @param trimEnd - Whether to ignore whitespaces at the end of each line
   */
  getLayout(e, t, s = !0) {
    const r = this.getFont(e, t), n = `${e}-${t.styleKey}-${s}`;
    if (this.measureCache.has(n))
      return this.measureCache.get(n);
    const o = Ge.graphemeSegmenter(e), a = Pm(o, t, r, s);
    return this.measureCache.set(n, a), a;
  }
  /**
   * Measure the text using the specified style.
   * @param text - The text to measure
   * @param style - The style to use
   * @param trimEnd - Whether to ignore whitespaces at the end of each line
   */
  measureText(e, t, s = !0) {
    return this.getLayout(e, t, s);
  }
  // eslint-disable-next-line max-len
  install(...e) {
    let t = e[0];
    typeof t == "string" && (t = {
      name: t,
      style: e[1],
      chars: e[2]?.chars,
      resolution: e[2]?.resolution,
      padding: e[2]?.padding,
      skipKerning: e[2]?.skipKerning
    }, N(J, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));
    const s = t?.name;
    if (!s)
      throw new Error("[BitmapFontManager] Property `name` is required.");
    t = { ...this.defaultOptions, ...t };
    const r = t.style, n = r instanceof Ze ? r : new Ze(r), o = t.dynamicFill ?? this._canUseTintForStyle(n), a = new Dd({
      style: n,
      overrideFill: o,
      skipKerning: t.skipKerning,
      padding: t.padding,
      resolution: t.resolution,
      overrideSize: !1,
      textureStyle: t.textureStyle
    }), l = xT(t.chars);
    return a.ensureCharacters(l.join("")), ne.set(`${s}-bitmap`, a), a.once("destroy", () => ne.remove(`${s}-bitmap`)), a;
  }
  /**
   * Uninstalls a bitmap font from the cache.
   * @param {string} name - The name of the bitmap font to uninstall.
   */
  uninstall(e) {
    const t = `${e}-bitmap`, s = ne.get(t);
    s && s.destroy();
  }
  /**
   * Determines if a style can use tinting instead of baking colors into the bitmap.
   * Tinting is more efficient as it allows reusing the same bitmap with different colors.
   * @param style - The text style to evaluate
   * @returns true if the style can use tinting, false if colors must be baked in
   * @private
   */
  _canUseTintForStyle(e) {
    return !e._stroke && (!e.dropShadow || e.dropShadow.color === 0) && !e._fill.fill && e._fill.color === 16777215;
  }
}
const lr = new yT();
class Um extends um {
  constructor(e, t) {
    super();
    const { textures: s, data: r } = e;
    Object.keys(r.pages).forEach((n) => {
      const o = r.pages[parseInt(n, 10)], a = s[o.id];
      this.pages.push({ texture: a });
    }), Object.keys(r.chars).forEach((n) => {
      const o = r.chars[n], {
        frame: a,
        source: l,
        rotate: c
      } = s[o.page], h = Q.transformRectCoords(
        o,
        a,
        c,
        new G()
      ), u = new L({
        frame: h,
        orig: new G(0, 0, o.width, o.height),
        source: l,
        rotate: c
      });
      this.chars[n] = {
        id: n.codePointAt(0),
        xOffset: o.xOffset,
        yOffset: o.yOffset,
        xAdvance: o.xAdvance,
        kerning: o.kerning ?? {},
        texture: u
      };
    }), this.baseRenderedFontSize = r.fontSize, this.baseMeasurementFontSize = r.fontSize, this.fontMetrics = {
      ascent: 0,
      descent: 0,
      fontSize: r.fontSize
    }, this.baseLineOffset = r.baseLineOffset, this.lineHeight = r.lineHeight, this.fontFamily = r.fontFamily, this.distanceField = r.distanceField ?? {
      type: "none",
      range: 0
    }, this.url = t;
  }
  /** Destroys the BitmapFont object. */
  destroy() {
    super.destroy();
    for (let e = 0; e < this.pages.length; e++) {
      const { texture: t } = this.pages[e];
      t.destroy(!0);
    }
    this.pages = null;
  }
  /**
   * Generates and installs a bitmap font with the specified options.
   * The font will be cached and available for use in BitmapText objects.
   * @param options - Setup options for font generation
   * @returns Installed font instance
   * @example
   * ```ts
   * // Install a basic font
   * BitmapFont.install({
   *     name: 'Title',
   *     style: {
   *         fontFamily: 'Arial',
   *         fontSize: 32,
   *         fill: '#ffffff'
   *     }
   * });
   *
   * // Install with advanced options
   * BitmapFont.install({
   *     name: 'Custom',
   *     style: {
   *         fontFamily: 'Arial',
   *         fontSize: 24,
   *         fill: '#00ff00',
   *         stroke: { color: '#000000', width: 2 }
   *     },
   *     chars: [['a', 'z'], ['A', 'Z'], ['0', '9']],
   *     resolution: 2,
   *     padding: 4,
   *     textureStyle: {
   *         scaleMode: 'nearest'
   *     }
   * });
   * ```
   */
  static install(e) {
    lr.install(e);
  }
  /**
   * Uninstalls a bitmap font from the cache.
   * This frees up memory and resources associated with the font.
   * @param name - The name of the bitmap font to uninstall
   * @example
   * ```ts
   * // Remove a font when it's no longer needed
   * BitmapFont.uninstall('MyCustomFont');
   *
   * // Clear multiple fonts
   * ['Title', 'Heading', 'Body'].forEach(BitmapFont.uninstall);
   * ```
   */
  static uninstall(e) {
    lr.uninstall(e);
  }
}
const ah = {
  test(i) {
    return typeof i == "string" && i.startsWith("info face=");
  },
  parse(i) {
    const e = i.match(/^[a-z]+\s+.+$/gm), t = {
      info: [],
      common: [],
      page: [],
      char: [],
      chars: [],
      kerning: [],
      kernings: [],
      distanceField: []
    };
    for (const u in e) {
      const d = e[u].match(/^[a-z]+/gm)[0], f = e[u].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), m = {};
      for (const g in f) {
        const p = f[g].split("="), x = p[0], y = p[1].replace(/"/gm, ""), v = parseFloat(y), _ = isNaN(v) ? y : v;
        m[x] = _;
      }
      t[d].push(m);
    }
    const s = {
      chars: {},
      pages: [],
      lineHeight: 0,
      fontSize: 0,
      fontFamily: "",
      distanceField: null,
      baseLineOffset: 0
    }, [r] = t.info, [n] = t.common, [o] = t.distanceField ?? [];
    o && (s.distanceField = {
      range: parseInt(o.distanceRange, 10),
      type: o.fieldType
    }), s.fontSize = parseInt(r.size, 10), s.fontFamily = r.face, s.lineHeight = parseInt(n.lineHeight, 10);
    const a = t.page;
    for (let u = 0; u < a.length; u++)
      s.pages.push({
        id: parseInt(a[u].id, 10) || 0,
        file: a[u].file
      });
    const l = {};
    s.baseLineOffset = s.lineHeight - parseInt(n.base, 10);
    const c = t.char;
    for (let u = 0; u < c.length; u++) {
      const d = c[u], f = parseInt(d.id, 10);
      let m = d.letter ?? d.char ?? String.fromCharCode(f);
      m === "space" && (m = " "), l[f] = m, s.chars[m] = {
        id: f,
        // texture deets..
        page: parseInt(d.page, 10) || 0,
        x: parseInt(d.x, 10),
        y: parseInt(d.y, 10),
        width: parseInt(d.width, 10),
        height: parseInt(d.height, 10),
        xOffset: parseInt(d.xoffset, 10),
        yOffset: parseInt(d.yoffset, 10),
        xAdvance: parseInt(d.xadvance, 10),
        kerning: {}
      };
    }
    const h = t.kerning || [];
    for (let u = 0; u < h.length; u++) {
      const d = parseInt(h[u].first, 10), f = parseInt(h[u].second, 10), m = parseInt(h[u].amount, 10);
      s.chars[l[f]].kerning[l[d]] = m;
    }
    return s;
  }
}, Ld = {
  test(i) {
    const e = i;
    return typeof e != "string" && "getElementsByTagName" in e && e.getElementsByTagName("page").length && e.getElementsByTagName("info")[0].getAttribute("face") !== null;
  },
  parse(i) {
    const e = {
      chars: {},
      pages: [],
      lineHeight: 0,
      fontSize: 0,
      fontFamily: "",
      distanceField: null,
      baseLineOffset: 0
    }, t = i.getElementsByTagName("info")[0], s = i.getElementsByTagName("common")[0], r = i.getElementsByTagName("distanceField")[0];
    r && (e.distanceField = {
      type: r.getAttribute("fieldType"),
      range: parseInt(r.getAttribute("distanceRange"), 10)
    });
    const n = i.getElementsByTagName("page"), o = i.getElementsByTagName("char"), a = i.getElementsByTagName("kerning");
    e.fontSize = parseInt(t.getAttribute("size"), 10), e.fontFamily = t.getAttribute("face"), e.lineHeight = parseInt(s.getAttribute("lineHeight"), 10);
    for (let c = 0; c < n.length; c++)
      e.pages.push({
        id: parseInt(n[c].getAttribute("id"), 10) || 0,
        file: n[c].getAttribute("file")
      });
    const l = {};
    e.baseLineOffset = e.lineHeight - parseInt(s.getAttribute("base"), 10);
    for (let c = 0; c < o.length; c++) {
      const h = o[c], u = parseInt(h.getAttribute("id"), 10);
      let d = h.getAttribute("letter") ?? h.getAttribute("char") ?? String.fromCharCode(u);
      d === "space" && (d = " "), l[u] = d, e.chars[d] = {
        id: u,
        // texture deets..
        page: parseInt(h.getAttribute("page"), 10) || 0,
        x: parseInt(h.getAttribute("x"), 10),
        y: parseInt(h.getAttribute("y"), 10),
        width: parseInt(h.getAttribute("width"), 10),
        height: parseInt(h.getAttribute("height"), 10),
        // render deets..
        xOffset: parseInt(h.getAttribute("xoffset"), 10),
        yOffset: parseInt(h.getAttribute("yoffset"), 10),
        // + baseLineOffset,
        xAdvance: parseInt(h.getAttribute("xadvance"), 10),
        kerning: {}
      };
    }
    for (let c = 0; c < a.length; c++) {
      const h = parseInt(a[c].getAttribute("first"), 10), u = parseInt(a[c].getAttribute("second"), 10), d = parseInt(a[c].getAttribute("amount"), 10);
      e.chars[l[u]].kerning[l[h]] = d;
    }
    return e;
  }
}, Nd = {
  test(i) {
    return typeof i == "string" && i.match(/<font(\s|>)/) ? Ld.test(re.get().parseXML(i)) : !1;
  },
  parse(i) {
    return Ld.parse(re.get().parseXML(i));
  }
}, vT = [".xml", ".fnt"], _T = {
  extension: {
    type: O.CacheParser,
    name: "cacheBitmapFont"
  },
  test: (i) => i instanceof Um,
  getCacheableAssets(i, e) {
    const t = {};
    return i.forEach((s) => {
      t[s] = e, t[`${s}-bitmap`] = e;
    }), t[`${e.fontFamily}-bitmap`] = e, t;
  }
}, bT = {
  extension: {
    type: O.LoadParser,
    priority: Et.Normal
  },
  /** used for deprecation purposes */
  name: "loadBitmapFont",
  id: "bitmap-font",
  test(i) {
    return vT.includes(He.extname(i).toLowerCase());
  },
  async testParse(i) {
    return ah.test(i) || Nd.test(i);
  },
  async parse(i, e, t) {
    const s = ah.test(i) ? ah.parse(i) : Nd.parse(i), { src: r } = e, { pages: n } = s, o = [], a = s.distanceField ? {
      scaleMode: "linear",
      alphaMode: "premultiply-alpha-on-upload",
      autoGenerateMipmaps: !1,
      resolution: 1
    } : {};
    for (let u = 0; u < n.length; ++u) {
      const d = n[u].file;
      let f = He.join(He.dirname(r), d);
      f = Rh(f, r), o.push({
        src: f,
        data: a
      });
    }
    const l = await t.load(o), c = o.map((u) => l[u.src]);
    return new Um({
      data: s,
      textures: c
    }, r);
  },
  async load(i, e) {
    return await (await re.get().fetch(i)).text();
  },
  async unload(i, e, t) {
    await Promise.all(i.pages.map((s) => t.unload(s.texture.source._sourceOrigin))), i.destroy();
  }
};
class wT {
  /**
   * @param loader
   * @param verbose - should the loader log to the console
   */
  constructor(e, t = !1) {
    this._loader = e, this._assetList = [], this._isLoading = !1, this._maxConcurrent = 1, this.verbose = t;
  }
  /**
   * Adds assets to the background loading queue. Assets are loaded one at a time to minimize
   * performance impact.
   * @param assetUrls - Array of resolved assets to load in the background
   * @example
   * ```ts
   * // Add assets to background load queue
   * backgroundLoader.add([
   *     { src: 'images/level1/bg.png' },
   *     { src: 'images/level1/characters.json' }
   * ]);
   *
   * // Assets will load sequentially in the background
   * // The loader automatically pauses when high-priority loads occur
   * // e.g. Assets.load() is called
   * ```
   * @remarks
   * - Assets are loaded one at a time to minimize performance impact
   * - Loading automatically pauses when Assets.load() is called
   * - No progress tracking is available for background loading
   * - Assets are cached as they complete loading
   * @internal
   */
  add(e) {
    e.forEach((t) => {
      this._assetList.push(t);
    }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next();
  }
  /**
   * Loads the next set of assets. Will try to load as many assets as it can at the same time.
   *
   * The max assets it will try to load at one time will be 4.
   */
  async _next() {
    if (this._assetList.length && this._isActive) {
      this._isLoading = !0;
      const e = [], t = Math.min(this._assetList.length, this._maxConcurrent);
      for (let s = 0; s < t; s++)
        e.push(this._assetList.pop());
      await this._loader.load(e), this._isLoading = !1, this._next();
    }
  }
  /**
   * Controls the active state of the background loader. When active, the loader will
   * continue processing its queue. When inactive, loading is paused.
   * @returns Whether the background loader is currently active
   * @example
   * ```ts
   * // Pause background loading
   * backgroundLoader.active = false;
   *
   * // Resume background loading
   * backgroundLoader.active = true;
   *
   * // Check current state
   * console.log(backgroundLoader.active); // true/false
   *
   * // Common use case: Pause during intensive operations
   * backgroundLoader.active = false;  // Pause background loading
   * ... // Perform high-priority tasks
   * backgroundLoader.active = true;   // Resume background loading
   * ```
   * @remarks
   * - Setting to true resumes loading immediately
   * - Setting to false pauses after current asset completes
   * - Background loading is automatically paused during `Assets.load()`
   * - Assets already being loaded will complete even when set to false
   */
  get active() {
    return this._isActive;
  }
  set active(e) {
    this._isActive !== e && (this._isActive = e, e && !this._isLoading && this._next());
  }
}
const TT = {
  extension: {
    type: O.CacheParser,
    name: "cacheTextureArray"
  },
  test: (i) => Array.isArray(i) && i.every((e) => e instanceof L),
  getCacheableAssets: (i, e) => {
    const t = {};
    return i.forEach((s) => {
      e.forEach((r, n) => {
        t[s + (n === 0 ? "" : n + 1)] = r;
      });
    }), t;
  }
};
async function Rm(i) {
  if ("Image" in globalThis)
    return new Promise((e) => {
      const t = new Image();
      t.onload = () => {
        e(!0);
      }, t.onerror = () => {
        e(!1);
      }, t.src = i;
    });
  if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
    try {
      const e = await (await fetch(i)).blob();
      await createImageBitmap(e);
    } catch {
      return !1;
    }
    return !0;
  }
  return !1;
}
const ST = {
  extension: {
    type: O.DetectionParser,
    priority: 1
  },
  test: async () => Rm(
    // eslint-disable-next-line max-len
    "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
  ),
  add: async (i) => [...i, "avif"],
  remove: async (i) => i.filter((e) => e !== "avif")
}, Gd = ["png", "jpg", "jpeg"], CT = {
  extension: {
    type: O.DetectionParser,
    priority: -1
  },
  test: () => Promise.resolve(!0),
  add: async (i) => [...i, ...Gd],
  remove: async (i) => i.filter((e) => !Gd.includes(e))
}, AT = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;
function vr(i) {
  return AT ? !1 : document.createElement("video").canPlayType(i) !== "";
}
const IT = {
  extension: {
    type: O.DetectionParser,
    priority: 0
  },
  test: async () => vr("video/mp4"),
  add: async (i) => [...i, "mp4", "m4v"],
  remove: async (i) => i.filter((e) => e !== "mp4" && e !== "m4v")
}, kT = {
  extension: {
    type: O.DetectionParser,
    priority: 0
  },
  test: async () => vr("video/ogg"),
  add: async (i) => [...i, "ogv"],
  remove: async (i) => i.filter((e) => e !== "ogv")
}, FT = {
  extension: {
    type: O.DetectionParser,
    priority: 0
  },
  test: async () => vr("video/webm"),
  add: async (i) => [...i, "webm"],
  remove: async (i) => i.filter((e) => e !== "webm")
}, MT = {
  extension: {
    type: O.DetectionParser,
    priority: 0
  },
  test: async () => Rm(
    "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
  ),
  add: async (i) => [...i, "webp"],
  remove: async (i) => i.filter((e) => e !== "webp")
}, Bm = class Ys {
  constructor() {
    this.loadOptions = { ...Ys.defaultOptions }, this._parsers = [], this._parsersValidated = !1, this.parsers = new Proxy(this._parsers, {
      set: (e, t, s) => (this._parsersValidated = !1, e[t] = s, !0)
    }), this.promiseCache = {};
  }
  /** function used for testing */
  reset() {
    this._parsersValidated = !1, this.promiseCache = {};
  }
  /**
   * Used internally to generate a promise for the asset to be loaded.
   * @param url - The URL to be loaded
   * @param data - any custom additional information relevant to the asset being loaded
   * @returns - a promise that will resolve to an Asset for example a Texture of a JSON object
   */
  _getLoadPromiseAndParser(e, t) {
    const s = {
      promise: null,
      parser: null
    };
    return s.promise = (async () => {
      let r = null, n = null;
      if ((t.parser || t.loadParser) && (n = this._parserHash[t.parser || t.loadParser], t.loadParser && se(
        `[Assets] "loadParser" is deprecated, use "parser" instead for ${e}`
      ), n || se(
        `[Assets] specified load parser "${t.parser || t.loadParser}" not found while loading ${e}`
      )), !n) {
        for (let o = 0; o < this.parsers.length; o++) {
          const a = this.parsers[o];
          if (a.load && a.test?.(e, t, this)) {
            n = a;
            break;
          }
        }
        if (!n)
          return se(`[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null;
      }
      r = await n.load(e, t, this), s.parser = n;
      for (let o = 0; o < this.parsers.length; o++) {
        const a = this.parsers[o];
        a.parse && a.parse && await a.testParse?.(r, t, this) && (r = await a.parse(r, t, this) || r, s.parser = a);
      }
      return r;
    })(), s;
  }
  async load(e, t) {
    this._parsersValidated || this._validateParsers();
    const s = typeof t == "function" ? { ...Ys.defaultOptions, ...this.loadOptions, onProgress: t } : { ...Ys.defaultOptions, ...this.loadOptions, ...t || {} }, { onProgress: r, onError: n, strategy: o, retryCount: a, retryDelay: l } = s;
    let c = 0;
    const h = {}, u = sr(e), d = Qe(e, (g) => ({
      alias: [g],
      src: g,
      data: {}
    })), f = d.reduce((g, p) => g + (p.progressSize || 1), 0), m = d.map(async (g) => {
      const p = He.toAbsolute(g.src);
      h[g.src] || (await this._loadAssetWithRetry(p, g, { onProgress: r, onError: n, strategy: o, retryCount: a, retryDelay: l }, h), c += g.progressSize || 1, r && r(c / f));
    });
    return await Promise.all(m), u ? h[d[0].src] : h;
  }
  /**
   * Unloads one or more assets. Any unloaded assets will be destroyed, freeing up memory for your app.
   * The parser that created the asset, will be the one that unloads it.
   * @example
   * // Single asset:
   * const asset = await Loader.load('cool.png');
   *
   * await Loader.unload('cool.png');
   *
   * console.log(asset.destroyed); // true
   * @param assetsToUnloadIn - urls that you want to unload, or a single one!
   */
  async unload(e) {
    const s = Qe(e, (r) => ({
      alias: [r],
      src: r
    })).map(async (r) => {
      const n = He.toAbsolute(r.src), o = this.promiseCache[n];
      if (o) {
        const a = await o.promise;
        delete this.promiseCache[n], await o.parser?.unload?.(a, r, this);
      }
    });
    await Promise.all(s);
  }
  /** validates our parsers, right now it only checks for name conflicts but we can add more here as required! */
  _validateParsers() {
    this._parsersValidated = !0, this._parserHash = this._parsers.filter((e) => e.name || e.id).reduce((e, t) => (!t.name && !t.id ? se("[Assets] parser should have an id") : (e[t.name] || e[t.id]) && se(`[Assets] parser id conflict "${t.id}"`), e[t.name] = t, t.id && (e[t.id] = t), e), {});
  }
  async _loadAssetWithRetry(e, t, s, r) {
    let n = 0;
    const { onError: o, strategy: a, retryCount: l, retryDelay: c } = s, h = (u) => new Promise((d) => setTimeout(d, u));
    for (; ; )
      try {
        this.promiseCache[e] || (this.promiseCache[e] = this._getLoadPromiseAndParser(e, t)), r[t.src] = await this.promiseCache[e].promise;
        return;
      } catch (u) {
        delete this.promiseCache[e], delete r[t.src], n++;
        const d = a !== "retry" || n > l;
        if (a === "retry" && !d) {
          o && o(u, t), await h(c);
          continue;
        }
        if (a === "skip") {
          o && o(u, t);
          return;
        }
        throw o && o(u, t), new Error(`[Loader.load] Failed to load ${e}.
${u}`);
      }
  }
};
Bm.defaultOptions = {
  onProgress: void 0,
  onError: void 0,
  strategy: "throw",
  retryCount: 3,
  retryDelay: 250
};
let ET = Bm;
function vi(i, e) {
  if (Array.isArray(e)) {
    for (const t of e)
      if (i.startsWith(`data:${t}`))
        return !0;
    return !1;
  }
  return i.startsWith(`data:${e}`);
}
function _i(i, e) {
  const t = i.split("?")[0], s = He.extname(t).toLowerCase();
  return Array.isArray(e) ? e.includes(s) : s === e;
}
const PT = ".json", UT = "application/json", RT = {
  extension: {
    type: O.LoadParser,
    priority: Et.Low
  },
  /** used for deprecation purposes */
  name: "loadJson",
  id: "json",
  test(i) {
    return vi(i, UT) || _i(i, PT);
  },
  async load(i) {
    return await (await re.get().fetch(i)).json();
  }
}, BT = ".txt", zT = "text/plain", OT = {
  /** used for deprecation purposes */
  name: "loadTxt",
  id: "text",
  extension: {
    type: O.LoadParser,
    priority: Et.Low,
    name: "loadTxt"
  },
  test(i) {
    return vi(i, zT) || _i(i, BT);
  },
  async load(i) {
    return await (await re.get().fetch(i)).text();
  }
}, DT = [
  "normal",
  "bold",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900"
], LT = [".ttf", ".otf", ".woff", ".woff2"], NT = [
  "font/ttf",
  "font/otf",
  "font/woff",
  "font/woff2"
], GT = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
function HT(i) {
  const e = He.extname(i), r = He.basename(i, e).replace(/(-|_)/g, " ").toLowerCase().split(" ").map((a) => a.charAt(0).toUpperCase() + a.slice(1));
  let n = r.length > 0;
  for (const a of r)
    if (!a.match(GT)) {
      n = !1;
      break;
    }
  let o = r.join(" ");
  return n || (o = `"${o.replace(/[\\"]/g, "\\$&")}"`), o;
}
const WT = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
function VT(i) {
  return WT.test(i) ? i : encodeURI(i);
}
const $T = {
  extension: {
    type: O.LoadParser,
    priority: Et.Low
  },
  /** used for deprecation purposes */
  name: "loadWebFont",
  id: "web-font",
  test(i) {
    return vi(i, NT) || _i(i, LT);
  },
  async load(i, e) {
    const t = re.get().getFontFaceSet();
    if (t) {
      const s = [], r = e.data?.family ?? HT(i), n = e.data?.weights?.filter((a) => DT.includes(a)) ?? ["normal"], o = e.data ?? {};
      for (let a = 0; a < n.length; a++) {
        const l = n[a], c = new FontFace(r, `url(${VT(i)})`, {
          ...o,
          weight: l
        });
        await c.load(), t.add(c), s.push(c);
      }
      return ne.has(`${r}-and-url`) ? ne.get(`${r}-and-url`).entries.push({ url: i, faces: s }) : ne.set(`${r}-and-url`, {
        entries: [{ url: i, faces: s }]
      }), s.length === 1 ? s[0] : s;
    }
    return se("[loadWebFont] FontFace API is not supported. Skipping loading font"), null;
  },
  unload(i) {
    const e = Array.isArray(i) ? i : [i], t = e[0].family, s = ne.get(`${t}-and-url`), r = s.entries.find((n) => n.faces.some((o) => e.indexOf(o) !== -1));
    r.faces = r.faces.filter((n) => e.indexOf(n) === -1), r.faces.length === 0 && (s.entries = s.entries.filter((n) => n !== r)), e.forEach((n) => {
      re.get().getFontFaceSet().delete(n);
    }), s.entries.length === 0 && ne.remove(`${t}-and-url`);
  }
};
function gu(i, e = 1) {
  const t = gi.RETINA_PREFIX?.exec(i);
  return t ? parseFloat(t[1]) : e;
}
function xu(i, e, t) {
  i.label = t, i._sourceOrigin = t;
  const s = new L({
    source: i,
    label: t
  }), r = () => {
    delete e.promiseCache[t], ne.has(t) && ne.remove(t);
  };
  return s.source.once("destroy", () => {
    e.promiseCache[t] && (se("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."), r());
  }), s.once("destroy", () => {
    i.destroyed || (se("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."), r());
  }), s;
}
const YT = ".svg", XT = "image/svg+xml", qT = {
  extension: {
    type: O.LoadParser,
    priority: Et.Low,
    name: "loadSVG"
  },
  /** used for deprecation purposes */
  name: "loadSVG",
  id: "svg",
  config: {
    crossOrigin: "anonymous",
    parseAsGraphicsContext: !1
  },
  test(i) {
    return vi(i, XT) || _i(i, YT);
  },
  async load(i, e, t) {
    return e.data?.parseAsGraphicsContext ?? this.config.parseAsGraphicsContext ? KT(i) : ZT(i, e, t, this.config.crossOrigin);
  },
  unload(i) {
    i.destroy(!0);
  }
};
async function ZT(i, e, t, s) {
  const r = await re.get().fetch(i), n = re.get().createImage();
  n.src = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(await r.text())}`, n.crossOrigin = s, await n.decode();
  const o = e.data?.width ?? n.width, a = e.data?.height ?? n.height, l = e.data?.resolution || gu(i), c = Math.ceil(o * l), h = Math.ceil(a * l), u = re.get().createCanvas(c, h), d = u.getContext("2d");
  d.imageSmoothingEnabled = !0, d.imageSmoothingQuality = "high", d.drawImage(n, 0, 0, o * l, a * l);
  const { parseAsGraphicsContext: f, ...m } = e.data ?? {}, g = new ft({
    resource: u,
    alphaMode: "premultiply-alpha-on-upload",
    resolution: l,
    ...m
  });
  return xu(g, t, i);
}
async function KT(i) {
  const t = await (await re.get().fetch(i)).text(), s = new $e();
  return s.svg(t), s;
}
const JT = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
let ai = null, Yh = class {
  constructor() {
    ai || (ai = URL.createObjectURL(new Blob([JT], { type: "application/javascript" }))), this.worker = new Worker(ai);
  }
};
Yh.revokeObjectURL = function() {
  ai && (URL.revokeObjectURL(ai), ai = null);
};
const jT = `(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;
let li = null;
class zm {
  constructor() {
    li || (li = URL.createObjectURL(new Blob([jT], { type: "application/javascript" }))), this.worker = new Worker(li);
  }
}
zm.revokeObjectURL = function() {
  li && (URL.revokeObjectURL(li), li = null);
};
let Hd = 0, lh;
class QT {
  constructor() {
    this._initialized = !1, this._createdWorkers = 0, this._workerPool = [], this._queue = [], this._resolveHash = {};
  }
  /**
   * Checks if ImageBitmap is supported in the current environment.
   *
   * This method uses a dedicated worker to test ImageBitmap support
   * and caches the result for subsequent calls.
   * @returns Promise that resolves to true if ImageBitmap is supported, false otherwise
   */
  isImageBitmapSupported() {
    return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise((e) => {
      const { worker: t } = new Yh();
      t.addEventListener("message", (s) => {
        t.terminate(), Yh.revokeObjectURL(), e(s.data);
      });
    }), this._isImageBitmapSupported);
  }
  /**
   * Loads an image as an ImageBitmap using a web worker.
   * @param src - The source URL or path of the image to load
   * @param asset - Optional resolved asset containing additional texture source options
   * @returns Promise that resolves to the loaded ImageBitmap
   * @example
   * ```typescript
   * const bitmap = await WorkerManager.loadImageBitmap('image.png');
   * const bitmapWithOptions = await WorkerManager.loadImageBitmap('image.png', asset);
   * ```
   */
  loadImageBitmap(e, t) {
    return this._run("loadImageBitmap", [e, t?.data?.alphaMode]);
  }
  /**
   * Initializes the worker pool if not already initialized.
   * Currently a no-op but reserved for future initialization logic.
   */
  async _initWorkers() {
    this._initialized || (this._initialized = !0);
  }
  /**
   * Gets an available worker from the pool or creates a new one if needed.
   *
   * Workers are created up to the MAX_WORKERS limit (based on navigator.hardwareConcurrency).
   * Each worker is configured with a message handler for processing results.
   * @returns Available worker or undefined if pool is at capacity and no workers are free
   */
  _getWorker() {
    lh === void 0 && (lh = navigator.hardwareConcurrency || 4);
    let e = this._workerPool.pop();
    return !e && this._createdWorkers < lh && (this._createdWorkers++, e = new zm().worker, e.addEventListener("message", (t) => {
      this._complete(t.data), this._returnWorker(t.target), this._next();
    })), e;
  }
  /**
   * Returns a worker to the pool after completing a task.
   * @param worker - The worker to return to the pool
   */
  _returnWorker(e) {
    this._workerPool.push(e);
  }
  /**
   * Handles completion of a worker task by resolving or rejecting the corresponding promise.
   * @param data - Result data from the worker containing uuid, data, and optional error
   */
  _complete(e) {
    this._resolveHash[e.uuid] && (e.error !== void 0 ? this._resolveHash[e.uuid].reject(e.error) : this._resolveHash[e.uuid].resolve(e.data), delete this._resolveHash[e.uuid]);
  }
  /**
   * Executes a task using the worker pool system.
   *
   * Queues the task and processes it when a worker becomes available.
   * @param id - Identifier for the type of task to run
   * @param args - Arguments to pass to the worker
   * @returns Promise that resolves with the worker's result
   */
  async _run(e, t) {
    await this._initWorkers();
    const s = new Promise((r, n) => {
      this._queue.push({ id: e, arguments: t, resolve: r, reject: n });
    });
    return this._next(), s;
  }
  /**
   * Processes the next item in the queue if workers are available.
   *
   * This method is called after worker initialization and when workers
   * complete tasks to continue processing the queue.
   */
  _next() {
    if (!this._queue.length)
      return;
    const e = this._getWorker();
    if (!e)
      return;
    const t = this._queue.pop(), s = t.id;
    this._resolveHash[Hd] = { resolve: t.resolve, reject: t.reject }, e.postMessage({
      data: t.arguments,
      uuid: Hd++,
      id: s
    });
  }
  /**
   * Resets the worker manager, terminating all workers and clearing the queue.
   *
   * This method:
   * - Terminates all active workers
   * - Rejects all pending promises with an error
   * - Clears all internal state
   * - Resets initialization flags
   *
   * This should be called when the worker manager is no longer needed
   * to prevent memory leaks and ensure proper cleanup.
   * @example
   * ```typescript
   * // Clean up when shutting down
   * WorkerManager.reset();
   * ```
   */
  reset() {
    this._workerPool.forEach((e) => e.terminate()), this._workerPool.length = 0, Object.values(this._resolveHash).forEach(({ reject: e }) => {
      e?.(new Error("WorkerManager has been reset before completion"));
    }), this._resolveHash = {}, this._queue.length = 0, this._initialized = !1, this._createdWorkers = 0;
  }
}
const Wd = new QT(), eS = [".jpeg", ".jpg", ".png", ".webp", ".avif"], tS = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "image/avif"
];
async function iS(i, e) {
  const t = await re.get().fetch(i);
  if (!t.ok)
    throw new Error(`[loadImageBitmap] Failed to fetch ${i}: ${t.status} ${t.statusText}`);
  const s = await t.blob();
  return e?.data?.alphaMode === "premultiplied-alpha" ? createImageBitmap(s, { premultiplyAlpha: "none" }) : createImageBitmap(s);
}
const Om = {
  /** used for deprecation purposes */
  name: "loadTextures",
  id: "texture",
  extension: {
    type: O.LoadParser,
    priority: Et.High,
    name: "loadTextures"
  },
  config: {
    preferWorkers: !0,
    preferCreateImageBitmap: !0,
    crossOrigin: "anonymous"
  },
  test(i) {
    return vi(i, tS) || _i(i, eS);
  },
  async load(i, e, t) {
    let s = null;
    globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await Wd.isImageBitmapSupported() ? s = await Wd.loadImageBitmap(i, e) : s = await iS(i, e) : s = await new Promise((n, o) => {
      s = re.get().createImage(), s.crossOrigin = this.config.crossOrigin, s.src = i, s.complete ? n(s) : (s.onload = () => {
        n(s);
      }, s.onerror = o);
    });
    const r = new ft({
      resource: s,
      alphaMode: "premultiply-alpha-on-upload",
      resolution: e.data?.resolution || gu(i),
      ...e.data
    });
    return xu(r, t, i);
  },
  unload(i) {
    i.destroy(!0);
  }
}, sS = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"];
let ch, hh;
function rS(i, e, t) {
  t === void 0 && !e.startsWith("data:") ? i.crossOrigin = oS(e) : t !== !1 && (i.crossOrigin = typeof t == "string" ? t : "anonymous");
}
function nS(i) {
  return new Promise((e, t) => {
    i.addEventListener("canplaythrough", s), i.addEventListener("error", r), i.load();
    function s() {
      n(), e();
    }
    function r(o) {
      n(), t(o);
    }
    function n() {
      i.removeEventListener("canplaythrough", s), i.removeEventListener("error", r);
    }
  });
}
function oS(i, e = globalThis.location) {
  if (i.startsWith("data:"))
    return "";
  e || (e = globalThis.location);
  const t = new URL(i, document.baseURI);
  return t.hostname !== e.hostname || t.port !== e.port || t.protocol !== e.protocol ? "anonymous" : "";
}
function aS() {
  const i = [], e = [];
  for (const t of sS) {
    const s = Xi.MIME_TYPES[t.substring(1)] || `video/${t.substring(1)}`;
    vr(s) && (i.push(t), e.includes(s) || e.push(s));
  }
  return {
    validVideoExtensions: i,
    validVideoMime: e
  };
}
const lS = {
  /** used for deprecation purposes */
  name: "loadVideo",
  id: "video",
  extension: {
    type: O.LoadParser,
    name: "loadVideo"
  },
  test(i) {
    if (!ch || !hh) {
      const { validVideoExtensions: s, validVideoMime: r } = aS();
      ch = s, hh = r;
    }
    const e = vi(i, hh), t = _i(i, ch);
    return e || t;
  },
  async load(i, e, t) {
    const s = {
      ...Xi.defaultOptions,
      resolution: e.data?.resolution || gu(i),
      alphaMode: e.data?.alphaMode || await Np(),
      ...e.data
    }, r = document.createElement("video"), n = {
      preload: s.autoLoad !== !1 ? "auto" : void 0,
      "webkit-playsinline": s.playsinline !== !1 ? "" : void 0,
      playsinline: s.playsinline !== !1 ? "" : void 0,
      muted: s.muted === !0 ? "" : void 0,
      loop: s.loop === !0 ? "" : void 0,
      autoplay: s.autoPlay !== !1 ? "" : void 0
    };
    Object.keys(n).forEach((l) => {
      const c = n[l];
      c !== void 0 && r.setAttribute(l, c);
    }), s.muted === !0 && (r.muted = !0), rS(r, i, s.crossorigin);
    const o = document.createElement("source");
    let a;
    if (s.mime)
      a = s.mime;
    else if (i.startsWith("data:"))
      a = i.slice(5, i.indexOf(";"));
    else if (!i.startsWith("blob:")) {
      const l = i.split("?")[0].slice(i.lastIndexOf(".") + 1).toLowerCase();
      a = Xi.MIME_TYPES[l] || `video/${l}`;
    }
    return o.src = i, a && (o.type = a), new Promise((l) => {
      const c = async () => {
        const h = new Xi({ ...s, resource: r });
        r.removeEventListener("canplay", c), e.data.preload && await nS(r), l(xu(h, t, i));
      };
      s.preload && !s.autoPlay && r.load(), r.addEventListener("canplay", c), r.appendChild(o);
    });
  },
  unload(i) {
    i.destroy(!0);
  }
}, Dm = {
  extension: {
    type: O.ResolveParser,
    name: "resolveTexture"
  },
  test: Om.test,
  parse: (i) => ({
    resolution: parseFloat(gi.RETINA_PREFIX.exec(i)?.[1] ?? "1"),
    format: i.split(".").pop(),
    src: i
  })
}, cS = {
  extension: {
    type: O.ResolveParser,
    priority: -2,
    name: "resolveJson"
  },
  test: (i) => gi.RETINA_PREFIX.test(i) && i.endsWith(".json"),
  parse: Dm.parse
};
class hS {
  constructor() {
    this._detections = [], this._initialized = !1, this.resolver = new gi(), this.loader = new ET(), this.cache = ne, this._backgroundLoader = new wT(this.loader), this._backgroundLoader.active = !0, this.reset();
  }
  /**
   * Initializes the Assets class with configuration options. While not required,
   * calling this before loading assets is recommended to set up default behaviors.
   * @param options - Configuration options for the Assets system
   * @example
   * ```ts
   * // Basic initialization (optional as Assets.load will call this automatically)
   * await Assets.init();
   *
   * // With CDN configuration
   * await Assets.init({
   *     basePath: 'https://my-cdn.com/assets/',
   *     defaultSearchParams: { version: '1.0.0' }
   * });
   *
   * // With manifest and preferences
   * await Assets.init({
   *     manifest: {
   *         bundles: [{
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'hero',
   *                     src: 'hero.{png,webp}',
   *                     data: { scaleMode: SCALE_MODES.NEAREST }
   *                 },
   *                 {
   *                     alias: 'map',
   *                     src: 'map.json'
   *                 }
   *             ]
   *         }]
   *     },
   *     // Optimize for device capabilities
   *     texturePreference: {
   *         resolution: window.devicePixelRatio,
   *         format: ['webp', 'png']
   *     },
   *     // Set global preferences
   *     preferences: {
   *         crossOrigin: 'anonymous',
   *     }
   * });
   *
   * // Load assets after initialization
   * const heroTexture = await Assets.load('hero');
   * ```
   * @remarks
   * - Can be called only once; subsequent calls will be ignored with a warning
   * - Format detection runs automatically unless `skipDetections` is true
   * - The manifest can be a URL to a JSON file or an inline object
   * @see {@link AssetInitOptions} For all available initialization options
   * @see {@link AssetsManifest} For manifest format details
   */
  async init(e = {}) {
    if (this._initialized) {
      se("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
      return;
    }
    if (this._initialized = !0, e.defaultSearchParams && this.resolver.setDefaultSearchParams(e.defaultSearchParams), e.basePath && (this.resolver.basePath = e.basePath), e.bundleIdentifier && this.resolver.setBundleIdentifier(e.bundleIdentifier), e.manifest) {
      let n = e.manifest;
      typeof n == "string" && (n = await this.load(n)), this.resolver.addManifest(n);
    }
    const t = e.texturePreference?.resolution ?? 1, s = typeof t == "number" ? [t] : t, r = await this._detectFormats({
      preferredFormats: e.texturePreference?.format,
      skipDetections: e.skipDetections,
      detections: this._detections
    });
    this.resolver.prefer({
      params: {
        format: r,
        resolution: s
      }
    }), e.preferences && this.setPreferences(e.preferences), e.loadOptions && (this.loader.loadOptions = {
      ...this.loader.loadOptions,
      ...e.loadOptions
    });
  }
  /**
   * Registers assets with the Assets resolver. This method maps keys (aliases) to asset sources,
   * allowing you to load assets using friendly names instead of direct URLs.
   * @param assets - The unresolved assets to add to the resolver
   * @example
   * ```ts
   * // Basic usage - single asset
   * Assets.add({
   *     alias: 'myTexture',
   *     src: 'assets/texture.png'
   * });
   * const texture = await Assets.load('myTexture');
   *
   * // Multiple aliases for the same asset
   * Assets.add({
   *     alias: ['hero', 'player'],
   *     src: 'hero.png'
   * });
   * const hero1 = await Assets.load('hero');
   * const hero2 = await Assets.load('player'); // Same texture
   *
   * // Multiple format support
   * Assets.add({
   *     alias: 'character',
   *     src: 'character.{webp,png}' // Will choose best format
   * });
   * Assets.add({
   *     alias: 'character',
   *     src: ['character.webp', 'character.png'], // Explicitly specify formats
   * });
   *
   * // With texture options
   * Assets.add({
   *     alias: 'sprite',
   *     src: 'sprite.png',
   *     data: { scaleMode: 'nearest' }
   * });
   *
   * // Multiple assets at once
   * Assets.add([
   *     { alias: 'bg', src: 'background.png' },
   *     { alias: 'music', src: 'music.mp3' },
   *     { alias: 'spritesheet', src: 'sheet.json', data: { ignoreMultiPack: false } }
   * ]);
   * ```
   * @remarks
   * - Assets are resolved when loaded, not when added
   * - Multiple formats use the best available format for the browser
   * - Adding with same alias overwrites previous definition
   * - The `data` property is passed to the asset loader
   * @see {@link Resolver} For details on asset resolution
   * @see {@link LoaderParser} For asset-specific data options
   * @advanced
   */
  add(e) {
    this.resolver.add(e);
  }
  async load(e, t) {
    this._initialized || await this.init();
    const s = sr(e), r = Qe(e).map((a) => {
      if (typeof a != "string") {
        const l = this.resolver.getAlias(a);
        return l.some((c) => !this.resolver.hasKey(c)) && this.add(a), Array.isArray(l) ? l[0] : l;
      }
      return this.resolver.hasKey(a) || this.add({ alias: a, src: a }), a;
    }), n = this.resolver.resolve(r), o = await this._mapLoadToResolve(n, t);
    return s ? o[r[0]] : o;
  }
  /**
   * Registers a bundle of assets that can be loaded as a group. Bundles are useful for organizing
   * assets into logical groups, such as game levels or UI screens.
   * @param bundleId - Unique identifier for the bundle
   * @param assets - Assets to include in the bundle
   * @example
   * ```ts
   * // Add a bundle using array format
   * Assets.addBundle('animals', [
   *     { alias: 'bunny', src: 'bunny.png' },
   *     { alias: 'chicken', src: 'chicken.png' },
   *     { alias: 'thumper', src: 'thumper.png' },
   * ]);
   *
   * // Add a bundle using object format
   * Assets.addBundle('animals', {
   *     bunny: 'bunny.png',
   *     chicken: 'chicken.png',
   *     thumper: 'thumper.png',
   * });
   *
   * // Add a bundle with advanced options
   * Assets.addBundle('ui', [
   *     {
   *         alias: 'button',
   *         src: 'button.{webp,png}',
   *         data: { scaleMode: 'nearest' }
   *     },
   *     {
   *         alias: ['logo', 'brand'],  // Multiple aliases
   *         src: 'logo.svg',
   *         data: { resolution: 2 }
   *     }
   * ]);
   *
   * // Load the bundle
   * await Assets.loadBundle('animals');
   *
   * // Use the loaded assets
   * const bunny = Sprite.from('bunny');
   * const chicken = Sprite.from('chicken');
   * ```
   * @remarks
   * - Bundle IDs must be unique
   * - Assets in bundles are not loaded until `loadBundle` is called
   * - Bundles can be background loaded using `backgroundLoadBundle`
   * - Assets in bundles can be loaded individually using their aliases
   * @see {@link Assets.loadBundle} For loading bundles
   * @see {@link Assets.backgroundLoadBundle} For background loading bundles
   * @see {@link Assets.unloadBundle} For unloading bundles
   * @see {@link AssetsManifest} For manifest format details
   */
  addBundle(e, t) {
    this.resolver.addBundle(e, t);
  }
  /**
   * Loads a bundle or multiple bundles of assets. Bundles are collections of related assets
   * that can be loaded together.
   * @param bundleIds - Single bundle ID or array of bundle IDs to load
   * @param onProgress - Optional callback for load progress (0.0 to 1.0)
   * @returns Promise that resolves with the loaded bundle assets
   * @example
   * ```ts
   * // Define bundles in your manifest
   * const manifest = {
   *     bundles: [
   *         {
   *             name: 'load-screen',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'sunset.png',
   *                 },
   *                 {
   *                     alias: 'bar',
   *                     src: 'load-bar.{png,webp}', // use an array of individual assets
   *                 },
   *             ],
   *         },
   *         {
   *             name: 'game-screen',
   *             assets: [
   *                 {
   *                     alias: 'character',
   *                     src: 'robot.png',
   *                 },
   *                 {
   *                     alias: 'enemy',
   *                     src: 'bad-guy.png',
   *                 },
   *             ],
   *         },
   *     ]
   * };
   *
   * // Initialize with manifest
   * await Assets.init({ manifest });
   *
   * // Or add bundles programmatically
   * Assets.addBundle('load-screen', [...]);
   * Assets.loadBundle('load-screen');
   *
   * // Load a single bundle
   * await Assets.loadBundle('load-screen');
   * const bg = Sprite.from('background'); // Uses alias from bundle
   *
   * // Load multiple bundles
   * await Assets.loadBundle([
   *     'load-screen',
   *     'game-screen'
   * ]);
   *
   * // Load with progress tracking
   * await Assets.loadBundle('game-screen', (progress) => {
   *     console.log(`Loading: ${Math.round(progress * 100)}%`);
   * });
   * ```
   * @remarks
   * - Bundle assets are cached automatically
   * - Bundles can be pre-loaded using `backgroundLoadBundle`
   * - Assets in bundles can be accessed by their aliases
   * - Progress callback receives values from 0.0 to 1.0
   * @throws {Error} If the bundle ID doesn't exist in the manifest
   * @see {@link Assets.addBundle} For adding bundles programmatically
   * @see {@link Assets.backgroundLoadBundle} For background loading bundles
   * @see {@link Assets.unloadBundle} For unloading bundles
   * @see {@link AssetsManifest} For manifest format details
   */
  async loadBundle(e, t) {
    this._initialized || await this.init();
    let s = !1;
    typeof e == "string" && (s = !0, e = [e]);
    const r = this.resolver.resolveBundle(e), n = {}, o = Object.keys(r);
    let a = 0;
    const l = [], c = () => {
      t?.(l.reduce((u, d) => u + d, 0) / a);
    }, h = o.map((u, d) => {
      const f = r[u], m = Object.values(f), p = [...new Set(m.flat())].reduce((x, y) => x + (y.progressSize || 1), 0);
      return l.push(0), a += p, this._mapLoadToResolve(f, (x) => {
        l[d] = x * p, c();
      }).then((x) => {
        n[u] = x;
      });
    });
    return await Promise.all(h), s ? n[e[0]] : n;
  }
  /**
   * Initiates background loading of assets. This allows assets to be loaded passively while other operations
   * continue, making them instantly available when needed later.
   *
   * Background loading is useful for:
   * - Preloading game levels while in a menu
   * - Loading non-critical assets during gameplay
   * - Reducing visible loading screens
   * @param urls - Single URL/alias or array of URLs/aliases to load in the background
   * @example
   * ```ts
   * // Basic background loading
   * Assets.backgroundLoad('images/level2-assets.png');
   *
   * // Background load multiple assets
   * Assets.backgroundLoad([
   *     'images/sprite1.png',
   *     'images/sprite2.png',
   *     'images/background.png'
   * ]);
   *
   * // Later, when you need the assets
   * const textures = await Assets.load([
   *     'images/sprite1.png',
   *     'images/sprite2.png'
   * ]); // Resolves immediately if background loading completed
   * ```
   * @remarks
   * - Background loading happens one asset at a time to avoid blocking the main thread
   * - Loading can be interrupted safely by calling `Assets.load()`
   * - Assets are cached as they complete loading
   * - No progress tracking is available for background loading
   */
  async backgroundLoad(e) {
    this._initialized || await this.init(), typeof e == "string" && (e = [e]);
    const t = this.resolver.resolve(e);
    this._backgroundLoader.add(Object.values(t));
  }
  /**
   * Initiates background loading of asset bundles. Similar to backgroundLoad but works with
   * predefined bundles of assets.
   *
   * Perfect for:
   * - Preloading level bundles during gameplay
   * - Loading UI assets during splash screens
   * - Preparing assets for upcoming game states
   * @param bundleIds - Single bundle ID or array of bundle IDs to load in the background
   * @example
   * ```ts
   * // Define bundles in your manifest
   * await Assets.init({
   *     manifest: {
   *         bundles: [
   *             {
   *               name: 'home',
   *               assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'images/home-bg.png',
   *                 },
   *                 {
   *                     alias: 'logo',
   *                     src: 'images/logo.png',
   *                 }
   *              ]
   *            },
   *            {
   *             name: 'level-1',
   *             assets: [
   *                 {
   *                     alias: 'background',
   *                     src: 'images/level1/bg.png',
   *                 },
   *                 {
   *                     alias: 'sprites',
   *                     src: 'images/level1/sprites.json'
   *                 }
   *             ]
   *         }]
   *     }
   * });
   *
   * // Load the home screen assets right away
   * await Assets.loadBundle('home');
   * showHomeScreen();
   *
   * // Start background loading while showing home screen
   * Assets.backgroundLoadBundle('level-1');
   *
   * // When player starts level, load completes faster
   * await Assets.loadBundle('level-1');
   * hideHomeScreen();
   * startLevel();
   * ```
   * @remarks
   * - Bundle assets are loaded one at a time
   * - Loading can be interrupted safely by calling `Assets.loadBundle()`
   * - Assets are cached as they complete loading
   * - Requires bundles to be registered via manifest or `addBundle`
   * @see {@link Assets.addBundle} For adding bundles programmatically
   * @see {@link Assets.loadBundle} For immediate bundle loading
   * @see {@link AssetsManifest} For manifest format details
   */
  async backgroundLoadBundle(e) {
    this._initialized || await this.init(), typeof e == "string" && (e = [e]);
    const t = this.resolver.resolveBundle(e);
    Object.values(t).forEach((s) => {
      this._backgroundLoader.add(Object.values(s));
    });
  }
  /**
   * Only intended for development purposes.
   * This will wipe the resolver and caches.
   * You will need to reinitialize the Asset
   * @internal
   */
  reset() {
    this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1;
  }
  get(e) {
    if (typeof e == "string")
      return ne.get(e);
    const t = {};
    for (let s = 0; s < e.length; s++)
      t[s] = ne.get(e[s]);
    return t;
  }
  /**
   * helper function to map resolved assets back to loaded assets
   * @param resolveResults - the resolve results from the resolver
   * @param progressOrLoadOptions - the progress callback or load options
   */
  async _mapLoadToResolve(e, t) {
    const s = [...new Set(Object.values(e))];
    this._backgroundLoader.active = !1;
    const r = await this.loader.load(s, t);
    this._backgroundLoader.active = !0;
    const n = {};
    return s.forEach((o) => {
      const a = r[o.src], l = [o.src];
      o.alias && l.push(...o.alias), l.forEach((c) => {
        n[c] = a;
      }), ne.set(l, a);
    }), n;
  }
  /**
   * Unloads assets and releases them from memory. This method ensures proper cleanup of
   * loaded assets when they're no longer needed.
   * @param urls - Single URL/alias or array of URLs/aliases to unload
   * @example
   * ```ts
   * // Unload a single asset
   * await Assets.unload('images/sprite.png');
   *
   * // Unload using an alias
   * await Assets.unload('hero'); // Unloads the asset registered with 'hero' alias
   *
   * // Unload multiple assets
   * await Assets.unload([
   *     'images/background.png',
   *     'images/character.png',
   *     'hero'
   * ]);
   *
   * // Unload and handle creation of new instances
   * await Assets.unload('hero');
   * const newHero = await Assets.load('hero'); // Will load fresh from source
   * ```
   * @remarks
   * > [!WARNING]
   * > Make sure assets aren't being used before unloading:
   * > - Remove sprites using the texture
   * > - Clear any references to the asset
   * > - Textures will be destroyed and can't be used after unloading
   * @throws {Error} If the asset is not found in cache
   */
  async unload(e) {
    this._initialized || await this.init();
    const t = Qe(e).map((r) => typeof r != "string" ? r.src : r), s = this.resolver.resolve(t);
    await this._unloadFromResolved(s);
  }
  /**
   * Unloads all assets in a bundle. Use this to free memory when a bundle's assets
   * are no longer needed, such as when switching game levels.
   * @param bundleIds - Single bundle ID or array of bundle IDs to unload
   * @example
   * ```ts
   * // Define and load a bundle
   * Assets.addBundle('level-1', {
   *     background: 'level1/bg.png',
   *     sprites: 'level1/sprites.json',
   *     music: 'level1/music.mp3'
   * });
   *
   * // Load the bundle
   * const level1 = await Assets.loadBundle('level-1');
   *
   * // Use the assets
   * const background = Sprite.from(level1.background);
   *
   * // When done with the level, unload everything
   * await Assets.unloadBundle('level-1');
   * // background sprite is now invalid!
   *
   * // Unload multiple bundles
   * await Assets.unloadBundle([
   *     'level-1',
   *     'level-2',
   *     'ui-elements'
   * ]);
   * ```
   * @remarks
   * > [!WARNING]
   * > - All assets in the bundle will be destroyed
   * > - Bundle needs to be reloaded to use assets again
   * > - Make sure no sprites or other objects are using the assets
   * @throws {Error} If the bundle is not found
   * @see {@link Assets.addBundle} For adding bundles
   * @see {@link Assets.loadBundle} For loading bundles
   */
  async unloadBundle(e) {
    this._initialized || await this.init(), e = Qe(e);
    const t = this.resolver.resolveBundle(e), s = Object.keys(t).map((r) => this._unloadFromResolved(t[r]));
    await Promise.all(s);
  }
  async _unloadFromResolved(e) {
    const t = Object.values(e);
    t.forEach((s) => {
      ne.remove(s.src);
    }), await this.loader.unload(t);
  }
  /**
   * Detects the supported formats for the browser, and returns an array of supported formats, respecting
   * the users preferred formats order.
   * @param options - the options to use when detecting formats
   * @param options.preferredFormats - the preferred formats to use
   * @param options.skipDetections - if we should skip the detections altogether
   * @param options.detections - the detections to use
   * @returns - the detected formats
   */
  async _detectFormats(e) {
    let t = [];
    e.preferredFormats && (t = Array.isArray(e.preferredFormats) ? e.preferredFormats : [e.preferredFormats]);
    for (const s of e.detections)
      e.skipDetections || await s.test() ? t = await s.add(t) : e.skipDetections || (t = await s.remove(t));
    return t = t.filter((s, r) => t.indexOf(s) === r), t;
  }
  /**
   * All the detection parsers currently added to the Assets class.
   * @advanced
   */
  get detections() {
    return this._detections;
  }
  /**
   * Sets global preferences for asset loading behavior. This method configures how assets
   * are loaded and processed across all parsers.
   * @param preferences - Asset loading preferences
   * @example
   * ```ts
   * // Basic preferences
   * Assets.setPreferences({
   *     crossOrigin: 'anonymous',
   *     parseAsGraphicsContext: false
   * });
   * ```
   * @remarks
   * Preferences are applied to all compatible parsers and affect future asset loading.
   * Common preferences include:
   * - `crossOrigin`: CORS setting for loaded assets
   * - `preferWorkers`: Whether to use web workers for loading textures
   * - `preferCreateImageBitmap`: Use `createImageBitmap` for texture creation. Turning this off will use the `Image` constructor instead.
   * @see {@link AssetsPreferences} For all available preferences
   */
  setPreferences(e) {
    this.loader.parsers.forEach((t) => {
      t.config && Object.keys(t.config).filter((s) => s in e).forEach((s) => {
        t.config[s] = e[s];
      });
    });
  }
}
const Ni = new hS();
ke.handleByList(O.LoadParser, Ni.loader.parsers).handleByList(O.ResolveParser, Ni.resolver.parsers).handleByList(O.CacheParser, Ni.cache.parsers).handleByList(O.DetectionParser, Ni.detections);
ke.add(
  TT,
  CT,
  ST,
  MT,
  IT,
  kT,
  FT,
  RT,
  OT,
  $T,
  qT,
  Om,
  lS,
  bT,
  _T,
  Dm,
  cS
);
const Vd = {
  loader: O.LoadParser,
  resolver: O.ResolveParser,
  cache: O.CacheParser,
  detection: O.DetectionParser
};
ke.handle(O.Asset, (i) => {
  const e = i.ref;
  Object.entries(Vd).filter(([t]) => !!e[t]).forEach(([t, s]) => ke.add(Object.assign(
    e[t],
    // Allow the function to optionally define it's own
    // ExtensionMetadata, the use cases here is priority for LoaderParsers
    { extension: e[t].extension ?? s }
  )));
}, (i) => {
  const e = i.ref;
  Object.keys(Vd).filter((t) => !!e[t]).forEach((t) => ke.remove(e[t]));
});
const Lm = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
}, uS = [
  "in vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uTexture;",
  "out vec4 finalColor;",
  "void main(void)",
  "{",
  "    finalColor = vec4(0.0);",
  "    %blur%",
  "}"
].join(`
`);
function dS(i) {
  const e = Lm[i], t = e.length;
  let s = uS, r = "";
  const n = "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;";
  let o;
  for (let a = 0; a < i; a++) {
    let l = n.replace("%index%", a.toString());
    o = a, a >= t && (o = i - a - 1), l = l.replace("%value%", e[o].toString()), r += l, r += `
`;
  }
  return s = s.replace("%blur%", r), s = s.replace("%size%", i.toString()), s;
}
const fS = `
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;

    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function pS(i, e) {
  const t = Math.ceil(i / 2);
  let s = fS, r = "", n;
  e ? n = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);" : n = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";
  for (let o = 0; o < i; o++) {
    let a = n.replace("%index%", o.toString());
    a = a.replace("%sampleIndex%", `${o - (t - 1)}.0`), r += a, r += `
`;
  }
  return s = s.replace("%blur%", r), s = s.replace("%size%", i.toString()), s = s.replace("%dimension%", e ? "z" : "w"), s;
}
function mS(i, e) {
  const t = pS(e, i), s = dS(e);
  return xi.from({
    vertex: t,
    fragment: s,
    name: `blur-${i ? "horizontal" : "vertical"}-pass-filter`
  });
}
var gS = `

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct BlurUniforms {
  uStrength:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    %blur-struct%
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}


@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {

  let filteredCord = filterTextureCoord(aPosition);

  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;

  return VSOutput(
   filterVertexPosition(aPosition),
    %blur-vertex-out%
  );
}

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  %blur-fragment-in%
) -> @location(0) vec4<f32> {

    var   finalColor = vec4(0.0);

    %blur-sampling%

    return finalColor;
}`;
function xS(i, e) {
  const t = Lm[e], s = t.length, r = [], n = [], o = [];
  for (let u = 0; u < e; u++) {
    r[u] = `@location(${u}) offset${u}: vec2<f32>,`, i ? n[u] = `filteredCord + vec2(${u - s + 1} * pixelStrength, 0.0),` : n[u] = `filteredCord + vec2(0.0, ${u - s + 1} * pixelStrength),`;
    const d = u < s ? u : e - u - 1, f = t[d].toString();
    o[u] = `finalColor += textureSample(uTexture, uSampler, offset${u}) * ${f};`;
  }
  const a = r.join(`
`), l = n.join(`
`), c = o.join(`
`), h = gS.replace("%blur-struct%", a).replace("%blur-vertex-out%", l).replace("%blur-fragment-in%", a).replace("%blur-sampling%", c).replace("%dimension%", i ? "z" : "w");
  return yi.from({
    vertex: {
      source: h,
      entryPoint: "mainVertex"
    },
    fragment: {
      source: h,
      entryPoint: "mainFragment"
    }
  });
}
const Nm = class Gm extends mr {
  /**
   * @param options
   * @param options.horizontal - Do pass along the x-axis (`true`) or y-axis (`false`).
   * @param options.strength - The strength of the blur filter.
   * @param options.quality - The quality of the blur filter.
   * @param options.kernelSize - The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15.
   */
  constructor(e) {
    e = { ...Gm.defaultOptions, ...e };
    const t = mS(e.horizontal, e.kernelSize), s = xS(e.horizontal, e.kernelSize);
    super({
      glProgram: t,
      gpuProgram: s,
      resources: {
        blurUniforms: {
          uStrength: { value: 0, type: "f32" }
        }
      },
      ...e
    }), this.horizontal = e.horizontal, this._quality = 0, this.quality = e.quality, this.blur = e.strength, this._uniforms = this.resources.blurUniforms.uniforms;
  }
  /**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - How to clear
   */
  apply(e, t, s, r) {
    if (this._uniforms.uStrength = this.strength / this.passes, this.passes === 1)
      e.applyFilter(this, t, s, r);
    else {
      const n = di.getSameSizeTexture(t);
      let o = t, a = n;
      this._state.blend = !1;
      const l = e.renderer.type === ji.WEBGPU;
      for (let c = 0; c < this.passes - 1; c++) {
        e.applyFilter(this, o, a, c === 0 ? !0 : l);
        const h = a;
        a = o, o = h;
      }
      this._state.blend = !0, e.applyFilter(this, o, s, r), di.returnTexture(n);
    }
  }
  /**
   * Sets the strength of both the blur.
   * @default 16
   */
  get blur() {
    return this.strength;
  }
  set blur(e) {
    this.padding = 1 + Math.abs(e) * 2, this.strength = e;
  }
  /**
   * Sets the quality of the blur by modifying the number of passes. More passes means higher
   * quality blurring but the lower the performance.
   * @default 4
   */
  get quality() {
    return this._quality;
  }
  set quality(e) {
    this._quality = e, this.passes = e;
  }
};
Nm.defaultOptions = {
  /** The strength of the blur filter. */
  strength: 8,
  /** The quality of the blur filter. */
  quality: 4,
  /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */
  kernelSize: 5
};
let uh = Nm;
class Hm extends mr {
  constructor(...e) {
    let t = e[0] ?? {};
    typeof t == "number" && (N(J, "BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }"), t = { strength: t }, e[1] !== void 0 && (t.quality = e[1]), e[2] !== void 0 && (t.resolution = e[2] || "inherit"), e[3] !== void 0 && (t.kernelSize = e[3])), t = { ...uh.defaultOptions, ...t };
    const { strength: s, strengthX: r, strengthY: n, quality: o, ...a } = t;
    super({
      ...a,
      compatibleRenderers: ji.BOTH,
      resources: {}
    }), this._repeatEdgePixels = !1, this.blurXFilter = new uh({ horizontal: !0, ...t }), this.blurYFilter = new uh({ horizontal: !1, ...t }), this.quality = o, this.strengthX = r ?? s, this.strengthY = n ?? s, this.repeatEdgePixels = !1;
  }
  /**
   * Applies the filter.
   * @param filterManager - The manager.
   * @param input - The input target.
   * @param output - The output target.
   * @param clearMode - How to clear
   * @advanced
   */
  apply(e, t, s, r) {
    const n = Math.abs(this.blurXFilter.strength), o = Math.abs(this.blurYFilter.strength);
    if (n && o) {
      const a = di.getSameSizeTexture(t);
      this.blurXFilter.blendMode = "normal", this.blurXFilter.apply(e, t, a, !0), this.blurYFilter.blendMode = this.blendMode, this.blurYFilter.apply(e, a, s, r), di.returnTexture(a);
    } else o ? (this.blurYFilter.blendMode = this.blendMode, this.blurYFilter.apply(e, t, s, r)) : (this.blurXFilter.blendMode = this.blendMode, this.blurXFilter.apply(e, t, s, r));
  }
  updatePadding() {
    this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2;
  }
  /**
   * Sets the strength of both the blurX and blurY properties simultaneously.
   * Controls the overall intensity of the Gaussian blur effect.
   * @example
   * ```ts
   * // Set equal blur strength for both axes
   * filter.strength = 8;
   *
   * // Will throw error if X and Y are different
   * filter.strengthX = 4;
   * filter.strengthY = 8;
   * filter.strength; // Error: BlurFilter's strengthX and strengthY are different
   * ```
   * @default 8
   * @throws {Error} If strengthX and strengthY are different values
   */
  get strength() {
    if (this.strengthX !== this.strengthY)
      throw new Error("BlurFilter's strengthX and strengthY are different");
    return this.strengthX;
  }
  set strength(e) {
    this.blurXFilter.blur = this.blurYFilter.blur = e, this.updatePadding();
  }
  /**
   * Sets the number of passes for blur. More passes means higher quality blurring.
   * Controls the precision and smoothness of the blur effect at the cost of performance.
   * @example
   * ```ts
   * // High quality blur (slower)
   * filter.quality = 8;
   *
   * // Low quality blur (faster)
   * filter.quality = 2;
   * ```
   * @default 4
   * @remarks Higher values produce better quality but impact performance
   */
  get quality() {
    return this.blurXFilter.quality;
  }
  set quality(e) {
    this.blurXFilter.quality = this.blurYFilter.quality = e;
  }
  /**
   * Sets the strength of horizontal blur.
   * Controls the blur intensity along the x-axis independently.
   * @example
   * ```ts
   * // Apply horizontal-only blur
   * filter.strengthX = 8;
   * filter.strengthY = 0;
   *
   * // Create motion blur effect
   * filter.strengthX = 16;
   * filter.strengthY = 2;
   * ```
   * @default 8
   */
  get strengthX() {
    return this.blurXFilter.blur;
  }
  set strengthX(e) {
    this.blurXFilter.blur = e, this.updatePadding();
  }
  /**
   * Sets the strength of the vertical blur.
   * Controls the blur intensity along the y-axis independently.
   * @example
   * ```ts
   * // Apply vertical-only blur
   * filter.strengthX = 0;
   * filter.strengthY = 8;
   *
   * // Create radial blur effect
   * filter.strengthX = 8;
   * filter.strengthY = 8;
   * ```
   * @default 8
   */
  get strengthY() {
    return this.blurYFilter.blur;
  }
  set strengthY(e) {
    this.blurYFilter.blur = e, this.updatePadding();
  }
  /**
   * Sets the strength of both the blurX and blurY properties simultaneously
   * @default 2
   * @deprecated since 8.3.0
   * @see BlurFilter.strength
   */
  get blur() {
    return N("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead."), this.strength;
  }
  set blur(e) {
    N("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead."), this.strength = e;
  }
  /**
   * Sets the strength of the blurX property
   * @default 2
   * @deprecated since 8.3.0
   * @see BlurFilter.strengthX
   */
  get blurX() {
    return N("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead."), this.strengthX;
  }
  set blurX(e) {
    N("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead."), this.strengthX = e;
  }
  /**
   * Sets the strength of the blurY property
   * @default 2
   * @deprecated since 8.3.0
   * @see BlurFilter.strengthY
   */
  get blurY() {
    return N("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead."), this.strengthY;
  }
  set blurY(e) {
    N("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead."), this.strengthY = e;
  }
  /**
   * If set to true the edge of the target will be clamped
   * @default false
   */
  get repeatEdgePixels() {
    return this._repeatEdgePixels;
  }
  set repeatEdgePixels(e) {
    this._repeatEdgePixels = e, this.updatePadding();
  }
}
Hm.defaultOptions = {
  /** The strength of the blur filter. */
  strength: 8,
  /** The quality of the blur filter. */
  quality: 4,
  /** The kernelSize of the blur filter.Options: 5, 7, 9, 11, 13, 15. */
  kernelSize: 5
};
class fe extends au {
  /**
   * Creates a new Graphics object.
   * @param options - Options for the Graphics.
   */
  constructor(e) {
    e instanceof $e && (e = { context: e });
    const { context: t, roundPixels: s, ...r } = e || {};
    super({
      label: "Graphics",
      ...r
    }), this.renderPipeId = "graphics", t ? this._context = t : this._context = this._ownedContext = new $e(), this._context.on("update", this.onViewUpdate, this), this.didViewUpdate = !0, this.allowChildren = !1, this.roundPixels = s ?? !1;
  }
  set context(e) {
    e !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = e, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate());
  }
  /**
   * The underlying graphics context used for drawing operations.
   * Controls how shapes and paths are rendered.
   * @example
   * ```ts
   * // Create a shared context
   * const sharedContext = new GraphicsContext();
   *
   * // Create graphics objects sharing the same context
   * const graphics1 = new Graphics();
   * const graphics2 = new Graphics();
   *
   * // Assign shared context
   * graphics1.context = sharedContext;
   * graphics2.context = sharedContext;
   *
   * // Both graphics will show the same shapes
   * sharedContext
   *     .rect(0, 0, 100, 100)
   *     .fill({ color: 0xff0000 });
   * ```
   * @see {@link GraphicsContext} For drawing operations
   * @see {@link GraphicsOptions} For context configuration
   */
  get context() {
    return this._context;
  }
  /**
   * The local bounds of the graphics object.
   * Returns the boundaries after all graphical operations but before any transforms.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw a shape
   * graphics
   *     .rect(0, 0, 100, 100)
   *     .fill({ color: 0xff0000 });
   *
   * // Get bounds information
   * const bounds = graphics.bounds;
   * console.log(bounds.width);  // 100
   * console.log(bounds.height); // 100
   * ```
   * @readonly
   * @see {@link Bounds} For bounds operations
   * @see {@link Container#getBounds} For transformed bounds
   */
  get bounds() {
    return this._context.bounds;
  }
  /**
   * Graphics objects do not need to update their bounds as the context handles this.
   * @private
   */
  updateBounds() {
  }
  /**
   * Checks if the object contains the given point.
   * Returns true if the point lies within the Graphics object's rendered area.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw a shape
   * graphics
   *     .rect(0, 0, 100, 100)
   *     .fill({ color: 0xff0000 });
   *
   * // Check point intersection
   * if (graphics.containsPoint({ x: 50, y: 50 })) {
   *     console.log('Point is inside rectangle!');
   * }
   * ```
   * @param point - The point to check in local coordinates
   * @returns True if the point is inside the Graphics object
   * @see {@link Graphics#bounds} For bounding box checks
   * @see {@link PointData} For point data structure
   */
  containsPoint(e) {
    return this._context.containsPoint(e);
  }
  /**
   * Destroys this graphics renderable and optionally its context.
   * @param options - Options parameter. A boolean will act as if all options
   *
   * If the context was created by this graphics and `destroy(false)` or `destroy()` is called
   * then the context will still be destroyed.
   *
   * If you want to explicitly not destroy this context that this graphics created,
   * then you should pass destroy({ context: false })
   *
   * If the context was passed in as an argument to the constructor then it will not be destroyed
   * @example
   * ```ts
   * // Destroy the graphics and its context
   * graphics.destroy();
   * graphics.destroy(true);
   * graphics.destroy({ context: true, texture: true, textureSource: true });
   * ```
   */
  destroy(e) {
    this._ownedContext && !e ? this._ownedContext.destroy(e) : (e === !0 || e?.context === !0) && this._context.destroy(e), this._ownedContext = null, this._context = null, super.destroy(e);
  }
  _callContextMethod(e, t) {
    return this.context[e](...t), this;
  }
  // --------------------------------------- GraphicsContext methods ---------------------------------------
  /**
   * Sets the current fill style of the graphics context.
   * The fill style can be a color, gradient, pattern, or a complex style object.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic color fill
   * graphics
   *     .setFillStyle({ color: 0xff0000 }) // Red fill
   *     .rect(0, 0, 100, 100)
   *     .fill();
   *
   * // Gradient fill
   * const gradient = new FillGradient({
   *    end: { x: 1, y: 0 },
   *    colorStops: [
   *         { offset: 0, color: 0xff0000 }, // Red at start
   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle
   *         { offset: 1, color: 0x0000ff }, // Blue at end
   *    ],
   * });
   *
   * graphics
   *     .setFillStyle(gradient)
   *     .circle(100, 100, 50)
   *     .fill();
   *
   * // Pattern fill
   * const pattern = new FillPattern(texture);
   * graphics
   *     .setFillStyle({
   *         fill: pattern,
   *         alpha: 0.5
   *     })
   *     .rect(0, 0, 200, 200)
   *     .fill();
   * ```
   * @param {FillInput} args - The fill style to apply
   * @returns The Graphics instance for chaining
   * @see {@link FillStyle} For fill style options
   * @see {@link FillGradient} For gradient fills
   * @see {@link FillPattern} For pattern fills
   */
  setFillStyle(...e) {
    return this._callContextMethod("setFillStyle", e);
  }
  /**
   * Sets the current stroke style of the graphics context.
   * Similar to fill styles, stroke styles can encompass colors, gradients, patterns, or more detailed configurations.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic color stroke
   * graphics
   *     .setStrokeStyle({
   *         width: 2,
   *         color: 0x000000
   *     })
   *     .rect(0, 0, 100, 100)
   *     .stroke();
   *
   * // Complex stroke style
   * graphics
   *     .setStrokeStyle({
   *         width: 4,
   *         color: 0xff0000,
   *         alpha: 0.5,
   *         join: 'round',
   *         cap: 'round',
   *         alignment: 0.5
   *     })
   *     .circle(100, 100, 50)
   *     .stroke();
   *
   * // Gradient stroke
   * const gradient = new FillGradient({
   *    end: { x: 1, y: 0 },
   *    colorStops: [
   *         { offset: 0, color: 0xff0000 }, // Red at start
   *         { offset: 0.5, color: 0x00ff00 }, // Green at middle
   *         { offset: 1, color: 0x0000ff }, // Blue at end
   *    ],
   * });
   *
   * graphics
   *     .setStrokeStyle({
   *         width: 10,
   *         fill: gradient
   *     })
   *     .poly([0,0, 100,50, 0,100])
   *     .stroke();
   * ```
   * @param {StrokeInput} args - The stroke style to apply
   * @returns The Graphics instance for chaining
   * @see {@link StrokeStyle} For stroke style options
   * @see {@link FillGradient} For gradient strokes
   * @see {@link FillPattern} For pattern strokes
   */
  setStrokeStyle(...e) {
    return this._callContextMethod("setStrokeStyle", e);
  }
  fill(...e) {
    return this._callContextMethod("fill", e);
  }
  /**
   * Strokes the current path with the current stroke style or specified style.
   * Outlines the shape using the stroke settings.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Stroke with direct color
   * graphics
   *     .circle(50, 50, 25)
   *     .stroke({
   *         width: 2,
   *         color: 0xff0000
   *     }); // 2px red stroke
   *
   * // Fill with texture
   * graphics
   *    .rect(0, 0, 100, 100)
   *    .stroke(myTexture); // Fill with texture
   *
   * // Stroke with gradient
   * const gradient = new FillGradient({
   *     end: { x: 1, y: 0 },
   *     colorStops: [
   *         { offset: 0, color: 0xff0000 },
   *         { offset: 0.5, color: 0x00ff00 },
   *         { offset: 1, color: 0x0000ff },
   *     ],
   * });
   *
   * graphics
   *     .rect(0, 0, 100, 100)
   *     .stroke({
   *         width: 4,
   *         fill: gradient,
   *         alignment: 0.5,
   *         join: 'round'
   *     });
   * ```
   * @param {StrokeStyle} args - Optional stroke style to apply. Can be:
   * - A stroke style object with width, color, etc.
   * - A gradient
   * - A pattern
   * If omitted, uses current stroke style.
   * @returns The Graphics instance for chaining
   * @see {@link StrokeStyle} For stroke style options
   * @see {@link FillGradient} For gradient strokes
   * @see {@link setStrokeStyle} For setting default stroke style
   */
  stroke(...e) {
    return this._callContextMethod("stroke", e);
  }
  texture(...e) {
    return this._callContextMethod("texture", e);
  }
  /**
   * Resets the current path. Any previous path and its commands are discarded and a new path is
   * started. This is typically called before beginning a new shape or series of drawing commands.
   * @example
   * ```ts
   * const graphics = new Graphics();
   * graphics
   *     .circle(150, 150, 50)
   *     .fill({ color: 0x00ff00 })
   *     .beginPath() // Starts a new path
   *     .circle(250, 150, 50)
   *     .fill({ color: 0x0000ff });
   * ```
   * @returns The Graphics instance for chaining
   * @see {@link Graphics#moveTo} For starting a new subpath
   * @see {@link Graphics#closePath} For closing the current path
   */
  beginPath() {
    return this._callContextMethod("beginPath", []);
  }
  /**
   * Applies a cutout to the last drawn shape. This is used to create holes or complex shapes by
   * subtracting a path from the previously drawn path.
   *
   * If a hole is not completely in a shape, it will fail to cut correctly.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw outer circle
   * graphics
   *     .circle(100, 100, 50)
   *     .fill({ color: 0xff0000 });
   *     .circle(100, 100, 25) // Inner circle
   *     .cut() // Cuts out the inner circle from the outer circle
   * ```
   */
  cut() {
    return this._callContextMethod("cut", []);
  }
  arc(...e) {
    return this._callContextMethod("arc", e);
  }
  arcTo(...e) {
    return this._callContextMethod("arcTo", e);
  }
  arcToSvg(...e) {
    return this._callContextMethod("arcToSvg", e);
  }
  bezierCurveTo(...e) {
    return this._callContextMethod("bezierCurveTo", e);
  }
  /**
   * Closes the current path by drawing a straight line back to the start point.
   *
   * This is useful for completing shapes and ensuring they are properly closed for fills.
   * @example
   * ```ts
   * // Create a triangle with closed path
   * const graphics = new Graphics();
   * graphics
   *     .moveTo(50, 50)
   *     .lineTo(100, 100)
   *     .lineTo(0, 100)
   *     .closePath()
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#beginPath} For starting a new path
   * @see {@link Graphics#fill} For filling closed paths
   * @see {@link Graphics#stroke} For stroking paths
   */
  closePath() {
    return this._callContextMethod("closePath", []);
  }
  ellipse(...e) {
    return this._callContextMethod("ellipse", e);
  }
  circle(...e) {
    return this._callContextMethod("circle", e);
  }
  path(...e) {
    return this._callContextMethod("path", e);
  }
  lineTo(...e) {
    return this._callContextMethod("lineTo", e);
  }
  moveTo(...e) {
    return this._callContextMethod("moveTo", e);
  }
  quadraticCurveTo(...e) {
    return this._callContextMethod("quadraticCurveTo", e);
  }
  rect(...e) {
    return this._callContextMethod("rect", e);
  }
  roundRect(...e) {
    return this._callContextMethod("roundRect", e);
  }
  poly(...e) {
    return this._callContextMethod("poly", e);
  }
  regularPoly(...e) {
    return this._callContextMethod("regularPoly", e);
  }
  roundPoly(...e) {
    return this._callContextMethod("roundPoly", e);
  }
  roundShape(...e) {
    return this._callContextMethod("roundShape", e);
  }
  filletRect(...e) {
    return this._callContextMethod("filletRect", e);
  }
  chamferRect(...e) {
    return this._callContextMethod("chamferRect", e);
  }
  star(...e) {
    return this._callContextMethod("star", e);
  }
  svg(...e) {
    return this._callContextMethod("svg", e);
  }
  restore(...e) {
    return this._callContextMethod("restore", e);
  }
  /**
   * Saves the current graphics state onto a stack. The state includes:
   * - Current transformation matrix
   * - Current fill style
   * - Current stroke style
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Save state before complex operations
   * graphics.save();
   *
   * // Create transformed and styled shape
   * graphics
   *     .translateTransform(100, 100)
   *     .rotateTransform(Math.PI / 4)
   *     .setFillStyle({
   *         color: 0xff0000,
   *         alpha: 0.5
   *     })
   *     .rect(-25, -25, 50, 50)
   *     .fill();
   *
   * // Restore to original state
   * graphics.restore();
   *
   * // Continue drawing with previous state
   * graphics
   *     .circle(50, 50, 25)
   *     .fill();
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#restore} For restoring the saved state
   * @see {@link Graphics#setTransform} For setting transformations
   */
  save() {
    return this._callContextMethod("save", []);
  }
  /**
   * Returns the current transformation matrix of the graphics context.
   * This matrix represents all accumulated transformations including translate, scale, and rotate.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Apply some transformations
   * graphics
   *     .translateTransform(100, 100)
   *     .rotateTransform(Math.PI / 4);
   *
   * // Get the current transform matrix
   * const matrix = graphics.getTransform();
   * console.log(matrix.tx, matrix.ty); // 100, 100
   *
   * // Use the matrix for other operations
   * graphics
   *     .setTransform(matrix)
   *     .circle(0, 0, 50)
   *     .fill({ color: 0xff0000 });
   * ```
   * @returns The current transformation matrix.
   * @see {@link Graphics#setTransform} For setting the transform matrix
   * @see {@link Matrix} For matrix operations
   */
  getTransform() {
    return this.context.getTransform();
  }
  /**
   * Resets the current transformation matrix to the identity matrix, effectively removing
   * any transformations (rotation, scaling, translation) previously applied.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Apply transformations
   * graphics
   *     .translateTransform(100, 100)
   *     .scaleTransform(2, 2)
   *     .circle(0, 0, 25)
   *     .fill({ color: 0xff0000 });
   * // Reset transform to default state
   * graphics
   *     .resetTransform()
   *     .circle(50, 50, 25) // Will draw at actual coordinates
   *     .fill({ color: 0x00ff00 });
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#getTransform} For getting the current transform
   * @see {@link Graphics#setTransform} For setting a specific transform
   * @see {@link Graphics#save} For saving the current transform state
   * @see {@link Graphics#restore} For restoring a previous transform state
   */
  resetTransform() {
    return this._callContextMethod("resetTransform", []);
  }
  rotateTransform(...e) {
    return this._callContextMethod("rotate", e);
  }
  scaleTransform(...e) {
    return this._callContextMethod("scale", e);
  }
  setTransform(...e) {
    return this._callContextMethod("setTransform", e);
  }
  transform(...e) {
    return this._callContextMethod("transform", e);
  }
  translateTransform(...e) {
    return this._callContextMethod("translate", e);
  }
  /**
   * Clears all drawing commands from the graphics context, effectively resetting it.
   * This includes clearing the current path, fill style, stroke style, and transformations.
   *
   * > [!NOTE] Graphics objects are not designed to be continuously cleared and redrawn.
   * > Instead, they are intended to be used for static or semi-static graphics that
   * > can be redrawn as needed. Frequent clearing and redrawing may lead to performance issues.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Draw some shapes
   * graphics
   *     .circle(100, 100, 50)
   *     .fill({ color: 0xff0000 })
   *     .rect(200, 100, 100, 50)
   *     .fill({ color: 0x00ff00 });
   *
   * // Clear all graphics
   * graphics.clear();
   *
   * // Start fresh with new shapes
   * graphics
   *     .circle(150, 150, 30)
   *     .fill({ color: 0x0000ff });
   * ```
   * @returns The Graphics instance for method chaining
   * @see {@link Graphics#beginPath} For starting a new path without clearing styles
   * @see {@link Graphics#save} For saving the current state
   * @see {@link Graphics#restore} For restoring a previous state
   */
  clear() {
    return this._callContextMethod("clear", []);
  }
  /**
   * Gets or sets the current fill style for the graphics context. The fill style determines
   * how shapes are filled when using the fill() method.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic color fill
   * graphics.fillStyle = {
   *     color: 0xff0000,  // Red
   *     alpha: 1
   * };
   *
   * // Using gradients
   * const gradient = new FillGradient({
   *     end: { x: 0, y: 1 }, // Vertical gradient
   *     stops: [
   *         { offset: 0, color: 0xff0000, alpha: 1 }, // Start color
   *         { offset: 1, color: 0x0000ff, alpha: 1 }  // End color
   *     ]
   * });
   *
   * graphics.fillStyle = {
   *     fill: gradient,
   *     alpha: 0.8
   * };
   *
   * // Using patterns
   * graphics.fillStyle = {
   *     texture: myTexture,
   *     alpha: 1,
   *     matrix: new Matrix()
   *         .scale(0.5, 0.5)
   *         .rotate(Math.PI / 4)
   * };
   * ```
   * @type {ConvertedFillStyle}
   * @see {@link FillStyle} For all available fill style options
   * @see {@link FillGradient} For creating gradient fills
   * @see {@link Graphics#fill} For applying the fill to paths
   */
  get fillStyle() {
    return this._context.fillStyle;
  }
  set fillStyle(e) {
    this._context.fillStyle = e;
  }
  /**
   * Gets or sets the current stroke style for the graphics context. The stroke style determines
   * how paths are outlined when using the stroke() method.
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Basic stroke style
   * graphics.strokeStyle = {
   *     width: 2,
   *     color: 0xff0000,
   *     alpha: 1
   * };
   *
   * // Using with gradients
   * const gradient = new FillGradient({
   *   end: { x: 0, y: 1 },
   *   stops: [
   *       { offset: 0, color: 0xff0000, alpha: 1 },
   *       { offset: 1, color: 0x0000ff, alpha: 1 }
   *   ]
   * });
   *
   * graphics.strokeStyle = {
   *     width: 4,
   *     fill: gradient,
   *     alignment: 0.5,
   *     join: 'round',
   *     cap: 'round'
   * };
   *
   * // Complex stroke settings
   * graphics.strokeStyle = {
   *     width: 6,
   *     color: 0x00ff00,
   *     alpha: 0.5,
   *     join: 'miter',
   *     miterLimit: 10,
   * };
   * ```
   * @see {@link StrokeStyle} For all available stroke style options
   * @see {@link Graphics#stroke} For applying the stroke to paths
   */
  get strokeStyle() {
    return this._context.strokeStyle;
  }
  set strokeStyle(e) {
    this._context.strokeStyle = e;
  }
  /**
   * Creates a new Graphics object that copies the current graphics content.
   * The clone can either share the same context (shallow clone) or have its own independent
   * context (deep clone).
   * @example
   * ```ts
   * const graphics = new Graphics();
   *
   * // Create original graphics content
   * graphics
   *     .circle(100, 100, 50)
   *     .fill({ color: 0xff0000 });
   *
   * // Create a shallow clone (shared context)
   * const shallowClone = graphics.clone();
   *
   * // Changes to original affect the clone
   * graphics
   *     .circle(200, 100, 30)
   *     .fill({ color: 0x00ff00 });
   *
   * // Create a deep clone (independent context)
   * const deepClone = graphics.clone(true);
   *
   * // Modify deep clone independently
   * deepClone
   *     .translateTransform(100, 100)
   *     .circle(0, 0, 40)
   *     .fill({ color: 0x0000ff });
   * ```
   * @param deep - Whether to create a deep clone of the graphics object.
   *              If false (default), the context will be shared between objects.
   *              If true, creates an independent copy of the context.
   * @returns A new Graphics instance with either shared or copied context
   * @see {@link Graphics#context} For accessing the underlying graphics context
   * @see {@link GraphicsContext} For understanding the shared context behavior
   */
  clone(e = !1) {
    return e ? new fe(this._context.clone()) : (this._ownedContext = null, new fe(this._context));
  }
  // -------- v7 deprecations ---------
  /**
   * @param width
   * @param color
   * @param alpha
   * @deprecated since 8.0.0 Use {@link Graphics#setStrokeStyle} instead
   */
  lineStyle(e, t, s) {
    N(J, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
    const r = {};
    return e && (r.width = e), t && (r.color = t), s && (r.alpha = s), this.context.strokeStyle = r, this;
  }
  /**
   * @param color
   * @param alpha
   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
   */
  beginFill(e, t) {
    N(J, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
    const s = {};
    return e !== void 0 && (s.color = e), t !== void 0 && (s.alpha = t), this.context.fillStyle = s, this;
  }
  /**
   * @deprecated since 8.0.0 Use {@link Graphics#fill} instead
   */
  endFill() {
    N(J, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill();
    const e = this.context.strokeStyle;
    return (e.width !== $e.defaultStrokeStyle.width || e.color !== $e.defaultStrokeStyle.color || e.alpha !== $e.defaultStrokeStyle.alpha) && this.context.stroke(), this;
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#circle} instead
   */
  drawCircle(...e) {
    return N(J, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", e);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#ellipse} instead
   */
  drawEllipse(...e) {
    return N(J, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", e);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#poly} instead
   */
  drawPolygon(...e) {
    return N(J, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", e);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#rect} instead
   */
  drawRect(...e) {
    return N(J, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", e);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#roundRect} instead
   */
  drawRoundedRect(...e) {
    return N(J, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", e);
  }
  /**
   * @param {...any} args
   * @deprecated since 8.0.0 Use {@link Graphics#star} instead
   */
  drawStar(...e) {
    return N(J, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", e);
  }
}
class Wm extends au {
  constructor(e, t) {
    const { text: s, resolution: r, style: n, anchor: o, width: a, height: l, roundPixels: c, ...h } = e;
    super({
      ...h
    }), this.batched = !0, this._resolution = null, this._autoResolution = !0, this._didTextUpdate = !0, this._styleClass = t, this.text = s ?? "", this.style = n, this.resolution = r ?? null, this.allowChildren = !1, this._anchor = new Ae(
      {
        _onUpdate: () => {
          this.onViewUpdate();
        }
      }
    ), o && (this.anchor = o), this.roundPixels = c ?? !1, a !== void 0 && (this.width = a), l !== void 0 && (this.height = l);
  }
  /**
   * The anchor point of the text that controls the origin point for positioning and rotation.
   * Can be a number (same value for x/y) or a PointData object.
   * - (0,0) is top-left
   * - (0.5,0.5) is center
   * - (1,1) is bottom-right
   * ```ts
   * // Set anchor to center
   * const text = new Text({
   *     text: 'Hello Pixi!',
   *     anchor: 0.5 // Same as { x: 0.5, y: 0.5 }
   * });
   * // Set anchor to top-left
   * const text2 = new Text({
   *     text: 'Hello Pixi!',
   *     anchor: { x: 0, y: 0 } // Top-left corner
   * });
   * // Set anchor to bottom-right
   * const text3 = new Text({
   *     text: 'Hello Pixi!',
   *     anchor: { x: 1, y: 1 } // Bottom-right corner
   * });
   * ```
   * @default { x: 0, y: 0 }
   */
  get anchor() {
    return this._anchor;
  }
  set anchor(e) {
    typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e);
  }
  /**
   * The text content to display. Use '\n' for line breaks.
   * Accepts strings, numbers, or objects with toString() method.
   * @example
   * ```ts
   * const text = new Text({
   *     text: 'Hello Pixi!',
   * });
   * const multilineText = new Text({
   *     text: 'Line 1\nLine 2\nLine 3',
   * });
   * const numberText = new Text({
   *     text: 12345, // Will be converted to '12345'
   * });
   * const objectText = new Text({
   *     text: { toString: () => 'Object Text' }, // Custom toString
   * });
   *
   * // Update text dynamically
   * text.text = 'Updated Text'; // Re-renders with new text
   * text.text = 67890; // Updates to '67890'
   * text.text = { toString: () => 'Dynamic Text' }; // Uses custom toString method
   * // Clear text
   * text.text = ''; // Clears the text
   * ```
   * @default ''
   */
  set text(e) {
    e = e.toString(), this._text !== e && (this._text = e, this.onViewUpdate());
  }
  get text() {
    return this._text;
  }
  /**
   * The resolution/device pixel ratio for rendering.
   * Higher values result in sharper text at the cost of performance.
   * Set to null for auto-resolution based on device.
   * @example
   * ```ts
   * const text = new Text({
   *     text: 'Hello Pixi!',
   *     resolution: 2 // High DPI for sharper text
   * });
   * const autoResText = new Text({
   *     text: 'Auto Resolution',
   *     resolution: null // Use device's pixel ratio
   * });
   * ```
   * @default null
   */
  set resolution(e) {
    this._autoResolution = e === null, this._resolution = e, this.onViewUpdate();
  }
  get resolution() {
    return this._resolution;
  }
  get style() {
    return this._style;
  }
  /**
   * The style configuration for the text.
   * Can be a TextStyle instance or a configuration object.
   * Supports canvas text styles, HTML text styles, and bitmap text styles.
   * @example
   * ```ts
   * const text = new Text({
   *     text: 'Styled Text',
   *     style: {
   *         fontSize: 24,
   *         fill: 0xff1010, // Red color
   *         fontFamily: 'Arial',
   *         align: 'center', // Center alignment
   *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke
   *         dropShadow: {
   *             color: '#000000', // Black shadow
   *             blur: 4, // Shadow blur
   *             distance: 6 // Shadow distance
   *         }
   *     }
   * });
   * const htmlText = new HTMLText({
   *     text: 'HTML Styled Text',
   *     style: {
   *         fontSize: '20px',
   *         fill: 'blue',
   *         fontFamily: 'Verdana',
   *     }
   * });
   * const bitmapText = new BitmapText({
   *     text: 'Bitmap Styled Text',
   *     style: {
   *         fontName: 'Arial',
   *         fontSize: 32,
   *     }
   * })
   *
   * // Update style dynamically
   * text.style = {
   *     fontSize: 30, // Change font size
   *     fill: 0x00ff00, // Change color to green
   *     align: 'right', // Change alignment to right
   *     stroke: { color: '#000000', width: 2 }, // Add black stroke
   * }
   */
  set style(e) {
    e || (e = {}), this._style?.off("update", this.onViewUpdate, this), e instanceof this._styleClass ? this._style = e : this._style = new this._styleClass(e), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate();
  }
  /**
   * The width of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set width directly
   * texture.width = 200;
   * console.log(texture.scale.x); // Scale adjusted to match width
   *
   * // For better performance when setting both width and height
   * texture.setSize(300, 400); // Avoids recalculating bounds twice
   * ```
   */
  get width() {
    return Math.abs(this.scale.x) * this.bounds.width;
  }
  set width(e) {
    this._setWidth(e, this.bounds.width);
  }
  /**
   * The height of the sprite, setting this will actually modify the scale to achieve the value set.
   * @example
   * ```ts
   * // Set height directly
   * texture.height = 200;
   * console.log(texture.scale.y); // Scale adjusted to match height
   *
   * // For better performance when setting both width and height
   * texture.setSize(300, 400); // Avoids recalculating bounds twice
   * ```
   */
  get height() {
    return Math.abs(this.scale.y) * this.bounds.height;
  }
  set height(e) {
    this._setHeight(e, this.bounds.height);
  }
  /**
   * Retrieves the size of the Text as a [Size]{@link Size} object based on the texture dimensions and scale.
   * This is faster than getting width and height separately as it only calculates the bounds once.
   * @example
   * ```ts
   * // Basic size retrieval
   * const text = new Text({
   *     text: 'Hello Pixi!',
   *     style: { fontSize: 24 }
   * });
   * const size = text.getSize();
   * console.log(`Size: ${size.width}x${size.height}`);
   *
   * // Reuse existing size object
   * const reuseSize = { width: 0, height: 0 };
   * text.getSize(reuseSize);
   * ```
   * @param out - Optional object to store the size in, to avoid allocating a new object
   * @returns The size of the Sprite
   * @see {@link Text#width} For getting just the width
   * @see {@link Text#height} For getting just the height
   * @see {@link Text#setSize} For setting both width and height
   */
  getSize(e) {
    return e || (e = {}), e.width = Math.abs(this.scale.x) * this.bounds.width, e.height = Math.abs(this.scale.y) * this.bounds.height, e;
  }
  /**
   * Sets the size of the Text to the specified width and height.
   * This is faster than setting width and height separately as it only recalculates bounds once.
   * @example
   * ```ts
   * // Basic size setting
   * const text = new Text({
   *    text: 'Hello Pixi!',
   *    style: { fontSize: 24 }
   * });
   * text.setSize(100, 200); // Width: 100, Height: 200
   *
   * // Set uniform size
   * text.setSize(100); // Sets both width and height to 100
   *
   * // Set size with object
   * text.setSize({
   *     width: 200,
   *     height: 300
   * });
   * ```
   * @param value - This can be either a number or a {@link Size} object
   * @param height - The height to set. Defaults to the value of `width` if not provided
   * @see {@link Text#width} For setting width only
   * @see {@link Text#height} For setting height only
   */
  setSize(e, t) {
    typeof e == "object" ? (t = e.height ?? e.width, e = e.width) : t ?? (t = e), e !== void 0 && this._setWidth(e, this.bounds.width), t !== void 0 && this._setHeight(t, this.bounds.height);
  }
  /**
   * Checks if the object contains the given point in local coordinates.
   * Uses the text's bounds for hit testing.
   * @example
   * ```ts
   * // Basic point check
   * const localPoint = { x: 50, y: 25 };
   * const contains = text.containsPoint(localPoint);
   * console.log('Point is inside:', contains);
   * ```
   * @param point - The point to check in local coordinates
   * @returns True if the point is within the text's bounds
   * @see {@link Container#toLocal} For converting global coordinates to local
   */
  containsPoint(e) {
    const t = this.bounds.width, s = this.bounds.height, r = -t * this.anchor.x;
    let n = 0;
    return e.x >= r && e.x <= r + t && (n = -s * this.anchor.y, e.y >= n && e.y <= n + s);
  }
  /** @internal */
  onViewUpdate() {
    this.didViewUpdate || (this._didTextUpdate = !0), super.onViewUpdate();
  }
  /**
   * Destroys this text renderable and optionally its style texture.
   * @param options - Options parameter. A boolean will act as if all options
   *  have been set to that value
   * @example
   * // Destroys the text and its style
   * text.destroy({ style: true, texture: true, textureSource: true });
   * text.destroy(true);
   * text.destroy() // Destroys the text, but not its style
   */
  destroy(e = !1) {
    super.destroy(e), this.owner = null, this._bounds = null, this._anchor = null, (typeof e == "boolean" ? e : e?.style) && this._style.destroy(e), this._style = null, this._text = null;
  }
  /**
   * Returns a unique key for this instance.
   * This key is used for caching.
   * @returns {string} Unique key for the instance
   */
  get styleKey() {
    return `${this._text}:${this._style.styleKey}:${this._resolution}`;
  }
}
function Vm(i, e) {
  let t = i[0] ?? {};
  return (typeof t == "string" || i[1]) && (N(J, `use new ${e}({ text: "hi!", style }) instead`), t = {
    text: t,
    style: i[1]
  }), t;
}
let Bt = null, yt = null;
function yS(i, e) {
  Bt || (Bt = re.get().createCanvas(256, 128), yt = Bt.getContext("2d", { willReadFrequently: !0 }), yt.globalCompositeOperation = "copy", yt.globalAlpha = 1), (Bt.width < i || Bt.height < e) && (Bt.width = ci(i), Bt.height = ci(e));
}
function $d(i, e, t) {
  for (let s = 0, r = 4 * t * e; s < e; ++s, r += 4)
    if (i[r + 3] !== 0)
      return !1;
  return !0;
}
function Yd(i, e, t, s, r) {
  const n = 4 * e;
  for (let o = s, a = s * n + 4 * t; o <= r; ++o, a += n)
    if (i[a + 3] !== 0)
      return !1;
  return !0;
}
function vS(...i) {
  let e = i[0];
  e.canvas || (e = { canvas: i[0], resolution: i[1] });
  const { canvas: t } = e, s = Math.min(e.resolution ?? 1, 1), r = e.width ?? t.width, n = e.height ?? t.height;
  let o = e.output;
  if (yS(r, n), !yt)
    throw new TypeError("Failed to get canvas 2D context");
  yt.drawImage(
    t,
    0,
    0,
    r,
    n,
    0,
    0,
    r * s,
    n * s
  );
  const l = yt.getImageData(0, 0, r, n).data;
  let c = 0, h = 0, u = r - 1, d = n - 1;
  for (; h < n && $d(l, r, h); )
    ++h;
  if (h === n)
    return G.EMPTY;
  for (; $d(l, r, d); )
    --d;
  for (; Yd(l, r, c, h, d); )
    ++c;
  for (; Yd(l, r, u, h, d); )
    --u;
  return ++u, ++d, yt.globalCompositeOperation = "source-over", yt.strokeRect(c, h, u - c, d - h), yt.globalCompositeOperation = "copy", o ?? (o = new G()), o.set(c / s, h / s, (u - c) / s, (d - h) / s), o;
}
const Xd = new G();
class _S {
  /**
   * Creates a canvas with the specified text rendered to it.
   *
   * Generates a canvas of appropriate size, renders the text with the provided style,
   * and returns both the canvas/context and a Rectangle representing the text bounds.
   *
   * When trim is enabled in the style, the frame will represent the bounds of the
   * non-transparent pixels, which can be smaller than the full canvas.
   * @param options - The options for generating the text canvas
   * @param options.text - The text to render
   * @param options.style - The style to apply to the text
   * @param options.resolution - The resolution of the canvas (defaults to 1)
   * @param options.padding
   * @returns An object containing the canvas/context and the frame (bounds) of the text
   */
  getCanvasAndContext(e) {
    const { text: t, style: s, resolution: r = 1 } = e, n = s._getFinalPadding(), o = Ge.measureText(t || " ", s), a = Math.ceil(Math.ceil(Math.max(1, o.width) + n * 2) * r), l = Math.ceil(Math.ceil(Math.max(1, o.height) + n * 2) * r), c = rs.getOptimalCanvasAndContext(a, l);
    this._renderTextToCanvas(t, s, n, r, c);
    const h = s.trim ? vS({ canvas: c.canvas, width: a, height: l, resolution: 1, output: Xd }) : Xd.set(0, 0, a, l);
    return {
      canvasAndContext: c,
      frame: h
    };
  }
  /**
   * Returns a canvas and context to the pool.
   *
   * This should be called when you're done with the canvas to allow reuse
   * and prevent memory leaks.
   * @param canvasAndContext - The canvas and context to return to the pool
   */
  returnCanvasAndContext(e) {
    rs.returnCanvasAndContext(e);
  }
  /**
   * Renders text to its canvas, and updates its texture.
   * @param text - The text to render
   * @param style - The style of the text
   * @param padding - The padding of the text
   * @param resolution - The resolution of the text
   * @param canvasAndContext - The canvas and context to render the text to
   */
  _renderTextToCanvas(e, t, s, r, n) {
    const { canvas: o, context: a } = n, l = rr(t), c = Ge.measureText(e || " ", t), h = c.lines, u = c.lineHeight, d = c.lineWidths, f = c.maxLineWidth, m = c.fontProperties, g = o.height;
    if (a.resetTransform(), a.scale(r, r), a.textBaseline = t.textBaseline, t._stroke?.width) {
      const v = t._stroke;
      a.lineWidth = v.width, a.miterLimit = v.miterLimit, a.lineJoin = v.join, a.lineCap = v.cap;
    }
    a.font = l;
    let p, x;
    const y = t.dropShadow ? 2 : 1;
    for (let v = 0; v < y; ++v) {
      const _ = t.dropShadow && v === 0, b = _ ? Math.ceil(Math.max(1, g) + s * 2) : 0, T = b * r;
      if (_) {
        a.fillStyle = "black", a.strokeStyle = "black";
        const k = t.dropShadow, S = k.color, C = k.alpha;
        a.shadowColor = pe.shared.setValue(S).setAlpha(C).toRgbaString();
        const U = k.blur * r, R = k.distance * r;
        a.shadowBlur = U, a.shadowOffsetX = Math.cos(k.angle) * R, a.shadowOffsetY = Math.sin(k.angle) * R + T;
      } else {
        if (a.fillStyle = t._fill ? ar(t._fill, a, c, s * 2) : null, t._stroke?.width) {
          const k = t._stroke.width * 0.5 + s * 2;
          a.strokeStyle = ar(t._stroke, a, c, k);
        }
        a.shadowColor = "black";
      }
      let w = (u - m.fontSize) / 2;
      u - m.fontSize < 0 && (w = 0);
      const A = t._stroke?.width ?? 0;
      for (let k = 0; k < h.length; k++)
        p = A / 2, x = A / 2 + k * u + m.ascent + w, t.align === "right" ? p += f - d[k] : t.align === "center" && (p += (f - d[k]) / 2), t._stroke?.width && this._drawLetterSpacing(
          h[k],
          t,
          n,
          p + s,
          x + s - b,
          !0
        ), t._fill !== void 0 && this._drawLetterSpacing(
          h[k],
          t,
          n,
          p + s,
          x + s - b
        );
    }
  }
  /**
   * Render the text with letter-spacing.
   *
   * This method handles rendering text with the correct letter spacing, using either:
   * 1. Native letter spacing if supported by the browser
   * 2. Manual letter spacing calculation if not natively supported
   *
   * For manual letter spacing, it calculates the position of each character
   * based on its width and the desired spacing.
   * @param text - The text to draw
   * @param style - The text style to apply
   * @param canvasAndContext - The canvas and context to draw to
   * @param x - Horizontal position to draw the text
   * @param y - Vertical position to draw the text
   * @param isStroke - Whether to render the stroke (true) or fill (false)
   * @private
   */
  _drawLetterSpacing(e, t, s, r, n, o = !1) {
    const { context: a } = s, l = t.letterSpacing;
    let c = !1;
    if (Ge.experimentalLetterSpacingSupported && (Ge.experimentalLetterSpacing ? (a.letterSpacing = `${l}px`, a.textLetterSpacing = `${l}px`, c = !0) : (a.letterSpacing = "0px", a.textLetterSpacing = "0px")), l === 0 || c) {
      o ? a.strokeText(e, r, n) : a.fillText(e, r, n);
      return;
    }
    let h = r;
    const u = Ge.graphemeSegmenter(e);
    let d = a.measureText(e).width, f = 0;
    for (let m = 0; m < u.length; ++m) {
      const g = u[m];
      o ? a.strokeText(g, h, n) : a.fillText(g, h, n);
      let p = "";
      for (let x = m + 1; x < u.length; ++x)
        p += u[x];
      f = a.measureText(p).width, h += d - f + l, d = f;
    }
  }
}
const qd = new _S();
class bS extends Wm {
  constructor(...e) {
    const t = Vm(e, "Text");
    super(t, Ze), this.renderPipeId = "text", t.textureStyle && (this.textureStyle = t.textureStyle instanceof hi ? t.textureStyle : new hi(t.textureStyle));
  }
  /** @private */
  updateBounds() {
    const e = this._bounds, t = this._anchor;
    let s = 0, r = 0;
    if (this._style.trim) {
      const { frame: n, canvasAndContext: o } = qd.getCanvasAndContext({
        text: this.text,
        style: this._style,
        resolution: 1
      });
      qd.returnCanvasAndContext(o), s = n.width, r = n.height;
    } else {
      const n = Ge.measureText(
        this._text,
        this._style
      );
      s = n.width, r = n.height;
    }
    e.minX = -t._x * s, e.maxX = e.minX + s, e.minY = -t._y * r, e.maxY = e.minY + r;
  }
}
class wS extends Wm {
  constructor(...e) {
    var t;
    const s = Vm(e, "BitmapText");
    s.style ?? (s.style = s.style || {}), (t = s.style).fill ?? (t.fill = 16777215), super(s, Ze), this.renderPipeId = "bitmapText";
  }
  /** @private */
  updateBounds() {
    const e = this._bounds, t = this._anchor, s = lr.measureText(this.text, this._style), r = s.scale, n = s.offsetY * r;
    let o = s.width * r, a = s.height * r;
    const l = this._style._stroke;
    l && (o += l.width, a += l.width), e.minX = -t._x * o, e.maxX = e.minX + o, e.minY = -t._y * (a + n), e.maxY = e.minY + a;
  }
  /**
   * The resolution / device pixel ratio for text rendering.
   * Unlike other text types, BitmapText resolution is managed by the BitmapFont.
   * Individual resolution changes are not supported.
   * @example
   * ```ts
   * //  Incorrect: Setting resolution directly (will trigger warning)
   * const text = new BitmapText({
   *     text: 'Hello',
   *     resolution: 2 // This will be ignored
   * });
   *
   * //  Correct: Set resolution when installing the font
   * BitmapFont.install({
   *     name: 'MyFont',
   *     style: {
   *         fontFamily: 'Arial',
   *     },
   *     resolution: 2 // Resolution is set here
   * });
   *
   * const text = new BitmapText({
   *     text: 'Hello',
   *     style: {
   *         fontFamily: 'MyFont' // Uses font's resolution
   *     }
   * });
   * ```
   * @default 1
   * @see {@link BitmapFont.install} For setting font resolution
   * @throws {Warning} When attempting to change resolution directly
   * @readonly
   */
  set resolution(e) {
    e !== null && se(
      // eslint-disable-next-line max-len
      "[BitmapText] dynamically updating the resolution is not supported. Resolution should be managed by the BitmapFont."
    );
  }
  get resolution() {
    return this._resolution;
  }
}
class Pe extends L {
  static create(e) {
    return new Pe({
      source: new Ke(e)
    });
  }
  /**
   * Resizes the render texture.
   * @param width - The new width of the render texture.
   * @param height - The new height of the render texture.
   * @param resolution - The new resolution of the render texture.
   * @returns This texture.
   */
  resize(e, t, s) {
    return this.source.resize(e, t, s), this;
  }
}
function TS(i) {
  const { text: e, style: t, chars: s } = i, r = t, n = lr.getFont(e, r), o = Ge.graphemeSegmenter(e), a = Pm(o, r, n, !0), l = a.scale, c = [], h = [], u = [], d = t.lineHeight ? t.lineHeight : n.lineHeight * l;
  let f = 0;
  for (const m of a.lines) {
    if (m.chars.length === 0)
      continue;
    const g = new oe({ label: "line" });
    g.y = f, u.push(g);
    let p = new oe({ label: "word" }), x = 0;
    for (let y = 0; y < m.chars.length; y++) {
      const v = m.chars[y];
      if (!v || !n.chars[v])
        continue;
      const b = v === " ", T = y === m.chars.length - 1;
      let w;
      s.length > 0 ? (w = s.shift(), w.text = v, w.style = r, w.label = `char-${v}`, w.x = m.charPositions[y] * l - m.charPositions[x] * l) : w = new wS({
        text: v,
        style: r,
        label: `char-${v}`,
        x: m.charPositions[y] * l - m.charPositions[x] * l
      }), b || (c.push(w), p.addChild(w)), (b || T) && p.children.length > 0 && (p.x = m.charPositions[x] * l, h.push(p), g.addChild(p), p = new oe({ label: "word" }), x = y + 1);
    }
    f += d;
  }
  return { chars: c, lines: u, words: h };
}
class SS extends oe {
  constructor(e) {
    const {
      text: t,
      style: s,
      autoSplit: r,
      lineAnchor: n,
      wordAnchor: o,
      charAnchor: a,
      ...l
    } = e;
    super(l), this._dirty = !1, this._canReuseChars = !1, this.chars = [], this.words = [], this.lines = [], this._originalText = t, this._autoSplit = r, this._lineAnchor = n, this._wordAnchor = o, this._charAnchor = a, this.style = s;
  }
  /**
   * Splits the text into lines, words, and characters.
   * Call this manually when autoSplit is false.
   * @example Manual Splitting
   * ```ts
   * const text = new SplitText({
   *   text: 'Manual Update',
   *   autoSplit: false
   * });
   *
   * text.text = 'New Content';
   * text.style = { fontSize: 32 };
   * text.split(); // Apply changes
   * ```
   */
  split() {
    const e = this.splitFn();
    this.chars = e.chars, this.words = e.words, this.lines = e.lines, this.addChild(...this.lines), this.charAnchor = this._charAnchor, this.wordAnchor = this._wordAnchor, this.lineAnchor = this._lineAnchor, this._dirty = !1, this._canReuseChars = !0;
  }
  get text() {
    return this._originalText;
  }
  /**
   * Gets or sets the text content.
   * Setting new text triggers splitting if autoSplit is true.
   * > [!NOTE] Setting this frequently can have a performance impact, especially with large texts and canvas text.
   * @example Dynamic Text Updates
   * ```ts
   * const text = new SplitText({
   *   text: 'Original',
   *   autoSplit: true
   * });
   *
   * // Auto-splits on change
   * text.text = 'Updated Content';
   *
   * // Manual update
   * text.autoSplit = false;
   * text.text = 'Manual Update';
   * text.split();
   * ```
   */
  set text(e) {
    this._originalText = e, this.lines.forEach((t) => t.destroy({ children: !0 })), this.lines.length = 0, this.words.length = 0, this.chars.length = 0, this._canReuseChars = !1, this.onTextUpdate();
  }
  _setOrigin(e, t, s) {
    let r;
    typeof e == "number" ? r = { x: e, y: e } : r = { x: e.x, y: e.y }, t.forEach((n) => {
      const o = n.getLocalBounds(), a = o.minX + o.width * r.x, l = o.minY + o.height * r.y;
      n.origin.set(a, l);
    }), this[s] = e;
  }
  /**
   * Gets or sets the transform anchor for line segments.
   * The anchor point determines the center of rotation and scaling for each line.
   * @example Setting Line Anchors
   * ```ts
   * // Center rotation/scaling
   * text.lineAnchor = 0.5;
   *
   * // Rotate/scale from top-right corner
   * text.lineAnchor = { x: 1, y: 0 };
   *
   * // Custom anchor point
   * text.lineAnchor = {
   *   x: 0.2, // 20% from left
   *   y: 0.8  // 80% from top
   * };
   * ```
   */
  get lineAnchor() {
    return this._lineAnchor;
  }
  set lineAnchor(e) {
    this._setOrigin(e, this.lines, "_lineAnchor");
  }
  /**
   * Gets or sets the transform anchor for word segments.
   * The anchor point determines the center of rotation and scaling for each word.
   * @example
   * ```ts
   * // Center each word
   * text.wordAnchor = 0.5;
   *
   * // Scale from bottom-left
   * text.wordAnchor = { x: 0, y: 1 };
   *
   * // Rotate around custom point
   * text.wordAnchor = {
   *   x: 0.75,  // 75% from left
   *   y: 0.5    // Middle vertically
   * };
   * ```
   */
  get wordAnchor() {
    return this._wordAnchor;
  }
  set wordAnchor(e) {
    this._setOrigin(e, this.words, "_wordAnchor");
  }
  /**
   * Gets or sets the transform anchor for character segments.
   * The anchor point determines the center of rotation and scaling for each character.
   * @example Setting Character Anchors
   * ```ts
   * // Center each character
   * text.charAnchor = 0.5;
   *
   * // Rotate from top-center
   * text.charAnchor = { x: 0.5, y: 0 };
   *
   * // Scale from bottom-right
   * text.charAnchor = { x: 1, y: 1 };
   * ```
   * @example Animation with Anchors
   * ```ts
   * // Rotate characters around their centers
   * text.charAnchor = 0.5;
   * text.chars.forEach((char, i) => {
   *   gsap.to(char, {
   *     rotation: Math.PI * 2,
   *     duration: 1,
   *     delay: i * 0.1,
   *     repeat: -1
   *   });
   * });
   * ```
   */
  get charAnchor() {
    return this._charAnchor;
  }
  set charAnchor(e) {
    this._setOrigin(e, this.chars, "_charAnchor");
  }
  get style() {
    return this._style;
  }
  /**
   * The style configuration for the text.
   * Can be a TextStyle instance or a configuration object.
   * @example
   * ```ts
   * const text = new Text({
   *     text: 'Styled Text',
   *     style: {
   *         fontSize: 24,
   *         fill: 0xff1010, // Red color
   *         fontFamily: 'Arial',
   *         align: 'center', // Center alignment
   *         stroke: { color: '#4a1850', width: 5 }, // Purple stroke
   *         dropShadow: {
   *             color: '#000000', // Black shadow
   *             blur: 4, // Shadow blur
   *             distance: 6 // Shadow distance
   *         }
   *     }
   * });
   * // Update style dynamically
   * text.style = {
   *     fontSize: 30, // Change font size
   *     fill: 0x00ff00, // Change color to green
   *     align: 'right', // Change alignment to right
   *     stroke: { color: '#000000', width: 2 }, // Add black stroke
   * }
   */
  set style(e) {
    e || (e = {}), this._style = new Ze(e), this.words.forEach((t) => t.destroy()), this.words.length = 0, this.lines.forEach((t) => t.destroy()), this.lines.length = 0, this._canReuseChars = !0, this.onTextUpdate();
  }
  onTextUpdate() {
    this._dirty = !0, this._autoSplit && this.split();
  }
  /**
   * Destroys the SplitText instance and all its resources.
   * Cleans up all segment arrays, event listeners, and optionally the text style.
   * @param options - Destroy configuration options
   * @example
   * ```ts
   * // Clean up everything
   * text.destroy({ children: true, texture: true, style: true });
   *
   * // Remove from parent but keep style
   * text.destroy({ children: true, style: false });
   * ```
   */
  destroy(e) {
    super.destroy(e), this.chars = [], this.words = [], this.lines = [], (typeof e == "boolean" ? e : e?.style) && this._style.destroy(e), this._style = null, this._originalText = "";
  }
}
const $m = class Xs extends SS {
  constructor(e) {
    const t = {
      ...Xs.defaultOptions,
      ...e
    };
    super(t);
  }
  /**
   * Creates a SplitBitmapText instance from an existing text object.
   * Useful for converting standard Text or BitmapText objects into segmented versions.
   * @param text - The source text object to convert
   * @param options - Additional splitting options
   * @returns A new SplitBitmapText instance
   * @example
   * ```ts
   * const bitmapText = new BitmapText({
   *   text: 'Bitmap Text',
   *   style: { fontFamily: 'Arial' }
   * });
   *
   * const segmented = SplitBitmapText.from(bitmapText);
   *
   * // with additional options
   * const segmentedWithOptions = SplitBitmapText.from(bitmapText, {
   *   autoSplit: false,
   *   lineAnchor: 0.5,
   *   wordAnchor: { x: 0, y: 0.5 },
   * })
   * ```
   */
  static from(e, t) {
    const s = {
      ...Xs.defaultOptions,
      ...t,
      text: e.text,
      style: new Ze(e.style)
    };
    return new Xs({
      ...s
    });
  }
  splitFn() {
    return TS({
      text: this._originalText,
      style: this._style,
      chars: this._canReuseChars ? this.chars : []
    });
  }
};
$m.defaultOptions = {
  autoSplit: !0,
  // Auto-update on text/style changes
  lineAnchor: 0,
  // Top-left alignment
  wordAnchor: 0,
  // Top-left alignment
  charAnchor: 0
  // Top-left alignment
};
let CS = $m;
ke.add(bb, wb);
function ge(i) {
  if (i != null) {
    if (typeof i == "number") return i;
    if (typeof i == "string") {
      if (i === "transparent") return;
      if (i.startsWith("#")) {
        const t = parseInt(i.slice(1), 16);
        if (!isNaN(t)) return t;
      }
      if (i.startsWith("0x")) {
        const t = parseInt(i, 16);
        if (!isNaN(t)) return t;
      }
      const e = parseInt(i, 16);
      if (!isNaN(e)) return e;
      try {
        return new pe(i).toNumber();
      } catch {
        return;
      }
    }
  }
}
const Ym = (i) => i === "transparent", Nt = (i, e = 16777215) => Ym(i) ? { color: e, alpha: 0 } : {
  color: ge(i) ?? e,
  alpha: 1
};
class Ft extends Yt {
  type = "Caption";
  ready;
  _meta = {
    duration: 1 / 0,
    width: 0,
    height: 0
  };
  get meta() {
    return { ...this._meta };
  }
  /**
   * Caption text content (hybrid JSON structure)
   */
  text;
  // Text styling (hybrid JSON structure)
  // Provides direct access to styling properties
  get style() {
    if (!this.originalOpts) return {};
    const e = this.originalOpts;
    return {
      fontSize: e.fontSize,
      fontFamily: e.fontFamily,
      fontWeight: e.fontWeight,
      fontStyle: e.fontStyle,
      color: e.fill,
      align: e.align,
      textCase: e.textCase,
      stroke: e.stroke ? typeof e.stroke == "object" ? { color: e.stroke.color, width: e.stroke.width } : { color: e.stroke, width: e.strokeWidth ?? 0 } : void 0,
      shadow: e.dropShadow ? {
        color: e.dropShadow.color ?? "#000000",
        alpha: e.dropShadow.alpha ?? 0.5,
        blur: e.dropShadow.blur ?? 4,
        distance: e.dropShadow.distance ?? 0,
        angle: e.dropShadow.angle ?? 0
      } : void 0
    };
  }
  set style(e) {
    this.updateStyle(e);
  }
  get fontFamily() {
    return this.opts.fontFamily;
  }
  set fontFamily(e) {
    this.updateStyle({ fontFamily: e });
  }
  get fontUrl() {
    return this.opts.fontUrl;
  }
  set fontUrl(e) {
    this.updateStyle({ fontUrl: e });
  }
  get fontSize() {
    return this.opts.fontSize;
  }
  set fontSize(e) {
    this.updateStyle({ fontSize: e });
  }
  get fontWeight() {
    return this.opts.fontWeight;
  }
  set fontWeight(e) {
    this.updateStyle({ fontWeight: e });
  }
  get fontStyle() {
    return this.opts.fontStyle;
  }
  set fontStyle(e) {
    this.updateStyle({ fontStyle: e });
  }
  get fill() {
    return this.opts.fill;
  }
  set fill(e) {
    this.updateStyle({ fill: e });
  }
  get align() {
    return this.opts.align;
  }
  set align(e) {
    this.updateStyle({ align: e });
  }
  get stroke() {
    return this.originalOpts?.stroke;
  }
  set stroke(e) {
    this.updateStyle({ stroke: e });
  }
  get strokeWidth() {
    return this.opts.strokeWidth;
  }
  set strokeWidth(e) {
    this.updateStyle({ strokeWidth: e });
  }
  get dropShadow() {
    return this.originalOpts?.dropShadow;
  }
  set dropShadow(e) {
    this.updateStyle({ dropShadow: e });
  }
  get caption() {
    return this.originalOpts?.caption;
  }
  set caption(e) {
    this.updateStyle({ caption: e });
  }
  /**
   * Bottom offset from video bottom (hybrid JSON structure)
   */
  bottomOffset;
  /**
   * Text case proxy
   */
  get textCase() {
    return this.originalOpts?.textCase || "none";
  }
  set textCase(e) {
    this.updateStyle({ textCase: e });
  }
  /**
   * Unique identifier for this clip instance
   */
  id = `clip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  /**
   * Media ID of the source clip
   */
  get mediaId() {
    return this.opts.mediaId;
  }
  set mediaId(e) {
    this.opts.mediaId = e, this.originalOpts && (this.originalOpts.mediaId = e);
  }
  /**
   * Array of effects to be applied to this clip
   * Each effect specifies key, startTime, duration, and optional targets
   */
  effects = [];
  /**
   * Words getter for the clip
   */
  get words() {
    return this.opts.words;
  }
  /**
   * Words setter that triggers re-render and ensures consistency
   */
  set words(e) {
    this.opts.words = e, this.originalOpts && (this.originalOpts.caption ? this.originalOpts.caption.words = e : this.originalOpts.words = e), this.text = e.map((t) => t.text).filter((t) => t && t.trim() !== "").join(" "), this.refreshCaptions().then(() => {
      this.emit("propsChange", {});
    });
  }
  // Internal opts with defaults applied - use 'any' for complex union types
  opts;
  // Pixi rendering fields (to mirror TextClip)
  pixiTextContainer = null;
  renderTexture = null;
  wordTexts = [];
  extraPadding = 0;
  textStyle;
  externalRenderer = null;
  pixiApp = null;
  originalOpts = null;
  constructor(e, t = {}, s) {
    super(), this.text = e, this.originalOpts = { ...t }, this.externalRenderer = s ?? null, this.opts = {
      fontSize: t.fontSize ?? 30,
      fontFamily: t.fontFamily ?? "Arial",
      fontUrl: t.fontUrl ?? "",
      fontWeight: t.fontWeight ?? "normal",
      fontStyle: t.fontStyle ?? "normal",
      fill: t.fill ?? "#ffffff",
      strokeWidth: t.strokeWidth ?? 0,
      align: t.align ?? "center",
      wordWrapWidth: t.wordWrapWidth ?? 0,
      wordWrap: t.wordWrap ?? !1,
      lineHeight: t.lineHeight ?? 1,
      letterSpacing: t.letterSpacing ?? 0,
      textCase: t.textCase ?? "none",
      videoWidth: t.caption?.positioning?.videoWidth ?? t.videoWidth ?? 1280,
      videoHeight: t.caption?.positioning?.videoHeight ?? t.videoHeight ?? 720,
      bottomOffset: t.caption?.positioning?.bottomOffset ?? t.bottomOffset ?? 30,
      keyword: t.caption?.colors?.keyword ?? t.colors?.keyword ?? "#ffff00",
      background: t.caption?.colors?.background ?? t.colors?.background ?? "#000000",
      active: t.caption?.colors?.active ?? t.colors?.active ?? "#ffffff",
      activeFill: t.caption?.colors?.activeFill ?? t.colors?.activeFill ?? "#00ff00",
      appeared: t.caption?.colors?.appeared ?? t.colors?.appeared ?? "#ffffff",
      words: t.caption?.words ?? t.words ?? [],
      preserveKeywordColor: t.caption?.preserveKeywordColor ?? t.preserveKeywordColor ?? !1,
      mediaId: t.mediaId
    };
    const r = {
      fontSize: this.opts.fontSize,
      fontFamily: this.opts.fontFamily,
      fontWeight: this.opts.fontWeight,
      fontStyle: this.opts.fontStyle,
      align: this.opts.align
    };
    if (t.fill && typeof t.fill == "object" && t.fill.type === "gradient") {
      const a = new qe(
        t.fill.x0,
        t.fill.y0,
        t.fill.x1,
        t.fill.y1
      );
      t.fill.colors.forEach(({ ratio: l, color: c }) => {
        const h = typeof c == "number" ? c : ge(c) ?? 16777215;
        a.addColorStop(l, h);
      }), r.fill = { fill: a };
    } else {
      let a;
      t.fill === "transparent" ? a = 16777215 : (typeof t.fill == "string" || typeof t.fill == "number") && (a = ge(t.fill)), r.fill = a ?? 16777215;
    }
    const n = (a) => a === "transparent";
    if (t.stroke && typeof t.stroke == "object" && "color" in t.stroke) {
      if (!n(t.stroke.color)) {
        const a = ge(t.stroke.color);
        a !== void 0 && (r.stroke = {
          color: a,
          width: t.stroke.width
        }, t.stroke.join && (r.stroke.join = t.stroke.join));
      }
    } else if (!n(t.stroke)) {
      const a = ge(t.stroke);
      a !== void 0 ? r.stroke = {
        color: a,
        width: this.opts.strokeWidth ?? 0
      } : this.opts.strokeWidth && this.opts.strokeWidth > 0 && (r.stroke = {
        color: 0,
        width: this.opts.strokeWidth
      });
    }
    if (t.dropShadow) {
      const a = ge(t.dropShadow.color);
      a !== void 0 && (r.dropShadow = {
        color: a,
        alpha: t.dropShadow.alpha ?? 0.5,
        blur: t.dropShadow.blur ?? 4,
        angle: t.dropShadow.angle ?? Math.PI / 6,
        distance: t.dropShadow.distance ?? 2
      });
    }
    const o = new Ze(r);
    this.textStyle = o, this.ready = (async () => {
      await this.refreshCaptions();
      const a = { ...this._meta };
      return K.info("CaptionClip ready:", a), a;
    })();
  }
  /**
   * Update text styling options and refresh the caption rendering
   */
  async updateStyle(e) {
    this.originalOpts || (this.originalOpts = {}), this.originalOpts = { ...this.originalOpts, ...e }, e.fontSize !== void 0 && (this.opts.fontSize = e.fontSize), e.fontFamily !== void 0 && (this.opts.fontFamily = e.fontFamily), e.fontUrl !== void 0 && (this.opts.fontUrl = e.fontUrl), e.fontWeight !== void 0 && (this.opts.fontWeight = e.fontWeight), e.fontStyle !== void 0 && (this.opts.fontStyle = e.fontStyle), e.fill !== void 0 && (this.opts.fill = e.fill), e.align !== void 0 && (this.opts.align = e.align), e.letterSpacing !== void 0 && (this.opts.letterSpacing = e.letterSpacing), e.lineHeight !== void 0 && (this.opts.lineHeight = e.lineHeight), e.textCase !== void 0 && (this.opts.textCase = e.textCase), e.caption?.colors && (e.caption.colors.appeared !== void 0 && (this.opts.appeared = e.caption.colors.appeared), e.caption.colors.active !== void 0 && (this.opts.active = e.caption.colors.active), e.caption.colors.activeFill !== void 0 && (this.opts.activeFill = e.caption.colors.activeFill), e.caption.colors.background !== void 0 && (this.opts.background = e.caption.colors.background), e.caption.colors.keyword !== void 0 && (this.opts.keyword = e.caption.colors.keyword)), e.caption?.preserveKeywordColor !== void 0 && (this.opts.preserveKeywordColor = e.caption.preserveKeywordColor);
    const t = {
      fontSize: this.opts.fontSize,
      fontFamily: this.opts.fontFamily,
      fontWeight: this.opts.fontWeight,
      fontStyle: this.opts.fontStyle,
      align: this.opts.align
    };
    if (this.opts.fill && typeof this.opts.fill == "object" && this.opts.fill.type === "gradient") {
      const r = new qe(
        this.opts.fill.x0,
        this.opts.fill.y0,
        this.opts.fill.x1,
        this.opts.fill.y1
      );
      this.opts.fill.colors.forEach(({ ratio: n, color: o }) => {
        const a = typeof o == "number" ? o : ge(o) ?? 16777215;
        r.addColorStop(n, a);
      }), t.fill = { fill: r };
    } else {
      const r = typeof this.opts.fill == "string" || typeof this.opts.fill == "number" ? ge(this.opts.fill) : void 0;
      t.fill = r ?? 16777215;
    }
    if (e.stroke !== void 0 || e.strokeWidth !== void 0)
      if (this.originalOpts.stroke && typeof this.originalOpts.stroke == "object" && "color" in this.originalOpts.stroke) {
        const r = ge(this.originalOpts.stroke.color);
        r !== void 0 && (t.stroke = {
          color: r,
          width: this.originalOpts.stroke.width
        }, this.originalOpts.stroke.join && (t.stroke.join = this.originalOpts.stroke.join));
      } else {
        const r = ge(this.originalOpts.stroke), n = e.strokeWidth ?? this.originalOpts.strokeWidth ?? 0;
        r !== void 0 ? t.stroke = { color: r, width: n } : n > 0 && (t.stroke = { color: 0, width: n });
      }
    const s = e.dropShadow ?? this.originalOpts.dropShadow;
    if (s) {
      const r = ge(s.color);
      r !== void 0 && (t.dropShadow = {
        color: r,
        alpha: s.alpha ?? 0.5,
        blur: s.blur ?? 4,
        angle: s.angle ?? Math.PI / 6,
        distance: s.distance ?? 2
      });
    }
    this.textStyle = new Ze(t), await this.refreshCaptions(), this.emit("propsChange", e);
  }
  async refreshCaptions() {
    this.pixiTextContainer ? this.pixiTextContainer.removeChildren() : this.pixiTextContainer = new oe();
    const e = this.textStyle;
    let t = 0, s = 0, r = 0;
    const n = this.opts.textCase, o = Ge.measureText(" ", this.textStyle);
    this.wordTexts = this.opts.words.map((T) => {
      let w = T.text;
      if (!w || w.trim() === "") {
        const R = new oe();
        return R.label = "emptyWord", this.pixiTextContainer.addChild(R), R;
      }
      n === "uppercase" ? w = w.toUpperCase() : n === "lowercase" ? w = w.toLowerCase() : n === "title" && (w = w.replace(
        /\w\S*/g,
        (R) => R.charAt(0).toUpperCase() + R.substring(1).toLowerCase()
      ));
      const A = new CS({
        text: w,
        style: e
      });
      A.x = t, A.y = 0;
      const k = A.getLocalBounds(), S = Math.ceil(k.width || A.width), C = Math.ceil(k.height || A.height);
      s = Math.max(s, C), t += S + o.width, r = t - o.width, this.pixiTextContainer.addChild(A);
      const U = ge(this.opts.fill);
      return A.tint = U ?? 16777215, A;
    });
    const a = r, l = s, c = new fe();
    c.label = "containerBackground";
    const h = this.opts.background === "transparent" || !this.opts.background, u = h ? 0 : ge(this.opts.background), d = h ? 0 : 1, f = 15;
    c.roundRect(
      0,
      0,
      a + f * 2,
      l + f * 2,
      10
    ), c.fill({ color: u, alpha: d }), this.wordTexts.forEach((T) => {
      this.extraPadding = 0, T.pivot.y = 0, T.pivot.x = 0, T.y = f - this.extraPadding, T.x += f;
    }), this.pixiTextContainer.addChildAt(c, 0);
    const g = a + f * 2, p = l + f * 2;
    this.renderTexture ? this.renderTexture.resize(g, p) : this.renderTexture = Pe.create({
      width: g,
      height: p
    });
    try {
      (await this.getRenderer()).render({
        container: this.pixiTextContainer,
        target: this.renderTexture
      });
    } catch (T) {
      K.warn("CaptionClip: Could not render captions during refresh", T);
    }
    this._meta.width = g, this._meta.height = p, this._meta.duration = 1 / 0;
    const x = this.opts.videoWidth, y = this.opts.videoHeight, v = this.opts.bottomOffset, _ = y - p - v, b = (x - g) / 2;
    this.update({
      width: g,
      height: p,
      top: _,
      left: b
    });
  }
  lastLoggedTime = -1;
  updateState(e) {
    const t = e / 1e3, s = Math.floor(e / 1e6);
    s !== this.lastLoggedTime && (this.lastLoggedTime = s), this.opts.words.forEach((r, n) => {
      const o = t >= r.from && t < r.to, a = t >= r.to, l = r.isKeyWord && !Ym(this.opts.keyword);
      let c = 16777215, h = 1;
      r.isKeyWord && o && l ? { color: c, alpha: h } = Nt(
        this.opts.keyword
      ) : o ? { color: c, alpha: h } = Nt(
        this.opts.active
      ) : a && this.opts.preserveKeywordColor && l ? { color: c, alpha: h } = Nt(
        this.opts.keyword
      ) : a ? { color: c, alpha: h } = Nt(
        this.opts.appeared
      ) : { color: c, alpha: h } = Nt(this.opts.fill);
      const u = this.wordTexts[n];
      if (!u) {
        console.warn(
          `WARNING: SplitBitmapText was not found for word "${r.text}"!`
        );
        return;
      }
      u.children.forEach((f) => {
        f.label !== "bgRect" && (f.tint = c, f.alpha = h);
      });
      const d = u.getChildByLabel("bgRect");
      if (o) {
        const { color: f, alpha: m } = Nt(
          this.opts.activeFill,
          16753920
        ), g = 10;
        d && (d.visible = !1);
        const p = u.getLocalBounds();
        d && (d.visible = !0);
        const x = 16, y = d ?? new fe();
        y.label = "bgRect", y.clear(), y.roundRect(
          p.x - g / 2,
          p.y - g / 2 + this.extraPadding,
          p.width + g,
          p.height + g,
          x
        ), y.fill({ color: f, alpha: m }), y.tint = 16777215, d || u.addChildAt(y, 0);
      } else
        d && (u.removeChild(d), d.destroy());
    });
  }
  /**
   * Get the PixiJS Texture (RenderTexture) for optimized rendering in Studio
   * This avoids ImageBitmap  Canvas  Texture conversion
   *
   * @returns The RenderTexture containing the rendered caption, or null if not ready
   */
  async getTexture() {
    if (this.pixiTextContainer == null || this.renderTexture == null)
      return console.log(
        "[CaptionClip] getTexture returning null - container or texture not ready"
      ), null;
    try {
      return (await this.getRenderer()).render({
        container: this.pixiTextContainer,
        target: this.renderTexture
      }), this.renderTexture;
    } catch (e) {
      return console.error("[CaptionClip] Error in getTexture:", e), null;
    }
  }
  /**
   * Set an external renderer (e.g., from Studio) to avoid creating our own Pixi App
   */
  setRenderer(e) {
    this.externalRenderer = e;
  }
  async getRenderer() {
    if (this.externalRenderer != null) return this.externalRenderer;
    if (this.pixiApp?.renderer == null)
      throw new Error(
        "CaptionClip: No renderer available. Provide a renderer via setRenderer()."
      );
    return this.pixiApp.renderer;
  }
  async tick(e) {
    if (await this.ready, this.pixiTextContainer == null || this.renderTexture == null)
      throw new Error("CaptionClip not initialized");
    this.updateState(e);
    const t = await this.getRenderer();
    t.render({
      container: this.pixiTextContainer,
      target: this.renderTexture
    });
    const s = this.renderTexture.source?.resource?.source;
    let r;
    if (s instanceof HTMLCanvasElement)
      r = await createImageBitmap(s);
    else if (s instanceof OffscreenCanvas)
      r = await createImageBitmap(s);
    else {
      const o = t.extract.canvas(this.renderTexture);
      if (o instanceof HTMLCanvasElement || o instanceof OffscreenCanvas)
        r = await createImageBitmap(o);
      else
        throw new Error("Unable to extract canvas from render texture");
    }
    return { video: r, state: "success" };
  }
  async split(e) {
    await this.ready;
    const t = await this.clone(), s = await this.clone();
    return [t, s];
  }
  // Effects
  addEffect(e) {
    this.effects.push(e);
  }
  editEffect(e, t) {
    const s = this.effects.find((r) => r.id === e);
    s && Object.assign(s, t);
  }
  removeEffect(e) {
    const t = this.effects.findIndex((s) => s.id === e);
    t !== -1 && this.effects.splice(t, 1);
  }
  async clone() {
    await this.ready;
    const e = this.originalOpts || {}, t = new Ft(this.text, e);
    return this.copyStateTo(t), t.id = this.id, t.effects = [...this.effects], t;
  }
  destroy() {
    if (!this.destroyed) {
      K.info("CaptionClip destroy");
      try {
        this.wordTexts.forEach((e) => {
          e != null && !e.destroyed && e.destroy({ children: !0 });
        });
      } catch {
      } finally {
        this.wordTexts = [];
      }
      try {
        this.pixiTextContainer != null && this.pixiTextContainer.destroyed !== !0 && this.pixiTextContainer.destroy({ children: !0 });
      } catch {
      } finally {
        this.pixiTextContainer = null;
      }
      try {
        this.renderTexture != null && this.renderTexture.destroyed !== !0 && this.renderTexture.destroy(!0);
      } catch {
      } finally {
        this.renderTexture = null;
      }
      if (this.externalRenderer = null, this.pixiApp != null)
        try {
          const e = this.pixiApp;
          e.destroyed !== !0 && e.renderer != null && this.pixiApp.destroy(!0, {
            children: !0,
            texture: !0
          });
        } catch {
        } finally {
          this.pixiApp = null;
        }
      super.destroy();
    }
  }
  toJSON(e = !1) {
    const t = super.toJSON(e), s = {};
    if (this.originalOpts) {
      const u = this.originalOpts;
      u.fontSize !== void 0 && (s.fontSize = u.fontSize), u.fontFamily !== void 0 && (s.fontFamily = u.fontFamily), u.fontWeight !== void 0 && (s.fontWeight = u.fontWeight), u.fontStyle !== void 0 && (s.fontStyle = u.fontStyle), u.fill !== void 0 && (s.color = u.fill), u.align !== void 0 && (s.align = u.align), u.textCase !== void 0 && (s.textCase = u.textCase), u.fontUrl !== void 0 && (s.fontUrl = u.fontUrl), u.stroke && (typeof u.stroke == "object" ? s.stroke = {
        color: u.stroke.color,
        width: u.stroke.width
      } : s.stroke = {
        color: u.stroke,
        width: u.strokeWidth ?? 0
      }), u.dropShadow && (s.shadow = {
        color: u.dropShadow.color ?? "#000000",
        alpha: u.dropShadow.alpha ?? 0.5,
        blur: u.dropShadow.blur ?? 4,
        distance: u.dropShadow.distance ?? 0,
        angle: u.dropShadow.angle ?? 0
      });
    }
    const r = {};
    this.opts.words && this.opts.words.length > 0 && (r.words = this.opts.words);
    const n = {}, o = this.originalOpts?.caption?.colors ?? this.originalOpts?.colors;
    o?.appeared !== void 0 && (n.appeared = o.appeared), o?.active !== void 0 && (n.active = o.active), o?.activeFill !== void 0 && (n.activeFill = o.activeFill), o?.background !== void 0 && (n.background = o.background), o?.keyword !== void 0 && (n.keyword = o.keyword);
    let a;
    this.originalOpts?.caption?.preserveKeywordColor !== void 0 ? a = this.originalOpts.caption.preserveKeywordColor : this.originalOpts?.preserveKeywordColor !== void 0 && (a = this.originalOpts.preserveKeywordColor), Object.keys(n).length > 0 && (r.colors = n), a !== void 0 && (r.preserveKeywordColor = a);
    const l = {};
    this.bottomOffset !== void 0 && (l.bottomOffset = this.bottomOffset);
    const c = this.originalOpts?.caption?.positioning?.videoWidth ?? this.originalOpts?.videoWidth, h = this.originalOpts?.caption?.positioning?.videoHeight ?? this.originalOpts?.videoHeight;
    return c !== void 0 && (l.videoWidth = c), h !== void 0 && (l.videoHeight = h), Object.keys(l).length > 0 && (r.positioning = l), {
      ...t,
      type: "Caption",
      text: this.text,
      style: s,
      caption: Object.keys(r).length > 0 ? r : void 0,
      id: this.id,
      effects: this.effects,
      mediaId: this.mediaId
    };
  }
  /**
   * Create a CaptionClip instance from a JSON object (fabric.js pattern)
   * @param json The JSON object representing the clip
   * @returns Promise that resolves to a CaptionClip instance
   */
  static async fromObject(e) {
    if (e.type !== "Caption")
      throw new Error(`Expected Caption, got ${e.type}`);
    const t = e.text || "", s = e.style || {}, r = {};
    s.fontSize !== void 0 && (r.fontSize = s.fontSize), s.fontFamily !== void 0 && (r.fontFamily = s.fontFamily), s.fontWeight !== void 0 && (r.fontWeight = s.fontWeight), s.fontStyle !== void 0 && (r.fontStyle = s.fontStyle), s.color !== void 0 && (r.fill = s.color), s.align !== void 0 && (r.align = s.align), s.textCase !== void 0 && (r.textCase = s.textCase), s.fontUrl !== void 0 ? r.fontUrl = s.fontUrl : e.fontUrl !== void 0 && (r.fontUrl = e.fontUrl), e.mediaId && (r.mediaId = e.mediaId), s.stroke && (r.stroke = s.stroke.color, r.strokeWidth = s.stroke.width), s.shadow && (r.dropShadow = {
      color: s.shadow.color,
      alpha: s.shadow.alpha,
      blur: s.shadow.blur,
      distance: s.shadow.distance,
      angle: s.shadow.angle
    }), e.caption ? r.caption = e.caption : (e.bottomOffset !== void 0 && (r.bottomOffset = e.bottomOffset), e.words !== void 0 && (r.words = e.words), (e.appearedColor !== void 0 || e.activeColor !== void 0 || e.activeFillColor !== void 0 || e.backgroundColor !== void 0 || e.isKeyWordColor !== void 0) && (r.colors = {}, e.appearedColor !== void 0 && (r.colors.appeared = e.appearedColor), e.activeColor !== void 0 && (r.colors.active = e.activeColor), e.activeFillColor !== void 0 && (r.colors.activeFill = e.activeFillColor), e.backgroundColor !== void 0 && (r.colors.background = e.backgroundColor), e.isKeyWordColor !== void 0 && (r.colors.keyword = e.isKeyWordColor)), e.preservedColorKeyWord !== void 0 && (r.preserveKeywordColor = e.preservedColorKeyWord), e.videoWidth !== void 0 && (r.videoWidth = e.videoWidth), e.videoHeight !== void 0 && (r.videoHeight = e.videoHeight));
    const n = new Ft(t, r);
    return n.left = e.left, n.top = e.top, n.width = e.width, n.height = e.height, n.angle = e.angle, n.display.from = e.display.from, n.display.to = e.display.to, n.duration = e.duration, n.playbackRate = e.playbackRate, n.zIndex = e.zIndex, n.opacity = e.opacity, n.flip = e.flip, e.animation && n.setAnimation(e.animation.keyFrames, e.animation.opts), e.id && (n.id = e.id), e.effects && (n.effects = e.effects), await n.ready, n;
  }
}
class Se extends Yt {
  type = "Image";
  ready;
  _meta = {
    // microseconds
    duration: 0,
    width: 0,
    height: 0
  };
  /**
   *  Static images have duration of Infinity
   *
   * When wrapping with Sprite, you need to set its duration to a finite number
   *
   */
  get meta() {
    return { ...this._meta };
  }
  img = null;
  // Optimized: Store PixiJS Texture for direct use in Studio
  // This avoids ImageBitmap  Canvas  Texture conversion
  pixiTexture = null;
  frames = [];
  /**
   * Unique identifier for this clip instance
   */
  id = `clip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  /**
   * Array of effects to be applied to this clip
   * Each effect specifies key, startTime, duration, and optional targets
   */
  effects = [];
  /**
   * Load an image clip from a URL using PixiJS Assets
   * This is optimized for Studio as it uses Texture directly
   *
   * @param url Image URL
   * @param src Optional source identifier for serialization
   * @returns Promise that resolves to an ImageClip instance
   *
   * @example
   * const imgClip = await ImageClip.fromUrl('path/to/image.png');
   */
  static async fromUrl(e, t) {
    const s = await Ni.load(e), r = s.source?.resource?.source;
    let n;
    try {
      if (r instanceof HTMLCanvasElement || r instanceof OffscreenCanvas)
        n = await createImageBitmap(r);
      else if (r instanceof HTMLImageElement) {
        const a = new OffscreenCanvas(r.width, r.height), l = a.getContext("2d");
        if (l == null)
          throw new Error("Failed to create 2d context");
        l.drawImage(r, 0, 0), n = await createImageBitmap(a);
      } else if (r instanceof ImageBitmap)
        n = await createImageBitmap(r);
      else {
        const a = await fetch(e);
        if (!a.ok)
          throw new Error(
            `Failed to fetch image: ${a.status} ${a.statusText}`
          );
        const l = await a.blob();
        n = await createImageBitmap(l);
      }
    } catch {
      const l = await fetch(e);
      if (!l.ok)
        throw new Error(
          `Failed to fetch image: ${l.status} ${l.statusText}`
        );
      const c = await l.blob();
      n = await createImageBitmap(c);
    }
    const o = new Se(n, t || e);
    return o.pixiTexture = s, o;
  }
  /**
   * Get the PixiJS Texture (if available)
   * This is used for optimized rendering in Studio
   */
  getTexture() {
    return this.pixiTexture;
  }
  /**
   * Static images can be initialized using stream or ImageBitmap
   *
   * Animated images need to use VideoFrame[] or provide image type
   */
  constructor(e, t) {
    super(), this.src = t !== void 0 ? t : "";
    const s = (r) => {
      this.img = r, this._meta.width = r.width, this._meta.height = r.height, this._meta.duration = 1 / 0;
      const n = { ...this._meta };
      return this.width = this.width === 0 ? n.width : this.width, this.height = this.height === 0 ? n.height : this.height, this.duration === 0 && n.duration !== 1 / 0 && (this.duration = n.duration, this.display.to = this.display.from + this.duration), n;
    };
    if (e instanceof ReadableStream)
      this.ready = new Response(e).blob().then((r) => createImageBitmap(r)).then(s);
    else if (e instanceof ImageBitmap)
      this.ready = Promise.resolve(s(e));
    else if (Array.isArray(e) && e.every((r) => r instanceof VideoFrame)) {
      this.frames = e;
      const r = this.frames[0];
      if (r == null) throw Error("The frame count must be greater than 0");
      this._meta = {
        width: r.displayWidth,
        height: r.displayHeight,
        duration: this.frames.reduce(
          (o, a) => o + (a.duration ?? 0),
          0
        )
      };
      const n = { ...this._meta, duration: 1 / 0 };
      this.width = this.width === 0 ? n.width : this.width, this.height = this.height === 0 ? n.height : this.height, this.duration === 0 && n.duration !== 1 / 0 && (this.duration = n.duration, this.display.to = this.display.from + this.duration), this.ready = Promise.resolve(n);
    } else if ("type" in e)
      this.ready = this.initAnimateImg(e.stream, e.type).then(
        () => {
          const r = {
            width: this._meta.width,
            height: this._meta.height,
            duration: 1 / 0
          };
          return this.width = this.width === 0 ? r.width : this.width, this.height = this.height === 0 ? r.height : this.height, this.duration === 0 && r.duration !== 1 / 0 && (this.duration = r.duration, this.display.to = this.display.from + this.duration), r;
        }
      );
    else
      throw Error("Illegal arguments");
  }
  async initAnimateImg(e, t) {
    this.frames = await gb(e, t);
    const s = this.frames[0];
    if (s == null) throw Error("No frame available in gif");
    this._meta = {
      duration: this.frames.reduce((r, n) => r + (n.duration ?? 0), 0),
      width: s.codedWidth,
      height: s.codedHeight
    }, K.info("ImageClip ready:", this._meta);
  }
  tickInterceptor = async (e, t) => t;
  async tick(e) {
    if (this.img != null)
      return await this.tickInterceptor(e, {
        video: await createImageBitmap(this.img),
        state: "success"
      });
    const t = e % this._meta.duration;
    return await this.tickInterceptor(e, {
      video: (this.frames.find(
        (s) => t >= s.timestamp && t <= s.timestamp + (s.duration ?? 0)
      ) ?? this.frames[0]).clone(),
      state: "success"
    });
  }
  async split(e) {
    if (await this.ready, this.img != null)
      return [
        new Se(await createImageBitmap(this.img), this.src),
        new Se(await createImageBitmap(this.img), this.src)
      ];
    let t = -1;
    for (let n = 0; n < this.frames.length; n++) {
      const o = this.frames[n];
      if (!(e > o.timestamp)) {
        t = n;
        break;
      }
    }
    if (t === -1) throw Error("Not found frame by time");
    const s = this.frames.slice(0, t).map((n) => new VideoFrame(n)), r = this.frames.slice(t).map(
      (n) => new VideoFrame(n, {
        timestamp: n.timestamp - e
      })
    );
    return [
      new Se(s, this.src),
      new Se(r, this.src)
    ];
  }
  async clone() {
    await this.ready;
    const e = this.img == null ? this.frames.map((s) => s.clone()) : await createImageBitmap(this.img), t = new Se(e, this.src);
    return t.tickInterceptor = this.tickInterceptor, this.copyStateTo(t), t.id = this.id, t.effects = [...this.effects], t.transition = this.transition, t;
  }
  // Effects
  addEffect(e) {
    this.effects.push(e);
  }
  editEffect(e, t) {
    const s = this.effects.find((r) => r.id === e);
    s && Object.assign(s, t);
  }
  removeEffect(e) {
    const t = this.effects.findIndex((s) => s.id === e);
    t !== -1 && this.effects.splice(t, 1);
  }
  destroy() {
    K.info("ImageClip destroy"), this.img?.close(), this.frames.forEach((e) => e.close()), this.pixiTexture = null, super.destroy();
  }
  toJSON(e = !1) {
    return {
      ...super.toJSON(e),
      type: "Image",
      id: this.id,
      effects: this.effects
    };
  }
  /**
   * Create an ImageClip instance from a JSON object (fabric.js pattern)
   * @param json The JSON object representing the clip
   * @returns Promise that resolves to an ImageClip instance
   */
  static async fromObject(e) {
    if (e.type !== "Image")
      throw new Error(`Expected Image, got ${e.type}`);
    if (!e.src || e.src.trim() === "")
      throw new Error(
        "ImageClip requires a valid source URL. Generated clips (like text-to-image) cannot be loaded from JSON without their source data."
      );
    let t;
    try {
      const s = await fetch(e.src);
      if (!s.ok)
        throw new Error(
          `Failed to fetch image from ${e.src}: ${s.status} ${s.statusText}. Make sure the file exists in the public directory.`
        );
      const r = await s.blob();
      if (!r.type.startsWith("image/"))
        throw new Error(
          `Invalid image format: ${r.type}. Expected an image file.`
        );
      t = new Se(await createImageBitmap(r), e.src);
    } catch (s) {
      throw s instanceof Error && s.message.includes("could not be decoded") ? new Error(
        `Failed to decode image from ${e.src}. The image may be corrupted, in an unsupported format, or there may be CORS issues.`
      ) : s;
    }
    return await t.ready, t.left = e.left, t.top = e.top, t.width = e.width, t.height = e.height, t.angle = e.angle, t.display.from = e.display.from, t.display.to = e.display.to, t.duration = e.duration, t.playbackRate = e.playbackRate, t.zIndex = e.zIndex, t.opacity = e.opacity, t.flip = e.flip, e.style && (t.style = { ...t.style, ...e.style }), e.animation && t.setAnimation(e.animation.keyFrames, e.animation.opts), e.id && (t.id = e.id), e.effects && (t.effects = e.effects), e.transition && (t.transition = e.transition), t;
  }
  /**
   * Scale clip to fit within the scene dimensions while maintaining aspect ratio
   * Similar to fabric.js scaleToFit
   * @param sceneWidth Scene width
   * @param sceneHeight Scene height
   */
  async scaleToFit(e, t) {
    await this.ready;
    const { width: s, height: r } = this.meta;
    if (s === 0 || r === 0) return;
    const n = Math.min(e / s, t / r);
    this.width = s * n, this.height = r * n;
  }
  /**
   * Scale clip to fill the scene dimensions while maintaining aspect ratio
   * May crop parts of the clip. Similar to fabric.js scaleToFill
   * @param sceneWidth Scene width
   * @param sceneHeight Scene height
   */
  async scaleToFill(e, t) {
    await this.ready;
    const { width: s, height: r } = this.meta;
    if (s === 0 || r === 0) return;
    const n = Math.max(e / s, t / r);
    this.width = s * n, this.height = r * n;
  }
  /**
   * Center the clip within the scene dimensions
   * Similar to fabric.js center
   * @param sceneWidth Scene width
   * @param sceneHeight Scene height
   */
  centerInScene(e, t) {
    this.left = (e - this.width) / 2, this.top = (t - this.height) / 2;
  }
}
function yu(i, e) {
  const t = {}, s = e.videoTracks[0];
  if (s != null) {
    const n = IS(i.getTrackById(s.id))?.buffer, o = AS(s.codec);
    o && (t.videoTrackConf = {
      timescale: s.timescale,
      duration: s.duration,
      width: s.video.width,
      height: s.video.height,
      brands: e.brands,
      type: o.type,
      [o.descKey]: n
    }), t.videoDecoderConf = {
      codec: s.codec,
      codedHeight: s.video.height,
      codedWidth: s.video.width,
      description: n
    };
  }
  const r = e.audioTracks[0];
  if (r != null) {
    const n = kS(i), o = n ? FS(n) : {};
    t.audioTrackConf = {
      timescale: r.timescale,
      samplerate: o.sampleRate ?? r.audio.sample_rate,
      channel_count: o.numberOfChannels ?? r.audio.channel_count,
      hdlr: "soun",
      type: r.codec.startsWith("mp4a") ? "mp4a" : r.codec,
      description: n
    }, t.audioDecoderConf = {
      codec: o.codec ?? ie.codec,
      numberOfChannels: o.numberOfChannels ?? r.audio.channel_count,
      sampleRate: o.sampleRate ?? r.audio.sample_rate
    };
  }
  return t;
}
function AS(i) {
  return i.startsWith("avc1") ? { descKey: "avcDecoderConfigRecord", type: "avc1" } : i.startsWith("hvc1") ? { descKey: "hevcDecoderConfigRecord", type: "hvc1" } : null;
}
function IS(i) {
  for (const e of i.mdia.minf.stbl.stsd.entries) {
    const t = e.avcC ?? e.hvcC ?? e.av1C ?? e.vpcC;
    if (t != null) {
      const s = new $t.DataStream(void 0, 0, void 0);
      return t.write(s), new Uint8Array(s.buffer.slice(8));
    }
  }
}
function kS(i, e = "mp4a") {
  return i.moov?.traks.flatMap((t) => t.mdia.minf.stbl.stsd.entries).find((t) => t.type === e);
}
function FS(i) {
  const e = i.esd?.descs?.[0];
  if (!e) return {};
  let t = `mp4a.${e.oti.toString(16)}`;
  const s = e.descs?.[0];
  if (!s)
    return t.endsWith(".40") && (t += ".2"), { codec: t };
  const r = s.data;
  if (!r) return { codec: t };
  const n = (r[0] & 248) >> 3;
  t += `.${n}`;
  const o = (r[0] & 7) << 1 | r[1] >> 7, a = (r[1] & 120) >> 3;
  return {
    codec: t,
    sampleRate: [
      96e3,
      88200,
      64e3,
      48e3,
      44100,
      32e3,
      24e3,
      22050,
      16e3,
      12e3,
      11025,
      8e3,
      7350
    ][o],
    numberOfChannels: a
  };
}
async function MS(i, e, t) {
  const s = $t.createFile(!1);
  s.onReady = (o) => {
    e({ mp4boxFile: s, info: o }), [o.videoTracks[0], o.audioTracks[0]].forEach((a) => {
      if (a) {
        const l = a.video ? "video" : "audio";
        s.setExtractionOptions(a.id, l, { nbSamples: 100 });
      }
    }), s.start();
  }, s.onSamples = t;
  let r = 0;
  const n = 30 * 1024 * 1024;
  for (; ; ) {
    const o = await i.read(n, {
      at: r
    });
    if (o.byteLength === 0) break;
    o.fileStart = r;
    const a = s.appendBuffer(o);
    if (a == null) break;
    r = a;
  }
  s.stop();
}
function ES(i) {
  if (i?.length !== 9) return {};
  const e = new Int32Array(i.buffer), t = (h) => h / 65536, s = t(e[0]), r = t(e[1]), n = t(e[3]), o = t(e[4]), a = t(e[6]), l = t(e[7]), c = e[8] / (1 << 30);
  return {
    scaleX: Math.sqrt(s * s + n * n),
    scaleY: Math.sqrt(r * r + o * o),
    rotationRad: Math.atan2(n, s),
    rotationDeg: Math.atan2(n, s) * 180 / Math.PI,
    translateX: a,
    translateY: l,
    perspective: c
  };
}
function PS(i, e, t) {
  const s = (Math.round(t / 90) * 90 + 360) % 360;
  if (s === 0) return (c) => c;
  const r = s === 90 || s === 270, n = r ? e : i, o = r ? i : e, a = new OffscreenCanvas(n, o), l = a.getContext("2d");
  return l.translate(n / 2, o / 2), l.rotate(-s * Math.PI / 180), l.translate(-i / 2, -e / 2), (c) => {
    if (!c) return null;
    l.drawImage(c, 0, 0);
    const h = new VideoFrame(a, {
      timestamp: c.timestamp,
      duration: c.duration ?? void 0
    });
    return c.close(), h;
  };
}
let vu = 0;
function dh(i) {
  return i.kind === "file" && i.createReader instanceof Function;
}
class xe extends Yt {
  type = "Video";
  insId = vu++;
  logger = K.create(`VideoClip id:${this.insId},`);
  ready;
  _meta = {
    // microseconds
    duration: 0,
    width: 0,
    height: 0,
    audioSampleRate: 0,
    audioChanCount: 0
  };
  get meta() {
    return { ...this._meta };
  }
  localFile;
  /** Store binary data of video header (box: ftyp, moov) */
  headerBoxPos = [];
  /**
   * Provide binary data of video header (box: ftyp, moov)
   * Use any mp4 demuxer to parse and get detailed video information
   * Unit tests include sample code using mp4box.js
   */
  async getFileHeaderBinData() {
    await this.ready;
    const e = await this.localFile.getOriginFile();
    if (e == null) throw Error("VideoClip localFile is not origin file");
    return await new Blob(
      this.headerBoxPos.map(
        ({ start: t, size: s }) => e.slice(t, t + s)
      )
    ).arrayBuffer();
  }
  /** Store video transform and rotation info, currently only restores rotation */
  parsedMatrix = {
    perspective: 1,
    rotationRad: 0,
    rotationDeg: 0,
    scaleX: 1,
    scaleY: 1,
    translateX: 0,
    translateY: 0
  };
  vfRotater = (e) => e;
  videoSamples = [];
  audioSamples = [];
  videoFrameFinder = null;
  audioFrameFinder = null;
  decoderConf = {
    video: null,
    audio: null
  };
  opts = { audio: !0 };
  /**
   * Whether to include audio track (hybrid JSON structure)
   */
  audio = !0;
  /**
   * Unique identifier for this clip instance
   */
  id = `clip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  /**
   * Array of effects to be applied to this clip
   * Each effect specifies key, startTime, duration, and optional targets
   */
  effects = [];
  /**
   * Load a video clip from a URL
   * @param url Video URL
   * @param opts Position and size options
   * @returns Promise that resolves to a video clip
   *
   * @example
   * const videoClip = await VideoClip.fromUrl('clip.mp4', {
   *   x: 0,
   *   y: 0,
   *   width: 1920,
   *   height: 1080,
   * });
   */
  static async fromUrl(e, t = {}) {
    const s = await fetch(e);
    if (!s.ok)
      throw new Error(
        `Failed to fetch video from ${e}: ${s.status} ${s.statusText}`
      );
    const r = new xe(s.body, {}, e);
    return await r.ready, t.x !== void 0 && (r.left = t.x), t.y !== void 0 && (r.top = t.y), t.width !== void 0 && (r.width = t.width), t.height !== void 0 && (r.height = t.height), r;
  }
  constructor(e, t = {}, s) {
    if (super(), this.src = s !== void 0 ? s : "", !(e instanceof ReadableStream) && !dh(e) && !Array.isArray(e.videoSamples))
      throw Error("Illegal argument");
    this.opts = { audio: !0, ...t }, this.audio = typeof this.opts.audio == "boolean" ? this.opts.audio : !0, this.volume = typeof t.audio == "object" && "volume" in t.audio ? t.audio.volume : t.volume ?? 1;
    const r = async (n) => (await Ji(this.localFile, n), this.localFile);
    this.localFile = dh(e) ? e : "localFile" in e ? e.localFile : Sh(), this.ready = (e instanceof ReadableStream ? r(e).then(
      (n) => Zd(n, this.opts)
    ) : dh(e) ? Zd(e, this.opts) : Promise.resolve(e)).then(
      async ({
        videoSamples: n,
        audioSamples: o,
        decoderConf: a,
        headerBoxPos: l,
        parsedMatrix: c
      }) => {
        this.videoSamples = n, this.audioSamples = o, this.decoderConf = a, this.headerBoxPos = l, this.parsedMatrix = c;
        const { videoFrameFinder: h, audioFrameFinder: u } = RS(
          {
            video: a.video == null ? null : {
              ...a.video,
              hardwareAcceleration: this.opts.__unsafe_hardwareAcceleration__
            },
            audio: a.audio
          },
          await this.localFile.createReader(),
          n,
          o,
          this.opts.audio !== !1 ? this.volume : 0
        );
        this.videoFrameFinder = h, this.audioFrameFinder = u;
        const { codedWidth: d, codedHeight: f } = a.video ?? {};
        d && f && (this.vfRotater = PS(
          d,
          f,
          c.rotationDeg
        )), this._meta = US(
          a,
          n,
          o,
          c.rotationDeg
        ), this.logger.info("VideoClip meta:", this._meta);
        const m = { ...this._meta };
        this.width = this.width === 0 ? m.width : this.width, this.height = this.height === 0 ? m.height : this.height, this.trim.to = this.trim.to === 0 ? m.duration : this.trim.to;
        const g = (this.trim.to - this.trim.from) / this.playbackRate;
        return this.duration = this.duration === 0 ? g : this.duration, this.display.to = this.display.from + this.duration, this.on("propsChange", (p) => {
          p.volume !== void 0 && this.audioFrameFinder && this.audioFrameFinder.setVolume(p.volume);
        }), m;
      }
    );
  }
  /**
   * Intercept data returned by {@link VideoClip.tick} method for secondary processing of image and audio data
   * @param time Time when tick was called
   * @param tickRet Data returned by tick
   *
   *    */
  tickInterceptor = async (e, t) => t;
  /**
   * Get image frame and audio data at specified time
   * @param time Time in microseconds
   */
  async tick(e) {
    const t = e + this.trim.from;
    if (t >= this.trim.to || t >= this._meta.duration)
      return await this.tickInterceptor(e, {
        audio: await this.audioFrameFinder?.find(t) ?? [],
        state: "done"
      });
    const [s, r] = await Promise.all([
      this.audioFrameFinder?.find(t) ?? [],
      this.videoFrameFinder?.find(t).then(this.vfRotater)
    ]);
    return r == null ? await this.tickInterceptor(e, {
      audio: s,
      state: "success"
    }) : await this.tickInterceptor(e, {
      video: r,
      audio: s,
      state: "success"
    });
  }
  async split(e) {
    if (await this.ready, e <= 0 || e >= this._meta.duration)
      throw Error("time out of bounds");
    const [t, s] = GS(
      this.videoSamples,
      e
    ), [r, n] = HS(
      this.audioSamples,
      e
    ), o = new xe(
      {
        localFile: this.localFile,
        videoSamples: t ?? [],
        audioSamples: r ?? [],
        decoderConf: this.decoderConf,
        headerBoxPos: this.headerBoxPos,
        parsedMatrix: this.parsedMatrix
      },
      this.opts,
      this.src
    ), a = new xe(
      {
        localFile: this.localFile,
        videoSamples: s ?? [],
        audioSamples: n ?? [],
        decoderConf: this.decoderConf,
        headerBoxPos: this.headerBoxPos,
        parsedMatrix: this.parsedMatrix
      },
      this.opts,
      this.src
    );
    return await Promise.all([o.ready, a.ready]), [o, a];
  }
  // Effects
  addEffect(e) {
    this.effects.push(e);
  }
  editEffect(e, t) {
    const s = this.effects.find((r) => r.id === e);
    s && Object.assign(s, t);
  }
  removeEffect(e) {
    const t = this.effects.findIndex((s) => s.id === e);
    t !== -1 && this.effects.splice(t, 1);
  }
  async clone() {
    await this.ready;
    const e = new xe(
      {
        localFile: this.localFile,
        videoSamples: [...this.videoSamples],
        audioSamples: [...this.audioSamples],
        decoderConf: this.decoderConf,
        headerBoxPos: this.headerBoxPos,
        parsedMatrix: this.parsedMatrix
      },
      this.opts,
      this.src
    );
    return await e.ready, e.tickInterceptor = this.tickInterceptor, this.copyStateTo(e), e.id = this.id, e.effects = [...this.effects], e;
  }
  /**
   * Split VideoClip into VideoClips containing only video track and audio track
   * @returns VideoClip[]
   */
  async splitTrack() {
    await this.ready;
    const e = [];
    if (this.videoSamples.length > 0) {
      const t = new xe(
        {
          localFile: this.localFile,
          videoSamples: [...this.videoSamples],
          audioSamples: [],
          decoderConf: {
            video: this.decoderConf.video,
            audio: null
          },
          headerBoxPos: this.headerBoxPos,
          parsedMatrix: this.parsedMatrix
        },
        this.opts,
        this.src
      );
      await t.ready, t.tickInterceptor = this.tickInterceptor, e.push(t);
    }
    if (this.audioSamples.length > 0) {
      const t = new xe(
        {
          localFile: this.localFile,
          videoSamples: [],
          audioSamples: [...this.audioSamples],
          decoderConf: {
            audio: this.decoderConf.audio,
            video: null
          },
          headerBoxPos: this.headerBoxPos,
          parsedMatrix: this.parsedMatrix
        },
        this.opts,
        this.src
      );
      await t.ready, t.tickInterceptor = this.tickInterceptor, e.push(t);
    }
    return e;
  }
  destroy() {
    this.destroyed || (this.destroyed = !0, this.logger.info("VideoClip destroy"), super.destroy(), this.videoFrameFinder?.destroy(), this.audioFrameFinder?.destroy());
  }
  toJSON(e = !1) {
    return {
      ...super.toJSON(e),
      type: "Video",
      audio: this.audio,
      volume: this.volume,
      id: this.id,
      effects: this.effects
    };
  }
  /**
   * Create a VideoClip instance from a JSON object (fabric.js pattern)
   * @param json The JSON object representing the clip
   * @returns Promise that resolves to a VideoClip instance
   */
  static async fromObject(e) {
    if (e.type !== "Video")
      throw new Error(`Expected Video, got ${e.type}`);
    const t = await fetch(e.src);
    if (!t.ok)
      throw new Error(
        `Failed to fetch video from ${e.src}: ${t.status} ${t.statusText}. Make sure the file exists in the public directory.`
      );
    const s = e.audio !== void 0 ? { audio: e.audio, volume: e.volume } : { volume: e.volume }, r = new xe(t.body, s, e.src);
    return await r.ready, r.left = e.left, r.top = e.top, r.width = e.width, r.height = e.height, r.angle = e.angle, r.display.from = e.display.from, r.display.to = e.display.to, r.duration = e.duration, r.playbackRate = e.playbackRate, r.zIndex = e.zIndex, r.opacity = e.opacity, r.flip = e.flip, e.style && (r.style = { ...r.style, ...e.style }), e.animation && r.setAnimation(e.animation.keyFrames, e.animation.opts), e.id && (r.id = e.id), e.effects && (r.effects = e.effects), e.transition && (r.transition = e.transition), e.trim && (r.trim.from = e.trim.from < 1e6 ? e.trim.from * 1e6 : e.trim.from, r.trim.to = e.trim.to < 1e6 ? e.trim.to * 1e6 : e.trim.to), e.volume !== void 0 && (r.volume = e.volume), r;
  }
  /**
   * Create HTMLVideoElement for playback
   */
  async createPlaybackElement() {
    await this.ready;
    const t = this.localFile;
    if (!t || typeof t.getOriginFile != "function")
      throw new Error("VideoClip does not have a local file for playback");
    const s = await t.getOriginFile();
    if (!s)
      throw new Error("Failed to get origin file from VideoClip");
    const r = URL.createObjectURL(s), n = document.createElement("video");
    return n.crossOrigin = "anonymous", n.muted = !0, n.autoplay = !1, n.playsInline = !0, n.preload = "auto", n.loop = !1, n.src = r, await new Promise((o, a) => {
      const l = () => {
        n.removeEventListener("loadeddata", l), n.removeEventListener("error", c), n.pause(), n.currentTime = 0, o();
      }, c = () => {
        n.removeEventListener("loadeddata", l), n.removeEventListener("error", c), a(new Error("Failed to load video"));
      };
      n.addEventListener("loadeddata", l, { once: !0 }), n.addEventListener("error", c, { once: !0 }), n.load();
    }), { element: n, objectUrl: r };
  }
  async play(e, t) {
    const s = e, r = t + this.trim.from / 1e6;
    if (Math.abs(s.currentTime - r) > 0.1 && (s.currentTime = r), s.muted = !1, s.paused)
      try {
        await s.play();
      } catch {
        try {
          await s.play();
        } catch (o) {
          console.warn("Failed to play video:", o);
        }
      }
  }
  pause(e) {
    const t = e;
    t.pause(), t.muted = !0;
  }
  async seek(e, t) {
    const s = e, r = t + this.trim.from / 1e6;
    return s.pause(), s.currentTime = r, new Promise((n) => {
      if (Math.abs(s.currentTime - t) < 0.01) {
        n();
        return;
      }
      const o = () => {
        s.removeEventListener("seeked", o), n();
      };
      s.addEventListener("seeked", o, { once: !0 }), setTimeout(() => {
        s.removeEventListener("seeked", o), n();
      }, 500);
    });
  }
  syncPlayback(e, t, s) {
    const r = e, n = (this.trim.to - this.trim.from) / 1e6, o = s >= 0 && s < n, a = s + this.trim.from / 1e6;
    r.volume = this.volume, t && o ? r.paused ? this.play(r, s).catch(console.warn) : (r.muted && (r.muted = !1), (r.ended || r.currentTime >= this.trim.to / 1e6) && (r.currentTime = a, r.play().catch(console.warn))) : (r.paused || r.pause(), r.muted = !0, o && Math.abs(r.currentTime - a) > 0.1 && (r.currentTime = a));
  }
  cleanupPlayback(e, t) {
    const s = e;
    s.pause(), s.removeAttribute("src"), s.load(), t && URL.revokeObjectURL(t);
  }
  /**
   * Scale clip to fit within the scene dimensions while maintaining aspect ratio
   * Similar to fabric.js scaleToFit
   * @param sceneWidth Scene width
   * @param sceneHeight Scene height
   */
  async scaleToFit(e, t) {
    await this.ready;
    const { width: s, height: r } = this.meta;
    if (s === 0 || r === 0) return;
    const n = Math.min(e / s, t / r);
    this.width = s * n, this.height = r * n;
  }
  /**
   * Scale clip to fill the scene dimensions while maintaining aspect ratio
   * May crop parts of the clip. Similar to fabric.js scaleToFill
   * @param sceneWidth Scene width
   * @param sceneHeight Scene height
   */
  async scaleToFill(e, t) {
    await this.ready;
    const { width: s, height: r } = this.meta;
    if (s === 0 || r === 0) return;
    const n = Math.max(e / s, t / r);
    this.width = s * n, this.height = r * n;
  }
  /**
   * Center the clip within the scene dimensions
   * Similar to fabric.js center
   * @param sceneWidth Scene width
   * @param sceneHeight Scene height
   */
  centerInScene(e, t) {
    this.left = (e - this.width) / 2, this.top = (t - this.height) / 2;
  }
}
function US(i, e, t, s) {
  const r = {
    duration: 0,
    width: 0,
    height: 0,
    audioSampleRate: 0,
    audioChanCount: 0
  };
  if (i.video != null && e.length > 0) {
    r.width = i.video.codedWidth ?? 0, r.height = i.video.codedHeight ?? 0;
    const a = (Math.round(s / 90) * 90 + 360) % 360;
    (a === 90 || a === 270) && ([r.width, r.height] = [r.height, r.width]);
  }
  i.audio != null && t.length > 0 && (r.audioSampleRate = ie.sampleRate, r.audioChanCount = ie.channelCount);
  let n = 0, o = 0;
  if (e.length > 0)
    for (let a = e.length - 1; a >= 0; a--) {
      const l = e[a];
      if (!l.deleted) {
        n = l.cts + l.duration;
        break;
      }
    }
  if (t.length > 0) {
    const a = t.at(-1);
    o = a.cts + a.duration;
  }
  return r.duration = Math.max(n, o), r;
}
function RS(i, e, t, s, r) {
  return {
    audioFrameFinder: r === 0 || i.audio == null || s.length === 0 ? null : new OS(
      e,
      s,
      i.audio,
      {
        volume: r,
        targetSampleRate: ie.sampleRate
      }
    ),
    videoFrameFinder: i.video == null || t.length === 0 ? null : new BS(
      e,
      t,
      i.video
    )
  };
}
async function Zd(i, e = {}) {
  let t = null;
  const s = { video: null, audio: null };
  let r = [], n = [], o = [];
  const a = {
    perspective: 1,
    rotationRad: 0,
    rotationDeg: 0,
    scaleX: 1,
    scaleY: 1,
    translateX: 0,
    translateY: 0
  };
  let l = -1, c = -1;
  const h = await i.createReader();
  await MS(
    h,
    async (d) => {
      t = d.info;
      const f = d.mp4boxFile.ftyp;
      o.push({ start: f.start, size: f.size });
      const m = d.mp4boxFile.moov;
      o.push({ start: m.start, size: m.size }), Object.assign(a, ES(t.videoTracks[0]?.matrix));
      let { videoDecoderConf: g, audioDecoderConf: p } = yu(
        d.mp4boxFile,
        d.info
      );
      if (s.video = g ?? null, s.audio = p ?? null, g == null && p == null && K.error("VideoClip no video and audio track"), p != null) {
        const { supported: x } = await AudioDecoder.isConfigSupported(p);
        x || K.error(`VideoClip audio codec is not supported: ${p.codec}`);
      }
      if (g != null) {
        const { supported: x } = await VideoDecoder.isConfigSupported(g);
        x || K.error(`VideoClip video codec is not supported: ${g.codec}`);
      }
      K.info(
        "mp4BoxFile moov ready",
        {
          ...d.info,
          tracks: null,
          videoTracks: null,
          audioTracks: null
        },
        s
      );
    },
    (d, f, m) => {
      if (f === "video") {
        l === -1 && (l = m[0].dts);
        for (const g of m)
          r.push(Kd(g, l, "video"));
      } else if (f === "audio" && e.audio) {
        c === -1 && (c = m[0].dts);
        for (const g of m)
          n.push(Kd(g, c, "audio"));
      }
    }
  ), await h.close();
  const u = r.at(-1) ?? n.at(-1);
  if (t == null)
    throw Error("VideoClip stream is done, but not emit ready");
  if (u == null)
    throw Error("VideoClip stream not contain any sample");
  return Xh(r), K.info("mp4 stream parsed"), {
    videoSamples: r,
    audioSamples: n,
    decoderConf: s,
    headerBoxPos: o,
    parsedMatrix: a
  };
}
function Kd(i, e = 0, t) {
  let s = i.offset;
  const r = t === "video" && i.is_sync ? VS(i.data, i.description.type) : -1;
  let n = i.size;
  return r > 0 && (s += r, n -= r), {
    ...i,
    is_idr: r >= 0,
    offset: s,
    size: n,
    cts: (i.cts - e) / i.timescale * 1e6,
    dts: (i.dts - e) / i.timescale * 1e6,
    duration: i.duration / i.timescale * 1e6,
    timescale: 1e6,
    // Audio data volume is controllable, save directly in memory
    data: t === "video" ? null : i.data
  };
}
class BS {
  constructor(e, t, s) {
    this.localFileReader = e, this.samples = t, this.conf = s;
  }
  decoder = null;
  timestamp = 0;
  curAborter = { abort: !1, st: performance.now() };
  find = async (e) => {
    (this.decoder == null || this.decoder.state === "closed" || e <= this.timestamp || e - this.timestamp > 3e6) && this.reset(e), this.curAborter.abort = !0, this.timestamp = e, this.curAborter = { abort: !1, st: performance.now() };
    const t = await this.parseFrame(e, this.decoder, this.curAborter);
    return this.sleepCnt = 0, t;
  };
  // Fix VideoFrame duration is null
  lastVfDur = 0;
  downgradeSoftDecode = !1;
  videoDecCursorIdx = 0;
  videoFrames = [];
  outputFrameCnt = 0;
  inputChunkCnt = 0;
  sleepCnt = 0;
  predecodeErr = !1;
  parseFrame = async (e, t, s) => {
    if (t == null || t.state === "closed" || s.abort) return null;
    if (this.videoFrames.length > 0) {
      const r = this.videoFrames[0];
      return e < r.timestamp ? null : (this.videoFrames.shift(), e > r.timestamp + (r.duration ?? 0) ? (r.close(), await this.parseFrame(e, t, s)) : (!this.predecodeErr && this.videoFrames.length < 10 && this.startDecode(t).catch((n) => {
        throw this.predecodeErr = !0, this.reset(e), n;
      }), r));
    }
    if (this.decoding || this.outputFrameCnt < this.inputChunkCnt && t.decodeQueueSize > 0) {
      if (performance.now() - s.st > 6e3)
        throw Error(
          `VideoClip.tick video timeout, ${JSON.stringify(this.getState())}`
        );
      this.sleepCnt += 1, await iu(15);
    } else {
      if (this.videoDecCursorIdx >= this.samples.length)
        return null;
      try {
        await this.startDecode(t);
      } catch (r) {
        throw this.reset(e), r;
      }
    }
    return await this.parseFrame(e, t, s);
  };
  decoding = !1;
  startDecode = async (e) => {
    if (this.decoding || e.decodeQueueSize > 600) return;
    let t = this.videoDecCursorIdx + 1;
    if (t > this.samples.length) return;
    this.decoding = !0;
    let s = !1;
    for (; t < this.samples.length; t++) {
      const r = this.samples[t];
      if (!s && !r.deleted && (s = !0), r.is_idr) break;
    }
    if (s) {
      const r = this.samples.slice(this.videoDecCursorIdx, t);
      if (r[0]?.is_idr !== !0)
        K.warn("First sample not idr frame");
      else {
        const n = performance.now(), o = await NS(r, this.localFileReader), a = performance.now() - n;
        if (a > 1e3) {
          const l = r[0], c = r.at(-1), h = c.offset + c.size - l.offset;
          K.warn(
            `Read video samples time cost: ${Math.round(
              a
            )}ms, file chunk size: ${h}`
          );
        }
        if (e.state === "closed") return;
        this.lastVfDur = o[0]?.duration ?? 0, WS(e, o, {
          onDecodingError: (l) => {
            if (this.downgradeSoftDecode)
              throw l;
            this.outputFrameCnt === 0 && (this.downgradeSoftDecode = !0, K.warn("Downgrade to software decode"), this.reset());
          }
        }), this.inputChunkCnt += o.length;
      }
    }
    this.videoDecCursorIdx = t, this.decoding = !1;
  };
  reset = (e) => {
    if (this.decoding = !1, this.videoFrames.forEach((s) => s.close()), this.videoFrames = [], e == null || e === 0)
      this.videoDecCursorIdx = 0;
    else {
      let s = 0;
      for (let r = 0; r < this.samples.length; r++) {
        const n = this.samples[r];
        if (n.is_idr && (s = r), !(n.cts < e)) {
          this.videoDecCursorIdx = s;
          break;
        }
      }
    }
    this.inputChunkCnt = 0, this.outputFrameCnt = 0, this.decoder?.state !== "closed" && this.decoder?.close();
    const t = {
      ...this.conf,
      ...this.downgradeSoftDecode ? { hardwareAcceleration: "prefer-software" } : {}
    };
    this.decoder = new VideoDecoder({
      output: (s) => {
        if (this.outputFrameCnt += 1, s.timestamp === -1) {
          s.close();
          return;
        }
        let r = s;
        s.duration == null && (r = new VideoFrame(s, {
          duration: this.lastVfDur
        }), s.close()), this.videoFrames.push(r);
      },
      error: (s) => {
        if (s.message.includes("Codec reclaimed due to inactivity")) {
          this.decoder = null, K.warn(s.message);
          return;
        }
        const r = `VideoFinder VideoDecoder err: ${s.message}, config: ${JSON.stringify(t)}, state: ${JSON.stringify(
          this.getState()
        )}`;
        throw K.error(r), Error(r);
      }
    }), this.decoder.configure(t);
  };
  getState = () => ({
    time: this.timestamp,
    decState: this.decoder?.state,
    decQSize: this.decoder?.decodeQueueSize,
    decCursorIdx: this.videoDecCursorIdx,
    sampleLen: this.samples.length,
    inputCnt: this.inputChunkCnt,
    outputCnt: this.outputFrameCnt,
    cacheFrameLen: this.videoFrames.length,
    softDecode: this.downgradeSoftDecode,
    clipIdCnt: vu,
    sleepCnt: this.sleepCnt,
    memInfo: Xm()
  });
  destroy = () => {
    this.decoder?.state !== "closed" && this.decoder?.close(), this.decoder = null, this.curAborter.abort = !0, this.videoFrames.forEach((e) => e.close()), this.videoFrames = [], this.localFileReader.close();
  };
}
function zS(i, e) {
  for (let t = 0; t < e.length; t++) {
    const s = e[t];
    if (i >= s.cts && i < s.cts + s.duration)
      return t;
    if (s.cts > i) break;
  }
  return 0;
}
class OS {
  constructor(e, t, s, r) {
    this.localFileReader = e, this.samples = t, this.conf = s, this.volume = r.volume, this.sampleRate = r.targetSampleRate;
  }
  volume = 1;
  sampleRate;
  setVolume(e) {
    this.volume = e, this.reset();
  }
  decoder = null;
  curAborter = { abort: !1, st: performance.now() };
  find = async (e) => {
    const t = e <= this.timestamp || e - this.timestamp > 1e5;
    (this.decoder == null || this.decoder.state === "closed" || t) && this.reset(), t && (this.timestamp = e, this.decCursorIdx = zS(e, this.samples)), this.curAborter.abort = !0;
    const s = e - this.timestamp;
    this.timestamp = e, this.curAborter = { abort: !1, st: performance.now() };
    const r = await this.parseFrame(
      Math.ceil(s * (this.sampleRate / 1e6)),
      this.decoder,
      this.curAborter
    );
    return this.sleepCnt = 0, r;
  };
  timestamp = 0;
  decCursorIdx = 0;
  pcmData = {
    frameCnt: 0,
    data: []
  };
  sleepCnt = 0;
  parseFrame = async (e, t = null, s) => {
    if (t == null || s.abort || t.state === "closed" || e === 0)
      return [];
    const r = this.pcmData.frameCnt - e;
    if (r > 0)
      return r < ie.sampleRate / 10 && this.startDecode(t), Jd(this.pcmData, e);
    if (t.decoding) {
      if (performance.now() - s.st > 3e3)
        throw s.abort = !0, Error(
          `VideoClip.tick audio timeout, ${JSON.stringify(this.getState())}`
        );
      this.sleepCnt += 1, await iu(15);
    } else {
      if (this.decCursorIdx >= this.samples.length - 1)
        return Jd(this.pcmData, this.pcmData.frameCnt);
      this.startDecode(t);
    }
    return this.parseFrame(e, t, s);
  };
  startDecode = (e) => {
    if (e.decodeQueueSize > 10) return;
    const s = [];
    let r = this.decCursorIdx;
    for (; r < this.samples.length; ) {
      const n = this.samples[r];
      if (r += 1, !n.deleted && (s.push(n), s.length >= 10))
        break;
    }
    this.decCursorIdx = r, e.decode(
      s.map(
        (n) => new EncodedAudioChunk({
          type: "key",
          timestamp: n.cts,
          duration: n.duration,
          data: n.data
        })
      )
    );
  };
  reset = () => {
    this.timestamp = 0, this.decCursorIdx = 0, this.pcmData = {
      frameCnt: 0,
      data: []
    }, this.decoder?.close(), this.decoder = DS(
      this.conf,
      {
        resampleRate: ie.sampleRate,
        volume: this.volume
      },
      (e) => {
        this.pcmData.data.push(e), this.pcmData.frameCnt += e[0].length;
      }
    );
  };
  getState = () => ({
    time: this.timestamp,
    decState: this.decoder?.state,
    decQSize: this.decoder?.decodeQueueSize,
    decCursorIdx: this.decCursorIdx,
    sampleLen: this.samples.length,
    pcmLen: this.pcmData.frameCnt,
    clipIdCnt: vu,
    sleepCnt: this.sleepCnt,
    memInfo: Xm()
  });
  destroy = () => {
    this.decoder = null, this.curAborter.abort = !0, this.pcmData = {
      frameCnt: 0,
      data: []
    }, this.localFileReader.close();
  };
}
function DS(i, e, t) {
  let s = 0, r = 0;
  const n = (h) => {
    if (r += 1, h.length !== 0) {
      if (e.volume !== 1)
        for (const u of h)
          for (let d = 0; d < u.length; d++) u[d] *= e.volume;
      h.length === 1 && (h = [h[0], h[0]]), t(h);
    }
  }, o = LS(n), a = e.resampleRate !== i.sampleRate;
  let l = new AudioDecoder({
    output: (h) => {
      const u = pp(h);
      a ? o(
        () => Z_(u, h.sampleRate, {
          rate: e.resampleRate,
          chanCount: h.numberOfChannels
        })
      ) : n(u), h.close();
    },
    error: (h) => {
      h.message.includes("Codec reclaimed due to inactivity") || c("VideoClip AudioDecoder err", h);
    }
  });
  l.configure(i);
  function c(h, u) {
    const d = `${h}: ${u.message}, state: ${JSON.stringify({
      qSize: l.decodeQueueSize,
      state: l.state,
      inputCnt: s,
      outputCnt: r
    })}`;
    throw K.error(d), Error(d);
  }
  return {
    decode(h) {
      s += h.length;
      try {
        for (const u of h) l.decode(u);
      } catch (u) {
        c("decode audio chunk error", u);
      }
    },
    close() {
      l.state !== "closed" && l.close();
    },
    get decoding() {
      return s > r && l.decodeQueueSize > 0;
    },
    get state() {
      return l.state;
    },
    get decodeQueueSize() {
      return l.decodeQueueSize;
    }
  };
}
function LS(i) {
  const e = [];
  let t = 0;
  function s(o, a) {
    e[a] = o, r();
  }
  function r() {
    const o = e[t];
    o != null && (i(o), t += 1, r());
  }
  let n = 0;
  return (o) => {
    const a = n;
    n += 1, o().then((l) => s(l, a)).catch((l) => s(l, a));
  };
}
function Jd(i, e) {
  const t = [new Float32Array(e), new Float32Array(e)];
  let s = 0, r = 0;
  for (; r < i.data.length; ) {
    const [n, o] = i.data[r];
    if (s + n.length > e) {
      const a = e - s;
      t[0].set(n.subarray(0, a), s), t[1].set(o.subarray(0, a), s), i.data[r][0] = n.subarray(a, n.length), i.data[r][1] = o.subarray(a, o.length);
      break;
    } else
      t[0].set(n, s), t[1].set(o, s), s += n.length, r++;
  }
  return i.data = i.data.slice(r), i.frameCnt -= e, t;
}
async function NS(i, e) {
  const t = i[0], s = i.at(-1);
  if (s == null) return [];
  const r = s.offset + s.size - t.offset;
  if (r < 3e7) {
    const n = new Uint8Array(
      await e.read(r, { at: t.offset })
    );
    return i.map((o) => {
      const a = o.offset - t.offset;
      return new EncodedVideoChunk({
        type: o.is_sync ? "key" : "delta",
        timestamp: o.cts,
        duration: o.duration,
        data: n.subarray(a, a + o.size)
      });
    });
  }
  return await Promise.all(
    i.map(async (n) => new EncodedVideoChunk({
      type: n.is_sync ? "key" : "delta",
      timestamp: n.cts,
      duration: n.duration,
      data: await e.read(n.size, {
        at: n.offset
      })
    }))
  );
}
function GS(i, e) {
  if (i.length === 0) return [];
  let t = 0, s = 0, r = -1;
  for (let l = 0; l < i.length; l++) {
    const c = i[l];
    if (r === -1 && e < c.cts && (r = l - 1), c.is_idr)
      if (r === -1)
        t = l;
      else {
        s = l;
        break;
      }
  }
  const n = i[r];
  if (n == null) throw Error("Not found video sample by time");
  const o = i.slice(0, s === 0 ? i.length : s).map((l) => ({ ...l }));
  for (let l = t; l < o.length; l++) {
    const c = o[l];
    e < c.cts && (c.deleted = !0, c.cts = -1);
  }
  Xh(o);
  const a = i.slice(n.is_idr ? r : t).map((l) => ({ ...l, cts: l.cts - e }));
  for (const l of a)
    l.cts < 0 && (l.deleted = !0, l.cts = -1);
  return Xh(a), [o, a];
}
function HS(i, e) {
  if (i.length === 0) return [];
  let t = -1;
  for (let n = 0; n < i.length; n++) {
    const o = i[n];
    if (!(e > o.cts)) {
      t = n;
      break;
    }
  }
  if (t === -1) throw Error("Not found audio sample by time");
  const s = i.slice(0, t).map((n) => ({ ...n })), r = i.slice(t).map((n) => ({ ...n, cts: n.cts - e }));
  return [s, r];
}
function WS(i, e, t) {
  if (i.state === "configured") {
    for (let s = 0; s < e.length; s++) i.decode(e[s]);
    i.flush().catch((s) => {
      if (!(s instanceof Error)) throw s;
      if (s.message.includes("Decoding error") && t.onDecodingError != null) {
        t.onDecodingError(s);
        return;
      }
      if (!s.message.includes("Aborted due to close"))
        throw s;
    });
  }
}
function VS(i, e) {
  if (e !== "avc1" && e !== "hvc1") return 0;
  const t = new DataView(i.buffer);
  for (let s = 0; s < i.byteLength - 4; ) {
    if (e === "avc1") {
      const r = t.getUint8(s + 4) & 31;
      if (r === 5 || r === 7 || r === 8) return s;
    } else if (e === "hvc1") {
      const r = t.getUint8(s + 4) >> 1 & 63;
      if (r === 19 || r === 20 || r === 32 || r === 33 || r === 34)
        return s;
    }
    s += t.getUint32(s) + 4;
  }
  return -1;
}
function Xh(i) {
  let e = 0, t = null;
  for (const s of i)
    if (!s.deleted) {
      if (s.is_sync && (e += 1), e >= 2) break;
      (t == null || s.cts < t.cts) && (t = s);
    }
  t != null && t.cts < 2e5 && (t.duration += t.cts, t.cts = 0);
}
function Xm() {
  try {
    const i = performance.memory;
    return {
      jsHeapSizeLimit: i.jsHeapSizeLimit,
      totalJSHeapSize: i.totalJSHeapSize,
      usedJSHeapSize: i.usedJSHeapSize,
      percentUsed: (i.usedJSHeapSize / i.jsHeapSizeLimit).toFixed(3),
      percentTotal: (i.totalJSHeapSize / i.jsHeapSizeLimit).toFixed(3)
    };
  } catch {
    return {};
  }
}
class et extends Yt {
  type = "Text";
  ready;
  _meta = {
    duration: 1 / 0,
    width: 0,
    height: 0
  };
  get meta() {
    return { ...this._meta };
  }
  // Override width/height to trigger refreshText when resized by transformer
  // Use getters from BaseSprite but override setters
  get width() {
    return this._width;
  }
  set width(e) {
    this.width !== e && (this._width = e, this.refreshText(), this.emit("propsChange", { width: e }));
  }
  get height() {
    return this._height;
  }
  set height(e) {
    this.height !== e && (this._height = e, this.refreshText(), this.emit("propsChange", { height: e }));
  }
  _lastContentWidth = 0;
  _lastContentHeight = 0;
  _text = "";
  /**
   * Text content (hybrid JSON structure)
   */
  get text() {
    return this._text;
  }
  set text(e) {
    this._text !== e && (this._text = e, this.originalOpts && this.textStyle && this.refreshText());
  }
  /**
   * Text styling (hybrid JSON structure)
   * Provides direct access to styling properties
   */
  /**
   * Text styling (hybrid JSON structure)
   * Provides direct access to styling properties
   */
  get style() {
    return {
      fontSize: this.originalOpts.fontSize,
      fontFamily: this.originalOpts.fontFamily,
      fontWeight: this.originalOpts.fontWeight,
      fontStyle: this.originalOpts.fontStyle,
      fill: this.originalOpts.fill,
      align: this.originalOpts.align,
      stroke: this.originalOpts.stroke ? typeof this.originalOpts.stroke == "object" ? {
        color: this.originalOpts.stroke.color,
        width: this.originalOpts.stroke.width,
        join: this.originalOpts.stroke.join,
        cap: this.originalOpts.stroke.cap,
        miterLimit: this.originalOpts.stroke.miterLimit
      } : {
        color: this.originalOpts.stroke,
        width: this.originalOpts.strokeWidth ?? 0
      } : void 0,
      dropShadow: this.originalOpts.dropShadow ? {
        color: this.originalOpts.dropShadow.color ?? "#000000",
        alpha: this.originalOpts.dropShadow.alpha ?? 0.5,
        blur: this.originalOpts.dropShadow.blur ?? 4,
        distance: this.originalOpts.dropShadow.distance ?? 0,
        angle: this.originalOpts.dropShadow.angle ?? 0
      } : void 0,
      wordWrap: this.originalOpts.wordWrap,
      wordWrapWidth: this.originalOpts.wordWrapWidth,
      lineHeight: this.originalOpts.lineHeight,
      letterSpacing: this.originalOpts.letterSpacing,
      textCase: this.originalOpts.textCase,
      textDecoration: this.originalOpts.textDecoration
    };
  }
  set style(e) {
    this.updateStyle(e);
  }
  /**
   * Text alignment proxy for compatibility with UI
   */
  get textAlign() {
    return this.originalOpts.align || this.originalOpts.textAlign || "left";
  }
  set textAlign(e) {
    this.updateStyle({ align: e });
  }
  /**
   * Vertical alignment or decoration proxy
   */
  get verticalAlign() {
    return this.originalOpts.verticalAlign || this.originalOpts.textDecoration || "top";
  }
  set verticalAlign(e) {
    ["underline", "overline", "strikethrough", "line-through"].includes(e) ? (this.updateStyle({
      textDecoration: e === "strikethrough" ? "line-through" : e
    }), this.originalOpts.verticalAlign = e) : this.updateStyle({ verticalAlign: e });
  }
  /**
   * Text case proxy
   */
  get textCase() {
    return this.originalOpts.textCase || "none";
  }
  set textCase(e) {
    this.updateStyle({ textCase: e });
  }
  pixiText = null;
  textStyle;
  renderTexture = null;
  // External renderer (preferred) - provided via constructor or setRenderer()
  // If not provided, TextClip will create its own minimal renderer as fallback
  externalRenderer = null;
  pixiApp = null;
  // Fallback renderer
  // Store original options for serialization to avoid accessing TextStyle properties
  originalOpts;
  /**
   * Unique identifier for this clip instance
   */
  id = `clip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  /**
   * Array of effects to be applied to this clip
   * Each effect specifies key, startTime, duration, and optional targets
   */
  effects = [];
  constructor(e, t = {}, s) {
    super(), this.originalOpts = { ...t }, this.text = e, this.externalRenderer = s ?? null;
    const r = this.createStyleFromOpts(t), n = new Ze(r);
    this.textStyle = n, this.ready = (async () => {
      await this.refreshText();
      const o = { ...this._meta };
      return K.info("TextClip ready:", o), o;
    })();
  }
  /**
   * Set an external renderer (e.g., from Studio) to avoid creating our own Pixi App
   * This is an optimization for Studio preview
   * Can be called before ready() completes
   */
  setRenderer(e) {
    this.externalRenderer = e;
  }
  /**
   * Get the renderer for rendering text to RenderTexture
   * Creates a minimal renderer as fallback if no external renderer is provided
   */
  async getRenderer() {
    if (this.externalRenderer != null)
      return this.externalRenderer;
    if (this.pixiApp?.renderer == null)
      throw new Error(
        "TextClip: Failed to create renderer. Please provide a renderer via constructor or setRenderer() method."
      );
    return this.pixiApp.renderer;
  }
  /**
   * Get the PixiJS Texture (RenderTexture) for optimized rendering in Studio
   * This avoids ImageBitmap  Canvas  Texture conversion
   *
   * @returns The RenderTexture containing the rendered text, or null if not ready
   */
  async getTexture() {
    return this.pixiText == null || this.renderTexture == null ? null : ((await this.getRenderer()).render({
      container: this.pixiText,
      target: this.renderTexture
    }), this.renderTexture);
  }
  async tick(e) {
    if (await this.ready, this.pixiText == null || this.renderTexture == null)
      throw new Error("TextClip not initialized");
    if (this.renderTexture.width <= 0 || this.renderTexture.height <= 0)
      throw new Error(
        `Invalid RenderTexture dimensions: ${this.renderTexture.width}x${this.renderTexture.height}`
      );
    (await this.getRenderer()).render({
      container: this.pixiText,
      target: this.renderTexture
    });
    const s = this.renderTexture.source?.resource?.source;
    let r;
    if (s instanceof HTMLCanvasElement)
      r = await createImageBitmap(s);
    else if (s instanceof OffscreenCanvas)
      r = await createImageBitmap(s);
    else {
      const a = (await this.getRenderer()).extract.canvas(this.renderTexture);
      if (a instanceof HTMLCanvasElement || a instanceof OffscreenCanvas)
        r = await createImageBitmap(a);
      else {
        const l = this.renderTexture.width, c = this.renderTexture.height;
        throw new OffscreenCanvas(l, c).getContext("2d") == null ? new Error("Failed to create 2d context for fallback rendering") : new Error("Unable to extract canvas from render texture");
      }
    }
    return {
      video: r,
      state: "success"
    };
  }
  async split(e) {
    await this.ready;
    const t = await this.clone(), s = await this.clone();
    return [t, s];
  }
  // Effects
  addEffect(e) {
    this.effects.push(e);
  }
  editEffect(e, t) {
    const s = this.effects.find((r) => r.id === e);
    s && Object.assign(s, t);
  }
  removeEffect(e) {
    const t = this.effects.findIndex((s) => s.id === e);
    t !== -1 && this.effects.splice(t, 1);
  }
  async clone() {
    await this.ready;
    const e = this.textStyle, t = this.originalOpts || {}, s = (o) => {
      if (o != null) {
        if (typeof o == "number") return o;
        if (o instanceof pe) return o.toNumber();
      }
    }, r = {
      fontSize: t.fontSize ?? e.fontSize,
      fontFamily: t.fontFamily ?? (Array.isArray(e.fontFamily) ? e.fontFamily[0] : typeof e.fontFamily == "string" ? e.fontFamily : "Roboto"),
      fontWeight: t.fontWeight ?? e.fontWeight,
      fontStyle: t.fontStyle ?? e.fontStyle,
      align: t.align ?? (e.align === "justify" ? "left" : e.align),
      textCase: t.textCase,
      textDecoration: t.textDecoration
    };
    if (t.fill && typeof t.fill == "object" && "type" in t.fill && t.fill.type === "gradient")
      r.fill = t.fill;
    else {
      const o = s(e.fill);
      r.fill = o ?? 16777215;
    }
    if (t.stroke && typeof t.stroke == "object" && "color" in t.stroke)
      r.stroke = t.stroke;
    else {
      const o = s(e.stroke);
      o !== void 0 && (r.stroke = o), r.strokeWidth = t.strokeWidth ?? e.strokeThickness ?? 0;
    }
    if (t.dropShadow)
      r.dropShadow = t.dropShadow;
    else if (e.dropShadow) {
      const o = e.dropShadow, a = s(o.color);
      a !== void 0 && (r.dropShadow = {
        color: a,
        alpha: o.alpha,
        blur: o.blur,
        angle: o.angle,
        distance: o.distance
      });
    }
    if (t.wordWrap !== void 0 ? (r.wordWrap = t.wordWrap, r.wordWrapWidth = t.wordWrapWidth) : e.wordWrap && (r.wordWrap = e.wordWrap, r.wordWrapWidth = e.wordWrapWidth), t.lineHeight !== void 0)
      r.lineHeight = t.lineHeight;
    else if (e.lineHeight !== void 0) {
      const o = r.fontSize ?? e.fontSize ?? 40;
      r.lineHeight = e.lineHeight / o;
    }
    t.letterSpacing !== void 0 ? r.letterSpacing = t.letterSpacing : e.letterSpacing !== void 0 && (r.letterSpacing = e.letterSpacing);
    const n = new et(this.text, r);
    return await n.ready, this.copyStateTo(n), n.id = this.id, n.effects = [...this.effects], n;
  }
  /**
   * Update text styling options and refresh the texture
   * This is used for dynamic updates like resizing with text reflow
   */
  async updateStyle(e) {
    this.originalOpts = { ...this.originalOpts, ...e };
    const t = this.createStyleFromOpts(this.originalOpts), s = new Ze(t);
    this.textStyle = s, await this.refreshText();
  }
  /**
   * Refresh the internal Pixi Text and RenderTexture
   * Calculates dimensions based on text bounds and wrapping options
   */
  async refreshText() {
    const e = this.textStyle;
    let t = this.text;
    const s = this.originalOpts.textCase;
    s === "uppercase" ? t = t.toUpperCase() : s === "lowercase" ? t = t.toLowerCase() : s === "title" && (t = t.replace(
      /\w\S*/g,
      (p) => p.charAt(0).toUpperCase() + p.substring(1).toLowerCase()
    )), this.pixiText ? (this.pixiText.text = t, this.pixiText.style = e, this.pixiText.children.forEach((p) => {
      p instanceof fe && p.destroy();
    }), this.pixiText.removeChildren()) : this.pixiText = new bS({ text: t, style: e });
    const r = this.originalOpts.textDecoration || this.originalOpts.verticalAlign;
    if (r && r !== "none" && ["underline", "overline", "strikethrough", "line-through"].includes(
      r
    )) {
      const p = r === "strikethrough" ? "line-through" : r, x = Ge.measureText(
        t,
        e
      ), y = e.fontSize ?? 40, v = Math.max(1, y / 12);
      let _ = 16777215;
      typeof e.fill == "number" ? _ = e.fill : e.fill && typeof e.fill == "object" && "fill" in e.fill && (_ = 16777215);
      const b = new fe(), T = e.lineHeight ?? x.lineHeight;
      for (let w = 0; w < x.lines.length; w++) {
        const A = x.lineWidths[w];
        let k = 0;
        e.align === "center" ? k = (x.maxLineWidth - A) / 2 : e.align === "right" && (k = x.maxLineWidth - A);
        const S = w * T;
        let C = 0;
        p === "underline" ? C = T : p === "line-through" ? C = T / 2 : p === "overline" && (C = 0);
        const U = S + C;
        b.rect(k, U, A, v), b.fill(_);
      }
      this.pixiText.addChild(b);
    }
    const n = this.pixiText.getLocalBounds(), o = Math.ceil(n.width || this.pixiText.width || 1), a = Math.ceil(n.height || this.pixiText.height || 1);
    let l = o;
    e.wordWrap && e.wordWrapWidth > 0 && (l = Math.max(l, e.wordWrapWidth));
    const c = a, h = this.width === 0 || Math.abs(this.width - this._lastContentWidth) < 0.1, u = this.height === 0 || Math.abs(this.height - this._lastContentHeight) < 0.1, d = h ? l : Math.max(l, this.width || 0), f = u ? c : Math.max(c, this.height || 0);
    this._lastContentWidth = l, this._lastContentHeight = c;
    const m = this.textAlign;
    m === "center" ? this.pixiText.x = (d - o) / 2 : m === "right" ? this.pixiText.x = d - o : this.pixiText.x = 0;
    const g = this.originalOpts.verticalAlign || "top";
    g === "center" ? this.pixiText.y = (f - a) / 2 : g === "bottom" ? this.pixiText.y = f - a : this.pixiText.y = 0, this.renderTexture && this.renderTexture.destroy(), this.renderTexture = Pe.create({
      width: d,
      height: f
    }), this._meta.width = d, this._meta.height = f, this._width = d, this._height = f, this.duration === 0 && this._meta.duration !== 1 / 0 && (this.duration = this._meta.duration, this.display.to = this.display.from + this.duration);
  }
  /**
   * Helper to create PixiJS TextStyle options from TextClip options
   */
  createStyleFromOpts(e) {
    const t = e.fontSize ?? 40, s = e.lineHeight ?? 1, r = {
      fontSize: t,
      fontFamily: e.fontFamily ?? "Roboto",
      fontWeight: e.fontWeight ?? "normal",
      fontStyle: e.fontStyle ?? "normal",
      align: e.align ?? "left",
      wordWrap: e.wordWrap ?? !1,
      wordWrapWidth: e.wordWrapWidth ?? 100,
      lineHeight: t * s,
      letterSpacing: e.letterSpacing ?? 0
    };
    if (e.fill && typeof e.fill == "object" && e.fill.type === "gradient") {
      const n = new qe(
        e.fill.x0,
        e.fill.y0,
        e.fill.x1,
        e.fill.y1
      );
      e.fill.colors.forEach(({ ratio: o, color: a }) => {
        const l = typeof a == "number" ? a : ge(a) ?? 16777215;
        n.addColorStop(o, l);
      }), r.fill = { fill: n };
    } else {
      const { color: n, alpha: o } = Nt(
        e.fill
      );
      r.fill = n, o < 1 && (r.fillAlpha = o);
    }
    if (e.stroke && typeof e.stroke == "object" && "color" in e.stroke) {
      const n = ge(e.stroke.color);
      n !== void 0 && (r.stroke = { color: n, width: e.stroke.width }, e.stroke.join && (r.stroke.join = e.stroke.join), e.stroke.cap && (r.stroke.cap = e.stroke.cap), e.stroke.miterLimit && (r.stroke.miterLimit = e.stroke.miterLimit));
    } else {
      const n = ge(e.stroke), o = e.strokeWidth ?? 0;
      n !== void 0 && o > 0 ? r.stroke = { color: n, width: o } : e.strokeWidth && e.strokeWidth > 0 && (r.stroke = { color: 0, width: e.strokeWidth });
    }
    if (e.dropShadow) {
      const n = ge(e.dropShadow.color);
      n !== void 0 && (r.dropShadow = {
        color: n,
        alpha: e.dropShadow.alpha ?? 0.5,
        blur: e.dropShadow.blur ?? 4,
        angle: e.dropShadow.angle ?? Math.PI / 6,
        distance: e.dropShadow.distance ?? 2
      });
    }
    return r;
  }
  destroy() {
    if (!this.destroyed) {
      K.info("TextClip destroy");
      try {
        this.pixiText != null && this.pixiText.destroyed !== !0 && this.pixiText.destroy({ children: !0 });
      } catch {
      } finally {
        this.pixiText = null;
      }
      try {
        this.renderTexture != null && this.renderTexture.destroyed !== !0 && this.renderTexture.destroy(!0);
      } catch {
      } finally {
        this.renderTexture = null;
      }
      if (this.externalRenderer = null, this.pixiApp != null)
        try {
          const e = this.pixiApp;
          e.destroyed !== !0 && e.renderer != null && this.pixiApp.destroy(!0, {
            children: !0,
            texture: !0
          });
        } catch {
        } finally {
          this.pixiApp = null;
        }
      super.destroy();
    }
  }
  toJSON(e = !1) {
    const t = super.toJSON(e), s = {};
    return this.originalOpts.fontSize !== void 0 && (s.fontSize = this.originalOpts.fontSize), this.originalOpts.fontFamily !== void 0 && (s.fontFamily = this.originalOpts.fontFamily), this.originalOpts.fontWeight !== void 0 && (s.fontWeight = this.originalOpts.fontWeight), this.originalOpts.fontStyle !== void 0 && (s.fontStyle = this.originalOpts.fontStyle), this.originalOpts.fill !== void 0 && (s.color = this.originalOpts.fill), this.originalOpts.align !== void 0 && (s.align = this.originalOpts.align), this.originalOpts.wordWrap !== void 0 && (s.wordWrap = this.originalOpts.wordWrap), this.originalOpts.wordWrapWidth !== void 0 && (s.wordWrapWidth = this.originalOpts.wordWrapWidth), this.originalOpts.lineHeight !== void 0 && (s.lineHeight = this.originalOpts.lineHeight), this.originalOpts.letterSpacing !== void 0 && (s.letterSpacing = this.originalOpts.letterSpacing), this.originalOpts.stroke && (typeof this.originalOpts.stroke == "object" ? s.stroke = {
      color: this.originalOpts.stroke.color,
      width: this.originalOpts.stroke.width,
      join: this.originalOpts.stroke.join,
      cap: this.originalOpts.stroke.cap,
      // cap might be missing from ITextClipOpts definition but present in object
      miterLimit: this.originalOpts.stroke.miterLimit
    } : s.stroke = {
      color: this.originalOpts.stroke,
      width: this.originalOpts.strokeWidth ?? 0
    }), this.originalOpts.dropShadow && (s.shadow = {
      color: this.originalOpts.dropShadow.color ?? "#000000",
      alpha: this.originalOpts.dropShadow.alpha ?? 0.5,
      blur: this.originalOpts.dropShadow.blur ?? 4,
      distance: this.originalOpts.dropShadow.distance ?? 0,
      angle: this.originalOpts.dropShadow.angle ?? 0
    }), {
      ...t,
      type: "Text",
      text: this.text,
      style: s,
      id: this.id,
      effects: this.effects
    };
  }
  /**
   * Create a TextClip instance from a JSON object (fabric.js pattern)
   * @param json The JSON object representing the clip
   * @returns Promise that resolves to a TextClip instance
   */
  static async fromObject(e) {
    if (e.type !== "Text")
      throw new Error(`Expected Text, got ${e.type}`);
    const t = e.text || "", s = e.style || {}, r = {};
    s.fontSize !== void 0 && (r.fontSize = s.fontSize), s.fontFamily !== void 0 && (r.fontFamily = s.fontFamily), s.fontWeight !== void 0 && (r.fontWeight = s.fontWeight), s.fontStyle !== void 0 && (r.fontStyle = s.fontStyle), s.color !== void 0 && (r.fill = s.color), s.align !== void 0 && (r.align = s.align), s.wordWrap !== void 0 && (r.wordWrap = s.wordWrap), s.wordWrapWidth !== void 0 && (r.wordWrapWidth = s.wordWrapWidth), s.lineHeight !== void 0 && (r.lineHeight = s.lineHeight), s.letterSpacing !== void 0 && (r.letterSpacing = s.letterSpacing), s.stroke && (s.stroke.join || s.stroke.cap || s.stroke.miterLimit !== void 0 ? r.stroke = {
      color: s.stroke.color,
      width: s.stroke.width,
      join: s.stroke.join,
      cap: s.stroke.cap,
      miterLimit: s.stroke.miterLimit
    } : (r.stroke = s.stroke.color, r.strokeWidth = s.stroke.width)), s.shadow && (r.dropShadow = {
      color: s.shadow.color,
      alpha: s.shadow.alpha,
      blur: s.shadow.blur,
      distance: s.shadow.distance,
      angle: s.shadow.angle
    });
    const n = new et(t, r);
    return n.left = e.left, n.top = e.top, n.width = e.width, n.height = e.height, n.angle = e.angle, n.display.from = e.display.from, n.display.to = e.display.to, n.duration = e.duration, n.playbackRate = e.playbackRate, n.zIndex = e.zIndex, n.opacity = e.opacity, n.flip = e.flip, e.animation && n.setAnimation(e.animation.keyFrames, e.animation.opts), e.id && (n.id = e.id), e.effects && (n.effects = e.effects), await n.ready, n;
  }
  /**
   * Override handle visibility for text clips
   * Text clips should only show: mr (mid-right), mb (mid-bottom), br (bottom-right), and rot (rotation)
   * This allows resizing width and height independently while preventing corner handles that might distort text
   */
  getVisibleHandles() {
    return ["mr", "mb", "br", "rot"];
  }
}
class tt extends Yt {
  type = "Effect";
  ready;
  _meta = {
    duration: 5e6,
    // Default 5 seconds
    width: 0,
    height: 0
  };
  get meta() {
    return { ...this._meta };
  }
  /**
   * Unique identifier for this clip instance
   */
  id = `clip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  /**
   * The effect configuration
   */
  effect;
  constructor(e) {
    super(), this.effect = {
      id: `eff_${Date.now()}`,
      key: e,
      name: e
    }, this.ready = Promise.resolve(this._meta), this.duration = this._meta.duration;
  }
  async clone() {
    const e = new tt(this.effect.key);
    return this.copyStateTo(e), e.id = this.id, e;
  }
  // EffectClip is invisible, so it returns empty/dummy data
  async tick(e) {
    return {
      video: void 0,
      state: "success"
    };
  }
  async split(e) {
    const t = await this.clone(), s = await this.clone();
    return [t, s];
  }
  toJSON(e = !1) {
    return {
      ...super.toJSON(e),
      type: "Effect",
      effect: this.effect,
      id: this.id,
      effects: this.effects
    };
  }
  /**
   * Create an EffectClip instance from a JSON object
   */
  static async fromObject(e) {
    if (e.type !== "Effect")
      throw new Error(`Expected Effect, got ${e.type}`);
    const t = new tt(e.effect.key);
    return t.effect = e.effect, t.left = e.left, t.top = e.top, t.width = e.width, t.height = e.height, t.angle = e.angle, t.display.from = e.display.from, t.display.to = e.display.to, t.duration = e.duration, t.playbackRate = e.playbackRate, t.zIndex = e.zIndex, t.opacity = e.opacity, t.flip = e.flip, e.animation && t.setAnimation(e.animation.keyFrames, e.animation.opts), e.id && (t.id = e.id), await t.ready, t;
  }
}
class pi extends Yt {
  type = "Transition";
  ready;
  _meta = {
    duration: 2e6,
    // Default 2 seconds
    width: 0,
    height: 0
  };
  get meta() {
    return { ...this._meta };
  }
  /**
   * Unique identifier for this clip instance
   */
  id = `clip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  /**
   * The transition configuration
   */
  transitionEffect;
  /**
   * ID of the clip from which the transition starts
   */
  fromClipId = null;
  /**
   * ID of the clip to which the transition ends
   */
  toClipId = null;
  constructor(e) {
    super(), this.transitionEffect = {
      id: `trans_${Date.now()}`,
      key: e,
      name: e
    }, this.ready = Promise.resolve(this._meta), this.duration = this._meta.duration;
  }
  async clone() {
    const e = new pi(this.transitionEffect.key);
    return this.copyStateTo(e), e.fromClipId = this.fromClipId, e.toClipId = this.toClipId, e;
  }
  // TransitionClip is invisible (it's applied via renderer logic), so it returns empty/dummy data
  async tick(e) {
    return {
      video: void 0,
      state: "success"
    };
  }
  async split(e) {
    const t = await this.clone(), s = await this.clone();
    return [t, s];
  }
  toJSON(e = !1) {
    return {
      ...super.toJSON(e),
      type: "Transition",
      transitionEffect: this.transitionEffect,
      fromClipId: this.fromClipId,
      toClipId: this.toClipId,
      id: this.id,
      effects: this.effects
    };
  }
  /**
   * Create a TransitionClip instance from a JSON object
   */
  static async fromObject(e) {
    if (e.type !== "Transition")
      throw new Error(`Expected Transition, got ${e.type}`);
    const t = new pi(e.transitionEffect.key);
    return t.transitionEffect = e.transitionEffect, t.fromClipId = e.fromClipId || null, t.toClipId = e.toClipId || null, t.left = e.left, t.top = e.top, t.width = e.width, t.height = e.height, t.angle = e.angle, t.display.from = e.display.from, t.display.to = e.display.to, t.duration = e.duration, t.playbackRate = e.playbackRate, t.zIndex = e.zIndex, t.opacity = e.opacity, t.flip = e.flip, e.animation && t.setAnimation(e.animation.keyFrames, e.animation.opts), e.id && (t.id = e.id), await t.ready, t;
  }
}
function qm(i, e) {
  let t = !1;
  async function s() {
    const r = i.getReader();
    for (; !t; ) {
      const { value: n, done: o } = await r.read();
      if (o) {
        e.onDone();
        return;
      }
      await e.onChunk(n);
    }
    r.releaseLock(), await i.cancel();
  }
  return s().catch(console.error), () => {
    t = !0;
  };
}
function Zm(i, e, t) {
  let s = 0, r = 0;
  const n = i.boxes;
  let o = !1;
  const a = () => {
    if (!o)
      if (n.find((m) => m.type === "moof") != null)
        o = !0;
      else
        return null;
    if (r >= n.length) return null;
    const d = new $t.DataStream();
    let f = r;
    try {
      for (; f < n.length; )
        n[f].write(d), delete n[f], f += 1;
    } catch (m) {
      const g = n[f];
      throw m instanceof Error && g != null ? Error(
        `${m.message} | deltaBuf( boxType: ${g.type}, boxSize: ${g.size}, boxDataLen: ${g.data?.length ?? -1})`
      ) : m;
    }
    return $S(i), r = n.length, new Uint8Array(d.buffer);
  };
  let l = !1, c = !1, h = null;
  return {
    stream: new ReadableStream({
      start(d) {
        s = self.setInterval(() => {
          const f = a();
          f != null && !c && d.enqueue(f);
        }, e), h = (f) => {
          if (clearInterval(s), i.flush(), f != null) {
            d.error(f);
            return;
          }
          const m = a();
          m != null && !c && d.enqueue(m), c || d.close();
        }, l && h();
      },
      cancel() {
        c = !0, clearInterval(s), t?.();
      }
    }),
    stop: (d) => {
      l || (l = !0, h?.(d));
    }
  };
}
function $S(i) {
  if (i.moov != null) {
    for (var e = 0; e < i.moov.traks.length; e++)
      i.moov.traks[e].samples = [];
    i.mdats = [], i.moofs = [];
  }
}
class Km {
  readable;
  writable;
  inputBufOffset = 0;
  isStreamCancelled = !1;
  constructor() {
    const e = $t.createFile();
    this.readable = new ReadableStream(
      {
        start: (t) => this.initMP4Box(e, t),
        cancel: () => {
          this.isStreamCancelled = !0, e.stop();
        }
      },
      { highWaterMark: 50 }
      // Each chunk typically contains 100 samples
    ), this.writable = new WritableStream({
      write: async (t) => {
        if (this.isStreamCancelled)
          throw new Error("Stream cancelled");
        const s = t.buffer;
        s.fileStart = this.inputBufOffset, this.inputBufOffset += s.byteLength, e.appendBuffer(s);
      },
      close: () => {
        e.flush(), e.stop(), e.onFlush?.();
      },
      abort: (t) => {
        YS.error("SampleTransform writable aborted:", t), e.stop();
      }
    });
  }
  initMP4Box(e, t) {
    e.onReady = (r) => {
      [r.videoTracks[0], r.audioTracks[0]].forEach((n) => {
        n && e.setExtractionOptions(
          n.id,
          n.video ? "video" : "audio",
          { nbSamples: 100 }
        );
      }), t.enqueue({ chunkType: "ready", data: { info: r, file: e } }), e.start();
    };
    const s = {};
    e.onSamples = (r, n, o) => {
      const a = o.map((l) => ({ ...l }));
      t.enqueue({
        chunkType: "samples",
        data: { id: r, type: n, samples: a }
      }), s[r] = (s[r] ?? 0) + o.length, e.releaseUsedSamples(r, s[r]);
    }, e.onFlush = () => {
      t.close();
    }, e.onError = (r) => {
      t.error(new Error(`mp4box error: ${r}`));
    };
  }
}
const YS = {
  error: (...i) => console.error("[SampleTransform]", ...i)
};
function XS(i) {
  let e = 0;
  const t = i.boxes, s = [];
  let r = 0;
  async function n() {
    const m = f(t, e);
    e = t.length, s.forEach(({ track: g, id: p }) => {
      const x = g.samples.at(-1);
      x != null && (r = Math.max(r, x.cts + x.duration)), i.releaseUsedSamples(p, g.samples.length), g.samples = [];
    }), i.mdats = [], i.moofs = [], m != null && await h?.write(m);
  }
  let o = [];
  function a() {
    if (o.length > 0) return !0;
    const m = t.findIndex((g) => g.type === "moov");
    if (m === -1) return !1;
    if (o = t.slice(0, m + 1), e = m + 1, s.length === 0)
      for (let g = 1; ; g += 1) {
        const p = i.getTrackById(g);
        if (p == null) break;
        s.push({ track: p, id: g });
      }
    return !0;
  }
  let l = 0;
  const c = Sh();
  let h = null;
  const u = (async () => {
    h = await c.createWriter(), l = self.setInterval(() => {
      a() && n();
    }, 100);
  })();
  let d = !1;
  return async () => {
    if (d) throw Error("File exported");
    if (d = !0, await u, clearInterval(l), !a() || h == null) return null;
    i.flush(), await n(), await h?.close();
    const m = o.find((x) => x.type === "moov");
    if (m == null) return null;
    m.mvhd.duration = r;
    const g = Sh(), p = f(o, 0);
    return await Ji(g, p.slice()), await Ji(g, c, { overwrite: !1 }), await g.stream();
  };
  function f(m, g) {
    if (g >= m.length) return null;
    const p = new $t.DataStream();
    for (let x = g; x < m.length; x++)
      m[x] !== null && (m[x].write(p), delete m[x]);
    return new Uint8Array(p.buffer).slice();
  }
}
function qS(i) {
  const e = new ArrayBuffer(i.byteLength);
  i.copyTo(e);
  const t = i.timestamp;
  return {
    duration: i.duration ?? 0,
    dts: t,
    cts: t,
    is_sync: i.type === "key",
    data: e
  };
}
async function ZS(i) {
  const e = $t.createFile(), t = XS(e);
  await KS(i, e);
  const s = await t();
  if (s == null) throw Error("Can not generate file from streams");
  return s;
}
async function KS(i, e) {
  let t = 0, s = 0, r = 0, n = 0, o = 0, a = 0, l = null, c = null;
  for (const h of i) {
    let u = null, d = null, f = null, m = null;
    if (await new Promise(async (g) => {
      qm(h.pipeThrough(new Km()), {
        onDone: g,
        onChunk: async ({ chunkType: p, data: x }) => {
          if (p === "ready") {
            const { videoTrackConf: y, audioTrackConf: v } = yu(
              x.file,
              x.info
            );
            t === 0 && y != null && (t = e.addTrack(y)), n === 0 && v != null && (n = e.addTrack(v));
          } else if (p === "samples") {
            const { type: y, samples: v } = x, _ = y === "video" ? t : n, b = y === "video" ? s : o, T = y === "video" ? r : a;
            v.forEach((A) => {
              let k, S;
              y === "video" ? (u === null && (u = A.dts, d = A.cts), k = A.dts - u, S = A.cts - (d ?? 0)) : (f === null && (f = A.dts, m = A.cts), k = A.dts - f, S = A.cts - (m ?? 0)), e.addSample(_, new Uint8Array(A.data), {
                duration: A.duration,
                dts: k + b,
                cts: S + T,
                is_sync: A.is_sync
              });
            });
            const w = v.at(-1);
            if (w == null) return;
            y === "video" ? l = w : y === "audio" && (c = w);
          }
        }
      });
    }), l != null && u !== null && d !== null) {
      const g = l.dts - u + l.duration, p = l.cts - d + l.duration;
      s += g, r += p;
    }
    if (c != null && l != null) {
      const g = c.timescale / l.timescale;
      o = Math.round(s * g), a = Math.round(r * g);
    }
  }
}
async function ak(i) {
  return await ZS([i]);
}
function JS(i) {
  let e = [];
  const t = new AudioDecoder({
    output: (s) => {
      e.push(s);
    },
    error: K.error
  });
  return t.configure(i), {
    decode: async (s) => {
      s.forEach((n) => {
        t.decode(
          new EncodedAudioChunk({
            type: n.is_sync ? "key" : "delta",
            timestamp: 1e6 * n.cts / n.timescale,
            duration: 1e6 * n.duration / n.timescale,
            data: n.data
          })
        );
      }), await t.flush();
      const r = e;
      return e = [], r;
    },
    close: () => {
      t.close();
    }
  };
}
function jS(i, e) {
  const t = {
    codec: i.codec,
    sampleRate: i.sampleRate,
    numberOfChannels: i.numberOfChannels
  }, s = new AudioEncoder({
    output: (o) => {
      e(qS(o));
    },
    error: (o) => {
      K.error("AudioEncoder error:", o, ", config:", t);
    }
  });
  s.configure(t);
  let r = null;
  function n(o, a) {
    return new AudioData({
      timestamp: a,
      numberOfChannels: i.numberOfChannels,
      numberOfFrames: o.length / i.numberOfChannels,
      sampleRate: i.sampleRate,
      format: "f32-planar",
      data: new Float32Array(o)
    });
  }
  return {
    encode: async (o, a) => {
      r != null && s.encode(n(r.data, r.ts)), r = { data: o, ts: a };
    },
    stop: async () => {
      r != null && (QS(
        r.data,
        i.numberOfChannels,
        i.sampleRate
      ), s.encode(n(r.data, r.ts)), r = null), await s.flush(), s.close();
    }
  };
}
function QS(i, e, t) {
  const s = i.length - 1, r = Math.min(t / 2, s);
  for (let n = 0; n < r; n++)
    for (let o = 1; o <= e; o++)
      i[Math.floor(s / o) - n] *= n / r;
}
function lk(i, e) {
  K.info("mixinMP4AndAudio, opts:", {
    volume: e.volume,
    loop: e.loop
  });
  const t = $t.createFile(), { stream: s, stop: r } = Zm(t, 500);
  let n = null, o = null, a = [], l = 0, c = 0, h = 0, u = !0, d = ie.sampleRate;
  qm(i.pipeThrough(new Km()), {
    onDone: async () => {
      await o?.stop(), n?.close(), r();
    },
    onChunk: async ({ chunkType: p, data: x }) => {
      if (p === "ready") {
        const { videoTrackConf: y, audioTrackConf: v, audioDecoderConf: _ } = yu(x.file, x.info);
        l === 0 && y != null && (l = t.addTrack(y));
        const b = v ?? {
          timescale: 1e6,
          samplerate: d,
          channel_count: ie.channelCount,
          hdlr: "soun",
          name: "SoundHandler",
          type: "mp4a"
        };
        c === 0 && (c = t.addTrack(b), d = v?.samplerate ?? d, u = v != null);
        const T = new AudioContext({ sampleRate: d });
        a = tu(
          await T.decodeAudioData(
            await new Response(e.stream).arrayBuffer()
          )
        ), _ != null && (n = JS(_)), o = jS(
          _ ?? {
            codec: b.type === "mp4a" ? ie.codec : b.type,
            numberOfChannels: b.channel_count,
            sampleRate: b.samplerate
          },
          (w) => t.addSample(c, new Uint8Array(w.data), w)
        );
      } else if (p === "samples") {
        const { id: y, type: v, samples: _ } = x;
        if (v === "video") {
          _.forEach(
            (b) => t.addSample(y, new Uint8Array(b.data), b)
          ), u || await m(_);
          return;
        }
        v === "audio" && await g(_);
      }
    }
  });
  function f(p) {
    const x = a.map(
      (y) => e.loop ? Ch(y, h, h + p) : y.slice(h, h + p)
    );
    if (h += p, e.volume !== 1)
      for (const y of x)
        for (let v = 0; v < y.length; v++) y[v] *= e.volume;
    return x;
  }
  async function m(p) {
    const x = p[0], y = p[p.length - 1], v = Math.floor(
      (y.cts + y.duration - x.cts) / x.timescale * d
    ), _ = Eu([f(v)]);
    _.length !== 0 && o?.encode(
      _,
      x.cts / x.timescale * 1e6
    );
  }
  async function g(p) {
    if (n == null) return;
    const x = (await n.decode(p)).map(
      pp
    ), y = fp(x), v = f(y[0].length), _ = p[0];
    o?.encode(
      // 2. Mix input audio
      Eu([y, v]),
      _.cts / _.timescale * 1e6
    );
  }
  return s;
}
const eC = `
in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;

    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, tC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;
uniform float rotationCount; 

void main(void)
{
    vec2 center = vec2(0.35, 0.35);
    vec2 uvs = vTextureCoord.xy - center;
    
    // Rotacin en funcin de la cantidad de vueltas
    float angle = uTime * rotationCount * 6.28318530718;
    
    float cosAngle = cos(angle);
    float sinAngle = sin(angle);
    mat2 rotation = mat2(cosAngle, -sinAngle, sinAngle, cosAngle);
    
    uvs = rotation * uvs;
    uvs += center;
    
    if (uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0) {
        discard;
    }
    
    vec4 fg = texture2D(uTexture, uvs);
    gl_FragColor = fg;
}
`, iC = {
  uTime: { value: 0, type: "f32" },
  rotationCount: { value: 4, type: "f32" }
}, sC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;

void main(void)
{
    vec2 uvs = vTextureCoord.xy;

    vec4 fg = texture2D(uTexture, vTextureCoord);

    fg.r = uvs.y + sin(uTime);

    gl_FragColor = fg;

}
`, rC = {
  uTime: { value: 0, type: "f32" }
}, nC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;
uniform vec3 bubbleColor;
uniform float bubbleCount;

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float softCircle(vec2 uv, vec2 c, float r, float g) {
    float d = distance(uv, c);
    float base = 1.0 - smoothstep(r * 0.9, r, d);
    float halo = (1.0 - smoothstep(r, r * (1.0 + g), d));
    return base + halo * 0.5;
}

vec2 bubblePos(float id) {
    float fx = rand(vec2(id, 1.234));
    float fy = rand(vec2(id, 9.345));
    return vec2(fx, fy);
}

float bubbleRadius(float id) {
    return mix(0.015, 0.025, rand(vec2(id, 44.123)));
}

void main(void)
{
    vec2 uvs = vTextureCoord.xy;
    vec4 fg = texture2D(uTexture, uvs);

    float bubbles = 0.0;

    for(float i = 0.0; i < 200.0; i++) {

        if(i >= bubbleCount) break;
        float spawnSpeed = 8.0; 
        float spawnTime = (i / bubbleCount) / spawnSpeed;
        float t = uTime - spawnTime;

        if(t < 0.0) continue;

        float grow = pow(clamp(t, 0.0, 1.0), 0.35);

        vec2 pos = bubblePos(i);
        vec2 bubbleCenter = pos;

        float baseR = bubbleRadius(i);

        float r = baseR * grow;

        float phase = rand(vec2(i, 999.0)) * 6.28318;
        float pulse = sin(t * 1.6 + phase) * 0.5 + 0.5;
        float opacity = mix(0.2, 1.0, pulse);

        bubbles += softCircle(uvs, bubbleCenter, r, 0.8) * opacity;
    }

    fg.rgb += bubbleColor * bubbles;
    gl_FragColor = fg;
}
`, oC = {
  uTime: { value: 0, type: "f32" },
  bubbleColor: { value: [1, 0.85, 0.4], type: "vec3<f32>" },
  bubbleCount: { value: 150, type: "f32" }
}, aC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;      
uniform float maxIntensity; 

void main(void)
{
    vec2 uvs = vTextureCoord.xy;
    vec4 color = texture2D(uTexture, uvs);

    float intensity = (sin(uTime) * 0.5 + 0.5) * maxIntensity;

    vec3 sepiaColor;
    sepiaColor.r = dot(color.rgb, vec3(0.393, 0.769, 0.189));
    sepiaColor.g = dot(color.rgb, vec3(0.349, 0.686, 0.168));
    sepiaColor.b = dot(color.rgb, vec3(0.272, 0.534, 0.131));

    color.rgb = mix(color.rgb, sepiaColor, intensity);

    gl_FragColor = color;
}
`, lC = {
  uTime: { value: 0, type: "f32" },
  maxIntensity: { value: 1, type: "f32" }
}, cC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform vec3 colorStart;  
uniform vec3 colorEnd;    
uniform int direction;  

void main(void)
{
    vec2 uvs = vTextureCoord.xy;
    vec4 fg = texture2D(uTexture, uvs);

    float t = 0.0;
    if(direction == 0) {
        t = uvs.x; 
    } else if(direction == 1) {
        t = uvs.y;
    } else {
        t = (uvs.x + uvs.y) * 0.5;
    }

    vec3 gradientColor = mix(colorStart, colorEnd, t);

    fg.rgb = fg.rgb * gradientColor; 

    gl_FragColor = fg;
}
`, hC = {
  colorStart: { value: [1, 0, 0], type: "vec3<f32>" },
  colorEnd: { value: [0, 0, 1], type: "vec3<f32>" },
  direction: { value: 0, type: "i32" }
}, uC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float intensity;
uniform int direction;   

vec3 rainbow(float t) {
    float r = 0.5 + 0.5 * sin(6.28318 * (t + 0.0));
    float g = 0.5 + 0.5 * sin(6.28318 * (t + 0.33));
    float b = 0.5 + 0.5 * sin(6.28318 * (t + 0.66));
    return vec3(r, g, b);
}

void main(void)
{
    vec2 uvs = vTextureCoord.xy;
    vec4 fg = texture2D(uTexture, uvs);

    float t = 0.0;
    if(direction == 0) {
        t = uvs.x; 
    } else if(direction == 1) {
        t = uvs.y; 
    } else {
        t = (uvs.x + uvs.y) * 0.5; 
    }

    vec3 rainbowColor = rainbow(t);

    fg.rgb = fg.rgb * rainbowColor*intensity;

    gl_FragColor = fg;
}
`, dC = {
  intensity: { value: 1, type: "f32" },
  direction: { value: 0, type: "i32" }
}, fC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;     
uniform float intensity;  
uniform float sliceCount;   
uniform float rgbShift;     

float rand(float n) { return fract(sin(n) * 43758.5453123); }
float rand2(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }

void main(void)
{
    vec2 uv = vTextureCoord.xy;

    float sliceId = floor(uv.y * sliceCount);
    float sliceShift = (rand(sliceId + uTime * 10.0) - 0.5) * 0.2 * intensity;

    uv.x += sliceShift;

    float rShift = rgbShift * intensity;
    float gShift = -rgbShift * 0.5 * intensity;
    float bShift = rgbShift * 0.75 * intensity;

    vec3 col;
    col.r = texture2D(uTexture, uv + vec2(rShift, 0.0)).r;
    col.g = texture2D(uTexture, uv + vec2(gShift, 0.0)).g;
    col.b = texture2D(uTexture, uv + vec2(bShift, 0.0)).b;

    float noise = rand2(vec2(uTime * 50.0, uv.y * 100.0));
    float noiseIntensity = noise * 0.15 * intensity;

    col += noiseIntensity;

    gl_FragColor = vec4(col, 1.0);
}
`, pC = {
  uTime: { value: 0, type: "f32" },
  intensity: { value: 0.5, type: "f32" },
  sliceCount: { value: 12, type: "f32" },
  rgbShift: { value: 0.01, type: "f32" }
}, Jm = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float pixelSize;
uniform float uTime;
uniform float jitterStrength;

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

void main(void)
{
    vec2 uv = vTextureCoord.xy;

    vec2 pixelUV = floor(uv / pixelSize) * pixelSize;

    float n1 = hash(pixelUV + uTime * 1.5);
    float n2 = hash(pixelUV * 2.3 + uTime * 1.7);

    vec2 jitter = (vec2(n1, n2) - 0.5) * jitterStrength * pixelSize;

    vec2 finalUV = pixelUV + jitter;

    finalUV = clamp(finalUV, 0.0, 1.0);
    vec4 color = texture2D(uTexture, finalUV);

    gl_FragColor = color;
}
`, jm = {
  pixelSize: { value: 0.02, type: "f32" },
  uTime: { value: 0, type: "f32" },
  jitterStrength: { value: 0.8, type: "f32" }
}, mC = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float glitchStrength;
uniform float glitchSpeed;

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
}

float rand2(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

void main(void)
{
    vec2 uv = vTextureCoord;

    vec4 base = texture2D(uTexture, uv);
    if (base.a < 0.01) {
        gl_FragColor = base;
        return;
    }

    float lineNoise =
        hash(vec2(floor(uv.y * 300.0), uTime * glitchSpeed));

    float rOffset =
        (hash(vec2(uTime, 1.0)) - 0.5) * glitchStrength;

    float gOffset =
        (hash(vec2(uTime, 2.0)) - 0.5) * glitchStrength * 0.5;

    float bOffset =
        (hash(vec2(uTime, 3.0)) - 0.5) * glitchStrength;

    float rShift = rOffset * lineNoise;
    float gShift = gOffset * lineNoise;
    float bShift = bOffset * lineNoise;

    vec2 uvR = clamp(uv + vec2(rShift, 0.0), 0.0, 1.0);
    vec2 uvG = clamp(uv + vec2(gShift, 0.0), 0.0, 1.0);
    vec2 uvB = clamp(uv + vec2(bShift, 0.0), 0.0, 1.0);

    vec3 col;
    col.r = texture2D(uTexture, uvR).r;
    col.g = texture2D(uTexture, uvG).g;
    col.b = texture2D(uTexture, uvB).b;

    float noise =
        (rand2(vec2(uTime * 50.0, uv.y * 100.0)) - 0.5) * 0.15;

    col += noise;

    gl_FragColor = vec4(col, base.a);
}
`, gC = {
  uTime: { value: 0, type: "f32" },
  glitchStrength: { value: 0.02, type: "f32" },
  glitchSpeed: { value: 2, type: "f32" }
}, xC = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float shiftAmount;
uniform float angle;
uniform float uTime;
uniform float wobbleAmount;
uniform float wobbleSpeed;

void main(void)
{
    vec2 uv = vTextureCoord;

    vec4 base = texture2D(uTexture, uv);

    if (base.a < 0.01) {
        gl_FragColor = base;
        return;
    }

    vec2 dir = vec2(cos(angle), sin(angle));
    float wobble = sin(uTime * wobbleSpeed) * wobbleAmount;

    vec2 rUV = uv + dir * shiftAmount + vec2(wobble, 0.0);
    vec2 gUV = uv;
    vec2 bUV = uv - dir * shiftAmount - vec2(wobble, 0.0);

    rUV = clamp(rUV, 0.0, 1.0);
    gUV = clamp(gUV, 0.0, 1.0);
    bUV = clamp(bUV, 0.0, 1.0);

    float r = texture2D(uTexture, rUV).r;
    float g = texture2D(uTexture, gUV).g;
    float b = texture2D(uTexture, bUV).b;

    gl_FragColor = vec4(r, g, b, base.a);
}
`, yC = {
  shiftAmount: { value: 0.01, type: "f32" },
  angle: { value: 0, type: "f32" },
  uTime: { value: 0, type: "f32" },
  wobbleAmount: { value: 3e-3, type: "f32" },
  wobbleSpeed: { value: 20, type: "f32" }
}, vC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float dotSize;       
uniform float intensity;     
uniform float angle;         
uniform float uTime;        
uniform float vibrateStrength;

float luminance(vec3 c) {
    return dot(c, vec3(0.299, 0.587, 0.114));
}

void main(void)
{
    vec2 uv = vTextureCoord.xy;

    float ca = cos(angle);
    float sa = sin(angle);
    mat2 rot = mat2(ca, -sa, sa, ca);
    vec2 rotatedUV = rot * (uv - 0.5) + 0.5;
    vec2 grid = rotatedUV / dotSize;
    vec2 cell = floor(grid) + 0.5;

    vec2 cellCenter = cell * dotSize;

    float jitter = sin(uTime * 10.0 + cell.x * 12.989 + cell.y * 78.233) * 0.5;
    float dist = distance(rotatedUV, cellCenter + jitter * vibrateStrength * dotSize);
    vec4 texColor = texture2D(uTexture, uv);
    float lum = luminance(texColor.rgb);
    float radius = (1.0 - lum) * dotSize * 0.5;
    float mask = smoothstep(radius, radius * 0.8, dist);

    vec3 halftone = texColor.rgb * mask;
    texColor.rgb = mix(texColor.rgb, halftone, intensity);

    gl_FragColor = texColor;
}
`, _C = {
  dotSize: { value: 0.03, type: "f32" },
  intensity: { value: 1, type: "f32" },
  angle: { value: 0, type: "f32" },
  uTime: { value: 0, type: "f32" },
  vibrateStrength: { value: 0.2, type: "f32" }
}, bC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;     
uniform float amplitude; 
uniform float frequency;  
uniform float speed;    
uniform int direction;    

void main(void)
{
    vec2 uv = vTextureCoord.xy;

    vec2 offset = vec2(0.0);

    if(direction == 0) {
        offset.y = sin((uv.x + uTime * speed) * frequency * 6.2831853) * amplitude;
    } else {
        offset.x = sin((uv.y + uTime * speed) * frequency * 6.2831853) * amplitude;
    }

    vec4 color = texture2D(uTexture, uv + offset);
    gl_FragColor = color;
}
`, wC = {
  uTime: { value: 0, type: "f32" },
  amplitude: { value: 0.02, type: "f32" },
  frequency: { value: 3, type: "f32" },
  speed: { value: 0.5, type: "f32" },
  direction: { value: 0, type: "i32" }
}, TC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;          // tiempo para animacin
uniform vec3 shineColor;      // color de los rayos
uniform float rayWidth;       // grosor del rayo
uniform float rayCount;       // cantidad de rayos
uniform float rotationSpeed;  // velocidad de rotacin

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    vec2 center = vec2(0.3, 0.35);

    vec2 dir = uv - center;

    float angle = atan(dir.y, dir.x);

    angle += uTime * rotationSpeed;

    float normAngle = fract(angle / 6.28318530718); // 2

    float rays = sin(normAngle * rayCount * 6.28318530718);

    float intensity = smoothstep(0.0, rayWidth, rays) - smoothstep(rayWidth, rayWidth*1.5, rays);

    vec4 color = texture2D(uTexture, uv);

    color.rgb += shineColor * intensity;

    gl_FragColor = color;
}
`, SC = {
  uTime: { value: 0, type: "f32" },
  shineColor: { value: [1, 1, 1], type: "vec3<f32>" },
  rayWidth: { value: 0.05, type: "f32" },
  rayCount: { value: 12, type: "f32" },
  rotationSpeed: { value: 0.5, type: "f32" }
}, CC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;    
uniform float blinkSpeed;  
uniform float minIntensity; 
uniform float maxIntensity; 

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    vec4 color = texture2D(uTexture, uv);
    float t = sin(uTime * blinkSpeed * 6.2831853) * 0.5 + 0.5;
    float intensity = mix(minIntensity, maxIntensity, t);

    color.rgb *= intensity;

    gl_FragColor = color;
}
`, AC = {
  uTime: { value: 0, type: "f32" },
  blinkSpeed: { value: 2, type: "f32" },
  minIntensity: { value: 0.3, type: "f32" },
  maxIntensity: { value: 1, type: "f32" }
}, IC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;         
uniform float frequency;      
uniform float damping;      
uniform float strength;      

void main(void)
{
    vec2 uv = vTextureCoord.xy;

    float spring = exp(-damping * uTime) *
                   sin(uTime * frequency * 6.2831853);

    uv.x += spring * strength;
    uv.y += spring * strength * 0.5; 

    vec4 color = texture2D(uTexture, uv);

    gl_FragColor = color;
}
`, kC = {
  uTime: { value: 0, type: "f32" },
  frequency: { value: 2, type: "f32" },
  damping: { value: 0.8, type: "f32" },
  strength: { value: 0.04, type: "f32" }
}, FC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform vec3 colorA;     
uniform vec3 colorB;    
uniform float intensity; 

void main(void)
{
    vec2 uv = vTextureCoord.xy;

    vec4 tex = texture2D(uTexture, uv);
    float gray = dot(tex.rgb, vec3(0.299, 0.587, 0.114));
    vec3 duo = mix(colorA, colorB, gray);
    tex.rgb = mix(tex.rgb, duo, intensity);
    gl_FragColor = tex;
}
`, MC = {
  colorA: { value: [0.1, 0.1, 0.5], type: "vec3<f32>" },
  colorB: { value: [1, 0.8, 0.2], type: "vec3<f32>" },
  intensity: { value: 1, type: "f32" }
}, EC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform vec3 colorShadow;   
uniform vec3 colorMid;       
uniform vec3 colorHighlight;

uniform float intensity;    

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    vec4 tex = texture2D(uTexture, uv);
    float gray = dot(tex.rgb, vec3(0.299, 0.587, 0.114));


    vec3 duoA = mix(colorShadow, colorMid, smoothstep(0.0, 0.5, gray));
    vec3 duoB = mix(colorMid, colorHighlight, smoothstep(0.5, 1.0, gray));
    vec3 tritone = mix(duoA, duoB, smoothstep(0.33, 0.66, gray));
    tex.rgb = mix(tex.rgb, tritone, intensity);

    gl_FragColor = tex;
}
`, PC = {
  colorShadow: { value: [0.1, 0, 0.3], type: "vec3<f32>" },
  colorMid: { value: [0.2, 0.8, 0.8], type: "vec3<f32>" },
  colorHighlight: { value: [1, 0.9, 0.4], type: "vec3<f32>" },
  intensity: { value: 1, type: "f32" }
}, UC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;    
uniform float amount;    

vec3 hueShift(vec3 color, float angle) {
    float cosA = cos(angle);
    float sinA = sin(angle);
    mat3 rot = mat3(
        0.299 + 0.701 * cosA + 0.168 * sinA,
        0.587 - 0.587 * cosA + 0.330 * sinA,
        0.114 - 0.114 * cosA - 0.497 * sinA,

        0.299 - 0.299 * cosA - 0.328 * sinA,
        0.587 + 0.413 * cosA + 0.035 * sinA,
        0.114 - 0.114 * cosA + 0.292 * sinA,

        0.299 - 0.300 * cosA + 1.250 * sinA,
        0.587 - 0.588 * cosA - 1.050 * sinA,
        0.114 + 0.886 * cosA - 0.203 * sinA
    );

    return color * rot;
}

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    vec4 tex = texture2D(uTexture, uv);

    vec3 shifted = hueShift(tex.rgb, uTime*2.5);

    tex.rgb = mix(tex.rgb, shifted, amount);

    gl_FragColor = tex;
}
`, RC = {
  uTime: { value: 0, type: "f32" },
  amount: { value: 1, type: "f32" }
}, BC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;       
uniform float uStrength;  
uniform float swirl;      

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    vec2 center = vec2(0.5, 0.5);
    vec2 dir = uv - center;
    float dist = length(dir);
    float warpAmount = pow(dist, 2.0) * uStrength * uTime;
    float angle = swirl * uTime * 6.283185; 

    float s = sin(angle * dist);
    float c = cos(angle * dist);

    mat2 rot = mat2(c, -s, s, c);
    vec2 warpedUV = center + rot * dir * (1.0 - warpAmount);
    vec4 color = texture2D(uTexture, warpedUV);

    gl_FragColor = color;
}
`, zC = {
  uTime: { value: 0, type: "f32" },
  uStrength: { value: 0.8, type: "f32" },
  swirl: { value: 0.3, type: "f32" }
}, OC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;      
uniform float uStrength;  
uniform int direction;     

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    float offset;
    if(direction == 0) {
        offset = (uv.y - 0.5) * uStrength * uTime;
        uv.x += offset;
    } else {
        offset = (uv.x - 0.5) * uStrength * uTime;
        uv.y += offset;
    }

    vec4 color = texture2D(uTexture, uv);

    gl_FragColor = color;
}
`, DC = {
  uTime: { value: 0, type: "f32" },
  uStrength: { value: 0.2, type: "f32" },
  direction: { value: 0, type: "i32" }
}, LC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uStrength;
uniform float uNoise;
uniform int direction;

float hash(float n) {
    return fract(sin(n) * 43758.5453);
}

float hash(vec2 p) {
    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);
}

void main(void)
{
    vec2 uv = vTextureCoord.xy;

    float offset;
    if(direction == 0) {
        offset = (uv.y - 0.5) * uStrength * uTime;
        uv.x += offset;
    } else {
        offset = (uv.x - 0.5) * uStrength * uTime;
        uv.y += offset;
    }

    float jitter = (hash(floor(uv * 100.0) + uTime) - 0.5) * uNoise;
    if(direction == 0) {
        uv.x += jitter;
    } else {
        uv.y += jitter;
    }

    float rOffset = (hash(uv + 1.0) - 0.5) * uNoise * 0.5;
    float gOffset = (hash(uv + 2.0) - 0.5) * uNoise * 0.5;
    float bOffset = (hash(uv + 3.0) - 0.5) * uNoise * 0.5;

    vec4 texR = texture2D(uTexture, uv + vec2(rOffset, 0.0));
    vec4 texG = texture2D(uTexture, uv + vec2(gOffset, 0.0));
    vec4 texB = texture2D(uTexture, uv + vec2(bOffset, 0.0));

    gl_FragColor = vec4(texR.r, texG.g, texB.b, 1.0);
}
`, NC = {
  uTime: { value: 0, type: "f32" },
  uStrength: { value: 0.2, type: "f32" },
  uNoise: { value: 0.05, type: "f32" },
  direction: { value: 0, type: "i32" }
}, GC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;       
uniform float maxPixelSize; 

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    float pixelSize = maxPixelSize * uTime;
    pixelSize = max(pixelSize, 0.001);
    vec2 pixelUV = floor(uv / pixelSize) * pixelSize;

    vec4 color = texture2D(uTexture, pixelUV);

    gl_FragColor = color;
}
`, HC = {
  uTime: { value: 0, type: "f32" },
  maxPixelSize: { value: 0.05, type: "f32" }
}, WC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;       
uniform float maxBlur;    

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    vec4 color = vec4(0.0);
    float blur = maxBlur * (1.0 - uTime);

    if(blur < 0.001) {
        color = texture2D(uTexture, uv);
    } else {
        vec2 offsets[9];
        offsets[0] = vec2(-blur, -blur);
        offsets[1] = vec2(0.0, -blur);
        offsets[2] = vec2(blur, -blur);
        offsets[3] = vec2(-blur, 0.0);
        offsets[4] = vec2(0.0, 0.0);
        offsets[5] = vec2(blur, 0.0);
        offsets[6] = vec2(-blur, blur);
        offsets[7] = vec2(0.0, blur);
        offsets[8] = vec2(blur, blur);

        for(int i = 0; i < 9; i++) {
            color += texture2D(uTexture, uv + offsets[i]);
        }

        color /= 9.0;
    }

    gl_FragColor = color;
}
`, VC = {
  uTime: { value: 0, type: "f32" },
  maxBlur: { value: 0.01, type: "f32" }
}, $C = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float amount;

void main(void)
{
    vec2 uv = vTextureCoord;
    vec4 tex = texture2D(uTexture, uv);

    vec3 inverted = vec3(1.0) - tex.rgb;

    float strength = amount * tex.a;

    tex.rgb = mix(tex.rgb, inverted, strength);

    gl_FragColor = tex;
}
`, YC = {
  amount: { value: 1, type: "f32" }
}, XC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float amount; 

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    vec4 tex = texture2D(uTexture, uv);
    float gray = dot(tex.rgb, vec3(0.299, 0.587, 0.114));
    vec3 grayscale = vec3(gray);

    tex.rgb = mix(tex.rgb, grayscale, amount);

    gl_FragColor = tex;
}
`, qC = {
  amount: { value: 1, type: "f32" }
}, ZC = `
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uIntensity;  
uniform float uSoftness;  

void main(void)
{
    vec2 uv = vTextureCoord.xy;

    vec2 centered = uv - vec2(0.5);
    float dist = length(centered);
    float vignette = smoothstep(0.5, 0.5 - uSoftness, dist);
    vec4 color = texture(uTexture, uv);
    color.rgb *= 1.0 - (vignette * uIntensity);

    gl_FragColor = color;
}
`, KC = {
  uIntensity: { value: 0.5, type: "f32" },
  uSoftness: { value: 0.2, type: "f32" }
}, JC = `
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uIntensity; 
uniform vec2 uDirection;  

void main(void)
{
    vec2 uv = vTextureCoord;
    vec2 offset = uDirection * uIntensity;
    float r = texture(uTexture, uv + offset).r;
    float g = texture(uTexture, uv).g;
    float b = texture(uTexture, uv - offset).b;
    vec4 color = vec4(r, g, b, 1.0);

    gl_FragColor = color;
}
`, jC = {
  uIntensity: { value: 5e-3, type: "f32" },
  uDirection: { value: [1, 0], type: "vec2<f32>" }
}, QC = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;
uniform float rotationCount;

uniform float swirlStrength; 
uniform float swirlRadius;   
uniform float rainbowIntensity;

vec3 hsv2rgb(vec3 c)
{
    vec3 rgb = clamp( abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0,
                      0.0,
                      1.0 );
    return c.z * mix(vec3(1.0), rgb, c.y);
}

float flamePattern(float dist, float angle, float time) {
    return pow(sin(dist * 10.0 - time * 5.0 + angle * 5.0) * 0.5 + 0.5, 2.0);
}

void main(void)
{
    vec2 center = vec2(0.3, 0.45);
    vec2 uvs = vTextureCoord - center;

    // fade del rainbow (0 cuando uTime >= 0.75)
    float fadeRainbow = clamp(1.0 - smoothstep(0.7, 0.75, uTime), 0.0, 1.0);

    // fade de swirl, wave y blur (disminuye entre 0.8 y 1.0)
    float fadeMotion = clamp(1.0 - smoothstep(0.8, 1.0, uTime), 0.0, 1.0);

    // ngulo total acumulado para mantener la direccin del giro
    float angleTotal = uTime * rotationCount * 6.2831853; 

    float cosA = cos(angleTotal);
    float sinA = sin(angleTotal);
    mat2 rotation = mat2(cosA, -sinA, sinA, cosA);
    vec2 rotatedUV = rotation * uvs + center;

    float dist = distance(rotatedUV, center);
    float d = clamp(dist / swirlRadius, 0.0, 1.0);

    // swirl disminuye suavemente sin invertir la direccin
    float swirlAngle = swirlStrength * d * d * 6.2831853 * fadeMotion;
    float cosS = cos(swirlAngle);
    float sinS = sin(swirlAngle);

    vec2 dir = rotatedUV - center;
    rotatedUV = vec2(
        dir.x * cosS - dir.y * sinS,
        dir.x * sinS + dir.y * cosS
    ) + center;

    float wave = sin(dist * 12.0 - uTime * 4.0) * 0.015 * fadeMotion; 
    rotatedUV += wave * normalize(dir);

    // blur de la textura
    vec4 color = vec4(0.0);
    float blurAmount = (0.004 + rotationCount * 0.001) * fadeMotion; 

    for (int i = -3; i <= 3; i++) {
        float offset = float(i) * blurAmount;
        vec2 blurUV = rotatedUV + vec2(offset * cosA, offset * sinA);
        color += texture2D(uTexture, blurUV);
    }
    color /= 7.0;

    // rainbow
    float rainbowScale = 0.05;
    float ang = atan(dir.y, dir.x);
    float hue = (ang / 6.2831853) + 0.5 + dist * rainbowScale;
    hue += uTime * 0.2 + rotationCount * 0.05;

    vec3 rainbow = hsv2rgb(vec3(hue, 0.35, 1.0));
    color.rgb = mix(color.rgb, rainbow, rainbowIntensity * fadeRainbow);

    // Flame disminuye con fadeMotion
    float flame = flamePattern(dist, ang, uTime) * fadeMotion;
    vec3 flameColor = vec3(1.0, 0.5, 0.0) * flame;
    flameColor = mix(flameColor, vec3(1.0,1.0,0.2), flame * 0.5);
    color.rgb += flameColor * 0.3;

    if (rotatedUV.x < 0.0 || rotatedUV.x > 1.0 || rotatedUV.y < 0.0 || rotatedUV.y > 1.0) {
        discard;
    }

    gl_FragColor = color;
}

`, eA = {
  uTime: { value: 0, type: "f32" },
  rotationCount: { value: 4, type: "f32" },
  swirlStrength: { value: 0.9, type: "f32" },
  swirlRadius: { value: 1, type: "f32" },
  rainbowIntensity: { value: 0.25, type: "f32" }
}, tA = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;
uniform vec3 heartColor;
uniform float heartCount;

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float heartShape(vec2 p) {
    p = (p - 0.5) * 2.0;   
    p.y = -p.y;           
    p.y += 0.25;          
    float x = p.x;
    float y = p.y;
    float val = pow(x*x + y*y - 1.0, 3.0) - x*x * y*y*y;
    return smoothstep(0.0, 0.02, -val);
}

vec2 heartPos(float id) {
    float fx = rand(vec2(id, 1.234)) * 0.85 - 0.025; 
    float fy = rand(vec2(id, 1.345)) * 0.85 + 0.025;
    return vec2(fx, fy);
}

float heartSize(float id) {
    return mix(0.02, 0.05, rand(vec2(id, 44.123))); 
}

void main() {
    vec2 uv = vTextureCoord.xy;
    vec4 base = texture2D(uTexture, uv);

    float hearts = 0.0;

    for(float i = 0.0; i < 200.0; i++) {
        if(i >= heartCount) break;

        vec2 pos = heartPos(i);
        float size = heartSize(i);

        float vibX = (rand(vec2(i, uTime)) - 0.5) * 0.02;
        float vibY = (rand(vec2(i+1.0, uTime)) - 0.5) * 0.02;

        vec2 heartUV = (uv - (pos + vec2(vibX, vibY))) / size + 0.5;

        float h = heartShape(heartUV);

        float pulse = sin(uTime * 4.0 + i) * 0.2 + 1.0;
        h *= pulse;

        hearts += h;
    }

    base.rgb += heartColor * hearts;
    gl_FragColor = base;
}
`, iA = {
  uTime: { value: 0, type: "f32" },
  heartColor: { value: [1, 0.2, 0.5], type: "vec3<f32>" },
  heartCount: { value: 150, type: "f32" }
}, sA = `
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;
uniform vec3 butterflyColor;
uniform float butterflyCount;

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float wing(vec2 p) {
    float d = pow(p.x, 2.0) + pow(p.y * 1.2, 2.0);
    return smoothstep(0.3, 0.0, d);
}

float butterflyShape(vec2 uv) {
    vec2 p = (uv - 0.5) * 2.0;

    float body = smoothstep(0.12, 0.05, abs(p.x)) 
               * smoothstep(0.4, 0.0, abs(p.y));

    float wL = wing(vec2(p.x * 1.2 + 0.6, p.y));
    float wR = wing(vec2(p.x * 1.2 - 0.6, p.y));

    return clamp(wL + wR + body, 0.0, 1.0);
}
vec2 butterflyPos(float id) {
    float fx = rand(vec2(id, 1.234)) * 0.85 - 0.025;
    float fy = rand(vec2(id, 1.345)) * 0.85 + 0.025;
    return vec2(fx, fy);
}

float butterflySize(float id) {
    return mix(0.03, 0.08, rand(vec2(id, 44.123)));
}

void main() {
    vec2 uv = vTextureCoord.xy;
    vec4 base = texture2D(uTexture, uv);

    float butterflies = 0.0;

    for(float i = 0.0; i < 200.0; i++) {
        if(i >= butterflyCount) break;

        vec2 pos = butterflyPos(i);
        float size = butterflySize(i);

        float vibX = (rand(vec2(i, uTime)) - 0.5) * 0.02;
        float vibY = (rand(vec2(i+1.0, uTime)) - 0.5) * 0.02;

        vec2 bUV = (uv - (pos + vec2(vibX, vibY))) / size + 0.5;

        float b = butterflyShape(bUV);

        float pulse = sin(uTime * 3.0 + i) * 0.25 + 1.0;
        b *= pulse;

        butterflies += b;
    }

    base.rgb += butterflyColor * butterflies;
    gl_FragColor = base;
}
`, rA = {
  uTime: { value: 0, type: "f32" },
  butterflyColor: { value: [0.5, 0.6, 1], type: "vec3<f32>" },
  butterflyCount: { value: 120, type: "f32" }
}, nA = `
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float amplitude; 
uniform float speed;     
uniform float uTime;  

void main() {
    vec2 p = vTextureCoord;
    vec2 center = vec2(0.28, 0.45);

    vec2 dir = p - center;
    float dist = length(dir);

    vec2 offset = vec2(0.0);

    if (dist <= uTime) {
        offset = dir * sin(dist * amplitude - uTime * speed);
    }

    gl_FragColor = texture2D(uTexture, p + offset);
}
`, oA = {
  uTime: { value: 0, type: "f32" },
  amplitude: { value: 30, type: "f32" },
  speed: { value: 30, type: "f32" }
}, aA = `
precision mediump float;

uniform sampler2D uTexture;
uniform float persp;      
uniform float unzoom;     
uniform float reflection; 
uniform float floating;   
uniform float uTime;

varying vec2 vTextureCoord;

bool inBounds(vec2 p) {
    return all(greaterThanEqual(p, vec2(0.0))) &&
           all(lessThanEqual(p, vec2(1.0)));
}

vec2 project(vec2 p) {
    return p * vec2(1.0, -1.2) + vec2(0.0, -floating / 100.0);
}

vec2 xskew(vec2 p, float persp, float center) {
    float x = mix(p.x, 1.0 - p.x, center);

    return (
        (
            vec2(
                x,
                (p.y - 0.5*(1.0-persp) * x) /
                (1.0+(persp-1.0)*x)
            )
            - vec2(0.5 - abs(center - 0.5), 0.0)
        )
        * vec2(
            0.5 / abs(center - 0.5) * (center < 0.5 ? 1.0 : -1.0),
            1.0
        )
        + vec2(center < 0.5 ? 0.0 : 1.0, 0.0)
    );
}

void main() {
    vec2 p = vTextureCoord;

    float uz = unzoom * sin(uTime * 0.5);
    p = -uz * 0.5 + (1.0 + uz) * p;

    vec2 warped = xskew(p, persp, 0.0);

    vec4 baseColor = vec4(0.0);

    if (inBounds(warped)) {
        baseColor = texture2D(uTexture, warped);
    }

    vec2 proj = project(warped);
    if (inBounds(proj)) {
        vec4 refl = texture2D(uTexture, proj);
        refl.rgb *= reflection * (1.0 - proj.y);
        baseColor += refl;
    }

    gl_FragColor = baseColor;
}

`, lA = {
  uTime: { value: 0, type: "f32" },
  persp: { value: 0.7, type: "f32" },
  unzoom: { value: 0.3, type: "f32" },
  reflection: { value: 0, type: "f32" },
  floating: { value: 3, type: "f32" }
}, cA = `
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;        
uniform float radius;       
uniform float spinPower;    
uniform float speed;       

void main() {
    vec2 uv = vTextureCoord;
    vec2 center = vec2(0.28, 0.45);

    vec2 pos = uv - center;

    float dist = length(pos);

    if (dist < radius) {
        float percent = (radius - dist) / radius;

        float theta = percent * percent * spinPower * sin(uTime * speed);

        float s = sin(theta);
        float c = cos(theta);

        pos = vec2(
            pos.x * c - pos.y * s,
            pos.x * s + pos.y * c
        );
    }

    uv = pos + center;

    gl_FragColor = texture2D(uTexture, uv);
}
`, hA = {
  uTime: { value: 0, type: "f32" },
  radius: { value: 1, type: "f32" },
  spinPower: { value: 18, type: "f32" },
  speed: { value: 4, type: "f32" }
}, uA = `
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;

uniform float speed;        
uniform float intensity;    
uniform int endx;
uniform int endy;

#define PI 3.14159265358979323

float rand(vec2 v) {
    return fract(sin(dot(v.xy , vec2(12.9898,78.233))) * 43758.5453);
}

vec2 rotate2d(vec2 v, float a) {
    mat2 rm = mat2(cos(a), -sin(a),
                   sin(a),  cos(a));
    return rm * v;
}

void main() {
    vec2 uv = vTextureCoord;

    vec2 p = uv - 0.5;

    float t = sin(uTime * speed) * 0.5 + 0.5;

    float warp = 1.0 + intensity * abs(t - 0.5);

    vec2 rp = p * warp;
    float tx = float(endx) + 0.5;
    float ty = float(endy) + 0.5;

    vec2 shifted = mix(vec2(0.5, 0.5), vec2(tx, ty), t*t);

    vec2 tiled = fract(rp + shifted);

    vec2 cell = floor(rp + shifted);

    bool isEnd = int(cell.x) == endx && int(cell.y) == endy;

    if (!isEnd) {
        float rnd = rand(cell);
        float angle = float(int(rnd * 4.0)) * 0.5 * PI;
        tiled = vec2(0.5) + rotate2d(tiled - vec2(0.5), angle);
    }
    gl_FragColor = texture2D(uTexture, tiled);
}
`, dA = {
  uTime: { value: 0, type: "f32" },
  speed: { value: 2, type: "f32" },
  intensity: { value: 1.5, type: "f32" },
  endx: { value: 2, type: "i32" },
  endy: { value: -1, type: "i32" }
}, fA = `
precision highp float;

in vec2 vTextureCoord;
uniform sampler2D uTexture;
uniform float uTime;

uniform float intensity;    
uniform float speed;        
uniform int slices;         
uniform float randomness;   

#define PI 3.141592653589793
float rand(float x) {
    return fract(sin(x * 12.9898) * 43758.5453);
}

void main() {
    vec2 uv = vTextureCoord;

    float sliceHeight = 1.0 / float(slices);
    float sliceIndex = floor(uv.y / sliceHeight);

    float offsetX = (rand(sliceIndex + uTime * speed) - 0.5) * intensity;

    float offsetY = sin(uTime * speed + sliceIndex * 1.5) * 0.01 * randomness;

    uv.x += offsetX;
    uv.y += offsetY;
    vec4 color = texture(uTexture, uv);

    gl_FragColor = color;
}

`, pA = {
  uTime: { value: 0, type: "f32" },
  intensity: { value: 0.05, type: "f32" },
  speed: { value: 2, type: "f32" },
  slices: { value: 10, type: "i32" },
  randomness: { value: 1, type: "f32" }
}, mA = `
precision highp float;

in vec2 vTextureCoord;
uniform sampler2D uTexture;
uniform float uTime;      
uniform float softness;   

void main() {
    vec2 uv = vTextureCoord;

    float t_raw = clamp(uTime, 0.0, 1.0);
    float t = pow(t_raw, 0.55);

    float mid = 0.5;

    float leftEdge = mid - t * mid;
    float rightEdge = mid + t * mid;

    float mask = smoothstep(leftEdge, leftEdge + softness, uv.x) *
                 (1.0 - smoothstep(rightEdge - softness, rightEdge, uv.x));

    vec4 color = texture(uTexture, uv);

    gl_FragColor = vec4(color.rgb * mask, color.a * mask);
}
`, gA = {
  uTime: { value: 0, type: "f32" },
  softness: { value: 0.2, type: "f32" }
}, xA = `
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float softness;
uniform float zoom;

#define PI 3.141592653589793

vec2 rotate2D(vec2 st, float angle) {
    st -= 0.5;
    st = mat2(cos(angle), -sin(angle),
              sin(angle),  cos(angle)) * st;
    st += 0.5;
    return st;
}

vec2 tile(vec2 st, float zoom) {
    st *= zoom;
    return fract(st);
}

vec2 rotateTile(vec2 st) {
    st *= 2.0;

    float index = 0.0;
    if (fract(st.x * 0.5) > 0.5) index += 1.0;
    if (fract(st.y * 0.5) > 0.5) index += 2.0;

    st = fract(st);

    if (index == 1.0)      st = rotate2D(st, PI * 0.5);
    else if (index == 2.0) st = rotate2D(st, PI * -0.5);
    else if (index == 3.0) st = rotate2D(st, PI);

    return st;
}

float triangleShape(vec2 st, float smoothness) {
    vec2 p0 = vec2(0.3, -0.5);
    vec2 p1 = vec2(0.7, -0.5);
    vec2 p2 = vec2(0.5, 1.0);

    vec3 e0, e1, e2;

    e0.xy = normalize(p1 - p0).yx * vec2(+1.0, -1.0);
    e1.xy = normalize(p2 - p1).yx * vec2(+1.0, -1.0);
    e2.xy = normalize(p0 - p2).yx * vec2(+1.0, -1.0);

    e0.z = dot(e0.xy, p0) - smoothness;
    e1.z = dot(e1.xy, p1) - smoothness;
    e2.z = dot(e2.xy, p2) - smoothness;

    float a = max(0.0, dot(e0.xy, st) - e0.z);
    float b = max(0.0, dot(e1.xy, st) - e1.z);
    float c = max(0.0, dot(e2.xy, st) - e2.z);

    return smoothstep(smoothness * 2.0, 1e-7, length(vec3(a, b, c)));
}

void main() {
    vec2 uv = vTextureCoord;
    vec2 st = uv;
    st = tile(st, zoom);
    st = rotateTile(st);
    st = rotate2D(st, -PI * 0.25 * uTime);

    float mask = triangleShape(st, softness);

    vec4 tex = texture(uTexture, uv);
    gl_FragColor = vec4(tex.rgb * mask, tex.a * mask);
}
`, yA = {
  uTime: { value: 0, type: "f32" },
  softness: { value: 0.2, type: "f32" },
  zoom: { value: 8, type: "f32" }
}, vA = `
precision highp float;

in vec2 vTextureCoord;
uniform sampler2D uTexture;
uniform float uTime;

vec2 mirrorTile(vec2 st, float zoom) {
    st *= zoom;

    if (fract(st.y * 0.5) > 0.5) {
        st.x = st.x + 0.5;
        st.y = 1.0 - st.y;
    }

    return fract(st);
}

float zigzag(vec2 st) {
    float x = st.x * 2.0;
    float a = floor(1.0 + sin(x * 3.14159));
    float b = floor(1.0 + sin((x + 1.0) * 3.14159));
    float f = fract(x);
    return mix(a, b, f);
}

void main() {
    vec2 st = vTextureCoord;

    st = mirrorTile(st * vec2(1.0, 2.0), 5.0);

    float zz = zigzag(st);

    st.y += zz * 0.03;

    vec4 tex = texture(uTexture, st);

    gl_FragColor = tex;
}
`, _A = {
  uTime: { value: 0, type: "f32" }
}, bA = `
precision highp float;

in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;
uniform float speed;      
uniform float intensity;  

void main(void)
{
    vec4 tex = texture2D(uTexture, vTextureCoord);
    float t = fract(uTime * speed);
    float wave = sin(t * 3.141592);
    float base = 0.6;
    float brightness = mix(base, 1.0, wave);
    float flash = 1.0 + brightness * intensity;

    vec3 color = tex.rgb * flash;

    gl_FragColor = vec4(color, tex.a);
}
`, wA = {
  uTime: { value: 0, type: "f32" },
  speed: { value: 10.2, type: "f32" },
  intensity: { value: 1.5, type: "f32" }
}, TA = `
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;

uniform float framesPerScreen;
uniform float scrollSpeed;
uniform float gateWeave;

void main() {
    vec2 uv = vTextureCoord;

    vec3 color = vec3(0.0);

    uv.y += uTime * scrollSpeed;
    uv.y += sin(uTime * 2.0) * 0.003 * gateWeave;

    float stripLeft  = 0.025;
    float stripRight = 0.5;

    if (uv.x < stripLeft || uv.x > stripRight) {
        gl_FragColor = vec4(color, 1.0);
        return;
    }

    vec2 stripUV;
    stripUV.x = (uv.x - stripLeft) / (stripRight - stripLeft);
    stripUV.y = fract(uv.y);

    float holeZone = 0.06; 
    float frameZone = 1.0 - holeZone * 2.0;

    float frameH = 1.0 / framesPerScreen;
    float localY = fract(stripUV.y / frameH);

    bool inFrameX =
        stripUV.x > holeZone &&
        stripUV.x < holeZone + frameZone;

    float marginX = 0.08;
    float marginY = 0.10;


    bool insideFrame =
        inFrameX &&
        stripUV.x > holeZone + marginX &&
        stripUV.x < holeZone + frameZone - marginX &&
        localY > marginY &&
        localY < 1.0 - marginY;

    float frameZoneX = frameZone - marginX * 4.0;
    float centerOffset = (1.0 - frameZoneX - holeZone * 2.0) * 0.5;

    vec2 frameUV;
    frameUV.x = (stripUV.x - (holeZone + marginX * 2.0) - centerOffset) / frameZoneX;
    frameUV.y = (localY - marginY) / (1.0 - marginY * 2.0);

    float holeH = 0.01;
    float holeSpacing = frameH * 0.1;

    float holeRow = step(mod(stripUV.y, holeSpacing), holeH);

    bool leftHole  = stripUV.x < holeZone * 0.8;
    bool rightHole = stripUV.x > 1.0 - holeZone * 0.8;

    bool isHole = holeRow > 0.5 && (leftHole || rightHole);
    if (isHole) {
        color = vec3(1.0);
    }
    else if (insideFrame) {
        color = texture2D(uTexture, frameUV).rgb;
    }
    else {
        color = vec3(0.0);
    }

    gl_FragColor = vec4(color, 1.0);
}
`, SA = {
  uTime: { value: 0, type: "f32" },
  framesPerScreen: { value: 2, type: "f32" },
  scrollSpeed: { value: 0.35, type: "f32" },
  gateWeave: { value: 0.6, type: "f32" }
}, CA = `
precision highp float;

in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;
float rand(vec2 co) {
    return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453);
}

float noise(float y) {
    return rand(vec2(y, uTime));
}

void main(void)
{
    vec2 uv = vTextureCoord;
    float flicker = 0.9 + 0.1 * sin(uTime * 30.0);
    float lineNoise = noise(floor(uv.y * 200.0));
    uv.x += (lineNoise - 0.5) * 0.03;
    uv.x += sin(uv.y * 40.0 + uTime * 10.0) * 0.005;
    float rgbShift = 0.004 * sin(uTime * 5.0);

    vec4 colR = texture2D(uTexture, uv + vec2(rgbShift, 0.0));
    vec4 colG = texture2D(uTexture, uv);
    vec4 colB = texture2D(uTexture, uv - vec2(rgbShift, 0.0));

    vec4 color;
    color.r = colR.r;
    color.g = colG.g;
    color.b = colB.b;
    color.a = colG.a;
    float staticNoise = rand(uv * uTime) * 0.08;
    color.rgb += staticNoise;
    float scanline = sin(uv.y * 800.0) * 0.04;
    color.rgb -= scanline;
    color.rgb *= flicker;

    gl_FragColor = color;
}

`, AA = {
  uTime: { value: 0, type: "f32" }
}, IA = `
precision highp float;

in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;

/* Configuracin */
uniform float strength;   // fuerza de la omniflexin
uniform float frequency;  // frecuencia de ondas
uniform float speed;      // velocidad animacin

void main(void)
{
    vec2 uv = vTextureCoord;
    vec2 center = vec2(0.5);

    vec2 dir = uv - center;
    float dist = length(dir);
    float wave =
        sin(dist * frequency - uTime * speed) *
        strength;

    float lens = dist * dist;

    vec2 flexUV = uv + normalize(dir) * wave * lens;
    vec4 color = texture2D(uTexture, flexUV);

    gl_FragColor = color;
}

`, kA = {
  uTime: { value: 0, type: "f32" },
  strength: { value: 0.08, type: "f32" },
  frequency: { value: 18, type: "f32" },
  speed: { value: 3.5, type: "f32" }
}, FA = `
precision highp float;

in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;

uniform float feather;

void main(void)
{
    vec2 uv = vTextureCoord;

    vec2 center = vec2(0.28, 0.48);

    float dist = distance(uv, center);

    float maxRadius = 0.8;

    float radius = mix(maxRadius, 0.0, uTime);

    float mask = smoothstep(
        radius - feather,
        radius + feather,
        dist
    );

    vec4 color = texture2D(uTexture, uv);

    gl_FragColor = vec4(color.rgb * mask, color.a);
}

`, MA = {
  uTime: { value: 0, type: "f32" },
  feather: { value: 0.03, type: "f32" }
}, EA = `
precision highp float;

in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;

void main(void)
{
    vec2 uv = vTextureCoord;

    float openPhase = smoothstep(0.0, 0.6, uTime);
    float zoomPhase = smoothstep(0.6, 1.0, uTime);

    float zoom =
        1.0 +
        sin(zoomPhase * 3.141592) * 0.2;

    vec2 center = vec2(0.28, 0.35);
    vec2 zoomUV = (uv - center) / zoom + center;

    vec4 tex = texture2D(uTexture, zoomUV);

    float centerY = 0.48;
    float halfOpen = openPhase * 0.5;

    float mask = step(abs(zoomUV.y - centerY), halfOpen);

    gl_FragColor = vec4(tex.rgb * mask, tex.a);
}

`, PA = {
  uTime: { value: 0, type: "f32" }
}, UA = `
precision highp float;

in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;

vec4 blur9(sampler2D tex, vec2 uv, vec2 resolution, float radius)
{
    vec4 color = vec4(0.0);
    vec2 off = radius / resolution;

    color += texture2D(tex, uv + off * vec2(-1.0, -1.0)) * 0.0625;
    color += texture2D(tex, uv + off * vec2( 0.0, -1.0)) * 0.125;
    color += texture2D(tex, uv + off * vec2( 1.0, -1.0)) * 0.0625;

    color += texture2D(tex, uv + off * vec2(-1.0,  0.0)) * 0.125;
    color += texture2D(tex, uv)                             * 0.25;
    color += texture2D(tex, uv + off * vec2( 1.0,  0.0)) * 0.125;

    color += texture2D(tex, uv + off * vec2(-1.0,  1.0)) * 0.0625;
    color += texture2D(tex, uv + off * vec2( 0.0,  1.0)) * 0.125;
    color += texture2D(tex, uv + off * vec2( 1.0,  1.0)) * 0.0625;

    return color;
}

void main(void)
{
    vec2 uv = vTextureCoord;

    float openPhase = smoothstep(0.0, 0.3, uTime);
    float zoomPhase = smoothstep(0.3, 1.0, uTime);

    float zoom =
        1.0 +
        sin(zoomPhase * 3.141592) * 0.2;

    vec2 center = vec2(0.28, 0.35);
    vec2 zoomUV = (uv - center) / zoom + center;

    float blurAmount = mix(10.0, 0.0, openPhase);

    vec4 blurred =
        blur9(uTexture, zoomUV, vec2(1024.0, 1024.0), blurAmount);

    float pulse =
    (sin(uTime * 2.0) * 0.5 + 0.5) * 0.8;
    blurred.rgb *= (1.0 + pulse);
    float centerY = 0.48;
    float halfOpen = openPhase * 0.5;

    float mask = step(abs(zoomUV.y - centerY), halfOpen);

    gl_FragColor = vec4(blurred.rgb * mask, blurred.a);
}

`, RA = {
  uTime: { value: 0, type: "f32" }
}, BA = `
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;

uniform float strength;

uniform float frequency;

void main(void)
{
    vec2 uv = vTextureCoord;

    float waveX = sin((uv.y + uTime * 0.6) * frequency) * strength;
    float waveY = cos((uv.x + uTime * 0.4) * frequency) * strength;

    vec2 distortedUV = uv + vec2(waveX, waveY);

    distortedUV = clamp(distortedUV, 0.0, 1.0);

    vec4 color = texture2D(uTexture, distortedUV);

    gl_FragColor = color;
}
`, zA = {
  uTime: { value: 0, type: "f32" },
  strength: { value: 0.015, type: "f32" },
  frequency: { value: 10, type: "f32" }
}, OA = `
precision mediump float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;

void main(void)
{
    vec2 uv = vTextureCoord;
    vec2 center = vec2(0.28, 0.45);

    float dist = distance(uv, center);

    float speed = 0.7;
    float progress = mod(uTime * speed, 1.0);

    float width = mix(0.01, 0.07, progress);

    float lightning = smoothstep(progress + width, progress, dist);

    float noise = sin((uv.x + uv.y) * 30.0 + uTime * 12.0);
    lightning *= noise * 0.5 + 0.5;

    float explosion = smoothstep(0.85, 1.0, progress);
    float burst = explosion * smoothstep(0.25, 0.0, dist);

    vec3 lightningColor = vec3(1.0, 0.9, 0.6) * lightning * 2.5;
    vec3 explosionColor = vec3(1.0, 0.4, 0.2) * burst * 4.0;

    vec4 base = texture2D(uTexture, uv);

    gl_FragColor = vec4(base.rgb + lightningColor + explosionColor, base.a);
}
`, DA = {
  uTime: { value: 0, type: "f32" }
}, LA = `
precision mediump float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);

    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
           (c - a) * u.y * (1.0 - u.x) +
           (d - b) * u.x * u.y;
}

void main(void)
{
    vec2 uv = vTextureCoord;
    vec2 center = vec2(0.5);

    vec2 dir = uv - center;
    float dist = length(dir);
    float t = uTime * 1.5;

    float veinNoise =
        noise(dir * 6.0 + t) * 0.6 +
        noise(dir * 12.0 - t * 1.3) * 0.3;

    float warpedDist = dist + veinNoise * 0.08;

    float thickness = 0.04 + veinNoise * 0.02;

    float lightning =
        smoothstep(thickness, 0.0, warpedDist);

    float branches =
        smoothstep(0.02, 0.0,
            abs(noise(dir * 20.0 + t) - 0.5));

    lightning += branches * 0.35;

    float pulse = sin(uTime * 10.0) * 0.3 + 0.7;
    lightning *= pulse;

    vec3 veinColor =
        vec3(0.6, 0.85, 1.0) * lightning * 2.5;

    vec4 base = texture2D(uTexture, uv);

    gl_FragColor =
        vec4(base.rgb + veinColor, base.a);
}
`, NA = {
  uTime: { value: 0, type: "f32" }
}, GA = `
precision mediump float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;

float rand(float x)
{
    return fract(sin(x) * 43758.5453123);
}

void main(void)
{
    vec2 uv = vTextureCoord;

    float pixelRows = 120.0;
    float row = floor(uv.y * pixelRows) / pixelRows;

    float offset =
        sin(row * 40.0 + uTime * 3.0) *
        0.015;

    offset += (rand(row * 10.0) - 0.5) * 0.01;

    vec2 distortedUV = vec2(uv.x + offset, uv.y);

    distortedUV = clamp(distortedUV, 0.0, 1.0);

    vec4 color = texture2D(uTexture, distortedUV);

    gl_FragColor = color;
}
`, HA = {
  uTime: { value: 0, type: "f32" }
}, WA = `
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uIntensity;

uniform float neonR;
uniform float neonG;
uniform float neonB;

void main(void)
{
    vec4 base = texture2D(uTexture, vTextureCoord);

    float speed = 4.2;                 
    float t = fract(uTime * speed);    

    float rise = smoothstep(0.0, 0.25, t);
    float fall = smoothstep(0.85, 0.55, t);
    float flash = rise * fall;

    flash = mix(0.25, 1.0, flash);

    flash *= uIntensity;

    base.r += base.r * neonR * flash;
    base.g += base.g * neonG * flash;
    base.b += base.b * neonB * flash;

    gl_FragColor = base;
}
`, VA = {
  uTime: { value: 0, type: "f32" },
  uIntensity: { value: 1.8, type: "f32" },
  neonR: { value: 0.1, type: "f32" },
  neonG: { value: 0.9, type: "f32" },
  neonB: { value: 1, type: "f32" }
}, $A = `
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uStrength;
uniform float uSpeed;

void main(void)
{
    vec2 uv = vTextureCoord;
    float time = uTime * uSpeed;

    float wave = sin((uv.y * 18.0) - time);

    float offsetX = wave * uStrength;

    vec2 distortedUV = uv + vec2(offsetX, 0.0);

    distortedUV = clamp(distortedUV, 0.0, 1.0);

    vec4 color = texture2D(uTexture, distortedUV);

    gl_FragColor = color;
}
`, YA = {
  uTime: { value: 0, type: "f32" },
  uStrength: { value: 0.02, type: "f32" },
  uSpeed: { value: 20, type: "f32" }
}, XA = `
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;

const int BALL_COUNT = 10;
float radius = 0.05;
float border = 0.006;

vec2 bounce(vec2 p)
{
    return abs(fract(p) * 2.0 - 1.0);
}

void main(void)
{
    vec2 uv = vTextureCoord;

    /* Textura base */
    vec4 color = texture2D(uTexture, uv);

    float ballsAlpha = 0.0;

    for (int i = 0; i < BALL_COUNT; i++)
    {
        float id = float(i) + 1.0;

        vec2 speed = vec2(
            0.3 + id * 0.12,
            0.25 + id * 0.15
        );

        vec2 pos = bounce(vec2(
            uTime * speed.x + id * 0.17,
            uTime * speed.y + id * 0.29
        ));

        float d = distance(uv, pos);

        float edge =
            smoothstep(radius, radius - border, d) -
            smoothstep(radius - border, radius - border - 0.01, d);

        ballsAlpha += edge;
    }

    ballsAlpha = clamp(ballsAlpha, 0.0, 1.0);
    color.rgb = mix(color.rgb, vec3(1.0), ballsAlpha);

    gl_FragColor = color;
}
`, qA = {
  uTime: { value: 0, type: "f32" }
}, ZA = `
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uWaveStrength;
uniform float uWaveSpeed;

void main(void)
{
    vec2 uv = vTextureCoord;

    if (uv.y < 0.5)
    {
        gl_FragColor = texture2D(uTexture, uv);
        return;
    }

    vec2 reflectUV = uv;
    reflectUV.y = 1.0 - uv.y;

    float wave =
        sin(reflectUV.y * 30.0 + uTime * uWaveSpeed) *
        uWaveStrength;

    reflectUV.x += wave;
    reflectUV = clamp(reflectUV, 0.0, 1.0);

    vec4 reflectColor = texture2D(uTexture, reflectUV);

    float fade = smoothstep(0.5, 1.0, uv.y);

    reflectColor.rgb *= (1.0 - fade) * 0.85;
    reflectColor.a *= (1.0 - fade);

    gl_FragColor = reflectColor;
}
`, KA = {
  uTime: { value: 0, type: "f32" },
  uWaveStrength: { value: 0.02, type: "f32" },
  uWaveSpeed: { value: 2.5, type: "f32" }
}, JA = `
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uStrength;

float rand(vec2 co)
{
    return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453);
}

void main(void)
{
    vec2 uv = vTextureCoord;

    float t = floor(uTime * 6.0);

    float blockSize = 0.08;
    float blockY = floor(uv.y / blockSize) * blockSize;

    float noise = rand(vec2(blockY, t));

    float shift =
        step(0.65, noise) *
        (rand(vec2(blockY, t + 1.0)) - 0.5) *
        uStrength;

    vec2 glitchUV = uv + vec2(shift, 0.0);
    glitchUV = clamp(glitchUV, 0.0, 1.0);

    vec4 color = texture2D(uTexture, glitchUV);
    float darkPulse =
        step(0.75, noise) *
        (0.4 + rand(vec2(uv.x, t)) * 0.6);

    color.rgb *= 1.0 - darkPulse;
    float pixelNoise = rand(uv * t);
    color.rgb *= 1.0 - step(0.96, pixelNoise) * 0.8;

    gl_FragColor = color;
}
`, jA = {
  uTime: { value: 0, type: "f32" },
  uStrength: { value: 0.08, type: "f32" }
}, QA = `
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;

vec4 blur5(sampler2D tex, vec2 uv, float strength)
{
    vec4 col = vec4(0.0);
    float s = strength;

    col += texture2D(tex, uv + vec2(-s, -s)) * 0.05;
    col += texture2D(tex, uv + vec2( 0.0, -s)) * 0.10;
    col += texture2D(tex, uv + vec2( s, -s)) * 0.05;

    col += texture2D(tex, uv + vec2(-s,  0.0)) * 0.10;
    col += texture2D(tex, uv)                * 0.40;
    col += texture2D(tex, uv + vec2( s,  0.0)) * 0.10;

    col += texture2D(tex, uv + vec2(-s,  s)) * 0.05;
    col += texture2D(tex, uv + vec2( 0.0,  s)) * 0.10;
    col += texture2D(tex, uv + vec2( s,  s)) * 0.05;

    return col;
}

void main(void)
{
    vec2 uv = vTextureCoord;
    vec2 center = vec2(0.5, 0.5);

    float t = clamp(uTime, 0.0, 1.0);
    float zoomPhase = smoothstep(0.0, 0.5, t) *
                      (1.0 - smoothstep(0.5, 1.0, t));

    float scale = 1.0 + zoomPhase * 0.5;

    vec2 offset = vec2(0.0);

    if (t < 0.33)
    {
        offset = vec2(0.12 * (t / 0.33), 0.0);
    }
    else if (t < 0.66)
    {
        offset = vec2(
            0.12 * (1.0 - (t - 0.33) / 0.33),
            0.0
        );
    }
    else
    {
        offset = vec2(
            0.08 * ((t - 0.66) / 0.34),
           -0.08 * ((t - 0.66) / 0.34)
        );
    }

    offset *= zoomPhase;
    vec2 transformedUV =
        (uv - center) / scale +
        center -
        offset;

    transformedUV = clamp(transformedUV, 0.0, 1.0);
    float blurStrength = zoomPhase * 0.015;

    vec4 color = blur5(uTexture, transformedUV, blurStrength);

    gl_FragColor = color;
}
`, e3 = {
  uTime: { value: 0, type: "f32" }
}, t3 = `
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uCutPos;


float noise(float x)
{
    return sin(x * 28.0) * 0.035;
}

vec4 blur5(sampler2D tex, vec2 uv, float s)
{
    vec4 c = vec4(0.0);
    c += texture2D(tex, uv + vec2(-s, -s)) * 0.05;
    c += texture2D(tex, uv + vec2( 0.0, -s)) * 0.10;
    c += texture2D(tex, uv + vec2( s, -s)) * 0.05;
    c += texture2D(tex, uv + vec2(-s,  0.0)) * 0.10;
    c += texture2D(tex, uv)                * 0.40;
    c += texture2D(tex, uv + vec2( s,  0.0)) * 0.10;
    c += texture2D(tex, uv + vec2(-s,  s)) * 0.05;
    c += texture2D(tex, uv + vec2( 0.0,  s)) * 0.10;
    c += texture2D(tex, uv + vec2( s,  s)) * 0.05;
    return c;
}

void main(void)
{
    vec2 uv = vTextureCoord;
    vec2 center = vec2(0.5);
    float movePhase  = smoothstep(0.0, 0.45, uTime);
    float settle     = smoothstep(0.45, 0.6, uTime);
    float cutPhase   = smoothstep(0.7, 0.9, uTime);
    float cleanPhase = smoothstep(0.9, 1.0, uTime);
    float scale = mix(1.5, 1.0, settle);

    float moveAlive = 1.0 - settle;

    vec2 movement = vec2(
        sin(uTime * 6.0) * 0.18 * moveAlive,
        0.0
    );

    vec2 uvScaled =
        (uv - center) / scale +
        center -
        movement;

    uvScaled = clamp(uvScaled, 0.0, 1.0);

    float blurStrength = (1.0 - cleanPhase) * 0.025;
    vec4 blurred = blur5(uTexture, uvScaled, blurStrength);
    vec4 clean = texture2D(uTexture, uv);

    float tearLine =
        mix(
            uCutPos,
            uCutPos + noise(uv.y + uTime * 3.0),
            cutPhase
        );

    tearLine = clamp(tearLine, uCutPos - 0.05, uCutPos + 0.05);

    float split = cutPhase * 0.35;

    vec2 leftUV  = uv;
    vec2 rightUV = uv;

    leftUV.x  -= split * step(uv.x, tearLine);
    rightUV.x += split * step(tearLine, uv.x);

    leftUV  = clamp(leftUV,  0.0, 1.0);
    rightUV = clamp(rightUV, 0.0, 1.0);

    vec4 left  = texture2D(uTexture, leftUV);
    vec4 right = texture2D(uTexture, rightUV);

    float cutMask =
        smoothstep(tearLine - 0.02, tearLine + 0.02, uv.x);

    vec4 broken = mix(left, right, cutMask);

    float edge =
        smoothstep(0.0, 0.02, abs(uv.x - tearLine)) *
        (1.0 - smoothstep(0.02, 0.05, abs(uv.x - tearLine)));

    vec3 edgeColor = vec3(1.0) * edge * cutPhase;

    broken.rgb += edgeColor;

    vec4 result = mix(blurred, broken, cutPhase);
    result = mix(result, clean, cleanPhase);

    gl_FragColor = result;
}
`, i3 = {
  uTime: { value: 0, type: "f32" },
  uCutPos: { value: 0.28, type: "f32" }
}, s3 = `
#ifdef GL_ES
precision mediump float;
#endif

varying vec2 vTextureCoord;

uniform float uTime;
uniform sampler2D uTexture;

float rand(vec2 st)
{
    return fract(sin(dot(st, vec2(12.9898,78.233))) * 43758.5453123);
}

float noise(vec2 st)
{
    vec2 i = floor(st);
    vec2 f = fract(st);

    float a = rand(i);
    float b = rand(i + vec2(1.0, 0.0));
    float c = rand(i + vec2(0.0, 1.0));
    float d = rand(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
           (c - a) * u.y * (1.0 - u.x) +
           (d - b) * u.x * u.y;
}

float spray(vec2 st, float radius)
{
    float dist = length(st - vec2(0.28, 0.5));
    float base = smoothstep(radius, radius - 0.06, dist);

    float speckle =
        noise(st * 45.0 + uTime * 3.0) *
        noise(st * 90.0);

    return clamp(base + speckle * 0.7, 0.0, 1.0);
}

float drips(vec2 st, float mask)
{
    float column = noise(vec2(st.x * 25.0, 0.0));

    float drip =
        smoothstep(0.3, 0.7, column) *
        smoothstep(0.1, 1.0, 1.0 - st.y);

    float flow =
        noise(vec2(st.x * 35.0, st.y * 6.0 + uTime * 2.5));

    return drip * flow * mask;
}

void main(void)
{
    vec2 uv = vTextureCoord;

    vec4 base = texture2D(uTexture, uv);

    vec3 graffitiColor = vec3(1.0, 0.0, 0.5);

    float reveal = smoothstep(0.0, 1.0, uTime);

    float sprayMask =
        spray(uv, 0.35 * reveal);

    float dripMask =
        drips(uv, sprayMask) * reveal;

    float graffitiMask =
        clamp(sprayMask + dripMask * 1.3, 0.0, 1.0);

    vec3 graffiti =
        graffitiColor * graffitiMask;

    vec3 Color =
        base.rgb + graffiti;

    gl_FragColor = vec4(Color, base.a);
}
`, r3 = {
  uTime: { value: 0, type: "f32" }
}, n3 = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform vec3 uColor;
uniform float uThickness;
uniform float uIntensity;

float noise(float x) {
    return sin(x * 40.0) * 0.005;
}

void main() {
    vec2 uv = vTextureCoord;

    vec4 baseColor = texture2D(uTexture, uv);

    float beamY = 0.48 + noise(uv.x + uTime * 5.0);

    float dist = abs(uv.y - beamY);

    float core = smoothstep(uThickness, 0.0, dist);

    float glow = smoothstep(uThickness * 4.0, uThickness, dist);

    float pulse = 0.6 + 0.4 * sin(uTime * 10.0);

    float laserMask = (core + glow * uIntensity) * pulse;

    vec3 laserColor = uColor * laserMask;

    vec3 color = baseColor.rgb + laserColor;

    gl_FragColor = vec4(color, baseColor.a);
}
`, o3 = {
  uTime: { value: 0, type: "f32" },
  uColor: { value: [1, 0, 0.2], type: "vec3<f32>" },
  uThickness: { value: 0.02, type: "f32" },
  uIntensity: { value: 1.5, type: "f32" }
}, a3 = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uStrength;
uniform float uFrequency;
uniform float uSpeed;

void main() {
    vec2 uv = vTextureCoord;

    vec2 center = vec2(0.5, 0.5);

    float dist = distance(uv, center);

    float wave =
        sin(dist * uFrequency - uTime * uSpeed) *
        uStrength *
        smoothstep(1.0, 0.0, dist);

    vec2 dir = normalize(uv - center);

    vec2 distortedUV = uv + dir * wave;

    vec4 color = texture2D(uTexture, distortedUV);

    gl_FragColor = color;
}
`, l3 = {
  uTime: { value: 0, type: "f32" },
  uStrength: { value: 0.02, type: "f32" },
  uFrequency: { value: 20, type: "f32" },
  uSpeed: { value: 4, type: "f32" }
}, c3 = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uDensity;
uniform float uSpeed;
uniform float uSize;

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}
vec3 randomColor(float h) {
    return vec3(
        0.5 + 0.5 * sin(h * 6.2831),
        0.5 + 0.5 * sin(h * 6.2831 + 2.1),
        0.5 + 0.5 * sin(h * 6.2831 + 4.2)
    );
}

void main() {
    vec2 uv = vTextureCoord;

    vec4 base = texture2D(uTexture, uv);

    vec3 sparkColor = vec3(0.0);
    float sparkAlpha = 0.0;

    vec2 grid = floor(uv * uDensity);
    vec2 id = grid;

    float h = hash(id);

    vec2 sparkPos = fract(vec2(
        h,
        h + uTime * uSpeed
    ));

    float d = distance(fract(uv * uDensity), sparkPos);

    float spark = smoothstep(uSize, 0.0, d);

    vec3 color = randomColor(h) * spark;

    sparkColor += color;
    sparkAlpha += spark;

    vec3 colorValue = base.rgb + sparkColor;

    gl_FragColor = vec4(colorValue, max(base.a, sparkAlpha));
}
`, h3 = {
  uTime: { value: 0, type: "f32" },
  uDensity: { value: 30, type: "f32" },
  uSpeed: { value: 2.5, type: "f32" },
  uSize: { value: 0.15, type: "f32" }
}, u3 = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform vec3 uColor;      
uniform float uScanWidth; 
uniform float uIntensity; 

float noise(float x) {
    return sin(x * 120.0) * 0.02;
}

void main() {
    vec2 uv = vTextureCoord;

    vec4 base = texture2D(uTexture, uv);

    float scanPos = fract(uTime * 0.5);
    float scanLine = smoothstep(
        uScanWidth,
        0.0,
        abs(uv.y - scanPos)
    );

    float lines = 0.5 + 0.5 * sin(uv.y * 300.0 + uTime * 10.0);

    float flicker = 0.9 + 0.1 * sin(uTime * 50.0);

    float holo =
        scanLine +
        lines * 0.2 +
        noise(uv.x + uTime) * 0.5;

    holo *= uIntensity * flicker;

    vec3 holoColor = uColor * holo;

    vec3 colorValue = base.rgb + holoColor;

    gl_FragColor = vec4(colorValue, base.a);
}
`, d3 = {
  uTime: { value: 0, type: "f32" },
  uColor: { value: [0, 1, 1], type: "vec3<f32>" },
  uScanWidth: { value: 0.02, type: "f32" },
  uIntensity: { value: 1.2, type: "f32" }
}, f3 = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uGrain;     
uniform float uFade;      
uniform float uVignette;  

float noise(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898,78.233)) + uTime) * 43758.5453);
}

void main() {
    vec2 uv = vTextureCoord;

    vec4 color = texture2D(uTexture, uv);

    vec3 faded = mix(color.rgb, vec3(
        dot(color.rgb, vec3(0.393, 0.769, 0.189)),
        dot(color.rgb, vec3(0.349, 0.686, 0.168)),
        dot(color.rgb, vec3(0.272, 0.534, 0.131))
    ), uFade);

    float grain = (noise(uv * 500.0) - 0.5) * uGrain;
    faded += grain;

    float flicker = 0.97 + 0.03 * sin(uTime * 60.0);
    faded *= flicker;

    float dist = distance(uv, vec2(0.5));
    float vignette = smoothstep(0.8, uVignette, dist);
    faded *= 1.0 - vignette;

    gl_FragColor = vec4(faded, color.a);
}
`, p3 = {
  uTime: { value: 0, type: "f32" },
  uGrain: { value: 0.08, type: "f32" },
  uFade: { value: 0.6, type: "f32" },
  uVignette: { value: 1, type: "f32" }
}, m3 = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uThickness;
uniform vec3 uOutlineColor;

void main() {
    vec2 uv = vTextureCoord;

    vec2 px = vec2(uThickness) / vec2(1024.0, 1024.0);

    vec4 centerTex = texture2D(uTexture, uv);
    vec3 center = centerTex.rgb;

    vec3 up     = texture2D(uTexture, uv + vec2(0.0,  px.y)).rgb;
    vec3 down   = texture2D(uTexture, uv - vec2(0.0,  px.y)).rgb;
    vec3 left   = texture2D(uTexture, uv - vec2(px.x, 0.0)).rgb;
    vec3 right  = texture2D(uTexture, uv + vec2(px.x, 0.0)).rgb;

    float edge =
        length(center - up) +
        length(center - down) +
        length(center - left) +
        length(center - right);

    edge = smoothstep(0.15, 0.4, edge);

    vec3 colorValue = mix(center, uOutlineColor, edge);
    gl_FragColor = vec4(colorValue, centerTex.a);
}

`, g3 = {
  uThickness: { value: 1.5, type: "f32" },
  uOutlineColor: { value: [1, 1, 1], type: "vec3<f32>" }
}, x3 = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uDensity;
uniform float uSize;
uniform float uIntensity;
uniform vec3 uColorA;
uniform vec3 uColorB;

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

vec3 accentColor(float h) {
    return mix(uColorA, uColorB, fract(h * 7.0));
}

void main() {
    vec2 uv = vTextureCoord;

    vec4 base = texture2D(uTexture, uv);

    vec2 gridUV = floor(uv * uDensity);
    float h = hash(gridUV);

    vec2 offset = vec2(
        fract(h * 13.3),
        fract(h * 7.7)
    );

    vec2 accentUV = fract(uv * uDensity) - offset;

    float dist = length(accentUV);

    float accent = smoothstep(uSize, 0.0, dist);

    accent *= 0.6 + 0.4 * sin(uTime * 10.0 + h * 6.28);

    vec3 color = accentColor(h) * accent * uIntensity;

    float alpha = accent;

    gl_FragColor = vec4(color + base.rgb, max(base.a, alpha));
}
`, y3 = {
  uTime: { value: 0, type: "f32" },
  uDensity: { value: 20, type: "f32" },
  uSize: { value: 0.25, type: "f32" },
  uIntensity: { value: 1.2, type: "f32" },
  uColorA: { value: [1, 0.2, 0.6], type: "vec3<f32>" },
  uColorB: { value: [0.2, 0.8, 1], type: "vec3<f32>" }
}, v3 = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform vec3 uColorA;
uniform vec3 uColorB;
uniform float uIntensity;

float noise(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
}

vec2 swirl(vec2 uv, float t) {
    vec2 center = vec2(0.5);
    vec2 diff = uv - center;
    float angle = 0.5 * t * length(diff);
    float s = sin(angle);
    float c = cos(angle);
    return center + vec2(c*diff.x - s*diff.y, s*diff.x + c*diff.y);
}

void main() {
    vec2 uv = vTextureCoord;

    vec2 uvSwirl = swirl(uv, uTime);

    vec4 base = texture2D(uTexture, uvSwirl);

    float n = noise(uv * 20.0 + uTime * 2.0);
    vec3 liquid = mix(uColorA, uColorB, n);

    vec3 colorValue = mix(base.rgb, liquid, uIntensity * n);

    gl_FragColor = vec4(colorValue, base.a);
}
`, _3 = {
  uTime: { value: 0, type: "f32" },
  uColorA: { value: [0.2, 0.8, 1], type: "vec3<f32>" },
  uColorB: { value: [1, 0.2, 0.6], type: "vec3<f32>" },
  uIntensity: { value: 0.8, type: "f32" }
}, b3 = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uLineThickness;
uniform float uLineIntensity;
uniform float uNoiseIntensity;
uniform vec3 uLineColor;

float rand(vec2 p){
    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);
}

void main() {
    vec2 uv = vTextureCoord;

    vec4 tex = texture2D(uTexture, uv);
    vec3 base = tex.rgb;

    float line = sin(uv.y * 800.0 * uLineThickness) * 0.5 + 0.5;
    line = mix(1.0, line, uLineIntensity);

    float noise =
        (rand(vec2(uTime, uv.y * 1000.0)) - 0.5) * uNoiseIntensity;

    vec3 colorValue = base * line + noise;

    gl_FragColor = vec4(colorValue, tex.a);
}
`, w3 = {
  uTime: { value: 0, type: "f32" },
  uLineThickness: { value: 2, type: "f32" },
  uLineIntensity: { value: 0.6, type: "f32" },
  uNoiseIntensity: { value: 0.05, type: "f32" },
  uLineColor: { value: [0.8, 1, 0.8], type: "vec3<f32>" }
}, T3 = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uExposure;
uniform float uSaturation;
uniform float uContrast;

vec3 adjustSaturation(vec3 color, float sat) {
    float grey = dot(color, vec3(0.299, 0.587, 0.114));
    return mix(vec3(grey), color, sat);
}

vec3 adjustContrast(vec3 color, float contrast) {
    return (color - 0.5) * contrast + 0.5;
}

void main() {
    vec2 uv = vTextureCoord;

    vec4 tex = texture2D(uTexture, uv);
    vec3 color = tex.rgb;
    color *= uExposure;

    color = adjustSaturation(color, uSaturation);

    color = adjustContrast(color, uContrast);

    color = color / (color + vec3(1.0));

    gl_FragColor = vec4(color, tex.a);
}
`, S3 = {
  uExposure: { value: 1.2, type: "f32" },
  uSaturation: { value: 4.3, type: "f32" },
  uContrast: { value: 2.2, type: "f32" }
}, C3 = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uIntensity;
uniform float uDuration;

void main() {
    vec2 uv = vTextureCoord;
    vec4 base = texture2D(uTexture, uv);

    float flash = smoothstep(0.0, uDuration * 0.5, mod(uTime, uDuration)) *
                  (1.0 - smoothstep(uDuration * 0.5, uDuration, mod(uTime, uDuration)));

    flash *= uIntensity;

    vec3 color = mix(base.rgb, vec3(0.0), flash);

    gl_FragColor = vec4(color, base.a);
}
`, A3 = {
  uTime: { value: 0, type: "f32" },
  uIntensity: { value: 0.7, type: "f32" },
  uDuration: { value: 0.2, type: "f32" }
}, I3 = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uPulseScale;  
uniform float uBlurStrength; 
uniform float uGlowBoost; 

vec4 blur3(sampler2D tex, vec2 uv, float s) {
    vec4 c = vec4(0.0);
    c += texture2D(tex, uv + vec2(-s, -s)) * 0.0625;
    c += texture2D(tex, uv + vec2( 0.0, -s)) * 0.125;
    c += texture2D(tex, uv + vec2( s, -s)) * 0.0625;
    c += texture2D(tex, uv + vec2(-s,  0.0)) * 0.125;
    c += texture2D(tex, uv) * 0.25;
    c += texture2D(tex, uv + vec2( s,  0.0)) * 0.125;
    c += texture2D(tex, uv + vec2(-s,  s)) * 0.0625;
    c += texture2D(tex, uv + vec2( 0.0,  s)) * 0.125;
    c += texture2D(tex, uv + vec2( s,  s)) * 0.0625;
    return c * uGlowBoost;
}

void main() {
    vec2 uv = vTextureCoord;

    float scale = 1.0 + uPulseScale * (0.5 + 0.5 * sin(uTime * 3.0));
    vec2 center = vec2(0.28,0.48); 
    vec2 uvScaled = (uv - center) / scale + center;
    uvScaled = clamp(uvScaled, 0.0, 1.0);
    vec4 base = texture2D(uTexture, uvScaled);
    vec4 blurred = blur3(uTexture, uvScaled, uBlurStrength);
    vec4 colorValue = mix(base, blurred, 0.8);

    gl_FragColor = colorValue;
}
`, k3 = {
  uTime: { value: 0, type: "f32" },
  uPulseScale: { value: 0.2, type: "f32" },
  uBlurStrength: { value: 0.02, type: "f32" },
  uGlowBoost: { value: 2, type: "f32" }
}, F3 = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uIntensity; // 0  original, 1  negativo completo
uniform float uContrast;  // fuerza de contraste

void main() {
    vec2 uv = vTextureCoord;
    vec4 color = texture2D(uTexture, uv);
    vec3 negative = 1.0 - color.rgb;

    vec3 contrasted = (negative - 0.5) * uContrast + 0.5;

    float maskedIntensity = uIntensity * color.a;

    vec3 colorValue =
        mix(color.rgb, contrasted, maskedIntensity);

    gl_FragColor = vec4(colorValue, color.a);
}
`, M3 = {
  uIntensity: { value: 1, type: "f32" },
  uContrast: { value: 2.5, type: "f32" }
}, E3 = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uIntensity;
uniform float uSpeed;

float rand(float x){
    return fract(sin(x * 12.9898) * 43758.5453);
}

vec2 shakeOffset(float time){
    float x = (rand(time * 0.7) - 0.5) * uIntensity;
    float y = (rand(time * 1.3 + 10.0) - 0.5) * uIntensity;
    return vec2(x, y);
}

void main() {
    vec2 uv = vTextureCoord;

    vec2 offset = shakeOffset(uTime * uSpeed);

    vec2 uvMoved = clamp(uv + offset, 0.0, 1.0);

    vec4 color = texture2D(uTexture, uvMoved);

    gl_FragColor = color;
}

`, P3 = {
  uTime: { value: 0, type: "f32" },
  uIntensity: { value: 1, type: "f32" },
  uSpeed: { value: 1, type: "f32" }
}, U3 = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uExposure;
uniform float uBloom;
uniform float uContrast;

vec3 tonemapReinhard(vec3 color){
    return color / (color + vec3(1.0));
}

void main() {
    vec2 uv = vTextureCoord;
    vec4 tex = texture2D(uTexture, uv);

    if (tex.a < 0.01) {
        gl_FragColor = tex;
        return;
    }

    vec3 color = tex.rgb;

    vec3 bright = max(color - 0.6, 0.0) * uBloom;
    bright = tonemapReinhard(bright);

    vec3 hdrColor = color + bright * 0.6;

    hdrColor *= uExposure;

    hdrColor = (hdrColor - 0.5) * uContrast + 0.5;

    hdrColor = clamp(hdrColor, 0.0, 1.0);

    gl_FragColor = vec4(hdrColor, tex.a);
}
`, R3 = {
  uExposure: { value: 1, type: "f32" },
  uBloom: { value: 1.5, type: "f32" },
  uContrast: { value: 2, type: "f32" }
}, B3 = `
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;       
uniform float uZoomSpeed;  
uniform float uMaxZoom;    
uniform float uBlurStrength; 

vec4 blur3(sampler2D tex, vec2 uv, float s) {
    vec4 c = vec4(0.0);
    c += texture2D(tex, uv + vec2(-s, -s)) * 0.0625;
    c += texture2D(tex, uv + vec2( 0.0, -s)) * 0.125;
    c += texture2D(tex, uv + vec2( s, -s)) * 0.0625;
    c += texture2D(tex, uv + vec2(-s,  0.0)) * 0.125;
    c += texture2D(tex, uv) * 0.25;
    c += texture2D(tex, uv + vec2( s,  0.0)) * 0.125;
    c += texture2D(tex, uv + vec2(-s,  s)) * 0.0625;
    c += texture2D(tex, uv + vec2( 0.0,  s)) * 0.125;
    c += texture2D(tex, uv + vec2( s,  s)) * 0.0625;
    return c;
}

void main() {
    vec2 uv = vTextureCoord;
    vec2 center = vec2(0.28,0.48); 

    float zoom = 1.0 + (uMaxZoom - 1.0) * smoothstep(0.0, 1.0, sin(uTime * uZoomSpeed));

    vec2 uvZoomed = (uv - center) / zoom + center;

    uvZoomed = clamp(uvZoomed, 0.0, 1.0);

    vec4 color = texture2D(uTexture, uvZoomed);

    if (uBlurStrength > 0.0) {
        vec4 blurred = blur3(uTexture, uvZoomed, uBlurStrength);
        color = mix(color, blurred, 0.5);
    }

    gl_FragColor = color;
}
`, z3 = {
  uTime: { value: 0, type: "f32" },
  uZoomSpeed: { value: 5, type: "f32" },
  uMaxZoom: { value: 2, type: "f32" },
  uBlurStrength: { value: 0.01, type: "f32" }
}, O3 = {
  rotationMovement: {
    label: "Rotation Movement",
    fragment: tC,
    uniforms: iC
  },
  redGradient: {
    label: "Red Gradient",
    fragment: sC,
    uniforms: rC
  },
  bubbleSparkles: {
    label: "Bubble Sparkles",
    fragment: nC,
    uniforms: oC
  },
  sepia: {
    label: "Sepia",
    fragment: aC,
    uniforms: lC
  },
  uvGradient: {
    label: "UV Gradient",
    fragment: cC,
    uniforms: hC
  },
  rainbow: {
    label: "Rainbow",
    fragment: uC,
    uniforms: dC
  },
  glitch: {
    label: "Glitch",
    fragment: fC,
    uniforms: pC
  },
  pixelate: {
    label: "Pixelate",
    fragment: Jm,
    uniforms: jm
  },
  rgbGlitch: {
    label: "RGB Glitch",
    fragment: mC,
    uniforms: gC
  },
  rgbShift: {
    label: "RGB Shift",
    fragment: xC,
    uniforms: yC
  },
  halftone: {
    label: "Halftone",
    fragment: vC,
    uniforms: _C
  },
  sinewave: {
    label: "Sinewave",
    fragment: bC,
    uniforms: wC
  },
  shine: {
    label: "Shine",
    fragment: TC,
    uniforms: SC
  },
  blink: {
    label: "Blink",
    fragment: CC,
    uniforms: AC
  },
  spring: {
    label: "Spring",
    fragment: IC,
    uniforms: kC
  },
  duotone: {
    label: "Duotone",
    fragment: FC,
    uniforms: MC
  },
  tritone: {
    label: "Tritone",
    fragment: EC,
    uniforms: PC
  },
  hueShift: {
    label: "Hue Shift",
    fragment: UC,
    uniforms: RC
  },
  warpTransition: {
    label: "Warp Transition",
    fragment: BC,
    uniforms: zC
  },
  slitScan: {
    label: "Slit Scan",
    fragment: OC,
    uniforms: DC
  },
  slitScanGlitch: {
    label: "Slit Scan Glitch",
    fragment: LC,
    uniforms: NC
  },
  pixelateTransition: {
    label: "Pixelate Transition",
    fragment: GC,
    uniforms: HC
  },
  focusTransition: {
    label: "Focus Transition",
    fragment: WC,
    uniforms: VC
  },
  invert: {
    label: "Invert",
    fragment: $C,
    uniforms: YC
  },
  grayscale: {
    label: "Grayscale",
    fragment: XC,
    uniforms: qC
  },
  vignette: {
    label: "Vignette",
    fragment: ZC,
    uniforms: KC
  },
  chromatic: {
    label: "Chromatic",
    fragment: JC,
    uniforms: jC
  },
  swirlMovement: {
    label: "Swirl Movement",
    fragment: QC,
    uniforms: eA
  },
  heartSparkles: {
    label: "Heart Sparkles",
    fragment: tA,
    uniforms: iA
  },
  butterflySparkles: {
    label: "Butterfly Sparkles",
    fragment: sA,
    uniforms: rA
  },
  distort: {
    label: "Distort",
    fragment: nA,
    uniforms: oA
  },
  perspectiveSingle: {
    label: "Perspective Single",
    fragment: aA,
    uniforms: lA
  },
  distortSpin: {
    label: "Distort Spin",
    fragment: cA,
    uniforms: hA
  },
  distortGrid: {
    label: "Distort Grid",
    fragment: uA,
    uniforms: dA
  },
  distortRip: {
    label: "Distort Rip",
    fragment: fA,
    uniforms: pA
  },
  twoCurtain: {
    label: "Two Curtain",
    fragment: mA,
    uniforms: gA
  },
  trianglePattern: {
    label: "Triangle Pattern",
    fragment: xA,
    uniforms: yA
  },
  mirrorTile: {
    label: "Mirror Tile",
    fragment: vA,
    uniforms: _A
  },
  flashLoop: {
    label: "Flash Loop",
    fragment: bA,
    uniforms: wA
  },
  filmStripPro: {
    label: "Film Strip Pro",
    fragment: TA,
    uniforms: SA
  },
  badSignal: {
    label: "Bad Signal",
    fragment: CA,
    uniforms: AA
  },
  omniflexion: {
    label: "Omniflexion",
    fragment: IA,
    uniforms: kA
  },
  inverseAperture: {
    label: "Inverse Aperture",
    fragment: FA,
    uniforms: MA
  },
  curtainOpen: {
    label: "Curtain Open",
    fragment: EA,
    uniforms: PA
  },
  curtainBlur: {
    label: "Curtain Blur",
    fragment: UA,
    uniforms: RA
  },
  distortV2: {
    label: "Distort V2",
    fragment: BA,
    uniforms: zA
  },
  lightning: {
    label: "Lightning",
    fragment: OA,
    uniforms: DA
  },
  lightningVeins: {
    label: "Lightning Veins",
    fragment: LA,
    uniforms: NA
  },
  pixelError: {
    label: "Pixel Error",
    fragment: GA,
    uniforms: HA
  },
  neonFlash: {
    label: "Neon Flash",
    fragment: WA,
    uniforms: VA
  },
  waveDistort: {
    label: "Wave Distort",
    fragment: $A,
    uniforms: YA
  },
  bouncingBalls: {
    label: "Bouncing Balls",
    fragment: XA,
    uniforms: qA
  },
  waterReflection: {
    label: "Water Reflection",
    fragment: ZA,
    uniforms: KA
  },
  darkError: {
    label: "Dark Error",
    fragment: JA,
    uniforms: jA
  },
  scaleMoveBlur: {
    label: "Scale Move Blur",
    fragment: QA,
    uniforms: e3
  },
  paperBreakReveal: {
    label: "Paper Break Reveal",
    fragment: t3,
    uniforms: i3
  },
  graffiti: {
    label: "Graffiti",
    fragment: s3,
    uniforms: r3
  },
  laser: {
    label: "Laser",
    fragment: n3,
    uniforms: o3
  },
  wave: {
    label: "Wave",
    fragment: a3,
    uniforms: l3
  },
  sparks: {
    label: "Sparks",
    fragment: c3,
    uniforms: h3
  },
  hologramScan: {
    label: "Hologram Scan",
    fragment: u3,
    uniforms: d3
  },
  retro70s: {
    label: "Retro 70s",
    fragment: f3,
    uniforms: p3
  },
  igOutline: {
    label: "IG Outline",
    fragment: m3,
    uniforms: g3
  },
  randomAccents: {
    label: "Random Accents",
    fragment: x3,
    uniforms: y3
  },
  solution: {
    label: "Solution",
    fragment: v3,
    uniforms: _3
  },
  tvScanlines: {
    label: "TV Scanlines",
    fragment: b3,
    uniforms: w3
  },
  hdr: {
    label: "HDR",
    fragment: T3,
    uniforms: S3
  },
  blackFlash: {
    label: "Black Flash",
    fragment: C3,
    uniforms: A3
  },
  brightPulse: {
    label: "Bright Pulse",
    fragment: I3,
    uniforms: k3
  },
  negativeDivision: {
    label: "Negative Division",
    fragment: F3,
    uniforms: M3
  },
  cameraMove: {
    label: "Camera Move",
    fragment: E3,
    uniforms: P3
  },
  hdrV2: {
    label: "HDR V2",
    fragment: U3,
    uniforms: R3
  },
  fastZoom: {
    label: "Fast Zoom",
    fragment: B3,
    uniforms: z3
  }
}, qh = {
  ...O3
}, ck = Object.entries(qh).map(([i, e]) => ({
  key: i,
  label: e.label,
  previewStatic: `https://cdn.subgen.co/previews/effects/static/effect_${i}_static.webp`,
  previewDynamic: `https://cdn.subgen.co/previews/effects/dynamic/effect_${i}_dynamic.webp`
}));
function Qm({ name: i, renderer: e }) {
  let t;
  const s = Object.keys(qh).find(
    (u) => u.toLowerCase() === i.toLowerCase()
  );
  s && (t = qh[s]);
  const { fragment: r, uniforms: n, label: o } = t, a = new Me(), l = Pe.create({
    width: e.width,
    height: e.height
  }), c = new xi({
    vertex: eC,
    fragment: r,
    name: `${o}-shader`
  }), h = new mr({
    glProgram: c,
    resources: {
      effectUniforms: {
        ...n
      }
    }
  });
  return a.filters = [h], {
    filter: h,
    render({ width: u, height: d, canvasTexture: f, progress: m }) {
      (l.width !== u || l.height !== d) && l.resize(u, d);
      const g = f instanceof Pe ? f : L.from(f);
      a.texture = g, a.width = u, a.height = d;
      const p = h.resources.effectUniforms.uniforms;
      return p.uTime = m, e.render({
        container: a,
        target: l,
        clear: !0
      }), l;
    }
  };
}
function D3(i, e) {
  const { opacity: t, zIndex: s, flip: r, left: n, top: o, width: a, height: l, angle: c } = i;
  e.x = n, e.y = o, e.width = Math.abs(a), e.height = Math.abs(l), e.angle = c, e.alpha = t, e.zIndex = s, r === "horizontal" ? e.scale.x = -Math.abs(e.scale.x) : r === "vertical" && (e.scale.y = -Math.abs(e.scale.y));
}
class qs {
  constructor(e, t, s = null) {
    this.sprite = t, this.targetContainer = s, !s && e && (this.targetContainer = e.stage), this.resolution = e?.renderer?.resolution ?? 1, this.canvas = new OffscreenCanvas(1, 1);
    const r = this.canvas.getContext("2d");
    if (r == null)
      throw new Error("Failed to create 2d context for PixiSpriteRenderer");
    this.context = r;
  }
  pixiSprite = null;
  texture = null;
  canvas;
  context;
  root = null;
  strokeGraphics = null;
  maskGraphics = null;
  shadowGraphics = null;
  shadowContainer = null;
  resolution = 1;
  destroyed = !1;
  /**
   * Update the sprite with a new video frame or Texture
   * @param frame ImageBitmap, Texture, or null to render
   *              (VideoFrames are converted to ImageBitmap in getFrame)
   */
  async updateFrame(e) {
    if (this.destroyed) return;
    if (e == null) {
      this.root != null && (this.root.visible = !1, this.applySpriteTransforms());
      return;
    }
    if (e instanceof L) {
      if (e.width === 0 || e.height === 0) {
        console.warn(
          "PixiSpriteRenderer: Invalid texture dimensions",
          e.width,
          e.height
        );
        return;
      }
      this.pixiSprite == null ? (this.pixiSprite = new Me(e), this.pixiSprite.label = "MainSprite", this.root = new oe(), this.root.addChild(this.pixiSprite), this.targetContainer?.addChild(this.root), this.applySpriteTransforms()) : this.pixiSprite.texture = e, this.root != null && (this.root.visible = !0, this.applySpriteTransforms());
      return;
    }
    if (e.width === 0 || e.height === 0) {
      console.warn(
        "PixiSpriteRenderer: Invalid frame dimensions",
        e.width,
        e.height
      );
      return;
    }
    const t = this.texture == null || this.pixiSprite == null;
    if (this.canvas.width !== e.width || this.canvas.height !== e.height || t) {
      if (this.canvas.width = e.width, this.canvas.height = e.height, this.texture != null && (this.texture.destroy(!0), this.texture = null), this.texture = L.from(this.canvas), !this.texture || !this.texture.source) {
        console.error("PixiSpriteRenderer: Failed to create valid texture");
        return;
      }
      this.pixiSprite == null ? (this.pixiSprite = new Me(this.texture), this.pixiSprite.label = "MainSprite", this.root = new oe(), this.root.addChild(this.pixiSprite), this.targetContainer?.addChild(this.root), this.applySpriteTransforms()) : this.pixiSprite.texture = this.texture;
    }
    if (this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.context.drawImage(e, 0, 0), this.texture != null && this.texture.source != null) {
      const r = this.texture.source;
      if (r.resource) {
        const n = r.resource;
        n.update && n.update();
      }
      typeof r.update == "function" && r.update();
    }
    this.root != null && (this.root.visible = !0, this.applySpriteTransforms());
  }
  /**
   * Apply sprite transformations to the Pixi Sprite
   */
  applySpriteTransforms() {
    if (this.pixiSprite == null || this.root == null || this.destroyed) return;
    const { flip: e, center: t, width: s, height: r, angle: n, opacity: o, zIndex: a } = this.sprite;
    this.root.x = t.x, this.root.y = t.y, this.root.angle = (e == null ? 1 : -1) * n, this.root.alpha = o, this.root.zIndex = a, this.root.scale.set(1, 1), this.pixiSprite.anchor.set(0.5, 0.5), this.pixiSprite.position.set(0, 0);
    const l = this.pixiSprite.texture?.width ?? 1, c = this.pixiSprite.texture?.height ?? 1, h = s && s !== 0 ? Math.abs(s) / l : 1, u = r && r !== 0 ? Math.abs(r) / c : 1;
    e === "horizontal" ? (this.pixiSprite.scale.x = -h, this.pixiSprite.scale.y = u) : e === "vertical" ? (this.pixiSprite.scale.x = h, this.pixiSprite.scale.y = -u) : (this.pixiSprite.scale.x = h, this.pixiSprite.scale.y = u), this.applyStyle();
  }
  /**
   * Apply all styles (stroke, borderRadius, dropShadow) to the sprite
   */
  applyStyle() {
    if (this.pixiSprite == null || this.destroyed) return;
    const e = this.sprite.style || {}, t = this.pixiSprite.texture?.width ?? 0, s = this.pixiSprite.texture?.height ?? 0;
    if (t === 0 || s === 0) return;
    const r = e.borderRadius || 0;
    r > 0 ? (this.maskGraphics == null && (this.maskGraphics = new fe(), this.pixiSprite.addChild(this.maskGraphics), this.pixiSprite.mask = this.maskGraphics), this.maskGraphics.clear(), this.maskGraphics.roundRect(
      -t / 2,
      -s / 2,
      t,
      s,
      Math.min(r, t / 2, s / 2)
    ), this.maskGraphics.fill({ color: 16777215, alpha: 1 }), this.maskGraphics.visible = !0) : this.maskGraphics && (this.maskGraphics.visible = !1, this.pixiSprite.mask = null), this.sprite.type !== "Text" && this.sprite.type !== "Caption" ? this.applyStroke(e, t, s) : this.strokeGraphics && (this.strokeGraphics.visible = !1), this.sprite.type !== "Text" && this.sprite.type !== "Caption" ? this.applyShadow(e) : this.shadowContainer && (this.shadowContainer.visible = !1, this.shadowContainer.filters = []);
  }
  applyStroke(e, t, s) {
    const r = e.stroke;
    if (r && r.width > 0) {
      this.strokeGraphics == null && (this.strokeGraphics = new fe(), this.pixiSprite.addChild(this.strokeGraphics)), this.strokeGraphics.clear();
      const n = ge(r.color) ?? 16777215, o = r.width, a = e.borderRadius || 0;
      if (this.strokeGraphics.setStrokeStyle({
        width: o,
        color: n,
        alignment: 1
      }), a > 0) {
        const l = Math.min(a, t / 2, s / 2);
        this.strokeGraphics.roundRect(
          -t / 2,
          -s / 2,
          t,
          s,
          l
        );
      } else
        this.strokeGraphics.rect(
          -t / 2,
          -s / 2,
          t,
          s
        );
      this.strokeGraphics.stroke(), this.strokeGraphics.visible = !0;
    } else this.strokeGraphics != null && (this.strokeGraphics.visible = !1);
  }
  applyShadow(e) {
    const t = e.dropShadow, s = Math.abs(this.sprite.width ?? 0), r = Math.abs(this.sprite.height ?? 0);
    if (t && s > 0 && r > 0 && (t.blur > 0 || t.distance > 0)) {
      this.shadowContainer == null && (this.shadowContainer = new oe(), this.shadowContainer.label = "ShadowContainer", this.shadowGraphics = new fe(), this.shadowContainer.addChild(this.shadowGraphics), this.root.addChildAt(this.shadowContainer, 0));
      const n = ge(t.color) ?? 0, o = t.alpha ?? 0.5, a = t.blur ?? 0, l = t.distance ?? 0, c = t.angle ?? 0, h = Math.cos(c) * l, u = Math.sin(c) * l;
      this.shadowContainer.position.set(h, u), this.shadowGraphics.clear();
      const d = e.borderRadius || 0;
      if (d > 0) {
        const f = Math.min(d, s / 2, r / 2);
        this.shadowGraphics.roundRect(
          -s / 2,
          -r / 2,
          s,
          r,
          f
        );
      } else
        this.shadowGraphics.rect(-s / 2, -r / 2, s, r);
      if (this.shadowGraphics.fill({ color: n, alpha: o }), a > 0) {
        (!this.shadowContainer.filters || this.shadowContainer.filters.length === 0) && (this.shadowContainer.filters = [new Hm()]);
        const f = this.shadowContainer.filters[0], m = this.root ? Math.sqrt(
          this.root.worldTransform.a ** 2 + this.root.worldTransform.b ** 2
        ) : 1;
        f.strength = a * m, f.resolution = this.resolution, f.padding = Math.max(a * 2 * m, 20);
      } else
        this.shadowContainer.filters = [];
      this.shadowContainer.visible = !0;
    } else this.shadowContainer != null && (this.shadowContainer.visible = !1, this.shadowContainer.filters = []);
  }
  updateTransforms() {
    this.root != null && !this.destroyed && this.applySpriteTransforms();
  }
  getSprite() {
    return this.pixiSprite;
  }
  getRoot() {
    return this.root;
  }
  destroy() {
    this.destroyed || (this.destroyed = !0, this.root != null && (this.root.parent && this.root.parent.removeChild(this.root), this.root.destroy({ children: !0 }), this.root = null, this.pixiSprite = null), this.strokeGraphics != null && (this.strokeGraphics.destroy(), this.strokeGraphics = null), this.maskGraphics != null && (this.maskGraphics.destroy(), this.maskGraphics = null), this.shadowGraphics != null && (this.shadowGraphics.destroy(), this.shadowGraphics = null), this.shadowContainer != null && (this.shadowContainer.destroy({ children: !0 }), this.shadowContainer = null), this.texture != null && (this.texture.destroy(), this.texture = null));
  }
}
function Zs(i, e = !1) {
  return i.toJSON(e);
}
async function Ks(i) {
  let e, t = null;
  switch (i.type) {
    case "Video":
      t = xe;
      break;
    case "Audio":
      t = Ne;
      break;
    case "Image":
      t = Se;
      break;
    case "Text":
      t = et;
      break;
    case "Caption":
      t = Ft;
      break;
    case "Effect":
      t = tt;
      break;
    case "Transition":
      t = pi;
      break;
  }
  if (t && typeof t.fromObject == "function")
    return await t.fromObject(i);
  switch (i.type) {
    case "Video": {
      const s = await fetch(i.src);
      if (!s.ok)
        throw new Error(
          `Failed to fetch video from ${i.src}: ${s.status} ${s.statusText}. Make sure the file exists in the public directory.`
        );
      const r = i.audio !== void 0 ? { audio: i.audio, volume: i.volume } : { volume: i.volume };
      e = new xe(s.body, r, i.src);
      break;
    }
    case "Audio": {
      if (!i.src || i.src.trim() === "")
        throw new Error("AudioClip requires a valid source URL");
      const s = {};
      i.loop !== void 0 && (s.loop = i.loop), i.volume !== void 0 && (s.volume = i.volume), e = await Ne.fromUrl(i.src, s);
      break;
    }
    case "Image": {
      if (!i.src || i.src.trim() === "")
        throw new Error(
          "ImageClip requires a valid source URL. Generated clips (like text-to-image) cannot be loaded from JSON without their source data."
        );
      try {
        const s = await fetch(i.src);
        if (!s.ok)
          throw new Error(
            `Failed to fetch image from ${i.src}: ${s.status} ${s.statusText}. Make sure the file exists in the public directory.`
          );
        const r = await s.blob();
        if (!r.type.startsWith("image/"))
          throw new Error(
            `Invalid image format: ${r.type}. Expected an image file.`
          );
        e = new Se(await createImageBitmap(r), i.src);
      } catch (s) {
        throw s instanceof Error && s.message.includes("could not be decoded") ? new Error(
          `Failed to decode image from ${i.src}. The image may be corrupted, in an unsupported format, or there may be CORS issues.`
        ) : s;
      }
      break;
    }
    case "Text": {
      const s = i.text || "", r = i.style || {}, n = {
        fontSize: r.fontSize,
        fontFamily: r.fontFamily,
        fontWeight: r.fontWeight,
        fontStyle: r.fontStyle,
        fill: r.color,
        // Map 'color' to 'fill'
        align: r.align
      };
      r.stroke && (n.stroke = r.stroke.color, n.strokeWidth = r.stroke.width), r.shadow && (n.dropShadow = {
        color: r.shadow.color,
        alpha: r.shadow.alpha,
        blur: r.shadow.blur,
        distance: r.shadow.distance,
        angle: r.shadow.angle
      }), e = new et(s, n);
      break;
    }
    case "Caption": {
      const s = i.text || "", r = i.style || {}, n = {
        fontSize: r.fontSize,
        fontFamily: r.fontFamily,
        fontWeight: r.fontWeight,
        fontStyle: r.fontStyle,
        fill: r.color,
        // Map 'color' to 'fill'
        align: r.align
      };
      if (r.fontUrl !== void 0 ? n.fontUrl = r.fontUrl : i.fontUrl !== void 0 && (n.fontUrl = i.fontUrl), r.stroke && (n.stroke = r.stroke.color, n.strokeWidth = r.stroke.width), r.shadow && (n.dropShadow = {
        color: r.shadow.color,
        alpha: r.shadow.alpha,
        blur: r.shadow.blur,
        distance: r.shadow.distance,
        angle: r.shadow.angle
      }), i.caption) {
        const o = i.caption;
        o.words && (n.words = o.words), o.colors && (o.colors.appeared !== void 0 && (n.appearedColor = o.colors.appeared), o.colors.active !== void 0 && (n.activeColor = o.colors.active), o.colors.activeFill !== void 0 && (n.activeFillColor = o.colors.activeFill), o.colors.background !== void 0 && (n.backgroundColor = o.colors.background), o.colors.keyword !== void 0 && (n.isKeyWordColor = o.colors.keyword)), o.preserveKeywordColor !== void 0 && (n.preservedColorKeyWord = o.preserveKeywordColor), o.positioning && (o.positioning.bottomOffset !== void 0 && (n.bottomOffset = o.positioning.bottomOffset), o.positioning.videoWidth !== void 0 && (n.videoWidth = o.positioning.videoWidth), o.positioning.videoHeight !== void 0 && (n.videoHeight = o.positioning.videoHeight));
      } else
        i.bottomOffset !== void 0 && (n.bottomOffset = i.bottomOffset), i.words && (n.words = i.words), i.appearedColor !== void 0 && (n.appearedColor = i.appearedColor), i.activeColor !== void 0 && (n.activeColor = i.activeColor), i.activeFillColor !== void 0 && (n.activeFillColor = i.activeFillColor), i.backgroundColor !== void 0 && (n.backgroundColor = i.backgroundColor), i.isKeyWordColor !== void 0 && (n.isKeyWordColor = i.isKeyWordColor), i.preservedColorKeyWord !== void 0 && (n.preservedColorKeyWord = i.preservedColorKeyWord), i.videoWidth !== void 0 && (n.videoWidth = i.videoWidth), i.videoHeight !== void 0 && (n.videoHeight = i.videoHeight);
      i.mediaId && (n.mediaId = i.mediaId), e = new Ft(s, n);
      break;
    }
    case "Effect": {
      e = new tt(i.effect.key), e.effect = i.effect;
      break;
    }
    default:
      throw new Error(`Unsupported clip type: ${i.type}`);
  }
  return e.left = i.left, e.top = i.top, e.width = i.width, e.height = i.height, e.angle = i.angle, e.display.from = i.display.from, e.display.to = i.display.to, e.duration = i.duration, e.playbackRate = i.playbackRate, e.zIndex = i.zIndex, e.opacity = i.opacity, e.flip = i.flip, i.style && (e.style = { ...e.style, ...i.style }), i.animation && e.setAnimation(i.animation.keyFrames, i.animation.opts), i.id && (e.id = i.id), i.effects && (e.effects = i.effects), i.trim && (e.trim.from = i.trim.from < 1e6 ? i.trim.from * 1e6 : i.trim.from, e.trim.to = i.trim.to < 1e6 ? i.trim.to * 1e6 : i.trim.to), e;
}
var fh, jd;
function L3() {
  return jd || (jd = 1, fh = [{ name: "Bounce", paramsTypes: { shadow_colour: "vec4", shadow_height: "float", bounces: "float" }, defaultParams: { shadow_colour: [0, 0, 0, 0.6], shadow_height: 0.075, bounces: 3 }, glsl: `// Author: Adrian Purser
// License: MIT

uniform vec4 shadow_colour; // = vec4(0.,0.,0.,.6)
uniform float shadow_height; // = 0.075
uniform float bounces; // = 3.0

const float PI = 3.14159265358;

vec4 transition (vec2 uv) {
  float time = progress;
  float stime = sin(time * PI / 2.);
  float phase = time * PI * bounces;
  float y = (abs(cos(phase))) * (1.0 - stime);
  float d = uv.y - y;
  return mix(
    mix(
      getToColor(uv),
      shadow_colour,
      step(d, shadow_height) * (1. - mix(
        ((d / shadow_height) * shadow_colour.a) + (1.0 - shadow_colour.a),
        1.0,
        smoothstep(0.95, 1., progress) // fade-out the shadow at the end
      ))
    ),
    getFromColor(vec2(uv.x, uv.y + (1.0 - y))),
    step(d, 0.0)
  );
}
`, author: "Adrian Purser", license: "MIT", createdAt: "Fri, 10 Nov 2017 17:01:45 +0000", updatedAt: "Sat, 11 Nov 2017 08:50:40 +0100" }, { name: "BowTieHorizontal", paramsTypes: {}, defaultParams: {}, glsl: `// Author: huynx
// License: MIT

vec2 bottom_left = vec2(0.0, 1.0);
vec2 bottom_right = vec2(1.0, 1.0);
vec2 top_left = vec2(0.0, 0.0);
vec2 top_right = vec2(1.0, 0.0);
vec2 center = vec2(0.5, 0.5);

float check(vec2 p1, vec2 p2, vec2 p3)
{
  return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
}

bool PointInTriangle (vec2 pt, vec2 p1, vec2 p2, vec2 p3)
{
    bool b1, b2, b3;
    b1 = check(pt, p1, p2) < 0.0;
    b2 = check(pt, p2, p3) < 0.0;
    b3 = check(pt, p3, p1) < 0.0;
    return ((b1 == b2) && (b2 == b3));
}

bool in_left_triangle(vec2 p){
  vec2 vertex1, vertex2, vertex3;
  vertex1 = vec2(progress, 0.5);
  vertex2 = vec2(0.0, 0.5-progress);
  vertex3 = vec2(0.0, 0.5+progress);
  if (PointInTriangle(p, vertex1, vertex2, vertex3))
  {
    return true;
  }
  return false;
}

bool in_right_triangle(vec2 p){
  vec2 vertex1, vertex2, vertex3;
  vertex1 = vec2(1.0-progress, 0.5);
  vertex2 = vec2(1.0, 0.5-progress);
  vertex3 = vec2(1.0, 0.5+progress);
  if (PointInTriangle(p, vertex1, vertex2, vertex3))
  {
    return true;
  }
  return false;
}

float blur_edge(vec2 bot1, vec2 bot2, vec2 top, vec2 testPt)
{
  vec2 lineDir = bot1 - top;
  vec2 perpDir = vec2(lineDir.y, -lineDir.x);
  vec2 dirToPt1 = bot1 - testPt;
  float dist1 = abs(dot(normalize(perpDir), dirToPt1));
  
  lineDir = bot2 - top;
  perpDir = vec2(lineDir.y, -lineDir.x);
  dirToPt1 = bot2 - testPt;
  float min_dist = min(abs(dot(normalize(perpDir), dirToPt1)), dist1);
  
  if (min_dist < 0.005) {
    return min_dist / 0.005;
  }
  else  {
    return 1.0;
  };
}


vec4 transition (vec2 uv) {
  if (in_left_triangle(uv))
  {
    if (progress < 0.1)
    {
      return getFromColor(uv);
    }
    if (uv.x < 0.5)
    {
      vec2 vertex1 = vec2(progress, 0.5);
      vec2 vertex2 = vec2(0.0, 0.5-progress);
      vec2 vertex3 = vec2(0.0, 0.5+progress);
      return mix(
        getFromColor(uv),
        getToColor(uv),
        blur_edge(vertex2, vertex3, vertex1, uv)
      );
    }
    else
    {
      if (progress > 0.0)
      {
        return getToColor(uv);
      }
      else
      {
        return getFromColor(uv);
      }
    }    
  }
  else if (in_right_triangle(uv))
  {
    if (uv.x >= 0.5)
    {
      vec2 vertex1 = vec2(1.0-progress, 0.5);
      vec2 vertex2 = vec2(1.0, 0.5-progress);
      vec2 vertex3 = vec2(1.0, 0.5+progress);
      return mix(
        getFromColor(uv),
        getToColor(uv),
        blur_edge(vertex2, vertex3, vertex1, uv)
      );  
    }
    else
    {
      return getFromColor(uv);
    }
  }
  else {
    return getFromColor(uv);
  }
}`, author: "huynx", license: "MIT", createdAt: "Sat, 24 Mar 2018 12:54:26 +0100", updatedAt: "Sat, 24 Mar 2018 12:54:26 +0100" }, { name: "BowTieVertical", paramsTypes: {}, defaultParams: {}, glsl: `// Author: huynx\r
// License: MIT\r
\r
float check(vec2 p1, vec2 p2, vec2 p3)\r
{\r
  return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\r
}\r
\r
bool PointInTriangle (vec2 pt, vec2 p1, vec2 p2, vec2 p3)\r
{\r
    bool b1, b2, b3;\r
    b1 = check(pt, p1, p2) < 0.0;\r
    b2 = check(pt, p2, p3) < 0.0;\r
    b3 = check(pt, p3, p1) < 0.0;\r
    return ((b1 == b2) && (b2 == b3));\r
}\r
\r
bool in_top_triangle(vec2 p){\r
  vec2 vertex1, vertex2, vertex3;\r
  vertex1 = vec2(0.5, progress);\r
  vertex2 = vec2(0.5-progress, 0.0);\r
  vertex3 = vec2(0.5+progress, 0.0);\r
  if (PointInTriangle(p, vertex1, vertex2, vertex3))\r
  {\r
    return true;\r
  }\r
  return false;\r
}\r
\r
bool in_bottom_triangle(vec2 p){\r
  vec2 vertex1, vertex2, vertex3;\r
  vertex1 = vec2(0.5, 1.0 - progress);\r
  vertex2 = vec2(0.5-progress, 1.0);\r
  vertex3 = vec2(0.5+progress, 1.0);\r
  if (PointInTriangle(p, vertex1, vertex2, vertex3))\r
  {\r
    return true;\r
  }\r
  return false;\r
}\r
\r
float blur_edge(vec2 bot1, vec2 bot2, vec2 top, vec2 testPt)\r
{\r
  vec2 lineDir = bot1 - top;\r
  vec2 perpDir = vec2(lineDir.y, -lineDir.x);\r
  vec2 dirToPt1 = bot1 - testPt;\r
  float dist1 = abs(dot(normalize(perpDir), dirToPt1));\r
  \r
  lineDir = bot2 - top;\r
  perpDir = vec2(lineDir.y, -lineDir.x);\r
  dirToPt1 = bot2 - testPt;\r
  float min_dist = min(abs(dot(normalize(perpDir), dirToPt1)), dist1);\r
  \r
  if (min_dist < 0.005) {\r
    return min_dist / 0.005;\r
  }\r
  else  {\r
    return 1.0;\r
  };\r
}\r
\r
\r
vec4 transition (vec2 uv) {\r
  if (in_top_triangle(uv))\r
  {\r
    if (progress < 0.1)\r
    {\r
      return getFromColor(uv);\r
    }\r
    if (uv.y < 0.5)\r
    {\r
      vec2 vertex1 = vec2(0.5, progress);\r
      vec2 vertex2 = vec2(0.5-progress, 0.0);\r
      vec2 vertex3 = vec2(0.5+progress, 0.0);\r
      return mix(\r
        getFromColor(uv),\r
        getToColor(uv),\r
        blur_edge(vertex2, vertex3, vertex1, uv)\r
      );\r
    }\r
    else\r
    {\r
      if (progress > 0.0)\r
      {\r
        return getToColor(uv);\r
      }\r
      else\r
      {\r
        return getFromColor(uv);\r
      }\r
    }    \r
  }\r
  else if (in_bottom_triangle(uv))\r
  {\r
    if (uv.y >= 0.5)\r
    {\r
      vec2 vertex1 = vec2(0.5, 1.0-progress);\r
      vec2 vertex2 = vec2(0.5-progress, 1.0);\r
      vec2 vertex3 = vec2(0.5+progress, 1.0);\r
      return mix(\r
        getFromColor(uv),\r
        getToColor(uv),\r
        blur_edge(vertex2, vertex3, vertex1, uv)\r
      );  \r
    }\r
    else\r
    {\r
      return getFromColor(uv);\r
    }\r
  }\r
  else {\r
    return getFromColor(uv);\r
  }\r
}`, author: "huynx", license: "MIT", createdAt: "Tue, 27 Mar 2018 10:07:54 +0700", updatedAt: "Tue, 27 Mar 2018 10:07:54 +0700" }, { name: "ButterflyWaveScrawler", paramsTypes: { amplitude: "float", waves: "float", colorSeparation: "float" }, defaultParams: { amplitude: 1, waves: 30, colorSeparation: 0.3 }, glsl: `// Author: mandubian
// License: MIT
uniform float amplitude; // = 1.0
uniform float waves; // = 30.0
uniform float colorSeparation; // = 0.3
float PI = 3.14159265358979323846264;
float compute(vec2 p, float progress, vec2 center) {
vec2 o = p*sin(progress * amplitude)-center;
// horizontal vector
vec2 h = vec2(1., 0.);
// butterfly polar function (don't ask me why this one :))
float theta = acos(dot(o, h)) * waves;
return (exp(cos(theta)) - 2.*cos(4.*theta) + pow(sin((2.*theta - PI) / 24.), 5.)) / 10.;
}
vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy;
  float inv = 1. - progress;
  vec2 dir = p - vec2(.5);
  float dist = length(dir);
  float disp = compute(p, progress, vec2(0.5, 0.5)) ;
  vec4 texTo = getToColor(p + inv*disp);
  vec4 texFrom = vec4(
  getFromColor(p + progress*disp*(1.0 - colorSeparation)).r,
  getFromColor(p + progress*disp).g,
  getFromColor(p + progress*disp*(1.0 + colorSeparation)).b,
  1.0);
  return texTo*progress + texFrom*inv;
}
`, author: "mandubian", license: "MIT", createdAt: "Thu, 1 Jun 2017 11:47:17 +0200", updatedAt: "Thu, 1 Jun 2017 11:47:17 +0200" }, { name: "CircleCrop", paramsTypes: { bgcolor: "vec4" }, defaultParams: { bgcolor: [0, 0, 0, 1] }, glsl: `// License: MIT
// Author: fkuteken
// ported by gre from https://gist.github.com/fkuteken/f63e3009c1143950dee9063c3b83fb88

uniform vec4 bgcolor; // = vec4(0.0, 0.0, 0.0, 1.0)

vec2 ratio2 = vec2(1.0, 1.0 / ratio);
float s = pow(2.0 * abs(progress - 0.5), 3.0);

vec4 transition(vec2 p) {
  float dist = length((vec2(p) - 0.5) * ratio2);
  return mix(
    progress < 0.5 ? getFromColor(p) : getToColor(p), // branching is ok here as we statically depend on progress uniform (branching won't change over pixels)
    bgcolor,
    step(s, dist)
  );
}
`, license: "MIT", author: "fkuteken", createdAt: "Mon, 12 Jun 2017 12:52:34 +0800", updatedAt: "Mon, 12 Jun 2017 12:52:34 +0800" }, { name: "ColourDistance", paramsTypes: { power: "float" }, defaultParams: { power: 5 }, glsl: `// License: MIT
// Author: P-Seebauer
// ported by gre from https://gist.github.com/P-Seebauer/2a5fa2f77c883dd661f9

uniform float power; // = 5.0

vec4 transition(vec2 p) {
  vec4 fTex = getFromColor(p);
  vec4 tTex = getToColor(p);
  float m = step(distance(fTex, tTex), progress);
  return mix(
    mix(fTex, tTex, m),
    tTex,
    pow(progress, power)
  );
}
`, license: "MIT", author: "P-Seebauer", createdAt: "Mon, 12 Jun 2017 12:57:42 +0800", updatedAt: "Mon, 12 Jun 2017 12:57:42 +0800" }, { name: "CrazyParametricFun", paramsTypes: { a: "float", b: "float", amplitude: "float", smoothness: "float" }, defaultParams: { a: 4, b: 1, amplitude: 120, smoothness: 0.1 }, glsl: `// Author: mandubian
// License: MIT

uniform float a; // = 4
uniform float b; // = 1
uniform float amplitude; // = 120
uniform float smoothness; // = 0.1

vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy;
  vec2 dir = p - vec2(.5);
  float dist = length(dir);
  float x = (a - b) * cos(progress) + b * cos(progress * ((a / b) - 1.) );
  float y = (a - b) * sin(progress) - b * sin(progress * ((a / b) - 1.));
  vec2 offset = dir * vec2(sin(progress  * dist * amplitude * x), sin(progress * dist * amplitude * y)) / smoothness;
  return mix(getFromColor(p + offset), getToColor(p), smoothstep(0.2, 1.0, progress));
}
`, author: "mandubian", license: "MIT", createdAt: "Thu, 1 Jun 2017 13:03:12 +0200", updatedAt: "Thu, 1 Jun 2017 13:03:12 +0200" }, { name: "CrossZoom", paramsTypes: { strength: "float" }, defaultParams: { strength: 0.4 }, glsl: `// License: MIT
// Author: rectalogic
// ported by gre from https://gist.github.com/rectalogic/b86b90161503a0023231

// Converted from https://github.com/rectalogic/rendermix-basic-effects/blob/master/assets/com/rendermix/CrossZoom/CrossZoom.frag
// Which is based on https://github.com/evanw/glfx.js/blob/master/src/filters/blur/zoomblur.js
// With additional easing functions from https://github.com/rectalogic/rendermix-basic-effects/blob/master/assets/com/rendermix/Easing/Easing.glsllib

uniform float strength; // = 0.4

const float PI = 3.141592653589793;

float Linear_ease(in float begin, in float change, in float duration, in float time) {
    return change * time / duration + begin;
}

float Exponential_easeInOut(in float begin, in float change, in float duration, in float time) {
    if (time == 0.0)
        return begin;
    else if (time == duration)
        return begin + change;
    time = time / (duration / 2.0);
    if (time < 1.0)
        return change / 2.0 * pow(2.0, 10.0 * (time - 1.0)) + begin;
    return change / 2.0 * (-pow(2.0, -10.0 * (time - 1.0)) + 2.0) + begin;
}

float Sinusoidal_easeInOut(in float begin, in float change, in float duration, in float time) {
    return -change / 2.0 * (cos(PI * time / duration) - 1.0) + begin;
}

float rand (vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 crossFade(in vec2 uv, in float dissolve) {
    return mix(getFromColor(uv).rgb, getToColor(uv).rgb, dissolve);
}

vec4 transition(vec2 uv) {
    vec2 texCoord = uv.xy / vec2(1.0).xy;

    // Linear interpolate center across center half of the image
    vec2 center = vec2(Linear_ease(0.25, 0.5, 1.0, progress), 0.5);
    float dissolve = Exponential_easeInOut(0.0, 1.0, 1.0, progress);

    // Mirrored sinusoidal loop. 0->strength then strength->0
    float strength = Sinusoidal_easeInOut(0.0, strength, 0.5, progress);

    vec3 color = vec3(0.0);
    float total = 0.0;
    vec2 toCenter = center - texCoord;

    /* randomize the lookup values to hide the fixed number of samples */
    float offset = rand(uv);

    for (float t = 0.0; t <= 40.0; t++) {
        float percent = (t + offset) / 40.0;
        float weight = 4.0 * (percent - percent * percent);
        color += crossFade(texCoord + toCenter * percent * strength, dissolve) * weight;
        total += weight;
    }
    return vec4(color / total, 1.0);
}
`, license: "MIT", author: "rectalogic", createdAt: "Mon, 12 Jun 2017 12:33:07 +0800", updatedAt: "Mon, 12 Jun 2017 12:33:07 +0800" }, { name: "Directional", paramsTypes: { direction: "vec2" }, defaultParams: { direction: [0, 1] }, glsl: `// Author: Gatan Renaudeau
// License: MIT

uniform vec2 direction; // = vec2(0.0, 1.0)

vec4 transition (vec2 uv) {
  vec2 p = uv + progress * sign(direction);
  vec2 f = fract(p);
  return mix(
    getToColor(f),
    getFromColor(f),
    step(0.0, p.y) * step(p.y, 1.0) * step(0.0, p.x) * step(p.x, 1.0)
  );
}
`, author: "Gatan Renaudeau", license: "MIT", createdAt: "Thu, 19 Apr 2018 12:20:29 +0200", updatedAt: "Thu, 19 Apr 2018 12:20:29 +0200" }, { name: "DoomScreenTransition", paramsTypes: { bars: "int", amplitude: "float", noise: "float", frequency: "float", dripScale: "float" }, defaultParams: { bars: 30, amplitude: 2, noise: 0.1, frequency: 0.5, dripScale: 0.5 }, glsl: `// Author: Zeh Fernando
// License: MIT


// Transition parameters --------

// Number of total bars/columns
uniform int bars; // = 30

// Multiplier for speed ratio. 0 = no variation when going down, higher = some elements go much faster
uniform float amplitude; // = 2

// Further variations in speed. 0 = no noise, 1 = super noisy (ignore frequency)
uniform float noise; // = 0.1

// Speed variation horizontally. the bigger the value, the shorter the waves
uniform float frequency; // = 0.5

// How much the bars seem to "run" from the middle of the screen first (sticking to the sides). 0 = no drip, 1 = curved drip
uniform float dripScale; // = 0.5


// The code proper --------

float rand(int num) {
  return fract(mod(float(num) * 67123.313, 12.0) * sin(float(num) * 10.3) * cos(float(num)));
}

float wave(int num) {
  float fn = float(num) * frequency * 0.1 * float(bars);
  return cos(fn * 0.5) * cos(fn * 0.13) * sin((fn+10.0) * 0.3) / 2.0 + 0.5;
}

float drip(int num) {
  return sin(float(num) / float(bars - 1) * 3.141592) * dripScale;
}

float pos(int num) {
  return (noise == 0.0 ? wave(num) : mix(wave(num), rand(num), noise)) + (dripScale == 0.0 ? 0.0 : drip(num));
}

vec4 transition(vec2 uv) {
  int bar = int(uv.x * (float(bars)));
  float scale = 1.0 + pos(bar) * amplitude;
  float phase = progress * scale;
  float posY = uv.y / vec2(1.0).y;
  vec2 p;
  vec4 c;
  if (phase + posY < 1.0) {
    p = vec2(uv.x, uv.y + mix(0.0, vec2(1.0).y, phase)) / vec2(1.0).xy;
    c = getFromColor(p);
  } else {
    p = uv.xy / vec2(1.0).xy;
    c = getToColor(p);
  }

  // Finally, apply the color
  return c;
}
`, author: "Zeh Fernando", license: "MIT", createdAt: "Tue, 30 May 2017 09:39:09 -0700", updatedAt: "Tue, 30 May 2017 09:39:09 -0700" }, { name: "Dreamy", paramsTypes: {}, defaultParams: {}, glsl: `// Author: mikolalysenko
// License: MIT

vec2 offset(float progress, float x, float theta) {
  float phase = progress*progress + progress + theta;
  float shifty = 0.03*progress*cos(10.0*(progress+x));
  return vec2(0, shifty);
}
vec4 transition(vec2 p) {
  return mix(getFromColor(p + offset(progress, p.x, 0.0)), getToColor(p + offset(1.0-progress, p.x, 3.14)), progress);
}
`, author: "mikolalysenko", license: "MIT", createdAt: "Mon, 12 Jun 2017 12:27:38 +0800", updatedAt: "Mon, 12 Jun 2017 12:27:38 +0800" }, { name: "DreamyZoom", paramsTypes: { rotation: "float", scale: "float" }, defaultParams: { rotation: 6, scale: 1.2 }, glsl: `// Author: Zeh Fernando
// License: MIT

// Definitions --------
#define DEG2RAD 0.03926990816987241548078304229099 // 1/180*PI


// Transition parameters --------

// In degrees
uniform float rotation; // = 6

// Multiplier
uniform float scale; // = 1.2


// The code proper --------

vec4 transition(vec2 uv) {
  // Massage parameters
  float phase = progress < 0.5 ? progress * 2.0 : (progress - 0.5) * 2.0;
  float angleOffset = progress < 0.5 ? mix(0.0, rotation * DEG2RAD, phase) : mix(-rotation * DEG2RAD, 0.0, phase);
  float newScale = progress < 0.5 ? mix(1.0, scale, phase) : mix(scale, 1.0, phase);
  
  vec2 center = vec2(0, 0);

  // Calculate the source point
  vec2 assumedCenter = vec2(0.5, 0.5);
  vec2 p = (uv.xy - vec2(0.5, 0.5)) / newScale * vec2(ratio, 1.0);

  // This can probably be optimized (with distance())
  float angle = atan(p.y, p.x) + angleOffset;
  float dist = distance(center, p);
  p.x = cos(angle) * dist / ratio + 0.5;
  p.y = sin(angle) * dist + 0.5;
  vec4 c = progress < 0.5 ? getFromColor(p) : getToColor(p);

  // Finally, apply the color
  return c + (progress < 0.5 ? mix(0.0, 1.0, phase) : mix(1.0, 0.0, phase));
}
`, author: "Zeh Fernando", license: "MIT", createdAt: "Tue, 30 May 2017 10:44:06 -0700", updatedAt: "Tue, 30 May 2017 10:44:06 -0700" }, { name: "GlitchDisplace", paramsTypes: {}, defaultParams: {}, glsl: `// Author: Matt DesLauriers
// License: MIT

highp float random(vec2 co)
{
    highp float a = 12.9898;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}
float voronoi( in vec2 x ) {
    vec2 p = floor( x );
    vec2 f = fract( x );
    float res = 8.0;
    for( float j=-1.; j<=1.; j++ )
    for( float i=-1.; i<=1.; i++ ) {
        vec2  b = vec2( i, j );
        vec2  r = b - f + random( p + b );
        float d = dot( r, r );
        res = min( res, d );
    }
    return sqrt( res );
}

vec2 displace(vec4 tex, vec2 texCoord, float dotDepth, float textureDepth, float strength) {
    float b = voronoi(.003 * texCoord + 2.0);
    float g = voronoi(0.2 * texCoord);
    float r = voronoi(texCoord - 1.0);
    vec4 dt = tex * 1.0;
    vec4 dis = dt * dotDepth + 1.0 - tex * textureDepth;

    dis.x = dis.x - 1.0 + textureDepth*dotDepth;
    dis.y = dis.y - 1.0 + textureDepth*dotDepth;
    dis.x *= strength;
    dis.y *= strength;
    vec2 res_uv = texCoord ;
    res_uv.x = res_uv.x + dis.x - 0.0;
    res_uv.y = res_uv.y + dis.y;
    return res_uv;
}

float ease1(float t) {
  return t == 0.0 || t == 1.0
    ? t
    : t < 0.5
      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)
      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;
}
float ease2(float t) {
  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);
}



vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy;
  vec4 color1 = getFromColor(p);
  vec4 color2 = getToColor(p);
  vec2 disp = displace(color1, p, 0.33, 0.7, 1.0-ease1(progress));
  vec2 disp2 = displace(color2, p, 0.33, 0.5, ease2(progress));
  vec4 dColor1 = getToColor(disp);
  vec4 dColor2 = getFromColor(disp2);
  float val = ease1(progress);
  vec3 gray = vec3(dot(min(dColor2, dColor1).rgb, vec3(0.299, 0.587, 0.114)));
  dColor2 = vec4(gray, 1.0);
  dColor2 *= 2.0;
  color1 = mix(color1, dColor2, smoothstep(0.0, 0.5, progress));
  color2 = mix(color2, dColor1, smoothstep(1.0, 0.5, progress));
  return mix(color1, color2, val);
  //gl_FragColor = mix(gl_FragColor, dColor, smoothstep(0.0, 0.5, progress));
  
   //gl_FragColor = mix(texture2D(from, p), texture2D(to, p), progress);
}
`, author: "Matt DesLauriers", license: "MIT", createdAt: "Tue, 30 May 2017 14:53:04 -0400", updatedAt: "Tue, 30 May 2017 14:53:04 -0400" }, { name: "GlitchMemories", paramsTypes: {}, defaultParams: {}, glsl: `// author: Gunnar Roth
// based on work from natewave
// license: MIT
vec4 transition(vec2 p) {
  vec2 block = floor(p.xy / vec2(16));
  vec2 uv_noise = block / vec2(64);
  uv_noise += floor(vec2(progress) * vec2(1200.0, 3500.0)) / vec2(64);
  vec2 dist = progress > 0.0 ? (fract(uv_noise) - 0.5) * 0.3 *(1.0 -progress) : vec2(0.0);
  vec2 red = p + dist * 0.2;
  vec2 green = p + dist * .3;
  vec2 blue = p + dist * .5;

  return vec4(mix(getFromColor(red), getToColor(red), progress).r,mix(getFromColor(green), getToColor(green), progress).g,mix(getFromColor(blue), getToColor(blue), progress).b,1.0);
}

`, author: "Gunnar Roth", license: "MIT", createdAt: "Wed, 21 Feb 2018 00:52:15 +0100", updatedAt: "Wed, 21 Feb 2018 19:32:02 +0100" }, { name: "GridFlip", paramsTypes: { size: "ivec2", pause: "float", dividerWidth: "float", bgcolor: "vec4", randomness: "float" }, defaultParams: { size: [4, 4], pause: 0.1, dividerWidth: 0.05, bgcolor: [0, 0, 0, 1], randomness: 0.1 }, glsl: `// License: MIT
// Author: TimDonselaar
// ported by gre from https://gist.github.com/TimDonselaar/9bcd1c4b5934ba60087bdb55c2ea92e5

uniform ivec2 size; // = ivec2(4)
uniform float pause; // = 0.1
uniform float dividerWidth; // = 0.05
uniform vec4 bgcolor; // = vec4(0.0, 0.0, 0.0, 1.0)
uniform float randomness; // = 0.1
 
float rand (vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float getDelta(vec2 p) {
  vec2 rectanglePos = floor(vec2(size) * p);
  vec2 rectangleSize = vec2(1.0 / vec2(size).x, 1.0 / vec2(size).y);
  float top = rectangleSize.y * (rectanglePos.y + 1.0);
  float bottom = rectangleSize.y * rectanglePos.y;
  float left = rectangleSize.x * rectanglePos.x;
  float right = rectangleSize.x * (rectanglePos.x + 1.0);
  float minX = min(abs(p.x - left), abs(p.x - right));
  float minY = min(abs(p.y - top), abs(p.y - bottom));
  return min(minX, minY);
}

float getDividerSize() {
  vec2 rectangleSize = vec2(1.0 / vec2(size).x, 1.0 / vec2(size).y);
  return min(rectangleSize.x, rectangleSize.y) * dividerWidth;
}

vec4 transition(vec2 p) {
  if(progress < pause) {
    float currentProg = progress / pause;
    float a = 1.0;
    if(getDelta(p) < getDividerSize()) {
      a = 1.0 - currentProg;
    }
    return mix(bgcolor, getFromColor(p), a);
  }
  else if(progress < 1.0 - pause){
    if(getDelta(p) < getDividerSize()) {
      return bgcolor;
    } else {
      float currentProg = (progress - pause) / (1.0 - pause * 2.0);
      vec2 q = p;
      vec2 rectanglePos = floor(vec2(size) * q);
      
      float r = rand(rectanglePos) - randomness;
      float cp = smoothstep(0.0, 1.0 - r, currentProg);
    
      float rectangleSize = 1.0 / vec2(size).x;
      float delta = rectanglePos.x * rectangleSize;
      float offset = rectangleSize / 2.0 + delta;
      
      p.x = (p.x - offset)/abs(cp - 0.5)*0.5 + offset;
      vec4 a = getFromColor(p);
      vec4 b = getToColor(p);
      
      float s = step(abs(vec2(size).x * (q.x - delta) - 0.5), abs(cp - 0.5));
      return mix(bgcolor, mix(b, a, step(cp, 0.5)), s);
    }
  }
  else {
    float currentProg = (progress - 1.0 + pause) / pause;
    float a = 1.0;
    if(getDelta(p) < getDividerSize()) {
      a = currentProg;
    }
    return mix(bgcolor, getToColor(p), a);
  }
}
`, license: "MIT", author: "TimDonselaar", createdAt: "Mon, 12 Jun 2017 11:32:51 +0800", updatedAt: "Mon, 12 Jun 2017 11:32:51 +0800" }, { name: "InvertedPageCurl", paramsTypes: {}, defaultParams: {}, glsl: `// author: Hewlett-Packard
// license: BSD 3 Clause
// Adapted by Sergey Kosarevsky from:
// http://rectalogic.github.io/webvfx/examples_2transition-shader-pagecurl_8html-example.html

/*
Copyright (c) 2010 Hewlett-Packard Development Company, L.P. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

   * Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following disclaimer
     in the documentation and/or other materials provided with the
     distribution.
   * Neither the name of Hewlett-Packard nor the names of its
     contributors may be used to endorse or promote products derived from
     this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
in vec2 texCoord;
*/

const float MIN_AMOUNT = -0.16;
const float MAX_AMOUNT = 1.5;
float amount = progress * (MAX_AMOUNT - MIN_AMOUNT) + MIN_AMOUNT;

const float PI = 3.141592653589793;

const float scale = 512.0;
const float sharpness = 3.0;

float cylinderCenter = amount;
// 360 degrees * amount
float cylinderAngle = 2.0 * PI * amount;

const float cylinderRadius = 1.0 / PI / 2.0;

vec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation)
{
        float hitPoint = hitAngle / (2.0 * PI);
        point.y = hitPoint;
        return rrotation * point;
}

vec4 antiAlias(vec4 color1, vec4 color2, float distanc)
{
        distanc *= scale;
        if (distanc < 0.0) return color2;
        if (distanc > 2.0) return color1;
        float dd = pow(1.0 - distanc / 2.0, sharpness);
        return ((color2 - color1) * dd) + color1;
}

float distanceToEdge(vec3 point)
{
        float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);
        float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);
        if (point.x < 0.0) dx = -point.x;
        if (point.x > 1.0) dx = point.x - 1.0;
        if (point.y < 0.0) dy = -point.y;
        if (point.y > 1.0) dy = point.y - 1.0;
        if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);
        return min(dx, dy);
}

vec4 seeThrough(float yc, vec2 p, mat3 rotation, mat3 rrotation)
{
        float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);
        vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);
        if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0))
        {
            return getToColor(p);
        }

        if (yc > 0.0) return getFromColor(p);

        vec4 color = getFromColor(point.xy);
        vec4 tcolor = vec4(0.0);

        return antiAlias(color, tcolor, distanceToEdge(point));
}

vec4 seeThroughWithShadow(float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation)
{
        float shadow = distanceToEdge(point) * 30.0;
        shadow = (1.0 - shadow) / 3.0;

        if (shadow < 0.0) shadow = 0.0; else shadow *= amount;

        vec4 shadowColor = seeThrough(yc, p, rotation, rrotation);
        shadowColor.r -= shadow;
        shadowColor.g -= shadow;
        shadowColor.b -= shadow;

        return shadowColor;
}

vec4 backside(float yc, vec3 point)
{
        vec4 color = getFromColor(point.xy);
        float gray = (color.r + color.b + color.g) / 15.0;
        gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));
        color.rgb = vec3(gray);
        return color;
}

vec4 behindSurface(vec2 p, float yc, vec3 point, mat3 rrotation)
{
        float shado = (1.0 - ((-cylinderRadius - yc) / amount * 7.0)) / 6.0;
        shado *= 1.0 - abs(point.x - 0.5);

        yc = (-cylinderRadius - cylinderRadius - yc);

        float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;
        point = hitPoint(hitAngle, yc, point, rrotation);

        if (yc < 0.0 && point.x >= 0.0 && point.y >= 0.0 && point.x <= 1.0 && point.y <= 1.0 && (hitAngle < PI || amount > 0.5))
        {
                shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / (71.0 / 100.0));
                shado *= pow(-yc / cylinderRadius, 3.0);
                shado *= 0.5;
        }
        else
        {
                shado = 0.0;
        }
        return vec4(getToColor(p).rgb - shado, 1.0);
}

vec4 transition(vec2 p) {

  const float angle = 100.0 * PI / 180.0;
        float c = cos(-angle);
        float s = sin(-angle);

        mat3 rotation = mat3( c, s, 0,
                                                                -s, c, 0,
                                                                -0.801, 0.8900, 1
                                                                );
        c = cos(angle);
        s = sin(angle);

        mat3 rrotation = mat3(	c, s, 0,
                                                                        -s, c, 0,
                                                                        0.98500, 0.985, 1
                                                                );

        vec3 point = rotation * vec3(p, 1.0);

        float yc = point.y - cylinderCenter;

        if (yc < -cylinderRadius)
        {
                // Behind surface
                return behindSurface(p,yc, point, rrotation);
        }

        if (yc > cylinderRadius)
        {
                // Flat surface
                return getFromColor(p);
        }

        float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;

        float hitAngleMod = mod(hitAngle, 2.0 * PI);
        if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI/2.0 && amount < 0.0))
        {
                return seeThrough(yc, p, rotation, rrotation);
        }

        point = hitPoint(hitAngle, yc, point, rrotation);

        if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0)
        {
                return seeThroughWithShadow(yc, p, point, rotation, rrotation);
        }

        vec4 color = backside(yc, point);

        vec4 otherColor;
        if (yc < 0.0)
        {
                float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);
                shado *= pow(-yc / cylinderRadius, 3.0);
                shado *= 0.5;
                otherColor = vec4(0.0, 0.0, 0.0, shado);
        }
        else
        {
                otherColor = getFromColor(p);
        }

        color = antiAlias(color, otherColor, cylinderRadius - abs(yc));

        vec4 cl = seeThroughWithShadow(yc, p, point, rotation, rrotation);
        float dist = distanceToEdge(point);

        return antiAlias(color, cl, dist);
}
`, author: "Hewlett-Packard", license: "BSD 3 Clause", createdAt: "Wed, 21 Feb 2018 01:13:49 +0100", updatedAt: "Wed, 21 Feb 2018 16:00:02 +0100" }, { name: "LinearBlur", paramsTypes: { intensity: "float" }, defaultParams: { intensity: 0.1 }, glsl: `// author: gre
// license: MIT
uniform float intensity; // = 0.1
const int passes = 6;

vec4 transition(vec2 uv) {
    vec4 c1 = vec4(0.0);
    vec4 c2 = vec4(0.0);

    float disp = intensity*(0.5-distance(0.5, progress));
    for (int xi=0; xi<passes; xi++)
    {
        float x = float(xi) / float(passes) - 0.5;
        for (int yi=0; yi<passes; yi++)
        {
            float y = float(yi) / float(passes) - 0.5;
            vec2 v = vec2(x,y);
            float d = disp;
            c1 += getFromColor( uv + d*v);
            c2 += getToColor( uv + d*v);
        }
    }
    c1 /= float(passes*passes);
    c2 /= float(passes*passes);
    return mix(c1, c2, progress);
}
`, author: "gre", license: "MIT", createdAt: "Fri, 23 Feb 2018 15:18:22 +0100", updatedAt: "Fri, 23 Feb 2018 15:18:22 +0100" }, { name: "Mosaic", paramsTypes: { endx: "int", endy: "int" }, defaultParams: { endx: 2, endy: -1 }, glsl: `// License: MIT
// Author: Xaychru
// ported by gre from https://gist.github.com/Xaychru/130bb7b7affedbda9df5

#define PI 3.14159265358979323
#define POW2(X) X*X
#define POW3(X) X*X*X
uniform int endx; // = 2
uniform int endy; // = -1

float Rand(vec2 v) {
  return fract(sin(dot(v.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
vec2 Rotate(vec2 v, float a) {
  mat2 rm = mat2(cos(a), -sin(a),
                 sin(a), cos(a));
  return rm*v;
}
float CosInterpolation(float x) {
  return -cos(x*PI)/2.+.5;
}
vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy - .5;
  vec2 rp = p;
  float rpr = (progress*2.-1.);
  float z = -(rpr*rpr*2.) + 3.;
  float az = abs(z);
  rp *= az;
  rp += mix(vec2(.5, .5), vec2(float(endx) + .5, float(endy) + .5), POW2(CosInterpolation(progress)));
  vec2 mrp = mod(rp, 1.);
  vec2 crp = rp;
  bool onEnd = int(floor(crp.x))==endx&&int(floor(crp.y))==endy;
  if(!onEnd) {
    float ang = float(int(Rand(floor(crp))*4.))*.5*PI;
    mrp = vec2(.5) + Rotate(mrp-vec2(.5), ang);
  }
  if(onEnd || Rand(floor(crp))>.5) {
    return getToColor(mrp);
  } else {
    return getFromColor(mrp);
  }
}
`, license: "MIT", author: "Xaychru", createdAt: "Mon, 12 Jun 2017 10:26:51 +0800", updatedAt: "Mon, 12 Jun 2017 10:26:51 +0800" }, { name: "PolkaDotsCurtain", paramsTypes: { dots: "float", center: "vec2" }, defaultParams: { dots: 20, center: [0, 0] }, glsl: `// author: bobylito
// license: MIT
const float SQRT_2 = 1.414213562373;
uniform float dots;// = 20.0;
uniform vec2 center;// = vec2(0, 0);

vec4 transition(vec2 uv) {
  bool nextImage = distance(fract(uv * dots), vec2(0.5, 0.5)) < ( progress / distance(uv, center));
  return nextImage ? getToColor(uv) : getFromColor(uv);
}
`, author: "bobylito", license: "MIT", createdAt: "Tue, 20 Feb 2018 23:41:45 +0100", updatedAt: "Tue, 20 Feb 2018 23:41:45 +0100" }, { name: "Radial", paramsTypes: { smoothness: "float" }, defaultParams: { smoothness: 1 }, glsl: `// License: MIT
// Author: Xaychru
// ported by gre from https://gist.github.com/Xaychru/ce1d48f0ce00bb379750

uniform float smoothness; // = 1.0

const float PI = 3.141592653589;

vec4 transition(vec2 p) {
  vec2 rp = p*2.-1.;
  return mix(
    getToColor(p),
    getFromColor(p),
    smoothstep(0., smoothness, atan(rp.y,rp.x) - (progress-.5) * PI * 2.5)
  );
}
`, license: "MIT", author: "Xaychru", createdAt: "Mon, 12 Jun 2017 10:36:24 +0800", updatedAt: "Mon, 12 Jun 2017 10:36:24 +0800" }, { name: "SimpleZoom", paramsTypes: { zoom_quickness: "float" }, defaultParams: { zoom_quickness: 0.8 }, glsl: `// Author: 0gust1
// License: MIT

uniform float zoom_quickness; // = 0.8
float nQuick = clamp(zoom_quickness,0.2,1.0);

vec2 zoom(vec2 uv, float amount) {
  return 0.5 + ((uv - 0.5) * (1.0-amount));	
}

vec4 transition (vec2 uv) {
  return mix(
    getFromColor(zoom(uv, smoothstep(0.0, nQuick, progress))),
    getToColor(uv),
   smoothstep(nQuick-0.2, 1.0, progress)
  );
}`, author: "0gust1", license: "MIT", createdAt: "Tue, 6 Mar 2018 00:43:47 +0100", updatedAt: "Tue, 6 Mar 2018 00:43:47 +0100" }, { name: "StereoViewer", paramsTypes: { zoom: "float", corner_radius: "float" }, defaultParams: { zoom: 0.88, corner_radius: 0.22 }, glsl: `// Tunable parameters
// How much to zoom (out) for the effect ~ 0.5 - 1.0
uniform float zoom; // = 0.88
// Corner radius as a fraction of the image height
uniform float corner_radius;  // = 0.22

// author: Ted Schundler
// license: BSD 2 Clause
// Free for use and modification by anyone with credit

// Copyright (c) 2016, Theodore K Schundler
// All rights reserved.

// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

///////////////////////////////////////////////////////////////////////////////
// Stereo Viewer Toy Transition                                              //
//                                                                           //
// Inspired by ViewMaster / Image3D image viewer devices.                    //
// This effect is similar to what you see when you press the device's lever. //
// There is a quick zoom in / out to make the transition 'valid' for GLSL.io //
///////////////////////////////////////////////////////////////////////////////

const vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
const vec2 c00 = vec2(0.0, 0.0); // the four corner points
const vec2 c01 = vec2(0.0, 1.0);
const vec2 c11 = vec2(1.0, 1.0);
const vec2 c10 = vec2(1.0, 0.0);

// Check if a point is within a given corner
bool in_corner(vec2 p, vec2 corner, vec2 radius) {
  // determine the direction we want to be filled
  vec2 axis = (c11 - corner) - corner;

  // warp the point so we are always testing the bottom left point with the
  // circle centered on the origin
  p = p - (corner + axis * radius);
  p *= axis / radius;
  return (p.x > 0.0 && p.y > -1.0) || (p.y > 0.0 && p.x > -1.0) || dot(p, p) < 1.0;
}

// Check all four corners
// return a float for v2 for anti-aliasing?
bool test_rounded_mask(vec2 p, vec2 corner_size) {
  return
      in_corner(p, c00, corner_size) &&
      in_corner(p, c01, corner_size) &&
      in_corner(p, c10, corner_size) &&
      in_corner(p, c11, corner_size);
}

// Screen blend mode - https://en.wikipedia.org/wiki/Blend_modes
// This more closely approximates what you see than linear blending
vec4 screen(vec4 a, vec4 b) {
  return 1.0 - (1.0 - a) * (1.0 -b);
}

// Given RGBA, find a value that when screened with itself
// will yield the original value.
vec4 unscreen(vec4 c) {
  return 1.0 - sqrt(1.0 - c);
}

// Grab a pixel, only if it isn't masked out by the rounded corners
vec4 sample_with_corners_from(vec2 p, vec2 corner_size) {
  p = (p - 0.5) / zoom + 0.5;
  if (!test_rounded_mask(p, corner_size)) {
    return black;
  }
  return unscreen(getFromColor(p));
}

vec4 sample_with_corners_to(vec2 p, vec2 corner_size) {
  p = (p - 0.5) / zoom + 0.5;
  if (!test_rounded_mask(p, corner_size)) {
    return black;
  }
  return unscreen(getToColor(p));
}

// special sampling used when zooming - extra zoom parameter and don't unscreen
vec4 simple_sample_with_corners_from(vec2 p, vec2 corner_size, float zoom_amt) {
  p = (p - 0.5) / (1.0 - zoom_amt + zoom * zoom_amt) + 0.5;
  if (!test_rounded_mask(p, corner_size)) {
    return black;
  }
  return getFromColor(p);
}

vec4 simple_sample_with_corners_to(vec2 p, vec2 corner_size, float zoom_amt) {
  p = (p - 0.5) / (1.0 - zoom_amt + zoom * zoom_amt) + 0.5;
  if (!test_rounded_mask(p, corner_size)) {
    return black;
  }
  return getToColor(p);
}

// Basic 2D affine transform matrix helpers
// These really shouldn't be used in a fragment shader - I should work out the
// the math for a translate & rotate function as a pair of dot products instead

mat3 rotate2d(float angle, float ratio) {
  float s = sin(angle);
  float c = cos(angle);
  return mat3(
    c, s ,0.0,
    -s, c, 0.0,
    0.0, 0.0, 1.0);
}

mat3 translate2d(float x, float y) {
  return mat3(
    1.0, 0.0, 0,
    0.0, 1.0, 0,
    -x, -y, 1.0);
}

mat3 scale2d(float x, float y) {
  return mat3(
    x, 0.0, 0,
    0.0, y, 0,
    0, 0, 1.0);
}

// Split an image and rotate one up and one down along off screen pivot points
vec4 get_cross_rotated(vec3 p3, float angle, vec2 corner_size, float ratio) {
  angle = angle * angle; // easing
  angle /= 2.4; // works out to be a good number of radians

  mat3 center_and_scale = translate2d(-0.5, -0.5) * scale2d(1.0, ratio);
  mat3 unscale_and_uncenter = scale2d(1.0, 1.0/ratio) * translate2d(0.5,0.5);
  mat3 slide_left = translate2d(-2.0,0.0);
  mat3 slide_right = translate2d(2.0,0.0);
  mat3 rotate = rotate2d(angle, ratio);

  mat3 op_a = center_and_scale * slide_right * rotate * slide_left * unscale_and_uncenter;
  mat3 op_b = center_and_scale * slide_left * rotate * slide_right * unscale_and_uncenter;

  vec4 a = sample_with_corners_from((op_a * p3).xy, corner_size);
  vec4 b = sample_with_corners_from((op_b * p3).xy, corner_size);

  return screen(a, b);
}

// Image stays put, but this time move two masks
vec4 get_cross_masked(vec3 p3, float angle, vec2 corner_size, float ratio) {
  angle = 1.0 - angle;
  angle = angle * angle; // easing
  angle /= 2.4;

  vec4 img;

  mat3 center_and_scale = translate2d(-0.5, -0.5) * scale2d(1.0, ratio);
  mat3 unscale_and_uncenter = scale2d(1.0 / zoom, 1.0 / (zoom * ratio)) * translate2d(0.5,0.5);
  mat3 slide_left = translate2d(-2.0,0.0);
  mat3 slide_right = translate2d(2.0,0.0);
  mat3 rotate = rotate2d(angle, ratio);

  mat3 op_a = center_and_scale * slide_right * rotate * slide_left * unscale_and_uncenter;
  mat3 op_b = center_and_scale * slide_left * rotate * slide_right * unscale_and_uncenter;

  bool mask_a = test_rounded_mask((op_a * p3).xy, corner_size);
  bool mask_b = test_rounded_mask((op_b * p3).xy, corner_size);

  if (mask_a || mask_b) {
    img = sample_with_corners_to(p3.xy, corner_size);
    return screen(mask_a ? img : black, mask_b ? img : black);
  } else {
    return black;
  }
}

vec4 transition(vec2 uv) {
  float a;
  vec2 p=uv.xy/vec2(1.0).xy;
  vec3 p3 = vec3(p.xy, 1.0); // for 2D matrix transforms

  // corner is warped to represent to size after mapping to 1.0, 1.0
  vec2 corner_size = vec2(corner_radius / ratio, corner_radius);

  if (progress <= 0.0) {
    // 0.0: start with the base frame always
    return getFromColor(p);
  } else if (progress < 0.1) {
    // 0.0-0.1: zoom out and add rounded corners
    a = progress / 0.1;
    return  simple_sample_with_corners_from(p, corner_size * a, a);
  } else if (progress < 0.48) {
    // 0.1-0.48: Split original image apart
    a = (progress - 0.1)/0.38;
    return get_cross_rotated(p3, a, corner_size, ratio);
  } else if (progress < 0.9) {
    // 0.48-0.52: black
    // 0.52 - 0.9: unmask new image
    return get_cross_masked(p3, (progress - 0.52)/0.38, corner_size, ratio);
  } else if (progress < 1.0) {
    // zoom out and add rounded corners
    a = (1.0 - progress) / 0.1;
    return simple_sample_with_corners_to(p, corner_size * a, a);
  } else {
    // 1.0 end with base frame
    return getToColor(p);
  }
}
`, author: "Ted Schundler", license: "BSD 2 Clause", createdAt: "Tue, 20 Feb 2018 23:20:29 +0100", updatedAt: "Wed, 21 Feb 2018 15:42:00 +0100" }, { name: "Swirl", paramsTypes: {}, defaultParams: {}, glsl: `// License: MIT
// Author: Sergey Kosarevsky
// ( http://www.linderdaum.com )
// ported by gre from https://gist.github.com/corporateshark/cacfedb8cca0f5ce3f7c

vec4 transition(vec2 UV)
{
	float Radius = 1.0;

	float T = progress;

	UV -= vec2( 0.5, 0.5 );

	float Dist = length(UV);

	if ( Dist < Radius )
	{
		float Percent = (Radius - Dist) / Radius;
		float A = ( T <= 0.5 ) ? mix( 0.0, 1.0, T/0.5 ) : mix( 1.0, 0.0, (T-0.5)/0.5 );
		float Theta = Percent * Percent * A * 8.0 * 3.14159;
		float S = sin( Theta );
		float C = cos( Theta );
		UV = vec2( dot(UV, vec2(C, -S)), dot(UV, vec2(S, C)) );
	}
	UV += vec2( 0.5, 0.5 );

	vec4 C0 = getFromColor(UV);
	vec4 C1 = getToColor(UV);

	return mix( C0, C1, T );
}
`, license: "MIT", author: "Sergey Kosarevsky", createdAt: "Mon, 12 Jun 2017 12:38:27 +0800", updatedAt: "Mon, 12 Jun 2017 12:38:27 +0800" }, { name: "WaterDrop", paramsTypes: { amplitude: "float", speed: "float" }, defaultParams: { amplitude: 30, speed: 30 }, glsl: `// author: Pawe Pciennik
// license: MIT
uniform float amplitude; // = 30
uniform float speed; // = 30

vec4 transition(vec2 p) {
  vec2 dir = p - vec2(.5);
  float dist = length(dir);

  if (dist > progress) {
    return mix(getFromColor( p), getToColor( p), progress);
  } else {
    vec2 offset = dir * sin(dist * amplitude - progress * speed);
    return mix(getFromColor( p + offset), getToColor( p), progress);
  }
}
`, author: "Pawe Pciennik", license: "MIT", createdAt: "Wed, 21 Feb 2018 19:37:15 +0100", updatedAt: "Wed, 21 Feb 2018 19:37:15 +0100" }, { name: "ZoomInCircles", paramsTypes: {}, defaultParams: {}, glsl: `// License: MIT
// Author: dycm8009
// ported by gre from https://gist.github.com/dycm8009/948e99b1800e81ad909a

vec2 zoom(vec2 uv, float amount) {
  return 0.5 + ((uv - 0.5) * amount);	
}

vec2 ratio2 = vec2(1.0, 1.0 / ratio);

vec4 transition(vec2 uv) {
  // TODO: some timing are hardcoded but should be one or many parameters
  // TODO: should also be able to configure how much circles
  // TODO: if() branching should be avoided when possible, prefer use of step() & other functions
  vec2 r = 2.0 * ((vec2(uv.xy) - 0.5) * ratio2);
  float pro = progress / 0.8;
  float z = pro * 0.2;
  float t = 0.0;
  if (pro > 1.0) {
    z = 0.2 + (pro - 1.0) * 5.;
    t = clamp((progress - 0.8) / 0.07, 0.0, 1.0);
  }
  if (length(r) < 0.5+z) {
    // uv = zoom(uv, 0.9 - 0.1 * pro);
  }
  else if (length(r) < 0.8+z*1.5) {
    uv = zoom(uv, 1.0 - 0.15 * pro);
    t = t * 0.5;
  }
  else if (length(r) < 1.2+z*2.5) {
    uv = zoom(uv, 1.0 - 0.2 * pro);
    t = t * 0.2;
  }
  else {
    uv = zoom(uv, 1.0 - 0.25 * pro);
  }
  return mix(getFromColor(uv), getToColor(uv), t);
}
`, license: "MIT", author: "dycm8009", createdAt: "Mon, 12 Jun 2017 11:24:34 +0800", updatedAt: "Mon, 12 Jun 2017 11:24:34 +0800" }, { name: "angular", paramsTypes: { startingAngle: "float" }, defaultParams: { startingAngle: 90 }, glsl: `// Author: Fernando Kuteken
// License: MIT

#define PI 3.141592653589

uniform float startingAngle; // = 90;

vec4 transition (vec2 uv) {
  
  float offset = startingAngle * PI / 180.0;
  float angle = atan(uv.y - 0.5, uv.x - 0.5) + offset;
  float normalizedAngle = (angle + PI) / (2.0 * PI);
  
  normalizedAngle = normalizedAngle - floor(normalizedAngle);

  return mix(
    getFromColor(uv),
    getToColor(uv),
    step(normalizedAngle, progress)
    );
}
`, author: "Fernando Kuteken", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "burn", paramsTypes: { color: "vec3" }, defaultParams: { color: [0.9, 0.4, 0.2] }, glsl: `// author: gre
// License: MIT
uniform vec3 color /* = vec3(0.9, 0.4, 0.2) */;
vec4 transition (vec2 uv) {
  return mix(
    getFromColor(uv) + vec4(progress*color, 1.0),
    getToColor(uv) + vec4((1.0-progress)*color, 1.0),
    progress
  );
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "cannabisleaf", paramsTypes: {}, defaultParams: {}, glsl: `// Author: @Flexi23
// License: MIT

// inspired by http://www.wolframalpha.com/input/?i=cannabis+curve

vec4 transition (vec2 uv) {
  if(progress == 0.0){
    return getFromColor(uv);
  }
  vec2 leaf_uv = (uv - vec2(0.5))/10./pow(progress,3.5);
	leaf_uv.y += 0.35;
	float r = 0.18;
	float o = atan(leaf_uv.y, leaf_uv.x);
  return mix(getFromColor(uv), getToColor(uv), 1.-step(1. - length(leaf_uv)+r*(1.+sin(o))*(1.+0.9 * cos(8.*o))*(1.+0.1*cos(24.*o))*(0.9+0.05*cos(200.*o)), 1.));
}
`, author: "@Flexi23", license: "MIT", createdAt: "Thu, 1 Jun 2017 15:58:58 +0200", updatedAt: "Thu, 1 Jun 2017 15:58:58 +0200" }, { name: "circle", paramsTypes: { center: "vec2", backColor: "vec3" }, defaultParams: { center: [0.5, 0.5], backColor: [0.1, 0.1, 0.1] }, glsl: `// Author: Fernando Kuteken
// License: MIT

uniform vec2 center; // = vec2(0.5, 0.5);
uniform vec3 backColor; // = vec3(0.1, 0.1, 0.1);

vec4 transition (vec2 uv) {
  
  float distance = length(uv - center);
  float radius = sqrt(8.0) * abs(progress - 0.5);
  
  if (distance > radius) {
    return vec4(backColor, 1.0);
  }
  else {
    if (progress < 0.5) return getFromColor(uv);
    else return getToColor(uv);
  }
}
`, author: "Fernando Kuteken", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "circleopen", paramsTypes: { smoothness: "float", opening: "bool" }, defaultParams: { smoothness: 0.3, opening: !0 }, glsl: `// author: gre
// License: MIT
uniform float smoothness; // = 0.3
uniform bool opening; // = true

const vec2 center = vec2(0.5, 0.5);
const float SQRT_2 = 1.414213562373;

vec4 transition (vec2 uv) {
  float x = opening ? progress : 1.-progress;
  float m = smoothstep(-smoothness, 0.0, SQRT_2*distance(center, uv) - x*(1.+smoothness));
  return mix(getFromColor(uv), getToColor(uv), opening ? 1.-m : m);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "colorphase", paramsTypes: { fromStep: "vec4", toStep: "vec4" }, defaultParams: { fromStep: [0, 0.2, 0.4, 0], toStep: [0.6, 0.8, 1, 1] }, glsl: `// Author: gre
// License: MIT

// Usage: fromStep and toStep must be in [0.0, 1.0] range 
// and all(fromStep) must be < all(toStep)

uniform vec4 fromStep; // = vec4(0.0, 0.2, 0.4, 0.0)
uniform vec4 toStep; // = vec4(0.6, 0.8, 1.0, 1.0)

vec4 transition (vec2 uv) {
  vec4 a = getFromColor(uv);
  vec4 b = getToColor(uv);
  return mix(a, b, smoothstep(fromStep, toStep, vec4(progress)));
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "crosshatch", paramsTypes: { center: "vec2", threshold: "float", fadeEdge: "float" }, defaultParams: { center: [0.5, 0.5], threshold: 3, fadeEdge: 0.1 }, glsl: `// License: MIT
// Author: pthrasher
// adapted by gre from https://gist.github.com/pthrasher/04fd9a7de4012cbb03f6

uniform vec2 center; // = vec2(0.5)
uniform float threshold; // = 3.0
uniform float fadeEdge; // = 0.1

float rand(vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
vec4 transition(vec2 p) {
  float dist = distance(center, p) / threshold;
  float r = progress - min(rand(vec2(p.y, 0.0)), rand(vec2(0.0, p.x)));
  return mix(getFromColor(p), getToColor(p), mix(0.0, mix(step(dist, r), 1.0, smoothstep(1.0-fadeEdge, 1.0, progress)), smoothstep(0.0, fadeEdge, progress)));    
}
`, license: "MIT", author: "pthrasher", createdAt: "Mon, 12 Jun 2017 10:02:12 +0800", updatedAt: "Mon, 12 Jun 2017 10:02:12 +0800" }, { name: "crosswarp", paramsTypes: {}, defaultParams: {}, glsl: `// Author: Eke Pter <peterekepeter@gmail.com>
// License: MIT
vec4 transition(vec2 p) {
  float x = progress;
  x=smoothstep(.0,1.0,(x*2.0+p.x-1.0));
  return mix(getFromColor((p-.5)*(1.-x)+.5), getToColor((p-.5)*x+.5), x);
}
`, author: "Eke Pter <peterekepeter@gmail.com>", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "cube", paramsTypes: { persp: "float", unzoom: "float", reflection: "float", floating: "float" }, defaultParams: { persp: 0.7, unzoom: 0.3, reflection: 0.4, floating: 3 }, glsl: `// Author: gre
// License: MIT
uniform float persp; // = 0.7
uniform float unzoom; // = 0.3
uniform float reflection; // = 0.4
uniform float floating; // = 3.0

vec2 project (vec2 p) {
  return p * vec2(1.0, -1.2) + vec2(0.0, -floating/100.);
}

bool inBounds (vec2 p) {
  return all(lessThan(vec2(0.0), p)) && all(lessThan(p, vec2(1.0)));
}

vec4 bgColor (vec2 p, vec2 pfr, vec2 pto) {
  vec4 c = vec4(0.0, 0.0, 0.0, 1.0);
  pfr = project(pfr);
  // FIXME avoid branching might help perf!
  if (inBounds(pfr)) {
    c += mix(vec4(0.0), getFromColor(pfr), reflection * mix(1.0, 0.0, pfr.y));
  }
  pto = project(pto);
  if (inBounds(pto)) {
    c += mix(vec4(0.0), getToColor(pto), reflection * mix(1.0, 0.0, pto.y));
  }
  return c;
}

// p : the position
// persp : the perspective in [ 0, 1 ]
// center : the xcenter in [0, 1] \\ 0.5 excluded
vec2 xskew (vec2 p, float persp, float center) {
  float x = mix(p.x, 1.0-p.x, center);
  return (
    (
      vec2( x, (p.y - 0.5*(1.0-persp) * x) / (1.0+(persp-1.0)*x) )
      - vec2(0.5-distance(center, 0.5), 0.0)
    )
    * vec2(0.5 / distance(center, 0.5) * (center<0.5 ? 1.0 : -1.0), 1.0)
    + vec2(center<0.5 ? 0.0 : 1.0, 0.0)
  );
}

vec4 transition(vec2 op) {
  float uz = unzoom * 2.0*(0.5-distance(0.5, progress));
  vec2 p = -uz*0.5+(1.0+uz) * op;
  vec2 fromP = xskew(
    (p - vec2(progress, 0.0)) / vec2(1.0-progress, 1.0),
    1.0-mix(progress, 0.0, persp),
    0.0
  );
  vec2 toP = xskew(
    p / vec2(progress, 1.0),
    mix(pow(progress, 2.0), 1.0, persp),
    1.0
  );
  // FIXME avoid branching might help perf!
  if (inBounds(fromP)) {
    return getFromColor(fromP);
  }
  else if (inBounds(toP)) {
    return getToColor(toP);
  }
  return bgColor(op, fromP, toP);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "directionalwarp", paramsTypes: { direction: "vec2" }, defaultParams: { direction: [-1, 1] }, glsl: `// Author: pschroen
// License: MIT

uniform vec2 direction; // = vec2(-1.0, 1.0)

const float smoothness = 0.5;
const vec2 center = vec2(0.5, 0.5);

vec4 transition (vec2 uv) {
  vec2 v = normalize(direction);
  v /= abs(v.x) + abs(v.y);
  float d = v.x * center.x + v.y * center.y;
  float m = 1.0 - smoothstep(-smoothness, 0.0, v.x * uv.x + v.y * uv.y - (d - 0.5 + progress * (1.0 + smoothness)));
  return mix(getFromColor((uv - 0.5) * (1.0 - m) + 0.5), getToColor((uv - 0.5) * m + 0.5), m);
}
`, author: "pschroen", license: "MIT", createdAt: "Wed, 13 Dec 2017 12:08:49 -0500", updatedAt: "Wed, 13 Dec 2017 12:08:49 -0500" }, { name: "directionalwipe", paramsTypes: { direction: "vec2", smoothness: "float" }, defaultParams: { direction: [1, -1], smoothness: 0.5 }, glsl: `// Author: gre
// License: MIT

uniform vec2 direction; // = vec2(1.0, -1.0)
uniform float smoothness; // = 0.5
 
const vec2 center = vec2(0.5, 0.5);
 
vec4 transition (vec2 uv) {
  vec2 v = normalize(direction);
  v /= abs(v.x)+abs(v.y);
  float d = v.x * center.x + v.y * center.y;
  float m =
    (1.0-step(progress, 0.0)) * // there is something wrong with our formula that makes m not equals 0.0 with progress is 0.0
    (1.0 - smoothstep(-smoothness, 0.0, v.x * uv.x + v.y * uv.y - (d-0.5+progress*(1.+smoothness))));
  return mix(getFromColor(uv), getToColor(uv), m);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "displacement", paramsTypes: { displacementMap: "sampler2D", strength: "float" }, defaultParams: { displacementMap: null, strength: 0.5 }, glsl: `// Author: Travis Fischer
// License: MIT
//
// Adapted from a Codrops article by Robin Delaporte
// https://tympanus.net/Development/DistortionHoverEffect

uniform sampler2D displacementMap;

uniform float strength; // = 0.5

vec4 transition (vec2 uv) {
  float displacement = texture2D(displacementMap, uv).r * strength;

  vec2 uvFrom = vec2(uv.x + progress * displacement, uv.y);
  vec2 uvTo = vec2(uv.x - (1.0 - progress) * displacement, uv.y);

  return mix(
    getFromColor(uvFrom),
    getToColor(uvTo),
    progress
  );
}
`, author: "Travis Fischer", license: "MIT", createdAt: "Tue, 10 Apr 2018 23:03:38 -0400", updatedAt: "Tue, 10 Apr 2018 23:03:38 -0400" }, { name: "doorway", paramsTypes: { reflection: "float", perspective: "float", depth: "float" }, defaultParams: { reflection: 0.4, perspective: 0.4, depth: 3 }, glsl: `// author: gre
// License: MIT 
uniform float reflection; // = 0.4
uniform float perspective; // = 0.4
uniform float depth; // = 3

const vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
const vec2 boundMin = vec2(0.0, 0.0);
const vec2 boundMax = vec2(1.0, 1.0);

bool inBounds (vec2 p) {
  return all(lessThan(boundMin, p)) && all(lessThan(p, boundMax));
}

vec2 project (vec2 p) {
  return p * vec2(1.0, -1.2) + vec2(0.0, -0.02);
}

vec4 bgColor (vec2 p, vec2 pto) {
  vec4 c = black;
  pto = project(pto);
  if (inBounds(pto)) {
    c += mix(black, getToColor(pto), reflection * mix(1.0, 0.0, pto.y));
  }
  return c;
}


vec4 transition (vec2 p) {
  vec2 pfr = vec2(-1.), pto = vec2(-1.);
  float middleSlit = 2.0 * abs(p.x-0.5) - progress;
  if (middleSlit > 0.0) {
    pfr = p + (p.x > 0.5 ? -1.0 : 1.0) * vec2(0.5*progress, 0.0);
    float d = 1.0/(1.0+perspective*progress*(1.0-middleSlit));
    pfr.y -= d/2.;
    pfr.y *= d;
    pfr.y += d/2.;
  }
  float size = mix(1.0, depth, 1.-progress);
  pto = (p + vec2(-0.5, -0.5)) * vec2(size, size) + vec2(0.5, 0.5);
  if (inBounds(pfr)) {
    return getFromColor(pfr);
  }
  else if (inBounds(pto)) {
    return getToColor(pto);
  }
  else {
    return bgColor(p, pto);
  }
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "fade", paramsTypes: {}, defaultParams: {}, glsl: `// author: gre
// license: MIT

vec4 transition (vec2 uv) {
  return mix(
    getFromColor(uv),
    getToColor(uv),
    progress
  );
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "fadecolor", paramsTypes: { color: "vec3", colorPhase: "float" }, defaultParams: { color: [0, 0, 0], colorPhase: 0.4 }, glsl: `// author: gre
// License: MIT
uniform vec3 color;// = vec3(0.0)
uniform float colorPhase/* = 0.4 */; // if 0.0, there is no black phase, if 0.9, the black phase is very important
vec4 transition (vec2 uv) {
  return mix(
    mix(vec4(color, 1.0), getFromColor(uv), smoothstep(1.0-colorPhase, 0.0, progress)),
    mix(vec4(color, 1.0), getToColor(uv), smoothstep(    colorPhase, 1.0, progress)),
    progress);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "fadegrayscale", paramsTypes: { intensity: "float" }, defaultParams: { intensity: 0.3 }, glsl: `// Author: gre
// License: MIT

uniform float intensity; // = 0.3; // if 0.0, the image directly turn grayscale, if 0.9, the grayscale transition phase is very important
 
vec3 grayscale (vec3 color) {
  return vec3(0.2126*color.r + 0.7152*color.g + 0.0722*color.b);
}
 
vec4 transition (vec2 uv) {
  vec4 fc = getFromColor(uv);
  vec4 tc = getToColor(uv);
  return mix(
    mix(vec4(grayscale(fc.rgb), 1.0), fc, smoothstep(1.0-intensity, 0.0, progress)),
    mix(vec4(grayscale(tc.rgb), 1.0), tc, smoothstep(    intensity, 1.0, progress)),
    progress);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "flyeye", paramsTypes: { size: "float", zoom: "float", colorSeparation: "float" }, defaultParams: { size: 0.04, zoom: 50, colorSeparation: 0.3 }, glsl: `// Author: gre
// License: MIT
uniform float size; // = 0.04
uniform float zoom; // = 50.0
uniform float colorSeparation; // = 0.3

vec4 transition(vec2 p) {
  float inv = 1. - progress;
  vec2 disp = size*vec2(cos(zoom*p.x), sin(zoom*p.y));
  vec4 texTo = getToColor(p + inv*disp);
  vec4 texFrom = vec4(
    getFromColor(p + progress*disp*(1.0 - colorSeparation)).r,
    getFromColor(p + progress*disp).g,
    getFromColor(p + progress*disp*(1.0 + colorSeparation)).b,
    1.0);
  return texTo*progress + texFrom*inv;
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "heart", paramsTypes: {}, defaultParams: {}, glsl: `// Author: gre
// License: MIT

float inHeart (vec2 p, vec2 center, float size) {
  if (size==0.0) return 0.0;
  vec2 o = (p-center)/(1.6*size);
  float a = o.x*o.x+o.y*o.y-0.3;
  return step(a*a*a, o.x*o.x*o.y*o.y*o.y);
}
vec4 transition (vec2 uv) {
  return mix(
    getFromColor(uv),
    getToColor(uv),
    inHeart(uv, vec2(0.5, 0.4), progress)
  );
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "hexagonalize", paramsTypes: { steps: "int", horizontalHexagons: "float" }, defaultParams: { steps: 50, horizontalHexagons: 20 }, glsl: `// Author: Fernando Kuteken
// License: MIT
// Hexagonal math from: http://www.redblobgames.com/grids/hexagons/

uniform int steps; // = 50;
uniform float horizontalHexagons; //= 20;

struct Hexagon {
  float q;
  float r;
  float s;
};

Hexagon createHexagon(float q, float r){
  Hexagon hex;
  hex.q = q;
  hex.r = r;
  hex.s = -q - r;
  return hex;
}

Hexagon roundHexagon(Hexagon hex){
  
  float q = floor(hex.q + 0.5);
  float r = floor(hex.r + 0.5);
  float s = floor(hex.s + 0.5);

  float deltaQ = abs(q - hex.q);
  float deltaR = abs(r - hex.r);
  float deltaS = abs(s - hex.s);

  if (deltaQ > deltaR && deltaQ > deltaS)
    q = -r - s;
  else if (deltaR > deltaS)
    r = -q - s;
  else
    s = -q - r;

  return createHexagon(q, r);
}

Hexagon hexagonFromPoint(vec2 point, float size) {
  
  point.y /= ratio;
  point = (point - 0.5) / size;
  
  float q = (sqrt(3.0) / 3.0) * point.x + (-1.0 / 3.0) * point.y;
  float r = 0.0 * point.x + 2.0 / 3.0 * point.y;

  Hexagon hex = createHexagon(q, r);
  return roundHexagon(hex);
  
}

vec2 pointFromHexagon(Hexagon hex, float size) {
  
  float x = (sqrt(3.0) * hex.q + (sqrt(3.0) / 2.0) * hex.r) * size + 0.5;
  float y = (0.0 * hex.q + (3.0 / 2.0) * hex.r) * size + 0.5;
  
  return vec2(x, y * ratio);
}

vec4 transition (vec2 uv) {
  
  float dist = 2.0 * min(progress, 1.0 - progress);
  dist = steps > 0 ? ceil(dist * float(steps)) / float(steps) : dist;
  
  float size = (sqrt(3.0) / 3.0) * dist / horizontalHexagons;
  
  vec2 point = dist > 0.0 ? pointFromHexagon(hexagonFromPoint(uv, size), size) : uv;

  return mix(getFromColor(point), getToColor(point), progress);
  
}
`, author: "Fernando Kuteken", license: "MIT", createdAt: "Tue, 30 May 2017 21:55:47 -0300", updatedAt: "Tue, 30 May 2017 21:55:47 -0300" }, { name: "kaleidoscope", paramsTypes: { speed: "float", angle: "float", power: "float" }, defaultParams: { speed: 1, angle: 1, power: 1.5 }, glsl: `// Author: nwoeanhinnogaehr
// License: MIT

uniform float speed; // = 1.0;
uniform float angle; // = 1.0;
uniform float power; // = 1.5;

vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy;
  vec2 q = p;
  float t = pow(progress, power)*speed;
  p = p -0.5;
  for (int i = 0; i < 7; i++) {
    p = vec2(sin(t)*p.x + cos(t)*p.y, sin(t)*p.y - cos(t)*p.x);
    t += angle;
    p = abs(mod(p, 2.0) - 1.0);
  }
  abs(mod(p, 1.0));
  return mix(
    mix(getFromColor(q), getToColor(q), progress),
    mix(getFromColor(p), getToColor(p), progress), 1.0 - 2.0*abs(progress - 0.5));
}
`, author: "nwoeanhinnogaehr", license: "MIT", createdAt: "Wed, 31 May 2017 21:48:26 -0400", updatedAt: "Wed, 31 May 2017 21:48:26 -0400" }, { name: "luma", paramsTypes: { luma: "sampler2D" }, defaultParams: { luma: null }, glsl: `// Author: gre
// License: MIT

uniform sampler2D luma;

vec4 transition(vec2 uv) {
  return mix(
    getToColor(uv),
    getFromColor(uv),
    step(progress, texture2D(luma, uv).r)
  );
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "luminance_melt", paramsTypes: { direction: "bool", l_threshold: "float", above: "bool" }, defaultParams: { direction: !0, l_threshold: 0.8, above: !1 }, glsl: `// Author: 0gust1
// License: MIT
//My own first transition  based on crosshatch code (from pthrasher), using  simplex noise formula (copied and pasted)
//-> cooler with high contrasted images (isolated dark subject on light background f.e.)
//TODO : try to rebase it on DoomTransition (from zeh)?
//optimizations :
//luminance (see http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color#answer-596241)
// Y = (R+R+B+G+G+G)/6
//or Y = (R+R+R+B+G+G+G+G)>>3 


//direction of movement :  0 : up, 1, down
uniform bool direction; // = 1 
//luminance threshold
uniform float l_threshold; // = 0.8 
//does the movement takes effect above or below luminance threshold ?
uniform bool above; // = false 


//Random function borrowed from everywhere
float rand(vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}


// Simplex noise :
// Description : Array and textureless GLSL 2D simplex noise function.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110822 (ijm)
//     License : MIT  
//               2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
// 

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v)
  {
  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                     -0.577350269189626,  // -1.0 + 2.0 * C.x
                      0.024390243902439); // 1.0 / 41.0
// First corner
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);

// Other corners
  vec2 i1;
  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
  //i1.y = 1.0 - i1.x;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  // x0 = x0 - 0.0 + 0.0 * C.xx ;
  // x1 = x0 - i1 + 1.0 * C.xx ;
  // x2 = x0 - 1.0 + 2.0 * C.xx ;
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

// Permutations
  i = mod289(i); // Avoid truncation effects in permutation
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
		+ i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;

// Gradients: 41 points uniformly over a line, mapped onto a diamond.
// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

// Normalise gradients implicitly by scaling m
// Approximation of: m *= inversesqrt( a0*a0 + h*h );
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

// Compute final noise value at P
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

// Simplex noise -- end

float luminance(vec4 color){
  //(0.299*R + 0.587*G + 0.114*B)
  return color.r*0.299+color.g*0.587+color.b*0.114;
}

vec2 center = vec2(1.0, direction);

vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy;
  if (progress == 0.0) {
    return getFromColor(p);
  } else if (progress == 1.0) {
    return getToColor(p);
  } else {
    float x = progress;
    float dist = distance(center, p)- progress*exp(snoise(vec2(p.x, 0.0)));
    float r = x - rand(vec2(p.x, 0.1));
    float m;
    if(above){
     m = dist <= r && luminance(getFromColor(p))>l_threshold ? 1.0 : (progress*progress*progress);
    }
    else{
     m = dist <= r && luminance(getFromColor(p))<l_threshold ? 1.0 : (progress*progress*progress);  
    }
    return mix(getFromColor(p), getToColor(p), m);    
  }
}
`, author: "0gust1", license: "MIT", createdAt: "Wed, 24 Jan 2018 19:02:32 +0100", updatedAt: "Wed, 24 Jan 2018 19:02:32 +0100" }, { name: "morph", paramsTypes: { strength: "float" }, defaultParams: { strength: 0.1 }, glsl: `// Author: paniq
// License: MIT
uniform float strength; // = 0.1

vec4 transition(vec2 p) {
  vec4 ca = getFromColor(p);
  vec4 cb = getToColor(p);
  
  vec2 oa = (((ca.rg+ca.b)*0.5)*2.0-1.0);
  vec2 ob = (((cb.rg+cb.b)*0.5)*2.0-1.0);
  vec2 oc = mix(oa,ob,0.5)*strength;
  
  float w0 = progress;
  float w1 = 1.0-w0;
  return mix(getFromColor(p+oc*w0), getToColor(p-oc*w1), progress);
}
`, author: "paniq", license: "MIT", createdAt: "Thu, 10 Aug 2017 00:27:36 +0200", updatedAt: "Thu, 10 Aug 2017 00:32:01 +0200" }, { name: "multiply_blend", paramsTypes: {}, defaultParams: {}, glsl: `// Author: Fernando Kuteken
// License: MIT

vec4 blend(vec4 a, vec4 b) {
  return a * b;
}

vec4 transition (vec2 uv) {
  
  vec4 blended = blend(getFromColor(uv), getToColor(uv));
  
  if (progress < 0.5)
    return mix(getFromColor(uv), blended, 2.0 * progress);
  else
    return mix(blended, getToColor(uv), 2.0 * progress - 1.0);
}

`, author: "Fernando Kuteken", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "perlin", paramsTypes: { scale: "float", smoothness: "float", seed: "float" }, defaultParams: { scale: 4, smoothness: 0.01, seed: 12.9898 }, glsl: `// Author: Rich Harris
// License: MIT

#ifdef GL_ES
precision mediump float;
#endif

uniform float scale; // = 4.0
uniform float smoothness; // = 0.01

uniform float seed; // = 12.9898

// http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
float random(vec2 co)
{
    highp float a = seed;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}

// 2D Noise based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    // Smooth Interpolation

    // Cubic Hermine Curve.  Same as SmoothStep()
    vec2 u = f*f*(3.0-2.0*f);
    // u = smoothstep(0.,1.,f);

    // Mix 4 coorners porcentages
    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

vec4 transition (vec2 uv) {
  vec4 from = getFromColor(uv);
  vec4 to = getToColor(uv);
  float n = noise(uv * scale);
  
  float p = mix(-smoothness, 1.0 + smoothness, progress);
  float lower = p - smoothness;
  float higher = p + smoothness;
  
  float q = smoothstep(lower, higher, n);
  
  return mix(
    from,
    to,
    1.0 - q
  );
}
`, author: "Rich Harris", license: "MIT", createdAt: "Tue, 23 Jan 2018 21:35:10 -0500", updatedAt: "Wed, 24 Jan 2018 07:35:04 -0500" }, { name: "pinwheel", paramsTypes: { speed: "float" }, defaultParams: { speed: 2 }, glsl: `// Author: Mr Speaker
// License: MIT

uniform float speed; // = 2.0;

vec4 transition(vec2 uv) {
  
  vec2 p = uv.xy / vec2(1.0).xy;
  
  float circPos = atan(p.y - 0.5, p.x - 0.5) + progress * speed;
  float modPos = mod(circPos, 3.1415 / 4.);
  float signed = sign(progress - modPos);
  
  return mix(getToColor(p), getFromColor(p), step(signed, 0.5));
  
}
`, author: "Mr Speaker", license: "MIT", createdAt: "Tue, 30 May 2017 09:04:31 -0400", updatedAt: "Tue, 30 May 2017 09:04:31 -0400" }, { name: "pixelize", paramsTypes: { squaresMin: "ivec2", steps: "int" }, defaultParams: { squaresMin: [20, 20], steps: 50 }, glsl: `// Author: gre
// License: MIT
// forked from https://gist.github.com/benraziel/c528607361d90a072e98

uniform ivec2 squaresMin/* = ivec2(20) */; // minimum number of squares (when the effect is at its higher level)
uniform int steps /* = 50 */; // zero disable the stepping

float d = min(progress, 1.0 - progress);
float dist = steps>0 ? ceil(d * float(steps)) / float(steps) : d;
vec2 squareSize = 2.0 * dist / vec2(squaresMin);

vec4 transition(vec2 uv) {
  vec2 p = dist>0.0 ? (floor(uv / squareSize) + 0.5) * squareSize : uv;
  return mix(getFromColor(p), getToColor(p), progress);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Wed, 31 May 2017 10:58:26 +0200" }, { name: "polar_function", paramsTypes: { segments: "int" }, defaultParams: { segments: 5 }, glsl: `// Author: Fernando Kuteken
// License: MIT

#define PI 3.14159265359

uniform int segments; // = 5;

vec4 transition (vec2 uv) {
  
  float angle = atan(uv.y - 0.5, uv.x - 0.5) - 0.5 * PI;
  float normalized = (angle + 1.5 * PI) * (2.0 * PI);
  
  float radius = (cos(float(segments) * angle) + 4.0) / 4.0;
  float difference = length(uv - vec2(0.5, 0.5));
  
  if (difference > radius * progress)
    return getFromColor(uv);
  else
    return getToColor(uv);
}
`, author: "Fernando Kuteken", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "randomsquares", paramsTypes: { size: "ivec2", smoothness: "float" }, defaultParams: { size: [10, 10], smoothness: 0.5 }, glsl: `// Author: gre
// License: MIT

uniform ivec2 size; // = ivec2(10, 10)
uniform float smoothness; // = 0.5
 
float rand (vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec4 transition(vec2 p) {
  float r = rand(floor(vec2(size) * p));
  float m = smoothstep(0.0, -smoothness, r - (progress * (1.0 + smoothness)));
  return mix(getFromColor(p), getToColor(p), m);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "ripple", paramsTypes: { amplitude: "float", speed: "float" }, defaultParams: { amplitude: 100, speed: 50 }, glsl: `// Author: gre
// License: MIT
uniform float amplitude; // = 100.0
uniform float speed; // = 50.0

vec4 transition (vec2 uv) {
  vec2 dir = uv - vec2(.5);
  float dist = length(dir);
  vec2 offset = dir * (sin(progress * dist * amplitude - progress * speed) + .5) / 30.;
  return mix(
    getFromColor(uv + offset),
    getToColor(uv),
    smoothstep(0.2, 1.0, progress)
  );
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 15:15:27 +0200", updatedAt: "Tue, 30 May 2017 15:15:27 +0200" }, { name: "rotate_scale_fade", paramsTypes: { center: "vec2", rotations: "float", scale: "float", backColor: "vec4" }, defaultParams: { center: [0.5, 0.5], rotations: 1, scale: 8, backColor: [0.15, 0.15, 0.15, 1] }, glsl: `// Author: Fernando Kuteken
// License: MIT

#define PI 3.14159265359

uniform vec2 center; // = vec2(0.5, 0.5);
uniform float rotations; // = 1;
uniform float scale; // = 8;
uniform vec4 backColor; // = vec4(0.15, 0.15, 0.15, 1.0);

vec4 transition (vec2 uv) {
  
  vec2 difference = uv - center;
  vec2 dir = normalize(difference);
  float dist = length(difference);
  
  float angle = 2.0 * PI * rotations * progress;
  
  float c = cos(angle);
  float s = sin(angle);
  
  float currentScale = mix(scale, 1.0, 2.0 * abs(progress - 0.5));
  
  vec2 rotatedDir = vec2(dir.x  * c - dir.y * s, dir.x * s + dir.y * c);
  vec2 rotatedUv = center + rotatedDir * dist / currentScale;
  
  if (rotatedUv.x < 0.0 || rotatedUv.x > 1.0 ||
      rotatedUv.y < 0.0 || rotatedUv.y > 1.0)
    return backColor;
    
  return mix(getFromColor(rotatedUv), getToColor(rotatedUv), progress);
}
`, author: "Fernando Kuteken", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "squareswire", paramsTypes: { squares: "ivec2", direction: "vec2", smoothness: "float" }, defaultParams: { squares: [10, 10], direction: [1, -0.5], smoothness: 1.6 }, glsl: `// Author: gre
// License: MIT
 
uniform ivec2 squares;// = ivec2(10,10)
uniform vec2 direction;// = vec2(1.0, -0.5)
uniform float smoothness; // = 1.6

const vec2 center = vec2(0.5, 0.5);
vec4 transition (vec2 p) {
  vec2 v = normalize(direction);
  v /= abs(v.x)+abs(v.y);
  float d = v.x * center.x + v.y * center.y;
  float offset = smoothness;
  float pr = smoothstep(-offset, 0.0, v.x * p.x + v.y * p.y - (d-0.5+progress*(1.+offset)));
  vec2 squarep = fract(p*vec2(squares));
  vec2 squaremin = vec2(pr/2.0);
  vec2 squaremax = vec2(1.0 - pr/2.0);
  float a = (1.0 - step(progress, 0.0)) * step(squaremin.x, squarep.x) * step(squaremin.y, squarep.y) * step(squarep.x, squaremax.x) * step(squarep.y, squaremax.y);
  return mix(getFromColor(p), getToColor(p), a);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "squeeze", paramsTypes: { colorSeparation: "float" }, defaultParams: { colorSeparation: 0.04 }, glsl: `// Author: gre
// License: MIT
 
uniform float colorSeparation; // = 0.04
 
vec4 transition (vec2 uv) {
  float y = 0.5 + (uv.y-0.5) / (1.0-progress);
  if (y < 0.0 || y > 1.0) {
     return getToColor(uv);
  }
  else {
    vec2 fp = vec2(uv.x, y);
    vec2 off = progress * vec2(0.0, colorSeparation);
    vec4 c = getFromColor(fp);
    vec4 cn = getFromColor(fp - off);
    vec4 cp = getFromColor(fp + off);
    return vec4(cn.r, c.g, cp.b, c.a);
  }
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "swap", paramsTypes: { reflection: "float", perspective: "float", depth: "float" }, defaultParams: { reflection: 0.4, perspective: 0.2, depth: 3 }, glsl: `// Author: gre
// License: MIT
// General parameters
uniform float reflection; // = 0.4
uniform float perspective; // = 0.2
uniform float depth; // = 3.0
 
const vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
const vec2 boundMin = vec2(0.0, 0.0);
const vec2 boundMax = vec2(1.0, 1.0);
 
bool inBounds (vec2 p) {
  return all(lessThan(boundMin, p)) && all(lessThan(p, boundMax));
}
 
vec2 project (vec2 p) {
  return p * vec2(1.0, -1.2) + vec2(0.0, -0.02);
}
 
vec4 bgColor (vec2 p, vec2 pfr, vec2 pto) {
  vec4 c = black;
  pfr = project(pfr);
  if (inBounds(pfr)) {
    c += mix(black, getFromColor(pfr), reflection * mix(1.0, 0.0, pfr.y));
  }
  pto = project(pto);
  if (inBounds(pto)) {
    c += mix(black, getToColor(pto), reflection * mix(1.0, 0.0, pto.y));
  }
  return c;
}
 
vec4 transition(vec2 p) {
  vec2 pfr, pto = vec2(-1.);
 
  float size = mix(1.0, depth, progress);
  float persp = perspective * progress;
  pfr = (p + vec2(-0.0, -0.5)) * vec2(size/(1.0-perspective*progress), size/(1.0-size*persp*p.x)) + vec2(0.0, 0.5);
 
  size = mix(1.0, depth, 1.-progress);
  persp = perspective * (1.-progress);
  pto = (p + vec2(-1.0, -0.5)) * vec2(size/(1.0-perspective*(1.0-progress)), size/(1.0-size*persp*(0.5-p.x))) + vec2(1.0, 0.5);

  if (progress < 0.5) {
    if (inBounds(pfr)) {
      return getFromColor(pfr);
    }
    if (inBounds(pto)) {
      return getToColor(pto);
    }  
  }
  if (inBounds(pto)) {
    return getToColor(pto);
  }
  if (inBounds(pfr)) {
    return getFromColor(pfr);
  }
  return bgColor(p, pfr, pto);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Sun, 18 Feb 2018 17:45:50 +0100" }, { name: "undulatingBurnOut", paramsTypes: { smoothness: "float", center: "vec2", color: "vec3" }, defaultParams: { smoothness: 0.03, center: [0.5, 0.5], color: [0, 0, 0] }, glsl: `// License: MIT
// Author: pthrasher
// adapted by gre from https://gist.github.com/pthrasher/8e6226b215548ba12734

uniform float smoothness; // = 0.03
uniform vec2 center; // = vec2(0.5)
uniform vec3 color; // = vec3(0.0)

const float M_PI = 3.14159265358979323846;

float quadraticInOut(float t) {
  float p = 2.0 * t * t;
  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;
}

float getGradient(float r, float dist) {
  float d = r - dist;
  return mix(
    smoothstep(-smoothness, 0.0, r - dist * (1.0 + smoothness)),
    -1.0 - step(0.005, d),
    step(-0.005, d) * step(d, 0.01)
  );
}

float getWave(vec2 p){
  vec2 _p = p - center; // offset from center
  float rads = atan(_p.y, _p.x);
  float degs = degrees(rads) + 180.0;
  vec2 range = vec2(0.0, M_PI * 30.0);
  vec2 domain = vec2(0.0, 360.0);
  float ratio = (M_PI * 30.0) / 360.0;
  degs = degs * ratio;
  float x = progress;
  float magnitude = mix(0.02, 0.09, smoothstep(0.0, 1.0, x));
  float offset = mix(40.0, 30.0, smoothstep(0.0, 1.0, x));
  float ease_degs = quadraticInOut(sin(degs));
  float deg_wave_pos = (ease_degs * magnitude) * sin(x * offset);
  return x + deg_wave_pos;
}

vec4 transition(vec2 p) {
  float dist = distance(center, p);
  float m = getGradient(getWave(p), dist);
  vec4 cfrom = getFromColor(p);
  vec4 cto = getToColor(p);
  return mix(mix(cfrom, cto, m), mix(cfrom, vec4(color, 1.0), 0.75), step(m, -2.0));
}
`, license: "MIT", author: "pthrasher", createdAt: "Mon, 12 Jun 2017 10:23:37 +0800", updatedAt: "Mon, 12 Jun 2017 10:23:37 +0800" }, { name: "wind", paramsTypes: { size: "float" }, defaultParams: { size: 0.2 }, glsl: `// Author: gre
// License: MIT

// Custom parameters
uniform float size; // = 0.2

float rand (vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec4 transition (vec2 uv) {
  float r = rand(vec2(0, uv.y));
  float m = smoothstep(0.0, -size, uv.x*(1.0-size) + size*r - (progress * (1.0 + size)));
  return mix(
    getFromColor(uv),
    getToColor(uv),
    m
  );
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "windowblinds", paramsTypes: {}, defaultParams: {}, glsl: `// Author: Fabien Benetou
// License: MIT

vec4 transition (vec2 uv) {
  float t = progress;
  
  if (mod(floor(uv.y*100.*progress),2.)==0.)
    t*=2.-.5;
  
  return mix(
    getFromColor(uv),
    getToColor(uv),
    mix(t, progress, smoothstep(0.8, 1.0, progress))
  );
}
`, author: "Fabien Benetou", license: "MIT", createdAt: "Wed, 31 May 2017 14:11:48 +0200", updatedAt: "Wed, 31 May 2017 14:11:48 +0200" }, { name: "windowslice", paramsTypes: { count: "float", smoothness: "float" }, defaultParams: { count: 10, smoothness: 0.5 }, glsl: `// Author: gre
// License: MIT

uniform float count; // = 10.0
uniform float smoothness; // = 0.5

vec4 transition (vec2 p) {
  float pr = smoothstep(-smoothness, 0.0, p.x - progress * (1.0 + smoothness));
  float s = step(pr, fract(count * p.x));
  return mix(getFromColor(p), getToColor(p), s);
}
`, author: "gre", license: "MIT", createdAt: "Wed, 28 Mar 2018 17:23:26 +0200", updatedAt: "Wed, 28 Mar 2018 17:23:26 +0200" }, { name: "wipeDown", paramsTypes: {}, defaultParams: {}, glsl: `// Author: Jake Nelson
// License: MIT

vec4 transition(vec2 uv) {
  vec2 p=uv.xy/vec2(1.0).xy;
  vec4 a=getFromColor(p);
  vec4 b=getToColor(p);
  return mix(a, b, step(1.0-p.y,progress));
}
`, author: "Jake Nelson", license: "MIT", createdAt: "Wed, 1 Nov 2017 15:26:01 -0500", updatedAt: "Thu, 2 Nov 2017 18:39:26 -0500" }, { name: "wipeLeft", paramsTypes: {}, defaultParams: {}, glsl: `// Author: Jake Nelson
// License: MIT

vec4 transition(vec2 uv) {
  vec2 p=uv.xy/vec2(1.0).xy;
  vec4 a=getFromColor(p);
  vec4 b=getToColor(p);
  return mix(a, b, step(1.0-p.x,progress));
}
`, author: "Jake Nelson", license: "MIT", createdAt: "Wed, 1 Nov 2017 15:26:28 -0500", updatedAt: "Fri, 3 Nov 2017 18:03:50 +0100" }, { name: "wipeRight", paramsTypes: {}, defaultParams: {}, glsl: `// Author: Jake Nelson
// License: MIT

vec4 transition(vec2 uv) {
  vec2 p=uv.xy/vec2(1.0).xy;
  vec4 a=getFromColor(p);
  vec4 b=getToColor(p);
  return mix(a, b, step(0.0+p.x,progress));
}
`, author: "Jake Nelson", license: "MIT", createdAt: "Wed, 1 Nov 2017 15:27:02 -0500", updatedAt: "Thu, 2 Nov 2017 18:40:22 -0500" }, { name: "wipeUp", paramsTypes: {}, defaultParams: {}, glsl: `// Author: Jake Nelson
// License: MIT

vec4 transition(vec2 uv) {
  vec2 p=uv.xy/vec2(1.0).xy;
  vec4 a=getFromColor(p);
  vec4 b=getToColor(p);
  return mix(a, b, step(0.0+p.y,progress));
}
`, author: "Jake Nelson", license: "MIT", createdAt: "Wed, 1 Nov 2017 15:24:36 -0500", updatedAt: "Thu, 2 Nov 2017 18:37:42 -0500" }]), fh;
}
var N3 = L3();
const ei = /* @__PURE__ */ ru(N3), G3 = `
	in vec2 aPosition;
	out vec2 _uv;               
	uniform mat3 projectionMatrix;
	uniform vec4 uInputSize;
	uniform vec4 uOutputFrame;
	out vec2 vTextureCoord;
	uniform vec4 uOutputTexture;

	vec4 filterVertexPosition( void )
	{
			vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;

			position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
			position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

			return vec4(position, 0.0, 1.0);
	}

	vec2 filterTextureCoord( void )
	{
	return aPosition * (uOutputFrame.zw * uInputSize.zw);
	}

	void main(void)
	{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vec2 absolute = aPosition * uOutputFrame.zw + uOutputFrame.xy;
	_uv = absolute / uOutputTexture.xy;
	}
`, te = {
  custom: (i) => {
    const e = i.defaultParams || {}, t = i.paramsTypes || {};
    return Object.fromEntries(
      Object.entries(e).map(([s, r]) => [
        s,
        {
          value: r,
          type: H3(t[s])
        }
      ])
    );
  },
  basics: {
    _fromR: { value: 1, type: "f32" },
    _toR: { value: 1, type: "f32" },
    ratio: { value: 1, type: "f32" },
    progress: { value: 0, type: "f32" },
    customUniform: { value: 0, type: "f32" },
    center: { value: [0.5, 0.5], type: "vec2<f32>" }
    // Center point of the canvas (not element centers)
  }
}, H3 = (i) => i === "f32" || i === "i32" ? i : i === "float" ? "f32" : `${i}<f32>`, W3 = (i) => `
	precision highp float;
	in vec2 vTextureCoord;
	in vec2 _uv; // Normalized [0,1] coordinates with center at (0.5, 0.5) for canvas-centered transitions
	uniform sampler2D from, to;
	uniform float progress, ratio, _fromR, _toR;
	uniform float customUniform;
	uniform vec2 center; // Center point of the canvas (0.5, 0.5) - NOT element centers

	vec4 getFromColor(vec2 uv){
		return texture2D(from, .5+(uv-.5)*vec2(max(ratio/_fromR,1.), max(_fromR/ratio,1.)));
	}
	vec4 getToColor(vec2 uv){
		return texture2D(to, .5+(uv-.5)*vec2(max(ratio/_toR,1.), max(_toR/ratio,1.)));
	}

	// Helper function to get distance from canvas center
	float distanceFromCenter(vec2 uv) {
		return distance(uv, center);
	}
	
	// Helper function to get angle from canvas center
	float angleFromCenter(vec2 uv) {
		vec2 centered = uv - center;
		return atan(centered.y, centered.x);
	}
	
	// Helper function to get centered coordinates relative to canvas center
	vec2 getCenteredCoord(vec2 uv) {
		return uv - center; // Coordinates relative to canvas center
	}

	// gl-transition code here
	${i}
	// gl-transition code end

	void main(){
		// Use _uv which is properly normalized to [0,1] range with center at (0.5, 0.5)
		// This ensures transitions are centered on the canvas, not element centers
		vec2 uv = _uv;
		gl_FragColor = transition(uv);
	}
`, V3 = `
const float PI = 3.141592653589;

vec4 transition(vec2 p) {
  vec2 rp = p * 2.0 - 1.0;
  float angle = atan(rp.y, rp.x);
  float threshold = (progress - 0.5) * PI * 2.5;
  float mix_factor = smoothstep(0.0, 0.1, angle - threshold);
  return mix(getToColor(p), getFromColor(p), mix_factor);
}
`, $3 = `
uniform vec2 gridSize;
uniform float pause;
uniform float dividerWidth;
uniform vec4 bgColor;
uniform float randomness;

float rand(vec2 co) { 
  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

float getDelta(vec2 p) { 
  vec2 rectanglePos = floor(gridSize * p); 
  vec2 rectangleSize = vec2(1.0 / gridSize.x, 1.0 / gridSize.y); 
  float top = rectangleSize.y * (rectanglePos.y + 1.0); 
  float bottom = rectangleSize.y * rectanglePos.y; 
  float left = rectangleSize.x * rectanglePos.x; 
  float right = rectangleSize.x * (rectanglePos.x + 1.0); 
  float minX = min(abs(p.x - left), abs(p.x - right)); 
  float minY = min(abs(p.y - top), abs(p.y - bottom)); 
  return min(minX, minY);
}

float getDividerSize() { 
  vec2 rectangleSize = vec2(1.0 / gridSize.x, 1.0 / gridSize.y); 
  return min(rectangleSize.x, rectangleSize.y) * dividerWidth;
}

vec4 transition(vec2 p) { 
  if (progress < pause) { 
    float currentProg = progress / pause; 
    float a = 1.0; 
    if (getDelta(p) < getDividerSize()) { 
      a = 1.0 - currentProg; 
    } 
    return mix(bgColor, getFromColor(p), a); 
  } 

  if (progress < 1.0 - pause) { 
    if (getDelta(p) < getDividerSize()) { 
      return bgColor; 
    } 

    float currentProg = (progress - pause) / (1.0 - pause * 2.0); 
    vec2 rectanglePos = floor(gridSize * p); 
    float r = rand(rectanglePos) - randomness; 
    float cp = smoothstep(0.0, 1.0 - r, currentProg); 
    float rectangleSize = 1.0 / gridSize.x; 
    float delta = rectanglePos.x * rectangleSize; 
    float offset = rectangleSize * 0.5 + delta; 

    vec2 warped = p; 
    warped.x = (warped.x - offset) / max(abs(cp - 0.5), 0.001) * 0.5 + offset; 

    float s = step(abs(gridSize.x * (p.x - delta) - 0.5), abs(cp - 0.5)); 
    vec4 mixColor = mix(getToColor(warped), getFromColor(warped), step(cp, 0.5)); 
    return mix(bgColor, mixColor, s); 
  } 

  float currentProg = (progress - 1.0 + pause) / pause; 
  float a = 1.0; 
  if (getDelta(p) < getDividerSize()) { 
    a = currentProg; 
  } 
  return mix(bgColor, getToColor(p), a);
}
`, Y3 = {
  gridSize: { value: [4, 4], type: "vec2<f32>" },
  pause: { value: 0.1, type: "f32" },
  dividerWidth: { value: 0.05, type: "f32" },
  bgColor: { value: [0, 0, 0, 1], type: "vec4<f32>" },
  randomness: { value: 0.1, type: "f32" }
}, X3 = `
uniform vec3 backColor;

vec4 transition(vec2 uv) { 
  float distance = length(uv - center); 
  float radius = sqrt(8.0) * abs(progress - 0.5); 

  if (distance > radius) { 
    return vec4(backColor, 1.0); 
  } else { 
    if (progress < 0.5) return getFromColor(uv); 
    else return getToColor(uv); 
  }
}
`, q3 = `
uniform vec2 direction;

vec4 transition(vec2 uv) { 
  vec2 p = uv + progress * sign(direction); 
  vec2 f = fract(p); 
  return mix( 
    getToColor(f), 
    getFromColor(f), 
    step(0.0, p.y) * step(p.y, 1.0) * step(0.0, p.x) * step(p.x, 1.0) 
  );
}
`, Z3 = {
  direction: { value: [0, 1], type: "vec2<f32>" }
}, K3 = `
uniform float smoothness;
uniform vec3 color;

const float M_PI = 3.14159265358979323846;

float quadraticInOut(float t) { 
  float p = 2.0 * t * t; 
  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;
}

float getGradient(float r, float dist) { 
  float d = r - dist; 
  return mix( 
    smoothstep(-smoothness, 0.0, r - dist * (1.0 + smoothness)), 
    -1.0 - step(0.005, d), 
    step(-0.005, d) * step(d, 0.01) 
  );
}

float getWave(vec2 p){ 
  vec2 _p = p - center; // offset from center 
  float rads = atan(_p.y, _p.x); 
  float degs = degrees(rads) + 180.0; 
  vec2 range = vec2(0.0, M_PI * 30.0); 
  vec2 domain = vec2(0.0, 360.0); 
  float ratio = (M_PI * 30.0) / 360.0; 
  degs = degs * ratio; 
  float x = progress; 
  float magnitude = mix(0.02, 0.09, smoothstep(0.0, 1.0, x)); 
  float offset = mix(40.0, 30.0, smoothstep(0.0, 1.0, x)); 
  float ease_degs = quadraticInOut(sin(degs)); 
  float deg_wave_pos = (ease_degs * magnitude) * sin(x * offset); 
  return x + deg_wave_pos;
}

vec4 transition(vec2 p) { 
  float dist = distance(center, p); 
  float m = getGradient(getWave(p), dist); 
  vec4 cfrom = getFromColor(p); 
  vec4 cto = getToColor(p); 
  return mix(mix(cfrom, cto, m), mix(cfrom, vec4(color, 1.0), 0.75), step(m, -2.0));
}
`, J3 = {
  smoothness: { value: 0.1, type: "f32" },
  center: { value: [0.5, 0.5], type: "vec2<f32>" },
  color: { value: [1, 0.5, 0], type: "vec3<f32>" }
}, j3 = `
uniform ivec2 squares;
uniform vec2 direction;
uniform float smoothness;

vec4 transition (vec2 p) { 
  vec2 v = normalize(direction); 
  v /= abs(v.x)+abs(v.y); 
  float d = v.x * center.x + v.y * center.y; 
  float offset = smoothness; 
  float pr = smoothstep(-offset, 0.0, v.x * p.x + v.y * p.y - (d-0.5+progress*(1.+offset))); 
  vec2 squarep = fract(p*vec2(squares)); 
  vec2 squaremin = vec2(pr/2.0); 
  vec2 squaremax = vec2(1.0 - pr/2.0); 
  float a = (1.0 - step(progress, 0.0)) * step(squaremin.x, squarep.x) * step(squaremin.y, squarep.y) * step(squarep.x, squaremax.x) * step(squarep.y, squaremax.y); 
  return mix(getFromColor(p), getToColor(p), a);
}
`, Q3 = {
  squares: { value: [10, 10], type: "vec2<i32>" },
  direction: { value: [1, -0.5], type: "vec2<f32>" },
  smoothness: { value: 1.6, type: "f32" }
}, eI = `
#define PI 3.14159265359

uniform float rotations;
uniform float scale;
uniform vec4 backColor;

vec4 transition (vec2 uv) { 
  vec2 difference = uv - center; 
  vec2 dir = normalize(difference); 
  float dist = length(difference); 

  float angle = 2.0 * PI * rotations * progress; 

  float c = cos(angle); 
  float s = sin(angle); 

  float currentScale = mix(scale, 1.0, 2.0 * abs(progress - 0.5)); 

  vec2 rotatedDir = vec2(dir.x * c - dir.y * s, dir.x * s + dir.y * c); 
  vec2 rotatedUv = center + rotatedDir * dist / currentScale; 

  if (rotatedUv.x < 0.0 || rotatedUv.x > 1.0 || 
      rotatedUv.y < 0.0 || rotatedUv.y > 1.0) 
    return backColor; 

  return mix(getFromColor(rotatedUv), getToColor(rotatedUv), progress);
}
`, tI = {
  center: { value: [0.5, 0.5], type: "vec2<f32>" },
  rotations: { value: 1, type: "f32" },
  scale: { value: 8, type: "f32" },
  backColor: { value: [0.15, 0.15, 0.15, 1], type: "vec4<f32>" }
}, iI = `
uniform ivec2 size;
uniform float smoothness;

float rand (vec2 co) { 
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec4 transition(vec2 p) { 
  float r = rand(floor(vec2(size) * p)); 
  float m = smoothstep(0.0, -smoothness, r - (progress * (1.0 + smoothness))); 
  return mix(getFromColor(p), getToColor(p), m);
}
`, sI = {
  size: { value: [10, 10], type: "vec2<i32>" },
  smoothness: { value: 0.5, type: "f32" }
}, rI = `
#define PI 3.14159265359

uniform int segments;

vec4 transition (vec2 uv) { 
  float angle = atan(uv.y - 0.5, uv.x - 0.5) - 0.5 * PI; 
  float normalized = (angle + 1.5 * PI) * (2.0 * PI); 

  float radius = (cos(float(segments) * angle) + 4.0) / 4.0; 
  float difference = length(uv - vec2(0.5, 0.5)); 

  if (difference > radius * progress) 
    return getFromColor(uv); 
  else 
    return getToColor(uv);
}
`, nI = {
  segments: { value: 5, type: "i32" }
}, oI = `
uniform ivec2 squaresMin;
uniform int steps;

vec4 transition(vec2 uv) { 
  float d = min(progress, 1.0 - progress);
  float dist = steps>0 ? ceil(d * float(steps)) / float(steps) : d;
  vec2 squareSize = 2.0 * dist / vec2(squaresMin);
  
  vec2 p = dist>0.0 ? (floor(uv / squareSize) + 0.5) * squareSize : uv; 
  return mix(getFromColor(p), getToColor(p), progress);
}
`, aI = {
  squaresMin: { value: [20, 20], type: "vec2<i32>" },
  steps: { value: 50, type: "i32" }
}, lI = `
uniform float scale;
uniform float smoothness;
uniform float seed;

// http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
float random(vec2 co)
{ 
  float a = seed; 
  float b = 78.233; 
  float c = 43758.5453; 
  float dt = dot(co.xy, vec2(a, b)); 
  float sn = mod(dt, 3.14); 
  return fract(sin(sn) * c);
}

// 2D Noise based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise(vec2 st) { 
  vec2 i = floor(st); 
  vec2 f = fract(st); 

  // Four corners in 2D of a tile 
  float a = random(i); 
  float b = random(i + vec2(1.0, 0.0)); 
  float c = random(i + vec2(0.0, 1.0)); 
  float d = random(i + vec2(1.0, 1.0)); 

  //Smooth Interpolation 

  // Cubic Hermine Curve. Same as SmoothStep() 
  vec2 u = f*f*(3.0-2.0*f); 
  // u = smoothstep(0.,1.,f); 

  // Mix 4 coorners percentages 
  return mix(a, b, u.x) + 
         (c - a)* u.y * (1.0 - u.x) + 
         (d - b) * u.x * u.y;
}

vec4 transition (vec2 uv) { 
  vec4 from = getFromColor(uv); 
  vec4 to = getToColor(uv); 
  float n = noise(uv * scale); 

  float p = mix(-smoothness, 1.0 + smoothness, progress); 
  float lower = p - smoothness; 
  float higher = p + smoothness; 

  float q = smoothstep(lower, higher, n); 

  return mix( 
    from, 
    to, 
    1.0 - q 
  );
}
`, cI = {
  scale: { value: 4, type: "f32" },
  smoothness: { value: 0.01, type: "f32" },
  seed: { value: 12.9898, type: "f32" }
}, hI = `

#define PI 3.14159265358979323846

uniform float spiralTurns;
uniform float spiralWidth;

vec4 transition(vec2 uv) {

    vec2 p = uv - center;

    float r = length(p);
    float angle = atan(p.y, p.x);

    float normalizedAngle = (angle + PI) / (2.0 * PI);

    float spiral = normalizedAngle + r * spiralTurns;
    spiral = fract(spiral);

    float factor = smoothstep(
        progress - spiralWidth,
        progress + spiralWidth,
        spiral
    );
    return mix(
        getToColor(uv),       // ahora aparece primero
        getFromColor(uv),     // aparece despus
        factor
    );
}


`, uI = {
  spiralTurns: { value: 1.5, type: "f32" },
  spiralWidth: { value: 0.02, type: "f32" }
}, dI = `
//direction of movement : 0 : up, 1, down
uniform float direction; // = 1.0 (using float instead of bool for WebGPU)

//luminance threshold
uniform float l_threshold; // = 0.8

//does the movement take effect above or below luminance threshold ?
uniform float above; // = 0.0 (false) (using float instead of bool for WebGPU)

//Random function borrowed from everywhere
float rand(vec2 co){ 
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

// Simplex noise:
// Description : Array and textureless GLSL 2D simplex noise function.
// Author: Ian McEwan, Ashima Arts.
// Maintainer : ijm
// Lastmod: 20110822 (ijm)
// License: MIT
// 2011 Ashima Arts. All rights reserved.
// Distributed under the MIT License. See LICENSE file.
// https://github.com/ashima/webgl-noise

vec3 mod289(vec3 x) { 
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) { 
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) { 
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v) 
{ 
  const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0 
                      0.366025403784439, // 0.5*(sqrt(3.0)-1.0) 
                      -0.577350269189626, // -1.0 + 2.0 * C.x 
                      0.024390243902439); // 1.0 / 41.0
  // First corner 
  vec2 i = floor(v + dot(v, C.yy) ); 
  vec2 x0 = v - i + dot(i, C.xx);

  // Other corners 
  vec2 i1; 
  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0 
  //i1.y = 1.0 - i1.x; 
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); 
  // x0 = x0 - 0.0 + 0.0 * C.xx ; 
  // x1 = x0 - i1 + 1.0 * C.xx ; 
  // x2 = x0 - 1.0 + 2.0 * C.xx ; 
  vec4 x12 = x0.xyxy + C.xxzz; 
  x12.xy -= i1;

  //Permutations 
  i = mod289(i); // Avoid truncation effects in permutation 
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) 
                    + i.x + vec3(0.0, i1.x, 1.0 )); 

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0); 
  m = m*m ; 
  m = m*m ;

  // Gradients: 41 points uniformly over a line, mapped onto a diamond.
  // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287) 

  vec3 x = 2.0 * fract(p * C.www) - 1.0; 
  vec3 h = abs(x) - 0.5; 
  vec3 ox = floor(x + 0.5); 
  vec3 a0 = x - ox;

  // Normalize gradients implicitly by scaling m
  // Approximation of: m *= inversesqrt( a0*a0 + h*h ); 
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

  // Compute final noise value at P 
  vec3 g; 
  g.x = a0.x * x0.x + h.x * x0.y; 
  g.yz = a0.yz * x12.xz + h.yz * x12.yw; 
  return 130.0 * dot(m, g);
}

// Simplex noise -- end

float luminance(vec4 color){ 
  //(0.299*R + 0.587*G + 0.114*B) 
  return color.r*0.299+color.g*0.587+color.b*0.114;
}

vec4 transition(vec2 uv) { 
  vec2 p = uv.xy / vec2(1.0).xy; 
  vec2 center = vec2(1.0, direction);
  
  if (progress == 0.0) { 
    return getFromColor(p); 
  } else if (progress == 1.0) { 
    return getToColor(p); 
  } else { 
    float x = progress; 
    float dist = distance(center, p) - progress*exp(snoise(vec2(p.x, 0.0))); 
    float r = x - rand(vec2(p.x, 0.1)); 
    float m; 
    if(above > 0.5){ 
      m = dist <= r && luminance(getFromColor(p))>l_threshold ? 1.0 : (progress*progress*progress); 
    } 
    else{ 
      m = dist <= r && luminance(getFromColor(p))<l_threshold ? 1.0 : (progress*progress*progress); 
    } 
    return mix(getFromColor(p), getToColor(p), m); 
  }
}
`, fI = {
  direction: { value: 1, type: "f32" },
  // 0.0 = up, 1.0 = down
  l_threshold: { value: 0.8, type: "f32" },
  above: { value: 0, type: "f32" }
  // 0.0 = false (below threshold), 1.0 = true (above threshold)
}, pI = `
uniform int steps; // = 50
uniform float horizontalHexagons; // = 20.0

struct Hexagon { 
  float q; 
  float r; 
  float s;
};

Hexagon createHexagon(float q, float r){ 
  Hexagon hex; 
  hex.q = q; 
  hex.r = r; 
  hex.s = -q - r; 
  return hex;
}

Hexagon roundHexagon(Hexagon hex){ 
  float q = floor(hex.q + 0.5); 
  float r = floor(hex.r + 0.5); 
  float s = floor(hex.s + 0.5); 

  float deltaQ = abs(q - hex.q); 
  float deltaR = abs(r - hex.r); 
  float deltaS = abs(s - hex.s); 

  if (deltaQ > deltaR && deltaQ > deltaS) 
    q = -r - s; 
  else if (deltaR > deltaS) 
    r = -q - s; 
  else 
    s = -q - r; 

  return createHexagon(q, r);
}

Hexagon hexagonFromPoint(vec2 point, float size) { 
  point.y /= ratio; 
  point = (point - 0.5) / size; 

  float q = (sqrt(3.0) / 3.0) * point.x + (-1.0 / 3.0) * point.y; 
  float r = 0.0 * point.x + 2.0/3.0 * point.y; 

  Hexagon hex = createHexagon(q, r); 
  return roundHexagon(hex);
}

vec2 pointFromHexagon(Hexagon hex, float size) { 
  float x = (sqrt(3.0) * hex.q + (sqrt(3.0) / 2.0) * hex.r) * size + 0.5; 
  float y = (0.0 * hex.q + (3.0/2.0) * hex.r) * size + 0.5; 

  return vec2(x, y * ratio);
}

vec4 transition (vec2 uv) { 
  float dist = 2.0 * min(progress, 1.0 - progress); 
  dist = steps > 0 ? ceil(dist * float(steps)) / float(steps) : dist; 

  float size = (sqrt(3.0) / 3.0) * dist / horizontalHexagons; 

  vec2 point = dist > 0.0 ? pointFromHexagon(hexagonFromPoint(uv, size), size) : uv; 

  return mix(getFromColor(point), getToColor(point), progress);
}
`, mI = {
  steps: { value: 50, type: "i32" },
  horizontalHexagons: { value: 20, type: "f32" }
}, gI = `
float inHeart (vec2 p, vec2 center, float size) { 
  if (size==0.0) return 0.0; 
  vec2 o = (p-center)/(1.6*size); 
  o.y = -o.y;
  float a = o.x*o.x+o.y*o.y-0.3; 
  return step(a*a*a, o.x*o.x*o.y*o.y*o.y);
}

vec4 transition (vec2 uv) { 
  return mix( 
    getFromColor(uv), 
    getToColor(uv), 
    inHeart(uv, vec2(0.5, 0.5), progress) 
  );
}
`, xI = {
  // No custom uniforms needed, uses progress from basics
}, yI = `
uniform sampler2D displacementMap;
uniform float strength; // = 0.5

vec4 transition (vec2 uv) { 
  float displacement = texture2D(displacementMap, uv).r * strength; 

  vec2 uvFrom = vec2(uv.x + progress * displacement, uv.y); 
  vec2 uvTo = vec2(uv.x - (1.0 - progress) * displacement, uv.y); 

  return mix( 
    getFromColor(uvFrom), 
    getToColor(uvTo), 
    progress 
  );
}
`, vI = {
  strength: { value: 0.5, type: "f32" }
}, _I = `
uniform vec2 direction; // = vec2(1.0, -1.0)
uniform float smoothness; // = 0.5

// Note: center is already defined as a uniform in the fragment wrapper

vec4 transition (vec2 uv) {
  vec2 v = normalize(direction);
  v /= abs(v.x)+abs(v.y);
  float d = v.x * center.x + v.y * center.y;
  float m = 
    (1.0-step(progress, 0.0)) * // there is something wrong with our formula that makes m not equals 0.0 with progress is 0.0 
    (1.0 - smoothstep(-smoothness, 0.0, v.x * uv.x + v.y * uv.y - (d-0.5+progress*(1.+smoothness)))); 
  return mix(getFromColor(uv), getToColor(uv), m);
}
`, bI = {
  direction: { value: [1, -1], type: "vec2<f32>" },
  smoothness: { value: 0.5, type: "f32" }
}, wI = `
uniform vec2 direction; // = vec2(-1.0, 1.0)

const float smoothness = 0.5;
// Note: center is already defined as a uniform in the fragment wrapper

vec4 transition (vec2 uv) { 
  vec2 v = normalize(direction); 
  v /= abs(v.x) + abs(v.y); 
  float d = v.x * center.x + v.y * center.y; 
  float m = 1.0 - smoothstep(-smoothness, 0.0, v.x * uv.x + v.y * uv.y - (d - 0.5 + progress * (1.0 + smoothness))); 
  return mix(getFromColor((uv - 0.5) * (1.0 - m) + 0.5), getToColor((uv - 0.5) * m + 0.5), m);
}
`, TI = {
  direction: { value: [-1, 1], type: "vec2<f32>" }
}, SI = `
uniform float threshold; // = 3.0
uniform float fadeEdge; // = 0.1

// Note: center is already defined as a uniform in the fragment wrapper

float rand(vec2 co) { 
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec4 transition(vec2 p) { 
  float dist = distance(center, p) / threshold; 
  float r = progress - min(rand(vec2(p.y, 0.0)), rand(vec2(0.0, p.x))); 
  return mix(getFromColor(p), getToColor(p), mix(0.0, mix(step(dist, r), 1.0, smoothstep(1.0-fadeEdge, 1.0, progress)), smoothstep(0.0, fadeEdge, progress)));
}
`, CI = {
  threshold: { value: 3, type: "f32" },
  fadeEdge: { value: 0.1, type: "f32" }
}, AI = `
uniform float smoothness; // = 0.3
uniform float opening; // = 1.0 (using float instead of bool for WebGPU: 1.0 = true, 0.0 = false)

// Note: center is already defined as a uniform in the fragment wrapper
const float SQRT_2 = 1.414213562373;

vec4 transition (vec2 uv) { 
  float x = opening > 0.5 ? progress : 1.0 - progress; 
  float m = smoothstep(-smoothness, 0.0, SQRT_2*distance(center, uv) - x*(1.0+smoothness)); 
  return mix(getFromColor(uv), getToColor(uv), opening > 0.5 ? 1.0 - m : m);
}
`, Qd = {
  smoothness: { value: 0.3, type: "f32" },
  opening: { value: 1, type: "f32" }
  // 1.0 = true (opening), 0.0 = false (closing)
}, II = `
vec4 transition (vec2 uv) {
  if(progress == 0.0){
    return getFromColor(uv);
  }
  vec2 leaf_uv = (uv - vec2(0.5))/10.0/pow(progress,3.5);
  leaf_uv.y = -leaf_uv.y;
  leaf_uv.y += 0.35;
  float r = 0.18;
  float o = atan(leaf_uv.y, leaf_uv.x);
  return mix(getFromColor(uv), getToColor(uv), 1.0-step(1.0 - length(leaf_uv)+r*(1.0+sin(o))*(1.0+0.9 * cos(8.0*o))*(1.0+0.1*cos(24.0*o))*(0.9+0.05*cos(200.0*o)), 1.0));
}
`, kI = {
  // No custom uniforms needed
}, FI = `
uniform float zoom; // = 0.88
uniform float corner_radius; // = 0.22

const vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
const vec2 c00 = vec2(0.0, 0.0);
const vec2 c01 = vec2(0.0, 1.0);
const vec2 c11 = vec2(1.0, 1.0);
const vec2 c10 = vec2(1.0, 0.0);

bool in_corner(vec2 p, vec2 corner, vec2 radius) { 
  vec2 axis = (c11 - corner) - corner; 
  p = p - (corner + axis * radius); 
  p *= axis / radius; 
  return (p.x > 0.0 && p.y > -1.0) || (p.y > 0.0 && p.x > -1.0) || dot(p, p) < 1.0;
}

bool test_rounded_mask(vec2 p, vec2 corner_size) { 
  return 
    in_corner(p, c00, corner_size) && 
    in_corner(p, c01, corner_size) && 
    in_corner(p, c10, corner_size) && 
    in_corner(p, c11, corner_size);
}

vec4 screen(vec4 a, vec4 b) { 
  return 1.0 - (1.0 - a) * (1.0 - b);
}

vec4 unscreen(vec4 c) { 
  return 1.0 - sqrt(1.0 - c);
}

vec4 sample_with_corners_from(vec2 p, vec2 corner_size) { 
  p = (p - 0.5) / zoom + 0.5; 
  if (!test_rounded_mask(p, corner_size)) { 
    return black; 
  } 
  return unscreen(getFromColor(p));
}

vec4 sample_with_corners_to(vec2 p, vec2 corner_size) { 
  p = (p - 0.5) / zoom + 0.5; 
  if (!test_rounded_mask(p, corner_size)) { 
    return black; 
  } 
  return unscreen(getToColor(p));
}

vec4 simple_sample_with_corners_from(vec2 p, vec2 corner_size, float zoom_amt) { 
  p = (p - 0.5) / (1.0 - zoom_amt + zoom * zoom_amt) + 0.5; 
  if (!test_rounded_mask(p, corner_size)) { 
    return black; 
  } 
  return getFromColor(p);
}

vec4 simple_sample_with_corners_to(vec2 p, vec2 corner_size, float zoom_amt) { 
  p = (p - 0.5) / (1.0 - zoom_amt + zoom * zoom_amt) + 0.5; 
  if (!test_rounded_mask(p, corner_size)) { 
    return black; 
  } 
  return getToColor(p);
}

mat3 rotate2d(float angle, float ratio) { 
  float s = sin(angle); 
  float c = cos(angle); 
  return mat3( 
    c, s, 0.0, 
    -s, c, 0.0, 
    0.0, 0.0, 1.0);
}

mat3 translate2d(float x, float y) { 
  return mat3( 
    1.0, 0.0, 0.0, 
    0.0, 1.0, 0.0, 
    -x, -y, 1.0);
}

mat3 scale2d(float x, float y) { 
  return mat3( 
    x, 0.0, 0.0, 
    0.0, y, 0.0, 
    0.0, 0.0, 1.0);
}

// Split an image and rotate one up and one down along off screen pivot points
vec4 get_cross_rotated(vec3 p3, float angle, vec2 corner_size, float ratio) { 
  angle = angle * angle; // easing 
  angle /= 2.4; // works out to be a good number of radians 

  mat3 center_and_scale = translate2d(-0.5, -0.5) * scale2d(1.0, ratio); 
  mat3 unscale_and_uncenter = scale2d(1.0, 1.0/ratio) * translate2d(0.5, 0.5); 
  mat3 slide_left = translate2d(-2.0, 0.0); 
  mat3 slide_right = translate2d(2.0, 0.0); 
  mat3 rotate = rotate2d(angle, ratio); 

  mat3 op_a = center_and_scale * slide_right * rotate * slide_left * unscale_and_uncenter; 
  mat3 op_b = center_and_scale * slide_left * rotate * slide_right * unscale_and_uncenter; 

  vec4 a = sample_with_corners_from((op_a * p3).xy, corner_size); 
  vec4 b = sample_with_corners_from((op_b * p3).xy, corner_size); 

  return screen(a, b);
}

// Image stays put, but this time moves two masks
vec4 get_cross_masked(vec3 p3, float angle, vec2 corner_size, float ratio) { 
  angle = 1.0 - angle; 
  angle = angle * angle; // easing 
  angle /= 2.4; 

  vec4 img; 

  mat3 center_and_scale = translate2d(-0.5, -0.5) * scale2d(1.0, ratio); 
  mat3 unscale_and_uncenter = scale2d(1.0 / zoom, 1.0 / (zoom * ratio)) * translate2d(0.5, 0.5); 
  mat3 slide_left = translate2d(-2.0, 0.0); 
  mat3 slide_right = translate2d(2.0, 0.0); 
  mat3 rotate = rotate2d(angle, ratio); 

  mat3 op_a = center_and_scale * slide_right * rotate * slide_left * unscale_and_uncenter; 
  mat3 op_b = center_and_scale * slide_left * rotate * slide_right * unscale_and_uncenter; 

  bool mask_a = test_rounded_mask((op_a * p3).xy, corner_size); 
  bool mask_b = test_rounded_mask((op_b * p3).xy, corner_size); 

  if (mask_a || mask_b) { 
    img = sample_with_corners_to(p3.xy, corner_size); 
    return screen(mask_a ? img : black, mask_b ? img : black); 
  } else { 
    return black; 
  }
}

vec4 transition(vec2 uv) { 
  float a; 
  vec2 p = uv.xy / vec2(1.0).xy; 
  vec3 p3 = vec3(p.xy, 1.0); 

  vec2 corner_size = vec2(corner_radius / ratio, corner_radius); 

  if (progress <= 0.0) { 
    return getFromColor(p); 
  } else if (progress < 0.1) { 
    a = progress / 0.1; 
    return simple_sample_with_corners_from(p, corner_size * a, a); 
  } else if (progress < 0.48) { 
    a = (progress - 0.1) / 0.38; 
    return get_cross_rotated(p3, a, corner_size, ratio); 
  } else if (progress < 0.9) { 
    return get_cross_masked(p3, (progress - 0.52) / 0.38, corner_size, ratio); 
  } else if (progress < 1.0) { 
    a = (1.0 - progress) / 0.1; 
    return simple_sample_with_corners_to(p, corner_size * a, a); 
  } else { 
    return getToColor(p); 
  }
}
`, MI = {
  zoom: { value: 0.88, type: "f32" },
  corner_radius: { value: 0.22, type: "f32" }
}, EI = `
float random(vec2 co) { 
  float a = 12.9898; 
  float b = 78.233; 
  float c = 43758.5453; 
  float dt = dot(co.xy, vec2(a, b)); 
  float sn = mod(dt, 3.14); 
  return fract(sin(sn) * c);
}

float voronoi(vec2 x) { 
  vec2 p = floor(x); 
  vec2 f = fract(x); 
  float res = 8.0; 
  for(float j = -1.; j <= 1.; j++) 
    for(float i = -1.; i <= 1.; i++) { 
      vec2 b = vec2(i, j); 
      vec2 r = b - f + random(p + b); 
      float d = dot(r, r); 
      res = min(res, d); 
    } 
  return sqrt(res);
}

vec2 displace(vec4 tex, vec2 texCoord, float dotDepth, float textureDepth, float strength) { 
  float b = voronoi(.003 * texCoord + 2.0); 
  float g = voronoi(0.2 * texCoord); 
  float r = voronoi(texCoord - 1.0); 
  vec4 dt = tex * 1.0; 
  vec4 dis = dt * dotDepth + 1.0 - tex * textureDepth; 

  dis.x = dis.x - 1.0 + textureDepth * dotDepth; 
  dis.y = dis.y - 1.0 + textureDepth * dotDepth; 
  dis.x *= strength; 
  dis.y *= strength; 
  vec2 res_uv = texCoord; 
  res_uv.x = res_uv.x + dis.x - 0.0; 
  res_uv.y = res_uv.y + dis.y; 
  return res_uv;
}

float ease1(float t) { 
  return t == 0.0 || t == 1.0 
    ? t 
    : t < 0.5 
    ? +0.5 * pow(2.0, (20.0 * t) - 10.0) 
    : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;
}

float ease2(float t) { 
  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);
}

vec4 transition(vec2 uv) { 
  vec2 p = uv.xy / vec2(1.0).xy; 
  vec4 color1 = getFromColor(p); 
  vec4 color2 = getToColor(p); 
  vec2 disp = displace(color1, p, 0.33, 0.7, 1.0 - ease1(progress)); 
  vec2 disp2 = displace(color2, p, 0.33, 0.5, ease2(progress)); 
  vec4 dColor1 = getToColor(disp); 
  vec4 dColor2 = getFromColor(disp2); 
  float val = ease1(progress); 
  vec3 gray = vec3(dot(min(dColor2, dColor1).rgb, vec3(0.299, 0.587, 0.114))); 
  dColor2 = vec4(gray, 1.0); 
  dColor2 *= 2.0; 
  color1 = mix(color1, dColor2, smoothstep(0.0, 0.5, progress)); 
  color2 = mix(color2, dColor1, smoothstep(1.0, 0.5, progress)); 
  return mix(color1, color2, val); 
}
`, PI = `
uniform float strength; // = 0.4

const float PI = 3.141592653589793;

float Linear_ease(float begin, float change, float duration, float time) { 
  return change * time / duration + begin;
}

float Exponential_easeInOut(float begin, float change, float duration, float time) { 
  if (time == 0.0) 
    return begin; 
  else if (time == duration) 
    return begin + change; 
  time = time / (duration / 2.0); 
  if (time < 1.0) 
    return change / 2.0 * pow(2.0, 10.0 * (time - 1.0)) + begin; 
  return change / 2.0 * (-pow(2.0, -10.0 * (time - 1.0)) + 2.0) + begin;
}

float Sine_easeInOut(float begin, float change, float duration, float time) { 
  return -change / 2.0 * (cos(PI * time / duration) - 1.0) + begin;
}

float rand(vec2 co) { 
  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 crossFade(vec2 uv, float dissolve) { 
  return mix(getFromColor(uv).rgb, getToColor(uv).rgb, dissolve);
}

vec4 transition(vec2 uv) { 
  vec2 texCoord = uv.xy / vec2(1.0).xy; 

  // Linear interpolate center across center half of the image 
  vec2 center = vec2(Linear_ease(0.25, 0.5, 1.0, progress), 0.5); 
  float dissolve = Exponential_easeInOut(0.0, 1.0, 1.0, progress); 

  // Mirrored sine loop. 0->strength then strength->0 
  float strengthValue = Sine_easeInOut(0.0, strength, 0.5, progress); 

  vec3 color = vec3(0.0); 
  float total = 0.0; 
  vec2 toCenter = center - texCoord; 

  /* randomize the lookup values to hide the fixed number of samples */ 
  float offset = rand(uv); 

  for (float t = 0.0; t <= 40.0; t++) { 
    float percent = (t + offset) / 40.0; 
    float weight = 4.0 * (percent - percent * percent); 
    color += crossFade(texCoord + toCenter * percent * strengthValue, dissolve) * weight; 
    total += weight; 
  } 
  return vec4(color / total, 1.0);
}
`, UI = {
  strength: { value: 0.4, type: "f32" }
}, RI = `
uniform float a; // = 4
uniform float b; // = 1
uniform float amplitude; // = 120
uniform float smoothness; // = 0.1

vec4 transition(vec2 uv) { 
  vec2 p = uv.xy / vec2(1.0).xy; 
  vec2 dir = p - vec2(.5); 
  float dist = length(dir); 
  float x = (a - b) * cos(progress) + b * cos(progress * ((a / b) - 1.)); 
  float y = (a - b) * sin(progress) - b * sin(progress * ((a / b) - 1.)); 
  vec2 offset = dir * vec2(sin(progress * dist * amplitude * x), sin(progress * dist * amplitude * y)) / smoothness; 
  return mix(getFromColor(p + offset), getToColor(p), smoothstep(0.2, 1.0, progress));
}
`, BI = {
  a: { value: 4, type: "f32" },
  b: { value: 1, type: "f32" },
  amplitude: { value: 120, type: "f32" },
  smoothness: { value: 0.1, type: "f32" }
}, zI = `
// License: MIT

vec2 bottom_left = vec2(0.0, 1.0);
vec2 bottom_right = vec2(1.0, 1.0);
vec2 top_left = vec2(0.0, 0.0);
vec2 top_right = vec2(1.0, 0.0);

float check(vec2 p1, vec2 p2, vec2 p3)
{
  return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
}

bool PointInTriangle (vec2 pt, vec2 p1, vec2 p2, vec2 p3)
{
    bool b1, b2, b3;
    b1 = check(pt, p1, p2) < 0.0;
    b2 = check(pt, p2, p3) < 0.0;
    b3 = check(pt, p3, p1) < 0.0;
    return ((b1 == b2) && (b2 == b3));
}

bool in_left_triangle(vec2 p){
  vec2 vertex1, vertex2, vertex3;
  vertex1 = vec2(progress, 0.5);
  vertex2 = vec2(0.0, 0.5-progress);
  vertex3 = vec2(0.0, 0.5+progress);
  if (PointInTriangle(p, vertex1, vertex2, vertex3))
  {
    return true;
  }
  return false;
}

bool in_right_triangle(vec2 p){
  vec2 vertex1, vertex2, vertex3;
  vertex1 = vec2(1.0-progress, 0.5);
  vertex2 = vec2(1.0, 0.5-progress);
  vertex3 = vec2(1.0, 0.5+progress);
  if (PointInTriangle(p, vertex1, vertex2, vertex3))
  {
    return true;
  }
  return false;
}

float blur_edge(vec2 bot1, vec2 bot2, vec2 top, vec2 testPt)
{
  vec2 lineDir = bot1 - top;
  vec2 perpDir = vec2(lineDir.y, -lineDir.x);
  vec2 dirToPt1 = bot1 - testPt;
  float dist1 = abs(dot(normalize(perpDir), dirToPt1));
  
  lineDir = bot2 - top;
  perpDir = vec2(lineDir.y, -lineDir.x);
  dirToPt1 = bot2 - testPt;
  float min_dist = min(abs(dot(normalize(perpDir), dirToPt1)), dist1);
  
  if (min_dist < 0.005) {
    return min_dist / 0.005;
  }
  else  {
    return 1.0;
  };
}


vec4 transition (vec2 uv) {
  if (in_left_triangle(uv))
  {
    if (progress < 0.1)
    {
      return getFromColor(uv);
    }
    if (uv.x < 0.5)
    {
      vec2 vertex1 = vec2(progress, 0.5);
      vec2 vertex2 = vec2(0.0, 0.5-progress);
      vec2 vertex3 = vec2(0.0, 0.5+progress);
      return mix(
        getFromColor(uv),
        getToColor(uv),
        blur_edge(vertex2, vertex3, vertex1, uv)
      );
    }
    else
    {
      if (progress > 0.0)
      {
        return getToColor(uv);
      }
      else
      {
        return getFromColor(uv);
      }
    }    
  }
  else if (in_right_triangle(uv))
  {
    if (uv.x >= 0.5)
    {
      vec2 vertex1 = vec2(1.0-progress, 0.5);
      vec2 vertex2 = vec2(1.0, 0.5-progress);
      vec2 vertex3 = vec2(1.0, 0.5+progress);
      return mix(
        getFromColor(uv),
        getToColor(uv),
        blur_edge(vertex2, vertex3, vertex1, uv)
      );  
    }
    else
    {
      return getFromColor(uv);
    }
  }
  else {
    return getFromColor(uv);
  }
}
`, OI = `

const float SQRT_2 = 1.414213562373;
uniform float dots;// = 20.0;

vec4 transition(vec2 uv) {
  bool nextImage = distance(fract(uv * dots), vec2(0.5, 0.5)) < ( progress / distance(uv, center));
  return nextImage ? getToColor(uv) : getFromColor(uv);
}
`, DI = {
  radialSwipe: {
    label: "Radial Swipe",
    fragment: V3
  }
}, ti = {
  ...ei.reduce((i, e) => (i[e.name] = {
    label: e.name,
    fragment: e.glsl,
    uniforms: e.defaultParams,
    previewDynamic: `transition: ${e.name}`
  }, i), {}),
  ...DI
}, hk = Object.entries(ti).map(([i, e]) => ({
  key: i,
  label: e.label,
  previewStatic: `https://cdn.subgen.co/previews/static/transition_${i}_static.webp`,
  previewDynamic: `https://cdn.subgen.co/previews/dynamic/transition_${i}_dynamic.webp`
}));
function eg({ name: i, renderer: e }) {
  let t = ei.find(
    (D) => D.name === i
  );
  if (!t) {
    const D = Object.keys(ti).find(
      (V) => V.toLowerCase() === i.toLowerCase()
    );
    D && (t = ti[D]);
  }
  if (t || (t = ei.find(
    (D) => D.name.toLowerCase() === i.toLowerCase()
  )), !t) {
    const D = [
      i,
      i.toLowerCase(),
      i.charAt(0).toUpperCase() + i.slice(1).toLowerCase(),
      i.replace(/([A-Z])/g, "_$1").toLowerCase().replace(/^_/, ""),
      i.replace(/_/g, "")
    ];
    for (const V of D) {
      if (t = ei.find(
        (_e) => _e.name.toLowerCase() === V.toLowerCase()
      ), t) break;
      const le = Object.keys(ti).find(
        (_e) => _e.toLowerCase() === V.toLowerCase()
      );
      if (le) {
        t = ti[le];
        break;
      }
    }
  }
  if (!t) {
    const D = ei.length, V = ei.slice(0, 5).map((_e) => _e.name).join(", "), le = Object.keys(ti).slice(0, 3).join(", ");
    throw console.error(
      `Transition not found: "${i}". Available in gl-transitions (${D} total):`,
      V + "..."
    ), console.error("Available locally:", le + "..."), new Error(
      `Transition "${i}" not found in gl-transitions library or local definitions`
    );
  }
  const s = new Me(L.WHITE), r = Pe.create({
    width: e.width,
    height: e.height
  }), n = new ft({}), o = new ft({}), a = t.name === "displacement" || i.toLowerCase() === "displacement" || t.label === "displacement", l = a ? new ft({}) : void 0;
  let c = null;
  if (a) {
    c = document.createElement("canvas"), c.width = 256, c.height = 256;
    const D = c.getContext("2d");
    if (D) {
      const V = D.createImageData(256, 256);
      for (let le = 0; le < V.data.length; le += 4) {
        const _e = Math.random();
        V.data[le] = _e * 255, V.data[le + 1] = _e * 255, V.data[le + 2] = _e * 255, V.data[le + 3] = 255;
      }
      D.putImageData(V, 0, 0);
    }
  }
  let h = t.glsl || t.fragment;
  if (!h)
    throw new Error(`Transition "${i}" has no glsl or fragment code`);
  let u = {
    ...te.basics,
    ...te.custom(t)
  };
  Object.entries(u).forEach(([, D]) => {
    D.type === "int<f32>" && (D.type = "i32", typeof D.value == "number" && (D.value = Math.trunc(D.value))), D.type === "ivec2<f32>" && (D.type = "vec2<f32>");
  });
  const d = t.name === "GridFlip" || i.toLowerCase() === "gridflip" || t.label === "gridflip", f = t.name === "circle" || i.toLowerCase() === "circle" || t.label === "circle", m = t.name === "directional" || i.toLowerCase() === "directional" || t.label === "directional", g = t.name === "UndulatingBurnOut" || i.toLowerCase() === "undulatingburnout" || t.label === "undulatingBurnOut", p = t.name === "SquaresWire" || i.toLowerCase() === "squareswire" || t.label === "squaresWire", x = t.name === "rotate_scale_fade" || i.toLowerCase() === "rotatescalefade" || t.label === "rotateScaleFade", y = t.name === "RandomSquares" || i.toLowerCase() === "randomsquares" || t.label === "randomSquares", v = t.name === "polar_function" || i.toLowerCase() === "polar_function" || t.label === "polar_function", _ = t.name === "pixelate" || i.toLowerCase() === "pixelate" || t.label === "pixelate", b = t.name === "perlin" || i.toLowerCase() === "perlin" || t.label === "perlin", T = t.name === "luma" || i.toLowerCase() === "luma" || t.label === "luma", w = t.name === "luminance_melt" || i.toLowerCase() === "luminance_melt" || i.toLowerCase() === "luminancemelt" || t.label === "luminance_melt", A = t.name === "hexagonalize" || i.toLowerCase() === "hexagonalize" || t.label === "hexagonalize", k = t.name === "heart" || i.toLowerCase() === "heart" || t.label === "heart", S = t.name === "displacement" || i.toLowerCase() === "displacement" || t.label === "displacement", C = t.name === "directionalwipe" || i.toLowerCase() === "directionalwipe" || i.toLowerCase() === "directional_wipe" || t.label === "directionalwipe", U = t.name === "directionalwarp" || i.toLowerCase() === "directionalwarp" || i.toLowerCase() === "directional_warp" || t.label === "directionalwarp", R = t.name === "crosshatch" || i.toLowerCase() === "crosshatch" || t.label === "crosshatch", H = t.name === "circleopen" || i.toLowerCase() === "circleopen" || i.toLowerCase() === "circle_open" || t.label === "circleopen", ae = t.name === "cannabisleaf" || i.toLowerCase() === "cannabisleaf" || i.toLowerCase() === "cannabis_leaf" || t.label === "cannabisleaf", M = t.name === "StereoViewer" || i.toLowerCase() === "stereoviewer" || i.toLowerCase() === "stereo_viewer" || t.label === "StereoViewer", E = t.name === "GlitchDisplace" || i.toLowerCase() === "glitchDisplace" || t.label === "GlitchDisplace", j = t.name === "CrossZoom" || i.toLowerCase() === "crosszoom" || t.label === "CrossZoom", B = t.name === "CrazyParametricFun" || i.toLowerCase() === "crazyparametricfun" || t.label === "CrazyParametricFun", X = t.name === "BowTieHorizontal" || i.toLowerCase() === "bowtiehorizontal" || t.label === "BowTieHorizontal", me = t.name === "PolkaDotsCurtain" || i.toLowerCase() === "polkadotscurtain" || t.label === "PolkaDotsCurtain", ee = t.name === "Pixelize" || i.toLowerCase() === "pixelize" || t.label === "Pixelize";
  d && (h = $3, u = {
    ...te.basics,
    ...Y3
  }), f && (h = X3, u = {
    ...te.basics,
    ...Qd
  }), m && (h = q3, u = {
    ...te.basics,
    ...Z3
  }), g && (h = K3, u = {
    ...te.basics,
    ...J3
  }), p && (h = j3, u = {
    ...te.basics,
    ...Q3
  }), x && (h = eI, u = {
    ...te.basics,
    ...tI
  }), y && (h = iI, u = {
    ...te.basics,
    ...sI
  }), v && (h = rI, u = {
    ...te.basics,
    ...nI
  }), _ && (h = Jm, u = {
    ...te.basics,
    ...jm
  }), b && (h = lI, u = {
    ...te.basics,
    ...cI
  }), T && (h = hI, u = {
    ...te.basics,
    ...uI
  }), w && (h = dI, u = {
    ...te.basics,
    ...fI
  }), A && (h = pI, u = {
    ...te.basics,
    ...mI
  }), k && (h = gI, u = {
    ...te.basics,
    ...xI
  }), S && (h = yI, u = {
    ...te.basics,
    ...vI
  }), C && (h = _I, u = {
    ...te.basics,
    ...bI
  }), U && (h = wI, u = {
    ...te.basics,
    ...TI
  }), R && (h = SI, u = {
    ...te.basics,
    ...CI
  }), H && (h = AI, u = {
    ...te.basics,
    ...Qd
  }), ae && (h = II, u = {
    ...te.basics,
    ...kI
  }), M && (h = FI, u = {
    ...te.basics,
    ...MI
  }), E && (h = EI), j && (h = PI, u = {
    ...te.basics,
    ...UI
  }), B && (h = RI, u = {
    ...te.basics,
    ...BI
  }), X && (h = zI), me && (h = OI), ee && (h = oI, u = {
    ...te.basics,
    ...aI
  });
  const ve = {
    from: n,
    to: o,
    uniforms: u
  };
  a && l && (ve.displacementMap = l, c && (l.resource = c, l.update()));
  const Ce = new mr({
    glProgram: new xi({
      vertex: G3,
      fragment: W3(h)
    }),
    resources: ve
  });
  return s.filters = [Ce], {
    render({ width: D, height: V, from: le, to: _e, progress: Xt }) {
      if ((s.width !== D || s.height !== V) && (s.setSize({ width: D, height: V }), r.resize(D, V)), le instanceof L ? Ce.resources.from = le.source : (n.resource = le, n.update(), Ce.resources.from = n), _e instanceof L ? Ce.resources.to = _e.source : (o.resource = _e, o.update(), Ce.resources.to = o), a && l && c) {
        if (c.width !== D || c.height !== V) {
          c.width = D, c.height = V;
          const wt = c.getContext("2d");
          if (wt) {
            const ot = wt.createImageData(D, V);
            for (let Be = 0; Be < ot.data.length; Be += 4) {
              const Je = Math.random();
              ot.data[Be] = Je * 255, ot.data[Be + 1] = Je * 255, ot.data[Be + 2] = Je * 255, ot.data[Be + 3] = 255;
            }
            wt.putImageData(ot, 0, 0);
          }
        }
        l.resource = c, l.update();
      }
      return Ce.resources.uniforms.uniforms.progress = Xt, e.render({
        container: s,
        target: r,
        clear: !1,
        width: D,
        height: V
      }), r;
    },
    destroy() {
      r.destroy(), s.destroy({ children: !0 });
    }
  };
}
let LI = 0;
async function tg(i) {
  i() > 50 && (await iu(15), await tg(i));
}
class uk extends su {
  /**
   * Check compatibility with the current environment
   * @param args.videoCodec Specify video codec, default avc1.42E032
   * @param args.width Specify video width, default 1920
   * @param args.height Specify video height, default 1080
   * @param args.bitrate Specify video bitrate, default 5e6
   */
  static async isSupported(e = {}) {
    return (self.OffscreenCanvas != null && self.VideoEncoder != null && self.VideoDecoder != null && self.VideoFrame != null && self.AudioEncoder != null && self.AudioDecoder != null && self.AudioData != null && ((await self.VideoEncoder.isConfigSupported({
      codec: e.videoCodec ?? "avc1.42E032",
      width: e.width ?? 1920,
      height: e.height ?? 1080,
      bitrate: e.bitrate ?? 7e6
    })).supported ?? !1) && (await self.AudioEncoder.isConfigSupported({
      codec: (await Ru()).codec,
      sampleRate: ie.sampleRate,
      numberOfChannels: ie.channelCount
    })).supported) ?? !1;
  }
  logger = K.create(`id:${LI++},`);
  destroyed = !1;
  sprites = [];
  canvas;
  pixiApp = null;
  // Stop output
  stopOutput = null;
  opts;
  hasVideoTrack;
  /**
   * Create a compositor instance based on configuration
   * @param opts ICompositorOpts
   */
  constructor(e = {}) {
    super();
    const { width: t = 0, height: s = 0 } = e;
    this.canvas = new OffscreenCanvas(t, s), this.opts = Object.assign(
      {
        bgColor: "#000",
        width: 0,
        height: 0,
        videoCodec: "avc1.42E032",
        audio: !0,
        bitrate: 5e6,
        fps: 30,
        metaDataTags: null
      },
      e
    ), this.hasVideoTrack = t * s > 0, Ru().catch((r) => {
      this.logger.warn("Failed to detect audio codec:", r);
    });
  }
  async initPixiApp() {
    const { width: e, height: t } = this.opts;
    if (this.pixiApp = new cu(), await this.pixiApp.init({
      canvas: this.canvas,
      width: e,
      height: t,
      backgroundColor: 0,
      antialias: !1,
      autoDensity: !1,
      resolution: 1,
      preference: "webgl"
      // Force WebGL to avoid WebGPU overhead/failures in Docker
    }), this.pixiApp.renderer == null || this.pixiApp.stage == null)
      throw new Error("Pixi.js Application failed to initialize properly");
    try {
      const s = this.pixiApp;
      s.ticker && typeof s.ticker.stop == "function" && s.ticker.stop();
    } catch {
    }
  }
  /**
   * Add a clip for video composition. Video duration defaults to the maximum duration value from all clips
   * @param clip Clip (extends BaseSprite)
   * @param opts.main If main is true, the video duration uses this clip's duration value
   */
  async addSprite(e, t = {}) {
    const s = {
      rect: {
        x: e.left,
        y: e.top,
        w: e.width,
        h: e.height
      },
      display: { ...e.display },
      duration: e.duration,
      playbackRate: e.playbackRate,
      zIndex: e.zIndex
    };
    this.logger.info("Compositor add clip", s);
    const r = await e.clone();
    this.pixiApp != null && this.pixiApp.renderer != null && typeof r.setRenderer == "function" && r.setRenderer(this.pixiApp.renderer), this.logger.info("Compositor add clip ready"), this.sprites.push(
      Object.assign(r, {
        main: t.main ?? !1,
        expired: !1
      })
    ), this.sprites.sort((n, o) => n.zIndex - o.zIndex);
  }
  initMuxer(e) {
    const { fps: t, width: s, height: r, videoCodec: n, bitrate: o, audio: a, metaDataTags: l } = this.opts, c = this.sprites.some(
      (d) => d.width > 0 && d.height > 0
    ), h = this.hasVideoTrack && c;
    return __({
      video: h ? {
        width: s,
        height: r,
        expectFPS: t,
        codec: n,
        bitrate: o,
        __unsafe_hardwareAcceleration__: this.opts.__unsafe_hardwareAcceleration__
      } : null,
      audio: a === !1 ? null : {
        codec: ie.codecType,
        sampleRate: ie.sampleRate,
        channelCount: ie.channelCount
      },
      duration: e,
      metaDataTags: l
    });
  }
  /**
   * Output video file binary stream
   * @param opts.maxTime Maximum duration allowed for output video, content exceeding this will be ignored
   */
  output(e = {}) {
    if (this.sprites.length === 0) throw Error("No sprite added");
    const t = this.sprites.find((u) => u.main), r = this.sprites.map((u) => u.display.from + u.duration).filter((u) => u !== 1 / 0), n = e.maxTime ?? (t != null ? t.display.from + t.duration : r.length > 0 ? Math.max(...r) : 1 / 0);
    if (n === 1 / 0 || n <= 0)
      throw Error(
        "Unable to determine the end time, please specify a main sprite, or limit the duration of ImageClip, AudioClip"
      );
    n === -1 && this.logger.warn(
      "Unable to determine the end time, process value don't update"
    ), this.logger.info(`start combinate video, maxTime:${n}`);
    const o = this.initMuxer(n);
    let a = performance.now();
    const l = this.runEncoding(o, n, {
      onProgress: (u) => {
        this.logger.debug("OutputProgress:", u), this.emit("OutputProgress", u);
      },
      onEnded: async () => {
        await o.flush(), this.logger.info(
          "===== output ended =====, cost:",
          performance.now() - a
        ), this.emit("OutputProgress", 1), this.destroy();
      },
      onError: (u) => {
        this.emit("error", u), h(u), this.destroy();
      }
    });
    this.stopOutput = () => {
      l(), o.close(), h();
    };
    const { stream: c, stop: h } = Zm(
      o.mp4file,
      500,
      this.destroy
    );
    return c;
  }
  /**
   * Destroy instance and release resources
   */
  destroy() {
    if (!this.destroyed && (this.destroyed = !0, this.stopOutput?.(), this.off("OutputProgress"), this.off("error"), this.pixiApp != null))
      try {
        const e = this.pixiApp;
        if (e.destroyed === !0) {
          this.pixiApp = null;
          return;
        }
        if (e.ticker && typeof e.ticker.stop == "function")
          try {
            e.ticker.stop();
          } catch {
          }
        if (e.renderer != null) {
          const t = e.renderer.gl;
          if (t && t.isContextLost()) {
            this.pixiApp = null;
            return;
          }
          this.pixiApp.destroy();
        }
      } catch (e) {
        console.warn("Error while destroying Pixi application:", e);
      } finally {
        this.pixiApp = null;
      }
  }
  runEncoding(e, t, {
    onProgress: s,
    onEnded: r,
    onError: n
  }) {
    let o = 0;
    const a = { aborted: !1 };
    let l = null, c = null;
    const h = async () => {
      const { fps: f, bgColor: m, audio: g } = this.opts, p = Math.round(1e6 / f), x = this.sprites.some(
        (_) => _.width > 0 && _.height > 0
      );
      c = NI({
        pixiApp: this.pixiApp,
        sprites: this.sprites,
        aborter: a
      });
      const y = GI({
        muxer: e,
        canvas: this.canvas,
        outputAudio: g,
        hasVideoTrack: this.hasVideoTrack && x,
        timeSlice: p,
        fps: f
      });
      let v = 0;
      for (; ; ) {
        if (l != null) return;
        if (a.aborted || t !== -1 && v > t || this.sprites.length === 0) {
          u(), await r();
          return;
        }
        o = v / t;
        const { audios: _, mainSprDone: b, hasVideo: T } = await c.render(v);
        if (b) {
          u(), await r();
          return;
        }
        if (a.aborted) return;
        this.hasVideoTrack && T && await new Promise((w) => requestAnimationFrame(w)), y(v, _, T), v += p, await tg(e.getEncodeQueueSize);
      }
    }, u = () => {
      a.aborted || (a.aborted = !0, clearInterval(d), c?.cleanup(), this.sprites.forEach((f) => {
        f.destroy();
      }));
    };
    h().catch((f) => {
      l = f, this.logger.error(f), u(), n(f);
    });
    const d = setInterval(() => {
      s(o);
    }, 500);
    return u;
  }
  /**
   * Export current compositor state to JSON
   */
  exportToJSON() {
    const e = this.sprites.map((s) => Zs(s, s.main)), t = [];
    return this.sprites.forEach((s) => {
      if (s.transition) {
        const r = this.sprites.filter(
          (n) => n.id !== s.id && n.zIndex === s.zIndex && n.display.from < s.display.from && (n instanceof xe || n instanceof Se)
        ).sort((n, o) => o.display.to - n.display.to)[0];
        r && t.push({
          key: s.transition.name,
          duration: s.transition.duration,
          clips: [r.id, s.id]
        });
      }
    }), {
      clips: e,
      settings: {
        width: this.opts.width,
        height: this.opts.height,
        fps: this.opts.fps,
        bgColor: this.opts.bgColor,
        videoCodec: this.opts.videoCodec,
        bitrate: this.opts.bitrate,
        audio: this.opts.audio,
        metaDataTags: this.opts.metaDataTags
      }
    };
  }
  /**
   * Load clips from JSON
   * @param json The JSON project data
   */
  async loadFromJSON(e) {
    this.sprites.forEach((t) => {
      t.destroy();
    }), this.sprites = [], e.settings && (e.settings.width !== void 0 && (this.opts.width = e.settings.width), e.settings.height !== void 0 && (this.opts.height = e.settings.height), e.settings.fps !== void 0 && (this.opts.fps = e.settings.fps), e.settings.bgColor !== void 0 && (this.opts.bgColor = e.settings.bgColor), e.settings.videoCodec !== void 0 && (this.opts.videoCodec = e.settings.videoCodec), e.settings.bitrate !== void 0 && (this.opts.bitrate = e.settings.bitrate), e.settings.audio !== void 0 && (this.opts.audio = e.settings.audio === !1 ? !1 : void 0), e.settings.metaDataTags !== void 0 && (this.opts.metaDataTags = e.settings.metaDataTags));
    for (const t of e.clips) {
      const s = await Ks(t);
      if (await this.addSprite(s, { main: t.main || !1 }), t.type === "Transition") {
        const r = t.toClipId, n = this.sprites.find((o) => o.id === r);
        n ? n.transition = {
          name: t.transitionEffect.key,
          duration: t.duration,
          prevClipId: t.fromClipId || ""
        } : console.warn(
          `[Compositor] Could not find target clip ${r} for transition ${t.transitionEffect.key}`
        );
      }
    }
  }
}
function NI(i) {
  const { pixiApp: e, sprites: t, aborter: s } = i, r = e != null, n = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), l = Pe.create({
    width: e?.renderer.width || 0,
    height: e?.renderer.height || 0
  }), c = Pe.create({
    width: e?.renderer.width || 0,
    height: e?.renderer.height || 0
  }), h = new fe().rect(0, 0, e?.renderer.width || 0, e?.renderer.height || 0).fill({ color: 0 }), u = /* @__PURE__ */ new Map(), d = (b) => t.filter(
    (T) => T.id !== b.id && T.zIndex === b.zIndex && // SAME TRACK
    T.display.from < b.display.from && (T instanceof xe || T instanceof Se)
  ).sort((T, w) => w.display.to - T.display.to)[0] || null, f = async (b, T, w) => {
    let A = null;
    if (b.transition?.prevClipId && (A = t.find((U) => U.id === b.transition.prevClipId) || null), A || (A = d(b)), !A) return null;
    const k = A.duration > 0 ? A.duration : 0, S = Math.max(
      0,
      Math.min(T - A.display.from, k)
    ), { video: C } = await w(A, S);
    return C;
  }, m = (b, T, w) => {
    if (!e) return;
    e.renderer.render({
      container: h,
      target: w,
      clear: !0
    });
    const A = new Me(
      T instanceof L ? T : L.from(T)
    );
    A.x = b.center.x, A.y = b.center.y, A.anchor.set(0.5, 0.5);
    const k = A.texture.width || 1, S = A.texture.height || 1, C = b.width && b.width !== 0 ? Math.abs(b.width) / k : 1, U = b.height && b.height !== 0 ? Math.abs(b.height) / S : 1;
    b.flip === "horizontal" ? (A.scale.x = -C, A.scale.y = U) : b.flip === "vertical" ? (A.scale.x = C, A.scale.y = -U) : (A.scale.x = C, A.scale.y = U), A.rotation = (b.flip == null ? 1 : -1) * b.angle, A.alpha = b.opacity;
    const R = b.style || {}, H = R.borderRadius || 0;
    let ae = null;
    H > 0 && (ae = new fe(), ae.roundRect(
      -k / 2,
      -S / 2,
      k,
      S,
      Math.min(H, k / 2, S / 2)
    ), ae.fill({ color: 16777215, alpha: 1 }), A.addChild(ae), A.mask = ae);
    const M = R.stroke;
    let E = null;
    if (M && M.width > 0) {
      E = new fe();
      const X = ge(M.color) ?? 16777215, me = M.width;
      if (E.setStrokeStyle({
        width: me,
        color: X,
        alignment: 1
      }), H > 0) {
        const ee = Math.min(H, k / 2, S / 2);
        E.roundRect(
          -k / 2,
          -S / 2,
          k,
          S,
          ee
        );
      } else
        E.rect(
          -k / 2,
          -S / 2,
          k,
          S
        );
      E.stroke(), A.addChild(E);
    }
    const j = R.dropShadow;
    let B = null;
    if (j && (j.blur > 0 || j.distance > 0)) {
      B = new fe();
      const X = ge(j.color) ?? 0, me = j.alpha ?? 0.5, ee = j.distance ?? 0, ve = j.angle ?? 0, Ce = Math.cos(ve) * ee, D = Math.sin(ve) * ee;
      if (H > 0) {
        const V = Math.min(H, k / 2, S / 2);
        B.roundRect(
          -k / 2 + Ce,
          -S / 2 + D,
          k,
          S,
          V
        );
      } else
        B.rect(
          -k / 2 + Ce,
          -S / 2 + D,
          k,
          S
        );
      B.fill({ color: X, alpha: me }), A.addChildAt(B, 0);
    }
    e.renderer.render({
      container: A,
      target: w,
      clear: !1
    }), T instanceof L || A.texture.destroy(!0), E && E.destroy(), ae && ae.destroy(), B && B.destroy(), A.destroy();
  };
  let g = null, p = null, x = null;
  r && e != null && (g = new oe(), p = new oe(), x = new oe(), p.sortableChildren = !0, x.sortableChildren = !0, e.stage.addChild(p), e.stage.addChild(x), g.visible = !1, e.stage.addChild(g));
  const y = [...t].sort((b, T) => b.zIndex - T.zIndex);
  return { render: async (b) => {
    const T = [];
    let w = !1, A = !1;
    const k = /* @__PURE__ */ new Map(), S = async (C, U) => {
      const R = `${C.id}_${U}`;
      if (k.has(R)) return k.get(R);
      const H = await C.getFrame(U);
      return k.set(R, H), H;
    };
    for (const C of a.values())
      C.visible = !1;
    for (const C of y) {
      if (s.aborted) break;
      if (b < C.display.from || C.expired) {
        if (r && e != null) {
          const E = n.get(C);
          E && await E.updateFrame(null);
        }
        continue;
      }
      const U = b - C.display.from, R = U * C.playbackRate;
      C.animate(R);
      const { video: H, audio: ae, done: M } = await S(C, U);
      if (T.push(ae), r && e != null && p != null) {
        if ((C instanceof xe || C instanceof Se) && C.transition && U >= 0 && U <= C.transition.duration) {
          const B = await f(
            C,
            b,
            S
          ), X = H;
          if (B && X) {
            const me = U / C.transition.duration, ee = d(C);
            ee ? m(
              ee,
              B,
              l
            ) : e.renderer.render({
              container: h,
              target: l,
              clear: !0
            }), m(C, X, c);
            let ve = o.get(C.id);
            ve || (ve = eg({
              name: C.transition.name,
              renderer: e.renderer
            }), o.set(C.id, ve));
            const Ce = ve.render({
              width: e.renderer.width,
              height: e.renderer.height,
              from: l,
              to: c,
              progress: me
            });
            let D = a.get(C.id);
            D || (D = new Me(), D.label = `TransitionSprite_${C.id}`, a.set(C.id, D), p.addChild(D)), D.texture = Ce, D.visible = !0, D.x = 0, D.y = 0, D.width = e.renderer.width, D.height = e.renderer.height, D.anchor.set(0, 0), D.zIndex = C.zIndex, A = !0;
            const V = n.get(C);
            if (V) {
              const le = V.getRoot();
              le && (le.visible = !1);
            }
            if (ee) {
              const le = n.get(ee);
              if (le) {
                const _e = le.getRoot();
                _e && (_e.visible = !1);
              }
            }
            continue;
          }
        }
        let j = n.get(C);
        j == null && H != null && (j = new qs(
          e,
          C,
          p
        ), n.set(C, j)), j != null && (H != null ? (A = !0, await j.updateFrame(H)) : await j.updateFrame(null)), j?.updateTransforms();
      }
      if (C.duration > 0 && b > C.display.from + C.duration || M) {
        if (C.main && (w = !0), C.expired = !0, r) {
          const E = n.get(C);
          if (E != null) {
            const j = E.getRoot();
            j && (j.visible = !1);
          }
        }
      } else if (r) {
        const E = n.get(C);
        E?.updateTransforms();
      }
    }
    if (r && e != null && g != null && p != null && x != null) {
      let C = null;
      for (const U of t)
        if (U instanceof tt && b >= U.display.from && b < U.display.from + U.duration) {
          C = {
            id: U.id,
            key: U.effect.key,
            startTime: U.display.from,
            duration: U.duration
          };
          break;
        }
      if (!C)
        for (const U of t) {
          if (U.effects && U.effects.length > 0) {
            for (const R of U.effects)
              if (b >= R.startTime && b < R.startTime + R.duration) {
                C = R;
                break;
              }
          }
          if (C) break;
        }
      x.removeChildren();
      for (const U of n.values()) {
        const R = U.getRoot();
        R && R.parent !== p && (R.parent && R.parent.removeChild(R), p.addChild(R));
      }
      if (C) {
        const { key: U, startTime: R, duration: H, id: ae } = C, M = b - R, E = H > 0 ? Math.min(Math.max(M / H, 0), 1) : 0, j = t.some(
          (B) => B.id === ae && B instanceof tt
        );
        for (const B of t) {
          let X = !1;
          if (j ? X = B.id !== ae && !(B instanceof tt) : X = !!B.effects && B.effects.some((me) => me.id === ae), X) {
            const me = n.get(B);
            if (me) {
              const ee = me.getRoot();
              ee && (ee.parent && ee.parent.removeChild(ee), g.addChild(ee));
            }
          }
        }
        if (g.children.length > 0) {
          let B = u.get(ae);
          if (!B)
            try {
              const X = Qm({
                name: U,
                renderer: e.renderer
              });
              X && X.filter && (B = { filter: X.filter, render: X.render }, u.set(ae, B));
            } catch (X) {
              console.warn("Failed to create effect", U, X);
            }
          if (B) {
            const { filter: X, render: me } = B;
            X.resources && X.resources.effectUniforms && (X.resources.effectUniforms.uniforms.uTime = E);
            const ee = e.renderer.width, ve = e.renderer.height, Ce = Pe.create({ width: ee, height: ve });
            if (g.visible = !0, e.renderer.render({
              container: g,
              target: Ce,
              clear: !0
            }), g.visible = !1, me) {
              const D = me({
                canvasTexture: Ce,
                progress: E,
                width: ee,
                height: ve
              }), V = new Me(D);
              V.width = ee, V.height = ve, x.addChild(V);
            }
          }
        }
      }
    }
    return r && e != null && e.render(), {
      audios: T,
      mainSprDone: w,
      hasVideo: A
    };
  }, cleanup: () => {
    l && l.destroy(!0), c && c.destroy(!0), h && h.destroy(!0);
    for (const b of a.values())
      b.destroy();
    a.clear(), o.clear(), g && g.destroy({ children: !0 }), p && p.destroy({ children: !0 }), x && x.destroy({ children: !0 }), n.forEach((b) => {
      b.destroy();
    }), n.clear();
  } };
}
function GI(i) {
  const { canvas: e, outputAudio: t, muxer: s, hasVideoTrack: r, timeSlice: n } = i;
  let o = 0;
  const a = Math.floor(3 * i.fps), l = HI(1024);
  return (c, h, u) => {
    if (t !== !1)
      for (const d of l(c, h))
        s.encodeAudio(d);
    if (r && u)
      try {
        const d = new VideoFrame(e, {
          duration: n,
          timestamp: c
        });
        s.encodeVideo(d, {
          keyFrame: o % a === 0
        }), o += 1;
      } catch (d) {
        console.warn(
          "Failed to create VideoFrame from canvas, skipping frame:",
          d
        );
      }
  };
}
function HI(i) {
  const e = i * ie.channelCount, t = new Float32Array(e * 3);
  let s = 0, r = 0;
  const n = i / ie.sampleRate * 1e6, o = new Float32Array(e), a = (l) => {
    let c = 0;
    const h = Math.floor(s / e), u = [];
    for (let d = 0; d < h; d++)
      u.push(
        new AudioData({
          timestamp: r,
          numberOfChannels: ie.channelCount,
          numberOfFrames: i,
          sampleRate: ie.sampleRate,
          format: "f32",
          data: t.subarray(c, c + e)
        })
      ), c += e, r += n;
    for (t.set(t.subarray(c, s), 0), s -= c; l - r > n; )
      u.push(
        new AudioData({
          timestamp: r,
          numberOfChannels: ie.channelCount,
          numberOfFrames: i,
          sampleRate: ie.sampleRate,
          format: "f32",
          data: o
        })
      ), r += n;
    return u;
  };
  return (l, c) => {
    const h = Math.max(...c.map((u) => u[0]?.length ?? 0));
    for (let u = 0; u < h; u++) {
      let d = 0, f = 0;
      for (let m = 0; m < c.length; m++) {
        const g = c[m][0]?.[u] ?? 0, p = c[m][1]?.[u] ?? g;
        d += g, f += p;
      }
      t[s] = d, t[s + 1] = f, s += 2;
    }
    return a(l);
  };
}
class WI extends fe {
  constructor() {
    super(), this.eventMode = "static", this.cursor = "move";
  }
  draw(e, t = 1) {
    const r = 1.5 * t;
    this.clear(), this.setStrokeStyle({ width: r, color: 165063 }).rect(e.x, e.y, e.width, e.height).stroke(), this.hitArea = e;
  }
}
class gt extends fe {
  #e = !1;
  handle;
  cursor;
  callbacks;
  constructor(e, t, s) {
    super(), this.handle = e, this.cursor = t, this.callbacks = s, this.eventMode = "static", this.#a(), this.on("pointerdown", this.#i), this.on("globalpointermove", this.#r), this.on("pointerup", this.#l), this.on("pointerupoutside", this.#l);
  }
  #a() {
    this.clear();
    const e = 165063;
    if (this.handle === "rot")
      this.circle(0, 0, 8), this.fill({ color: "#ffffff" }), this.stroke({ width: 1, color: 13421772 }), this.moveTo(0, -4), this.arc(0, 0, 4, -Math.PI / 2, Math.PI, !1), this.stroke({ width: 1, color: 0 }), this.moveTo(0, -8), this.lineTo(-3, -5), this.lineTo(0, -2), this.stroke({ width: 1, color: 0, cap: "round", join: "round" }), this.hitArea = new xr(0, 0, 24);
    else if (["ml", "mr", "mt", "mb"].includes(this.handle)) {
      const t = this.handle === "ml" || this.handle === "mr", s = t ? 6 : 24, r = t ? 24 : 6;
      this.roundRect(-s / 2, -r / 2, s, r, 3), this.fill({ color: "#ffffff" }), this.stroke({ width: 1, color: e }), this.hitArea = new G(-15, -15, 30, 30);
    } else
      this.rect(-4, -4, 8, 8), this.fill({ color: "#ffffff" }), this.stroke({ width: 1, color: e }), this.hitArea = new G(-15, -15, 30, 30);
  }
  #i = (e) => {
    this.#e = !0, this.cursor = "grabbing", this.callbacks.beginDrag(this.handle, e.global), e.stopPropagation();
  };
  #r = (e) => {
    this.#e && (this.callbacks.updateDrag(this.handle, e.global), e.stopPropagation());
  };
  #l = (e) => {
    this.#e && (this.#e = !1, this.cursor = "pointer", this.callbacks.endDrag(), e.stopPropagation());
  };
}
const ef = {
  delta: new W()
};
class VI extends oe {
  group;
  wireframe = new WI();
  selectionOutlines = new fe();
  isDragging = !1;
  lastPointer = new q();
  activeHandle = null;
  #e;
  #a = /* @__PURE__ */ new Map();
  #i = new q();
  #r = 0;
  #l = 0;
  #c = new G();
  #s = new q();
  #h = new G();
  // Reusable points for selection bounds calculation to avoid GC
  #t = [new q(), new q(), new q(), new q()];
  #n = 1;
  #o = 1;
  opts;
  constructor(e) {
    super(), this.opts = e, this.group = e.group, this.eventMode = "static";
    const t = {
      beginDrag: (s, r) => this.#_(s, r),
      updateDrag: (s, r) => this.#b(s, r),
      endDrag: () => this.#m()
    };
    this.#e = {
      tl: new gt("tl", "nwse-resize", t),
      tr: new gt("tr", "nesw-resize", t),
      bl: new gt("bl", "nesw-resize", t),
      br: new gt("br", "nwse-resize", t),
      ml: new gt("ml", "ew-resize", t),
      mr: new gt("mr", "ew-resize", t),
      mt: new gt("mt", "ns-resize", t),
      mb: new gt("mb", "ns-resize", t),
      rot: new gt("rot", "crosshair", {
        beginDrag: (s, r) => this.#T(r),
        updateDrag: (s, r) => this.#S(r),
        endDrag: () => this.#m()
      })
    }, this.addChild(
      this.selectionOutlines,
      this.wireframe,
      ...Object.values(this.#e)
    ), this.#x(), zi.shared.addOnce(() => {
      !this.destroyed && this.parent && this.#u();
    });
  }
  #x() {
    this.on("pointerdown", this.#y), this.on("pointerup", this.#p), this.on("pointerupoutside", this.#p), this.on("globalpointermove", this.#v);
  }
  #u() {
    if (this.group.length === 1) {
      const e = this.group[0];
      this.#r = e.rotation;
      const t = this.#f(e);
      let s, r;
      this.opts.clip ? (s = this.opts.clip.width, r = this.opts.clip.height) : (s = t.width, r = t.height);
      const n = e.toGlobal(new q(0, 0));
      this.#i.set(n.x, n.y), this.#h.copyFrom(
        new G(-s / 2, -r / 2, s, r)
      );
    } else {
      let e = 1 / 0, t = 1 / 0, s = -1 / 0, r = -1 / 0;
      if (this.parent)
        for (const c of this.group) {
          const h = this.#f(c);
          this.#t[0].set(h.x, h.y), this.#t[1].set(h.x + h.width, h.y), this.#t[2].set(h.x + h.width, h.y + h.height), this.#t[3].set(h.x, h.y + h.height);
          for (const u of this.#t)
            c.toGlobal(u, u), this.toLocal(u, void 0, u), e = Math.min(e, u.x), t = Math.min(t, u.y), s = Math.max(s, u.x), r = Math.max(r, u.y);
        }
      const n = s - e, o = r - t, a = e + n / 2, l = t + o / 2;
      if (this.#h.copyFrom(new G(-n / 2, -o / 2, n, o)), this.parent) {
        const c = this.toGlobal(
          new q(a, l)
        );
        this.#i.set(c.x, c.y);
      }
    }
    this.#d();
  }
  /**
   * Helper to compute bounds of a container excluding children labeled "ShadowContainer"
   */
  #f(e) {
    const t = e.children.filter(
      (l) => l.label !== "ShadowContainer"
    );
    if (t.length === 0) {
      const l = e.getLocalBounds();
      return new G(l.minX, l.minY, l.maxX - l.minX, l.maxY - l.minY);
    }
    const s = t.find((l) => l.label === "MainSprite");
    if (s) {
      const l = s.getLocalBounds(), c = s.localTransform, h = c.apply(new q(l.x, l.y)), u = c.apply(new q(l.x + l.width, l.y)), d = c.apply(new q(l.x + l.width, l.y + l.height)), f = c.apply(new q(l.x, l.y + l.height)), m = Math.min(h.x, u.x, d.x, f.x), g = Math.max(h.x, u.x, d.x, f.x), p = Math.min(h.y, u.y, d.y, f.y), x = Math.max(h.y, u.y, d.y, f.y);
      return new G(m, p, g - m, x - p);
    }
    let r = 1 / 0, n = 1 / 0, o = -1 / 0, a = -1 / 0;
    for (const l of t) {
      const c = l.getBounds(), h = e.toLocal(new q(c.minX, c.minY)), u = e.toLocal(new q(c.maxX, c.maxY));
      r = Math.min(r, h.x, u.x), n = Math.min(n, h.y, u.y), o = Math.max(o, h.x, u.x), a = Math.max(a, h.y, u.y);
    }
    return new G(r, n, o - r, a - n);
  }
  /**
   * Public method to update transformer bounds without recreating it
   * Useful for updating bounds after clip dimensions change
   */
  updateBounds() {
    this.#u();
  }
  #y = (e) => {
    this.#u(), this.isDragging = !0, this.lastPointer.copyFrom(e.global), this.cursor = "grabbing";
  };
  #p = () => {
    this.isDragging && this.emit("transformEnd"), this.isDragging = !1, this.activeHandle = null, this.cursor = "default";
  };
  #v = (e) => {
    if (!this.isDragging || this.activeHandle || !this.parent) return;
    const t = this.parent.toLocal(this.lastPointer), s = this.parent.toLocal(e.global), r = s.x - t.x, n = s.y - t.y;
    for (const l of this.group)
      l.x += r, l.y += n;
    const o = e.global.x - this.lastPointer.x, a = e.global.y - this.lastPointer.y;
    this.#i.x += o, this.#i.y += a, this.lastPointer.copyFrom(e.global), this.#d(), this.emit("transforming");
  };
  #_(e, t) {
    this.#u(), this.isDragging = !0, this.activeHandle = e, this.#a.clear();
    for (const s of this.group)
      this.#a.set(s, s.localTransform.clone());
    this.rotation = this.#r, this.#c.copyFrom(this.#h), this.#A(e);
  }
  #b(e, t) {
    this.#w(e, t);
  }
  async #w(e, t) {
    const s = this.#s, r = this.#I(
      e,
      this.toLocal(t),
      s
    ), n = r.width / this.#c.width, o = r.height / this.#c.height, a = this.toGlobal(s);
    if (this.opts.clip && this.opts.clip.type === "Text") {
      const c = r.width;
      this.emit("textClipResize", {
        handle: e,
        newWidth: c,
        newHeight: r.height,
        pivotWorld: a,
        proposed: r,
        sx: n,
        sy: o
      });
    } else
      this.#g(this.#k(a, this.#r, n, o));
    this.#h.copyFrom(r), this.#d(), this.emit("transforming");
  }
  #T(e) {
    this.#u(), this.isDragging = !0, this.activeHandle = "rot", this.#a.clear();
    for (const t of this.group)
      this.#a.set(t, t.localTransform.clone());
    this.#l = Math.atan2(
      e.y - this.#i.y,
      e.x - this.#i.x
    );
  }
  #S(e) {
    const s = Math.atan2(
      e.y - this.#i.y,
      e.x - this.#i.x
    ) - this.#l, r = this.#r + s;
    this.#g(this.#F(this.#i, s)), this.rotation = r, this.#d(r), this.emit("transforming");
  }
  #m() {
    this.isDragging = !1, this.#r = this.rotation, this.activeHandle = null, this.#d(this.#r), this.emit("transformEnd");
  }
  #d(e = this.#r) {
    this.parent && this.position.copyFrom(this.parent.toLocal(this.#i)), this.rotation = e;
    const s = 1 / ((this.parent ? Math.abs(this.parent.worldTransform.a) : 1) || 1), r = this.#h;
    this.wireframe.draw(r, s);
    const n = r.x + r.width / 2, o = r.y + r.height / 2, a = this.opts.clip?.getVisibleHandles?.() ?? [
      "tl",
      "tr",
      "bl",
      "br",
      "ml",
      "mr",
      "mt",
      "mb",
      "rot"
    ], l = [
      this.#e.tl,
      this.#e.tr,
      this.#e.bl,
      this.#e.br,
      this.#e.ml,
      this.#e.mr,
      this.#e.mt,
      this.#e.mb,
      this.#e.rot
    ];
    for (const c of l)
      c.scale.set(s);
    this.#e.tl.visible = a.includes("tl"), this.#e.tr.visible = a.includes("tr"), this.#e.bl.visible = a.includes("bl"), this.#e.br.visible = a.includes("br"), this.#e.ml.visible = a.includes("ml"), this.#e.mr.visible = a.includes("mr"), this.#e.mt.visible = a.includes("mt"), this.#e.mb.visible = a.includes("mb"), this.#e.rot.visible = a.includes("rot"), this.#e.tl.position.set(r.x, r.y), this.#e.tr.position.set(r.x + r.width, r.y), this.#e.bl.position.set(r.x, r.y + r.height), this.#e.br.position.set(r.x + r.width, r.y + r.height), this.#e.ml.position.set(r.x, o), this.#e.mr.position.set(r.x + r.width, o), this.#e.mt.position.set(n, r.y), this.#e.mb.position.set(n, r.y + r.height), this.#e.rot.position.set(n, r.y - 30 * s), this.#C(s);
  }
  /**
   * Draw individual bounding boxes for selected items
   * optimized to use cached points and avoid allocations
   */
  #C(e) {
    if (this.selectionOutlines.clear(), this.group.length <= 1 || !this.parent) return;
    const t = { width: 1 * e, color: 43775, alpha: 1 };
    for (const s of this.group) {
      const r = this.#f(s);
      this.#t[0].set(r.x, r.y), this.#t[1].set(r.x + r.width, r.y), this.#t[2].set(r.x + r.width, r.y + r.height), this.#t[3].set(r.x, r.y + r.height);
      for (const n of this.#t)
        s.toGlobal(n, n), this.toLocal(n, void 0, n);
      this.selectionOutlines.moveTo(this.#t[0].x, this.#t[0].y).lineTo(this.#t[1].x, this.#t[1].y).lineTo(this.#t[2].x, this.#t[2].y).lineTo(this.#t[3].x, this.#t[3].y).closePath().stroke(t);
    }
  }
  // helpers
  #A(e) {
    const t = this.#c;
    if (this.opts.centeredScaling) {
      this.#s.set(t.x + t.width / 2, t.y + t.height / 2);
      return;
    }
    e === "tl" ? this.#s.set(t.x + t.width, t.y + t.height) : e === "tr" ? this.#s.set(t.x, t.y + t.height) : e === "bl" ? this.#s.set(t.x + t.width, t.y) : e === "br" ? this.#s.set(t.x, t.y) : e === "ml" ? this.#s.set(t.x + t.width, t.y + t.height / 2) : e === "mr" ? this.#s.set(t.x, t.y + t.height / 2) : e === "mt" ? this.#s.set(t.x + t.width / 2, t.y + t.height) : e === "mb" && this.#s.set(t.x + t.width / 2, t.y);
  }
  #I(e, t, s) {
    if (this.opts.centeredScaling) {
      const n = Math.max(this.#n, Math.abs(t.x - s.x) * 2), o = Math.max(this.#o, Math.abs(t.y - s.y) * 2);
      return new G(s.x - n / 2, s.y - o / 2, n, o);
    }
    if (e === "tl") {
      const n = Math.min(t.x, s.x - this.#n), o = Math.min(t.y, s.y - this.#o);
      return new G(n, o, s.x - n, s.y - o);
    }
    if (e === "tr") {
      const n = Math.max(t.x, s.x + this.#n), o = Math.min(t.y, s.y - this.#o);
      return new G(s.x, o, n - s.x, s.y - o);
    }
    if (e === "bl") {
      const n = Math.min(t.x, s.x - this.#n), o = Math.max(t.y, s.y + this.#o);
      return new G(n, s.y, s.x - n, o - s.y);
    }
    if (e === "br") {
      const n = Math.max(t.x, s.x + this.#n), o = Math.max(t.y, s.y + this.#o);
      return new G(s.x, s.y, n - s.x, o - s.y);
    }
    const r = this.#c;
    if (e === "ml") {
      const n = Math.min(t.x, s.x - this.#n);
      return new G(n, r.y, s.x - n, r.height);
    }
    if (e === "mr") {
      const n = Math.max(t.x, s.x + this.#n);
      return new G(s.x, r.y, n - s.x, r.height);
    }
    if (e === "mt") {
      const n = Math.min(t.y, s.y - this.#o);
      return new G(r.x, n, r.width, s.y - n);
    }
    if (e === "mb") {
      const n = Math.max(t.y, s.y + this.#o);
      return new G(r.x, s.y, r.width, n - s.y);
    }
    return new G(s.x, s.y, this.#n, this.#o);
  }
  #k(e, t, s, r) {
    return ef.delta.identity().translate(-e.x, -e.y).rotate(-t).scale(s, r).rotate(t).translate(e.x, e.y);
  }
  #F(e, t) {
    return ef.delta.identity().translate(-e.x, -e.y).rotate(t).translate(e.x, e.y);
  }
  #g(e) {
    for (const t of this.group) {
      const s = this.#a.get(t), r = t.parent;
      if (!s || !r) continue;
      const n = r.worldTransform.clone().invert(), o = r.worldTransform.clone().append(s), a = e.clone().append(o), l = n.clone().append(a);
      t.setFromMatrix(l);
    }
  }
}
class $I {
  constructor(e) {
    this.studio = e;
  }
  selectedClips = /* @__PURE__ */ new Set();
  activeTransformer = null;
  interactiveClips = /* @__PURE__ */ new Set();
  // Track which clips have interactivity set up
  // Drag-to-select state
  selectionGraphics = null;
  isDragSelecting = !1;
  dragSelectionStart = new q();
  // Text/Caption realtime resize state
  isUpdatingTextClipRealtime = !1;
  textClipResizedWidth = null;
  textClipResizeHandle = null;
  textClipResizedSx = null;
  textClipResizedSy = null;
  init(e, t) {
    this.selectionGraphics = new fe(), this.selectionGraphics.visible = !1, this.selectionGraphics.zIndex = 1e3, t.addChild(this.selectionGraphics), e.stage.eventMode = "static", e.stage.hitArea = e.screen, e.stage.on("pointerdown", (s) => this.onStagePointerDown(s)), e.stage.on("globalpointermove", (s) => this.onStagePointerMove(s)), e.stage.on("pointerup", () => this.onStagePointerUp()), e.stage.on("pointerupoutside", () => this.onStagePointerUp());
  }
  onStagePointerDown(e) {
    e.target === this.studio.pixiApp?.stage && (e.shiftKey || this.deselectClip(), this.isDragSelecting = !0, this.studio.artboard?.toLocal(
      e.global,
      void 0,
      this.dragSelectionStart
    ), this.selectionGraphics && (this.selectionGraphics.clear(), this.selectionGraphics.visible = !0));
  }
  onStagePointerMove(e) {
    if (this.isDragSelecting && this.selectionGraphics && this.studio.artboard) {
      const t = this.studio.artboard.toLocal(e.global), s = Math.min(this.dragSelectionStart.x, t.x), r = Math.min(this.dragSelectionStart.y, t.y), n = Math.abs(t.x - this.dragSelectionStart.x), o = Math.abs(t.y - this.dragSelectionStart.y);
      this.selectionGraphics.clear(), this.selectionGraphics.rect(s, r, n, o).fill({ color: 703971, alpha: 0.3 }), this.selectionGraphics.rect(s, r, n, o).stroke({ width: 2, color: 703971 });
    }
  }
  onStagePointerUp() {
    if (this.isDragSelecting && this.selectionGraphics && this.studio.artboard) {
      const e = this.selectionGraphics.getBounds(), t = [], s = new G(
        e.x,
        e.y,
        e.width,
        e.height
      );
      if (s.width > 2 || s.height > 2) {
        for (const r of this.studio.clips) {
          const n = this.studio.spriteRenderers.get(r);
          if (!n) continue;
          const o = n.getRoot();
          if (!o || !o.visible) continue;
          const a = o.getBounds();
          s.x < a.x + a.width && s.x + s.width > a.x && s.y < a.y + a.height && s.y + s.height > a.y && t.push(r);
        }
        if (t.length > 0)
          for (const r of t)
            this.selectClip(r, !0);
      }
      this.selectionGraphics.clear(), this.selectionGraphics.visible = !1, this.isDragSelecting = !1;
    }
  }
  /**
   * Setup sprite interactivity for click selection
   */
  setupSpriteInteractivity(e) {
    if (this.interactiveClips.has(e)) return;
    const t = this.studio.spriteRenderers.get(e);
    if (t == null) return;
    const s = t.getRoot();
    s != null && (s.eventMode = "static", s.cursor = "pointer", s.on("pointerdown", (r) => {
      const n = this.getTopmostClipAtPoint(r.global);
      n && this.selectClip(n, r.shiftKey);
    }), this.interactiveClips.add(e));
  }
  /**
   * Find the topmost clip (highest zIndex) at a given point
   */
  getTopmostClipAtPoint(e) {
    if (!this.studio.pixiApp) return null;
    let t = null, s = -1 / 0;
    for (const r of this.interactiveClips) {
      const n = this.studio.spriteRenderers.get(r);
      if (!n) continue;
      const o = n.getRoot();
      if (!o || !o.visible) continue;
      const a = o.toLocal(e), l = o.getLocalBounds();
      a.x >= l.minX && a.x <= l.maxX && a.y >= l.minY && a.y <= l.maxY && r.zIndex > s && (s = r.zIndex, t = r);
    }
    return t;
  }
  /**
   * Select a clip and show transform controls
   */
  selectClip(e, t = !1) {
    if (!(this.studio.destroyed || this.studio.pixiApp == null)) {
      if (t || this.deselectClip(), t && this.selectedClips.has(e)) {
        this.selectedClips.delete(e), this.recreateTransformer(), this.studio.emit("selection:updated", {
          selected: Array.from(this.selectedClips)
        });
        return;
      }
      this.selectedClips.add(e), this.recreateTransformer(), t ? this.studio.emit("selection:updated", {
        selected: Array.from(this.selectedClips)
      }) : this.studio.emit("selection:created", {
        selected: Array.from(this.selectedClips)
      });
    }
  }
  selectClipsByIds(e) {
    const t = this.studio.clips.filter((s) => e.includes(s.id));
    this.setSelection(t);
  }
  setSelection(e) {
    if (!(this.studio.destroyed || this.studio.pixiApp == null) && !(this.selectedClips.size === e.length && e.every((t) => this.selectedClips.has(t)))) {
      for (const t of this.selectedClips)
        this.syncSpriteToClipProperties(t);
      this.destroyTransformer(), this.selectedClips.clear();
      for (const t of e)
        this.selectedClips.add(t);
      this.selectedClips.size > 0 ? (this.createTransformer(), this.studio.emit("selection:updated", {
        selected: Array.from(this.selectedClips)
      })) : this.studio.emit("selection:cleared", { deselected: [] });
    }
  }
  deselectClip() {
    if (this.selectedClips.size > 0)
      for (const t of this.selectedClips)
        this.syncSpriteToClipProperties(t);
    this.destroyTransformer();
    const e = Array.from(this.selectedClips);
    this.selectedClips.clear(), e.length > 0 && this.studio.emit("selection:cleared", { deselected: e });
  }
  clear() {
    this.deselectClip(), this.interactiveClips.clear();
  }
  recreateTransformer() {
    this.destroyTransformer(), this.selectedClips.size > 0 && this.createTransformer();
  }
  destroyTransformer() {
    this.activeTransformer != null && (this.activeTransformer.parent != null && this.activeTransformer.parent.removeChild(this.activeTransformer), this.activeTransformer.destroy(), this.activeTransformer = null);
  }
  createTransformer() {
    if (this.studio.destroyed || this.studio.artboard == null || this.selectedClips.size === 0)
      return;
    const e = [];
    let t = null;
    for (const r of this.selectedClips) {
      const n = this.studio.spriteRenderers.get(r);
      if (n == null) continue;
      const o = n.getRoot();
      o != null && (e.push(o), this.selectedClips.size === 1 && (t = r));
    }
    if (e.length === 0) {
      console.warn("Cannot create transformer: no sprites found");
      return;
    }
    this.activeTransformer = new VI({
      group: e,
      clip: t
      // Only pass clip for single selection
    });
    let s = null;
    this.activeTransformer.on("transforming", () => {
      s === null && (s = requestAnimationFrame(() => {
        s = null, this.syncSelectedClipsTransformsRealtime();
      }));
    }), this.activeTransformer.on("textClipResize", (r) => {
      this.textClipResizedWidth = r.newWidth, this.textClipResizeHandle = r.handle, this.textClipResizedSx = r.sx, this.textClipResizedSy = r.sy;
    }), this.activeTransformer.on("transformEnd", () => {
      s !== null && (cancelAnimationFrame(s), s = null), this.syncSelectedClipsTransforms();
    }), this.activeTransformer.on("pointerdown", (r) => {
      const n = this.getTopmostClipAtPoint(r.global);
      n && !this.selectedClips.has(n) && (this.selectClip(n, r.shiftKey), r.stopPropagation());
    }), this.studio.artboard.addChild(this.activeTransformer);
  }
  // Copied Sync Logic
  async syncSelectedClipsTransformsRealtime() {
    if (!(this.selectedClips.size === 0 || this.activeTransformer == null) && !this.isUpdatingTextClipRealtime) {
      this.isUpdatingTextClipRealtime = !0;
      try {
        const e = this.activeTransformer.activeHandle;
        if (e !== "mr" && e !== "ml") return;
        for (const t of this.selectedClips) {
          if (!(t instanceof et)) continue;
          const s = this.studio.spriteRenderers.get(t);
          if (s == null) continue;
          const r = s.getRoot(), n = s.getSprite();
          if (r == null || n == null || n.texture == null) continue;
          const o = Math.abs(r.scale.x * n.scale.x);
          if (o === 1) continue;
          const a = t.left, l = t.top, c = t.width, h = n.texture.width, u = o * h;
          await t.updateStyle({
            wordWrap: !0,
            wordWrapWidth: u
          });
          const d = await t.getTexture();
          d && (await s.updateFrame(d), n.scale.set(1, 1), r.scale.set(1, 1), e === "ml" ? t.left = a + c - t.width : t.left = a, t.top = l, r.x = t.left + t.width / 2, r.y = t.top + t.height / 2, this.activeTransformer.updateBounds());
        }
      } finally {
        this.isUpdatingTextClipRealtime = !1;
      }
    }
  }
  async syncSelectedClipsTransforms() {
    if (!(this.selectedClips.size === 0 || this.activeTransformer == null)) {
      for (const e of this.selectedClips) {
        const t = this.studio.spriteRenderers.get(e);
        if (t == null) continue;
        const s = t.getRoot(), r = t.getSprite();
        if (s == null || r == null || r.texture == null) continue;
        const n = r.texture.width, o = r.texture.height, a = Math.abs(s.scale.x * r.scale.x) * n, l = Math.abs(s.scale.y * r.scale.y) * o, c = (e instanceof et || e instanceof Ft) && this.textClipResizedWidth !== null ? this.textClipResizedWidth : a, h = e.width, d = (e.style?.fontSize ?? 16) * Math.max(this.textClipResizedSx || 1, this.textClipResizedSy || 1);
        let f = s.x;
        const m = s.y - l / 2, g = s.x - c / 2;
        if (e instanceof et && this.textClipResizedWidth !== null) {
          const x = {
            wordWrap: !0,
            wordWrapWidth: c
          };
          this.textClipResizeHandle === "mr" ? (f = e.left + c / 2, s.x = f) : this.textClipResizeHandle === "ml" ? (f = e.left + c / 2 - (c - h), s.x = f) : ["br", "tr"].includes(this.textClipResizeHandle) ? (f = e.left + c / 2, x.fontSize = d) : ["bl", "tl"].includes(this.textClipResizeHandle) && (f = e.left + c / 2 - (c - h), x.fontSize = d), await e.updateStyle(x);
          const y = await e.getTexture();
          y && (await t.updateFrame(y), e.width = c, e.height = y.height, this.textClipResizedWidth = null, e.left = f - e.width / 2, e.top = s.y - e.height / 2, r.scale.set(1, 1), s.scale.set(1, 1));
        } else {
          e.left = g, e.top = m, e.width = a, e.height = l;
          const x = e.flip == null ? 1 : -1;
          e.angle = x * s.angle;
        }
      }
      this.activeTransformer != null && this.activeTransformer.updateBounds();
      for (const e of this.selectedClips) {
        const t = this.studio.spriteRenderers.get(e);
        t?.updateTransforms();
      }
    }
  }
  syncSpriteToClipProperties(e) {
    const t = this.studio.spriteRenderers.get(e);
    if (t != null) {
      const s = t.getRoot(), r = t.getSprite();
      if (s != null && r != null && r.texture != null) {
        const n = r.texture.width, o = r.texture.height, a = Math.abs(s.scale.x * r.scale.x) * n, l = Math.abs(s.scale.y * r.scale.y) * o, c = s.x - a / 2, h = s.y - l / 2;
        e.left = c, e.top = h, e.width = a, e.height = l;
        const u = e.flip == null ? 1 : -1;
        e.angle = u * s.angle, t.updateTransforms();
      }
    }
  }
  async deleteSelected() {
    return this.studio.deleteSelected();
  }
}
class YI {
  constructor(e) {
    this.studio = e;
  }
  isPlaying = !1;
  currentTime = 0;
  // in microseconds
  maxDuration = 0;
  // in microseconds
  playStartTime = 0;
  // in microseconds - time when playback started
  playStartTimestamp = 0;
  // performance.now() when playback started
  rafId = null;
  // Playback elements for clips that support playback
  playbackElements = /* @__PURE__ */ new Map();
  setMaxDuration(e) {
    this.maxDuration = e;
  }
  /**
   * Start playback
   */
  async play() {
    if (!(this.isPlaying || this.studio.destroyed)) {
      if (this.maxDuration <= 0 || this.maxDuration === 1 / 0 || isNaN(this.maxDuration)) {
        console.warn("Cannot play: invalid duration", this.maxDuration);
        return;
      }
      this.isPlaying || (this.isPlaying = !0), this.playStartTime = this.currentTime, this.playStartTimestamp = performance.now();
      for (const [e, { element: t }] of this.playbackElements.entries()) {
        if (!(this.currentTime >= e.display.from && (e.display.to === 0 || this.currentTime <= e.display.to))) {
          this.isPlaybackCapable(e) && e.pause(t);
          continue;
        }
        const r = (this.currentTime - e.display.from) / 1e6;
        this.isPlaybackCapable(e) && await e.play(t, r);
      }
      this.renderLoop(), this.studio.emit("play", { isPlaying: !0 });
    }
  }
  /**
   * Pause playback
   */
  pause() {
    this.isPlaying = !1, this.rafId != null && (cancelAnimationFrame(this.rafId), this.rafId = null);
    for (const [e, { element: t }] of this.playbackElements.entries())
      this.isPlaybackCapable(e) && e.pause(t);
    this.studio.emit("pause", { isPlaying: !1 });
  }
  /**
   * Stop playback and reset to start
   */
  async stop() {
    this.pause(), await this.seek(0);
  }
  /**
   * Seek to a specific time (in microseconds)
   */
  async seek(e) {
    if (this.studio.destroyed) return;
    const t = this.isPlaying;
    this.playStartTime = Math.max(0, Math.min(e, this.maxDuration)), this.playStartTimestamp = performance.now(), this.currentTime = this.playStartTime;
    for (const [s, { element: r }] of this.playbackElements.entries()) {
      if (!(this.currentTime >= s.display.from && (s.display.to === 0 || this.currentTime <= s.display.to))) {
        this.isPlaybackCapable(s) && s.pause(r);
        continue;
      }
      const o = (this.currentTime - s.display.from) / 1e6;
      this.isPlaybackCapable(s) && await s.seek(r, o);
    }
    if (await this.studio.updateFrame(this.currentTime), this.studio.emit("currentTime", { currentTime: this.currentTime }), t) {
      this.isPlaying = !0;
      for (const [s, { element: r }] of this.playbackElements.entries()) {
        if (!(this.currentTime >= s.display.from && (s.display.to === 0 || this.currentTime <= s.display.to)))
          continue;
        const o = (this.currentTime - s.display.from) / 1e6;
        this.isPlaybackCapable(s) && await s.play(r, o);
      }
    }
  }
  async renderLoop() {
    if (!this.isPlaying || this.studio.destroyed || this.studio.pixiApp == null)
      return;
    if (this.maxDuration <= 0 || this.maxDuration === 1 / 0 || isNaN(this.maxDuration)) {
      this.pause();
      return;
    }
    const e = async () => {
      if (!this.isPlaying || this.studio.destroyed || this.studio.pixiApp == null)
        return;
      if (this.currentTime >= this.maxDuration) {
        this.currentTime = this.maxDuration, this.pause();
        return;
      }
      const s = (performance.now() - this.playStartTimestamp) * 1e3;
      this.currentTime = Math.min(
        this.playStartTime + s,
        this.maxDuration
      ), this.studio.emit("currentTime", { currentTime: this.currentTime });
      try {
        await this.studio.updateFrame(this.currentTime);
      } catch (r) {
        console.warn("Error updating frame:", r);
      }
      this.isPlaying && (this.rafId = requestAnimationFrame(e));
    };
    e();
  }
  isPlaybackCapable(e) {
    return "play" in e && "pause" in e && "seek" in e;
  }
}
class ri {
  static instance;
  fonts = /* @__PURE__ */ new Map();
  constructor() {
  }
  static getInstance() {
    return ri.instance || (ri.instance = new ri()), ri.instance;
  }
  async addFont(e) {
    if (!this.fonts.has(e.name))
      try {
        const s = await new FontFace(e.name, `url(${e.url})`).load();
        document.fonts.add(s), this.fonts.set(e.name, s);
      } catch (t) {
        console.error(`Failed to load font ${e.name}:`, t);
      }
  }
  async loadFonts(e) {
    await Promise.all(e.map((t) => this.addFont(t)));
  }
  removeFont(e) {
    const t = this.fonts.get(e);
    t && (document.fonts.delete(t), this.fonts.delete(e));
  }
  clear() {
    this.fonts.forEach((e) => {
      document.fonts.delete(e);
    }), this.fonts.clear();
  }
  getLoadedFonts() {
    return Array.from(this.fonts.keys());
  }
}
const XI = ri.getInstance();
class qI {
  constructor(e) {
    this.studio = e;
  }
  tracks = [];
  clips = [];
  getTrackById(e) {
    return this.tracks.find((t) => t.id === e);
  }
  getClipById(e) {
    return this.clips.find((t) => t.id === e);
  }
  findTrackIdByClipId(e) {
    for (const t of this.tracks)
      if (t.clipIds.includes(e)) return t.id;
  }
  getTrackIndex(e) {
    return this.tracks.findIndex((t) => t.id === e);
  }
  /**
   * Add a new track to the studio
   */
  addTrack(e) {
    const t = {
      id: e.id || `track_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      name: e.name,
      type: e.type,
      clipIds: []
    };
    return this.tracks.push(t), this.studio.emit("track:added", { track: t }), t;
  }
  /**
   * Remove a track and all its clips
   */
  async removeTrack(e) {
    const t = this.tracks.findIndex((n) => n.id === e);
    if (t === -1) return;
    const r = [...this.tracks[t].clipIds];
    for (const n of r)
      await this.removeClipById(n);
    this.tracks.splice(t, 1), this.studio.emit("track:removed", { trackId: e });
  }
  /**
   * Add a Media clip (Video/Image) to the main track with ripple effect
   */
  async addMedia(e) {
    if (this.studio.destroyed) return;
    const t = this.studio.opts.width, s = this.studio.opts.height;
    t && s && (typeof e.scaleToFit == "function" && await e.scaleToFit(t, s), typeof e.centerInScene == "function" && e.centerInScene(t, s));
    const r = e.duration > 0 ? e.duration : 5e6;
    e.duration <= 0 && (e.duration = r);
    const n = this.tracks.filter(
      (l) => ["media", "video", "image", "Video", "Image"].includes(l.type)
    ), o = n.find((l) => l.clipIds.length > 0) || n[0];
    let a;
    if (o) {
      a = o.id;
      const l = r;
      for (const c of o.clipIds) {
        const h = this.getClipById(c);
        if (h) {
          const u = h.display.from + l, d = h.display.to + l;
          await this.updateClip(c, {
            display: { from: u, to: d }
          });
        }
      }
    }
    e.display.from = 0, e.display.to = r, await this.addClip(e, { trackId: a }), await this.studio.seek(0);
  }
  /**
   * Add a Transition clip at the join where the selected clip starts.
   */
  async addTransition(e, t = 2e6, s, r) {
    if (this.studio.destroyed) return;
    let n = null, o = null;
    if (s && r && (n = this.getClipById(s) ?? null, o = this.getClipById(r) ?? null, !n || !o)) {
      console.warn("[Studio] Invalid fromClipId or toClipId", {
        fromClipId: s,
        toClipId: r
      });
      return;
    }
    if (!o) {
      const f = this.tracks.filter(
        (m) => ["media", "video", "image", "Video", "Image"].includes(m.type) || m.clipIds.length > 1
      );
      for (const m of f) {
        const g = m.clipIds.map((p) => this.getClipById(p)).filter((p) => !!p && p.type !== "Transition").sort((p, x) => p.display.from - x.display.from);
        for (let p = 0; p < g.length - 1; p++) {
          const x = g[p], y = g[p + 1];
          if (Math.abs(y.display.from - x.display.to) < 1e5) {
            n = x, o = y;
            break;
          }
        }
        if (n && o) break;
      }
    }
    if (o && !n) {
      const f = this.findTrackIdByClipId(o.id);
      if (f) {
        const m = this.tracks.find((g) => g.id === f);
        if (m) {
          const g = m.clipIds.map((x) => this.getClipById(x)).filter((x) => !!x && x.type !== "Transition").sort((x, y) => x.display.from - y.display.from), p = g.findIndex((x) => x.id === o.id);
          p > 0 && (n = g[p - 1]);
        }
      }
    }
    if (!n || !o) {
      console.warn(
        "[Studio] Unable to resolve Clip A and Clip B for transition"
      );
      return;
    }
    const a = t, l = o.display.from - a / 2, c = l + a, h = {
      key: e,
      name: e,
      duration: a,
      fromClipId: n.id,
      toClipId: o.id,
      start: Math.max(0, l),
      end: c
    }, u = this.findTrackIdByClipId(o.id);
    if (u) {
      const f = this.tracks.find((m) => m.id === u);
      if (f) {
        const m = f.clipIds.map((g) => this.getClipById(g)).filter((g) => {
          if (!g || g.type !== "Transition") return !1;
          const p = g;
          return p.fromClipId === n.id && p.toClipId === o.id;
        });
        for (const g of m)
          await this.removeClip(g);
      }
    }
    this.studio.transitionRenderers.has(n.id) && (this.studio.transitionRenderers.get(n.id)?.destroy(), this.studio.transitionRenderers.delete(n.id)), this.studio.transitionRenderers.has(o.id) && (this.studio.transitionRenderers.get(o.id)?.destroy(), this.studio.transitionRenderers.delete(o.id)), "transition" in n && (n.transition = { ...h }), "transition" in o && (o.transition = { ...h });
    const d = new pi(e);
    d.duration = a, d.fromClipId = Math.max(0, l) === 0 ? null : n.id, d.toClipId = o.id, d.fromClipId === null && n && (d.fromClipId = n.id), d.display.from = Math.max(0, l), d.display.to = c, await this.addClip(d, { trackId: u }), this.studio.seek(this.studio.currentTime);
  }
  /**
   * Add a clip (or clips) to the studio
   */
  async addClip(e, t) {
    const s = Array.isArray(e) ? e : [e];
    if (s.length === 0) return;
    const { trackId: r, audioSource: n } = this.normalizeAddClipOptions(t);
    if (this.studio.destroyed) return;
    if (this.studio.pixiApp == null)
      throw new Error("Failed to initialize Pixi.js Application");
    const o = [];
    for (const a of s)
      await this.prepareClipForTimeline(a, r), o.push(a);
    await this.recalculateMaxDuration();
    for (const a of o)
      await this.setupClipVisuals(a, n);
    await this.studio.updateFrame(this.studio.currentTime), this.emitAddClipEvents(o, r);
  }
  normalizeAddClipOptions(e) {
    let t, s;
    if (e && (typeof e == "string" || e instanceof File || e instanceof Blob))
      t = e;
    else if (typeof e == "object" && e !== null && !("size" in e)) {
      const r = e;
      t = r.audioSource, s = r.trackId;
    }
    return { trackId: s, audioSource: t };
  }
  async prepareClipForTimeline(e, t) {
    const s = async () => {
      await this.studio.updateFrame(this.studio.currentTime);
      const r = this.studio.selection;
      r.activeTransformer != null && r.selectedClips.has(e) && typeof r.activeTransformer.updateBounds == "function" && r.activeTransformer.updateBounds();
    };
    e.on("propsChange", s), this.studio.clipListeners.set(e, s), this.studio.pixiApp != null && typeof e.setRenderer == "function" && e.setRenderer(this.studio.pixiApp.renderer), await e.ready, e.id || (e.id = `clip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`), this.clips.includes(e) || this.clips.push(e), this.addClipToTrack(e, t);
  }
  addClipToTrack(e, t) {
    if (t) {
      const s = this.tracks.find((r) => r.id === t);
      s ? s.clipIds.includes(e.id) || s.clipIds.push(e.id) : this.tracks.unshift({
        id: t,
        name: `Track ${this.tracks.length + 1}`,
        type: e.type,
        clipIds: [e.id]
      });
    } else {
      const s = `track_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      this.tracks.unshift({
        id: s,
        name: `Track ${this.tracks.length + 1}`,
        type: e.type,
        clipIds: [e.id]
      });
    }
  }
  async setupClipVisuals(e, t) {
    const s = await e.ready;
    if (await this.setupPlaybackForClip(e, t), s.width > 0 && s.height > 0) {
      const r = this.studio.clipsNormalContainer;
      if (!(e instanceof xe) || e instanceof xe && e.tickInterceptor != null) {
        const n = new qs(
          this.studio.pixiApp,
          e,
          r
        );
        this.studio.spriteRenderers.set(e, n);
      }
    }
    this.studio.opts.interactivity && this.studio.selection.setupSpriteInteractivity(e);
  }
  emitAddClipEvents(e, t) {
    if (e.length !== 0)
      if (e.length === 1) {
        const s = e[0], r = t || this.tracks.find((n) => n.clipIds.includes(s.id))?.id || "";
        this.studio.emit("clip:added", {
          clip: s,
          trackId: r
        });
      } else
        this.studio.emit("clips:added", {
          clips: e,
          trackId: t
        });
  }
  async removeClip(e) {
    const t = this.clips.findIndex((a) => a === e);
    if (t === -1) return;
    if (e instanceof pi) {
      if (e.fromClipId) {
        const a = this.getClipById(e.fromClipId);
        a && "transition" in a && delete a.transition;
      }
      if (e.toClipId) {
        const a = this.getClipById(e.toClipId);
        a && "transition" in a && delete a.transition;
      }
    }
    this.studio.selection.selectedClips.has(e) && this.studio.selection.deselectClip(), this.clips.splice(t, 1);
    for (const a of this.tracks) {
      const l = a.clipIds.indexOf(e.id);
      l !== -1 && a.clipIds.splice(l, 1);
    }
    this.studio.selection.interactiveClips.delete(e);
    const s = this.studio.clipListeners.get(e);
    s && (e.off("propsChange", s), this.studio.clipListeners.delete(e));
    const r = this.studio.spriteRenderers.get(e);
    r != null && (r.destroy(), this.studio.spriteRenderers.delete(e));
    const n = this.studio.transport.playbackElements.get(e);
    n != null && (this.isPlaybackCapable(e) && e.cleanupPlayback(n.element, n.objectUrl), this.studio.transport.playbackElements.delete(e));
    const o = this.studio.videoSprites.get(e);
    o != null && this.studio.pixiApp != null && (o.parent && o.parent.removeChild(o), o.destroy(), this.studio.videoSprites.delete(e)), await this.recalculateMaxDuration(), this.studio.emit("clip:removed", { clipId: e.id });
  }
  async removeClipById(e) {
    const t = this.clips.find((s) => s.id === e);
    t && await this.removeClip(t);
  }
  async updateClip(e, t) {
    const s = this.clips.find((r) => r.id === e);
    s && (await this.applyClipUpdate(s, t), await this.recalculateMaxDuration(), await this.studio.updateFrame(this.studio.currentTime), this.updateTransformer(s), this.studio.emit("clip:updated", { clip: s }));
  }
  async updateClips(e) {
    const t = [];
    for (const { id: s, updates: r } of e) {
      const n = this.clips.find((o) => o.id === s);
      n && (await this.applyClipUpdate(n, r), t.push(n));
    }
    if (t.length !== 0) {
      await this.recalculateMaxDuration(), await this.studio.updateFrame(this.studio.currentTime);
      for (const s of t)
        this.updateTransformer(s), this.studio.emit("clip:updated", { clip: s });
    }
  }
  async applyClipUpdate(e, t) {
    if (e instanceof et && (await e.updateStyle(t), "style" in t && delete t.style), Object.assign(e, t), t.display && !t.duration ? e.duration = t.display.to - t.display.from : t.duration && (!t.display || !t.display.to) && (e.display || (e.display = { from: 0, to: t.duration }), e.display.to = e.display.from + t.duration), t.display && t.duration) {
      const s = t.display.to - t.display.from;
      s !== t.duration && (e.duration = s);
    } else
      e.display && (e.display.to = e.display.from + e.duration);
  }
  updateTransformer(e) {
    const t = this.studio.selection;
    t.selectedClips.has(e) && t.activeTransformer && t.activeTransformer.updateBounds();
  }
  /**
   * Export current project state to JSON
   */
  exportToJSON() {
    const e = this.clips.map((r) => Zs(r, !1)), t = this.tracks.map((r) => ({
      id: r.id,
      name: r.name,
      type: r.type,
      clipIds: r.clipIds
    })), s = [];
    return this.clips.forEach((r) => {
      if (r.transition) {
        const n = this.tracks.find((o) => o.clipIds.includes(r.id));
        if (n) {
          const o = n.clipIds.indexOf(r.id);
          if (o > 0) {
            const a = n.clipIds[o - 1];
            s.push({
              key: r.transition.name,
              duration: r.transition.duration,
              clips: [a, r.id]
            });
          }
        }
      }
    }), {
      tracks: t,
      clips: e,
      settings: {
        width: this.studio.opts.width,
        height: this.studio.opts.height,
        fps: this.studio.opts.fps,
        bgColor: this.studio.opts.bgColor
      }
    };
  }
  /**
   * Load clips from JSON
   */
  async loadFromJSON(e) {
    if (await this.clear(), e.settings) {
      const s = e.settings.width && e.settings.width !== this.studio.opts.width || e.settings.height && e.settings.height !== this.studio.opts.height;
      if (e.settings.width && (this.studio.opts.width = e.settings.width), e.settings.height && (this.studio.opts.height = e.settings.height), e.settings.fps && (this.studio.opts.fps = e.settings.fps), e.settings.bgColor && (this.studio.opts.bgColor = e.settings.bgColor), s && this.studio.pixiApp != null) {
        const r = this.studio.opts.width, n = this.studio.opts.height;
        this.studio.pixiApp.renderer.resize(r, n), this.studio.opts.canvas && (this.studio.opts.canvas.width = r, this.studio.opts.canvas.height = n);
      }
    }
    const t = [];
    if (e.clips) {
      await this.ensureFontsForClips(e.clips);
      const s = /* @__PURE__ */ new Map();
      if (e.tracks) {
        for (const n of e.tracks)
          if (n.clipIds)
            for (const o of n.clipIds)
              s.set(o, n.id);
      }
      if (e.tracks)
        for (const n of e.tracks)
          this.tracks.push({
            id: n.id,
            name: n.name,
            type: n.type,
            clipIds: []
            // Will fill as we add clips
          });
      for (const n of e.clips)
        t.push(
          (async () => {
            try {
              let o = n.id ? s.get(n.id) : void 0;
              if (n.type === "Transition") {
                const l = n, c = l.toClipId || l.fromClipId;
                c && (o = s.get(c));
              }
              if (n.type !== "Text" && n.type !== "Caption" && n.type !== "Effect" && n.type !== "Transition" && (!n.src || n.src.trim() === ""))
                return console.warn(
                  `Skipping clip ${n.type} with empty source`,
                  n
                ), { clip: null };
              const a = await Ks(n);
              return (a instanceof xe || a instanceof Se) && (!n.width || !n.height) && this.studio.opts.width && this.studio.opts.height && (typeof a.scaleToFit == "function" && await a.scaleToFit(
                this.studio.opts.width,
                this.studio.opts.height
              ), typeof a.centerInScene == "function" && a.centerInScene(
                this.studio.opts.width,
                this.studio.opts.height
              )), { clip: a, intendedTrackId: o };
            } catch (o) {
              return console.error(
                `Failed to load clip ${n.id || "unknown"}:`,
                o
              ), { clip: null };
            }
          })()
        );
      const r = await Promise.all(t);
      for (const { clip: n, intendedTrackId: o } of r)
        n && (n.id || (n.id = `clip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`), this.clips.push(n), this.addClipToTrack(n, o));
    }
    this.studio.pixiApp && await Promise.all(
      this.clips.map(async (s) => {
        const r = async () => {
          await this.studio.updateFrame(this.studio.currentTime);
          const n = this.studio.selection;
          n.activeTransformer != null && n.selectedClips.has(s) && typeof n.activeTransformer.updateBounds == "function" && n.activeTransformer.updateBounds();
        };
        s.on("propsChange", r), this.studio.clipListeners.set(s, r), typeof s.setRenderer == "function" && s.setRenderer(this.studio.pixiApp.renderer), await s.ready, await this.setupClipVisuals(s);
      })
    );
    for (const s of this.clips) {
      const r = s.effects;
      if (Array.isArray(r))
        for (const n of r)
          this.studio.globalEffects.has(n.id) || this.studio.globalEffects.set(n.id, {
            id: n.id,
            key: n.key,
            startTime: n.startTime,
            duration: n.duration
          });
    }
    await this.recalculateMaxDuration();
    try {
      await this.studio.updateFrame(this.studio.currentTime);
    } catch (s) {
      console.error("[Studio] Failed to update initial frame:", s);
    }
    this.studio.emit("studio:restored", {
      clips: this.clips,
      tracks: this.tracks,
      settings: this.studio.opts
    });
  }
  /**
   * Delete all currently selected clips
   */
  async deleteSelected() {
    const e = this.studio.selection.selectedClips, t = Array.from(e);
    if (t.length !== 0)
      for (const s of t)
        await this.removeClip(s);
  }
  /**
   * Duplicate all currently selected clips
   */
  async duplicateSelected() {
    const e = this.studio.selection.selectedClips, t = Array.from(e);
    if (t.length === 0) return;
    const s = [];
    for (const r of t) {
      const n = this.findTrackIdByClipId(r.id);
      if (!n) continue;
      const o = this.tracks.find((u) => u.id === n);
      if (!o) continue;
      const a = Zs(r, !1), l = await Ks(a);
      l.id = `clip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const c = `track_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, h = `${o.name} (Copy)`;
      this.addTrack({
        id: c,
        name: h,
        type: o.type
      }), await this.addClip(l, { trackId: c }), s.push(l.id);
    }
    s.length > 0 && this.studio.selection.selectClipsByIds(s);
  }
  /**
   * Split the selected clip at the given time or current time
   */
  async splitSelected(e) {
    const t = Array.from(this.studio.selection.selectedClips);
    if (t.length !== 1) {
      console.warn("[Studio] Split requires exactly one selected clip");
      return;
    }
    const s = t[0], r = e ?? this.studio.currentTime;
    if (r <= s.display.from || s.display.to > 0 && r >= s.display.to) {
      console.warn("[Studio] Split time is outside clip bounds");
      return;
    }
    const n = Zs(s, !1), o = r - s.display.from, a = s.playbackRate || 1, l = o * a, c = {
      duration: o,
      display: {
        from: s.display.from,
        to: r
      }
    };
    s.trim && (c.trim = {
      from: s.trim.from,
      to: s.trim.from + l
    }), await this.updateClip(s.id, c);
    const h = { ...n };
    h.display = {
      from: r,
      to: n.display.to
    }, h.duration = n.duration - o, h.trim && (h.trim = {
      from: h.trim.from + l,
      to: h.trim.to
    });
    const u = await Ks(h);
    u.id = `clip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const d = this.findTrackIdByClipId(s.id);
    d && (await this.addClip(u, { trackId: d }), this.studio.selection.selectClipsByIds([u.id]));
  }
  /**
   * Trim the selected clip from a specified time
   * @param trimFromSeconds - Number of seconds to trim from the start of the clip
   */
  async trimSelected(e) {
    const t = Array.from(this.studio.selection.selectedClips);
    if (t.length !== 1) {
      console.warn("[Studio] Trim requires exactly one selected clip");
      return;
    }
    const s = t[0], r = e * 1e6, n = s.playbackRate || 1, o = r * n;
    if (r >= s.duration) {
      console.warn("[Studio] Trim amount exceeds clip duration");
      return;
    }
    const a = s.duration - r, l = s.display.from + r, c = s.display.to, h = {
      duration: a,
      display: {
        from: l,
        to: c
      }
    };
    if (s.trim)
      h.trim = {
        from: s.trim.from + o,
        to: s.trim.to
      };
    else {
      const u = s.sourceDuration || s.duration;
      h.trim = {
        from: o,
        to: u
      };
    }
    await this.updateClip(s.id, h);
  }
  async updateSelected(e) {
    const t = Array.from(this.studio.selection.selectedClips);
    if (t.length !== 0)
      for (const s of t)
        await this.updateClip(s.id, e);
  }
  async setTracks(e) {
    this.tracks = e, await this.recalculateMaxDuration(), await this.studio.updateFrame(this.studio.currentTime);
  }
  async ensureFontsForClips(e) {
    const t = /* @__PURE__ */ new Map();
    for (const s of e) {
      if (s.type === "Text") {
        const r = s.style?.fontUrl || s.fontUrl;
        r && t.set(r, {
          name: s.style?.fontFamily || s.fontFamily || "CustomFont",
          url: r
        });
      }
      if (s.type === "Caption") {
        const r = s.style?.fontUrl || s.fontUrl;
        r && t.set(r, {
          name: s.style?.fontFamily || s.fontFamily || "CustomFont",
          url: r
        });
      }
    }
    if (t.size > 0)
      try {
        await XI.loadFonts(Array.from(t.values()));
      } catch (s) {
        console.warn("Failed to load some fonts:", s);
      }
  }
  async recalculateMaxDuration() {
    let e = 0;
    for (const t of this.clips) {
      t.display.to === 0 && t.duration !== 1 / 0 && !isNaN(t.duration) && t.duration > 0;
      const s = t.duration > 0 ? t.duration : 0;
      if (s === 1 / 0) continue;
      const r = t.display.to > 0 ? t.display.to : t.display.from + s;
      r > e && (e = r);
    }
    this.studio.maxDuration = e;
  }
  async setupPlaybackForClip(e, t) {
    if (this.studio.pixiApp != null) {
      if (!this.isPlaybackCapable(e)) {
        if (this.studio.pixiApp != null && (await e.ready).width > 0 && (await e.ready).height > 0) {
          const s = new qs(
            this.studio.pixiApp,
            e,
            this.studio.clipsNormalContainer
          );
          this.studio.spriteRenderers.set(e, s);
        }
        return;
      }
      try {
        const s = e;
        if (e instanceof Ne && t && typeof t != "string") {
          const o = URL.createObjectURL(t);
          e.src = o;
        }
        const { element: r, objectUrl: n } = await s.createPlaybackElement();
        if (e instanceof xe) {
          const o = L.from(r), a = new Me(o);
          a.visible = !1, this.studio.clipsNormalContainer && this.studio.clipsNormalContainer.addChild(a), this.studio.videoSprites.set(e, a);
        }
        this.studio.transport.playbackElements.set(e, { element: r, objectUrl: n });
      } catch (s) {
        if (console.warn(
          `Failed to setup playback for ${e.constructor.name}`,
          s
        ), this.studio.pixiApp != null && (await e.ready).width > 0 && (await e.ready).height > 0) {
          const r = new qs(
            this.studio.pixiApp,
            e,
            this.studio.artboard
          );
          this.studio.spriteRenderers.set(e, r);
        }
      }
    }
  }
  isPlaybackCapable(e) {
    return "createPlaybackElement" in e && "play" in e && "pause" in e && "seek" in e && "syncPlayback" in e && "cleanupPlayback" in e;
  }
  async clear() {
    this.studio.selection.deselectClip(), this.studio.selection.interactiveClips.clear();
    for (const [e, t] of this.studio.clipListeners)
      e.off("propsChange", t);
    this.studio.clipListeners.clear(), this.studio.globalEffects.clear(), this.studio.effectFilters.clear(), this.studio.transitionRenderers.forEach((e) => e.destroy()), this.studio.transitionRenderers.clear(), this.studio.transitionSprites.forEach((e) => {
      e.parent && e.parent.removeChild(e), e.destroy();
    }), this.studio.transitionSprites.clear(), this.studio.spriteRenderers.forEach((e) => e.destroy()), this.studio.spriteRenderers.clear();
    for (const [e, t] of this.studio.transport.playbackElements)
      this.isPlaybackCapable(e) && e.cleanupPlayback(t.element, t.objectUrl);
    this.studio.transport.playbackElements.clear();
    for (const e of this.studio.videoSprites.values())
      e.destroy();
    this.studio.videoSprites.clear(), this.tracks = [], this.clips = [], this.studio.maxDuration = 0, this.studio.currentTime = 0, this.studio.emit("reset");
  }
  /**
   * Remove a time range from the entire timeline and shift subsequent content left.
   * This is a ripple delete operation.
   * @param fromUs Start time in microseconds
   * @param toUs End time in microseconds
   */
  async rippleDelete(e, t) {
    if (e >= t) return;
    const s = t - e, r = [...this.clips];
    for (const n of r) {
      const o = n.display.from, a = n.display.to;
      if (!(a <= e)) {
        if (o >= t) {
          await this.updateClip(n.id, {
            display: {
              from: n.display.from - s,
              to: n.display.to - s
            }
          });
          continue;
        }
        if (o >= e && a <= t) {
          await this.removeClip(n);
          continue;
        }
        if (o < e && a > t) {
          const l = await n.clone();
          l.id = `clip_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          const c = e, h = e + (a - t), u = n.trim.from + (t - o) * n.playbackRate, d = n.trim.to, f = this.tracks.find((m) => m.clipIds.includes(n.id));
          f && (await this.addClip(l, { trackId: f.id }), await this.updateClip(l.id, {
            display: {
              from: c,
              to: h
            },
            trim: {
              from: u,
              to: d
            }
          })), await this.updateClip(n.id, {
            display: {
              from: n.display.from,
              to: e
            },
            trim: {
              from: n.trim.from,
              to: n.trim.from + (e - o) * n.playbackRate
            }
          });
          continue;
        }
        if (o < e && a <= t) {
          await this.updateClip(n.id, {
            display: {
              from: n.display.from,
              to: e
            },
            trim: {
              from: n.trim.from,
              to: n.trim.from + (e - o) * n.playbackRate
            }
          });
          continue;
        }
        if (o >= e && a > t) {
          await this.updateClip(n.id, {
            display: {
              from: e,
              to: e + (a - t)
            },
            trim: {
              from: n.trim.from + (t - o) * n.playbackRate,
              to: n.trim.to
            }
          });
          continue;
        }
      }
    }
    await this.recalculateMaxDuration(), await this.studio.updateFrame(this.studio.currentTime);
  }
}
class dk extends su {
  selection;
  transport;
  timeline;
  pixiApp = null;
  get tracks() {
    return this.timeline.tracks;
  }
  get clips() {
    return this.timeline.clips;
  }
  // BUT I need to remove the getter/setter I added in previous step.
  // And restoring `private clips` property.
  spriteRenderers = /* @__PURE__ */ new Map();
  artboard = null;
  clipContainer = null;
  artboardMask = null;
  artboardBg = null;
  // Transformer for interactive transform controls
  // Transformer for interactive transform controls
  // Delegated to SelectionManager
  get activeTransformer() {
    return this.selection.activeTransformer;
  }
  set activeTransformer(e) {
    this.selection.activeTransformer = e;
  }
  get selectedClips() {
    return this.selection.selectedClips;
  }
  set selectedClips(e) {
    this.selection.selectedClips = e;
  }
  get interactiveClips() {
    return this.selection.interactiveClips;
  }
  set interactiveClips(e) {
    this.selection.interactiveClips = e;
  }
  // Playback elements for clips that support playback
  get playbackElements() {
    return this.transport.playbackElements;
  }
  videoSprites = /* @__PURE__ */ new Map();
  clipListeners = /* @__PURE__ */ new Map();
  // Only for VideoClip
  get isPlaying() {
    return this.transport.isPlaying;
  }
  set isPlaying(e) {
    this.transport.isPlaying = e;
  }
  get currentTime() {
    return this.transport.currentTime;
  }
  set currentTime(e) {
    this.transport.currentTime = e;
  }
  get maxDuration() {
    return this.transport.maxDuration;
  }
  set maxDuration(e) {
    this.transport.maxDuration = e;
  }
  opts;
  destroyed = !1;
  renderingSuspended = !1;
  // Effect system
  globalEffects = /* @__PURE__ */ new Map();
  activeGlobalEffect = null;
  // private postProcessContainer: Container; // Removed
  currentGlobalEffectSprite = null;
  effectFilters = /* @__PURE__ */ new Map();
  transitionRenderers = /* @__PURE__ */ new Map();
  transitionSprites = /* @__PURE__ */ new Map();
  transFromTexture = null;
  transToTexture = null;
  transBgGraphics = null;
  clipsNormalContainer = null;
  clipsEffectContainer = null;
  videoTextureCache = /* @__PURE__ */ new WeakMap();
  lastFromFrame = null;
  lastToFrame = null;
  /**
   * Convert hex color string to number
   */
  hexToNumber(e) {
    const t = e.startsWith("#") ? e.slice(1) : e;
    return parseInt(t, 16);
  }
  ready;
  /**
   * Create a new Studio instance
   */
  constructor(e) {
    super(), this.opts = {
      fps: 30,
      bgColor: "#000000",
      interactivity: !0,
      ...e
    }, this.selection = new $I(this), this.transport = new YI(this), this.timeline = new qI(this), this.ready = this.initPixiApp(), this.on("clip:removed", this.handleClipRemoved), this.on("clip:updated", this.handleTimelineChange), this.on("clip:added", this.handleTimelineChange), this.on("clips:added", this.handleTimelineChange), this.on("track:removed", this.handleTimelineChange), this.on("track:added", this.handleTimelineChange);
  }
  handleTimelineChange = () => {
    this.updateFrame(this.currentTime);
  };
  handleClipRemoved = ({ clipId: e }) => {
    for (const [r, n] of this.spriteRenderers)
      if (r.id === e) {
        const o = n.getRoot();
        o && o.parent && o.parent.removeChild(o), n.destroy(), this.spriteRenderers.delete(r);
        break;
      }
    const t = this.transitionSprites.get(e);
    t && (t.parent && t.parent.removeChild(t), t.destroy(), this.transitionSprites.delete(e)), this.transitionRenderers.get(e) && this.transitionRenderers.delete(e);
    for (const [r, n] of this.videoSprites)
      if (r.id === e) {
        n.parent && n.parent.removeChild(n), n.destroy(), this.videoSprites.delete(r);
        break;
      }
    for (const [r] of this.clipListeners)
      if (r.id === e) {
        this.clipListeners.delete(r);
        break;
      }
    this.updateFrame(this.currentTime);
  };
  async initPixiApp() {
    if (this.destroyed) return;
    const e = this.opts.canvas || document.createElement("canvas");
    e.width = this.opts.width, e.height = this.opts.height;
    const t = new cu(), s = e.parentElement || window;
    await t.init({
      canvas: e,
      resizeTo: s,
      // Auto-resize to fill the container
      // width/height are derived from resizeTo, so we don't set them explicitly for the renderer
      backgroundColor: this.hexToNumber(this.opts.bgColor),
      antialias: !0,
      resolution: window.devicePixelRatio || 1,
      autoDensity: !0
    }), this.pixiApp = t, t.stage.eventMode = "static", t.stage.hitArea = t.screen, this.artboard = new oe(), this.artboard.label = "ArtboardRoot", t.stage.addChild(this.artboard), this.selection.init(t, this.artboard), this.artboardBg = new fe(), this.artboardBg.rect(0, 0, this.opts.width, this.opts.height).fill({ color: 0 }), this.artboard.addChild(this.artboardBg), this.clipContainer = new oe(), this.clipContainer.label = "ClipContainer", this.artboard.addChild(this.clipContainer), this.artboardMask = new fe(), this.artboardMask.rect(0, 0, this.opts.width, this.opts.height).fill({ color: 16777215 }), this.clipContainer.addChild(this.artboardMask), this.clipContainer.mask = this.artboardMask, this.clipsEffectContainer = new oe(), this.clipsEffectContainer.label = "ClipsEffect", this.clipsEffectContainer.visible = !1, this.clipsEffectContainer.zIndex = 1, this.clipsEffectContainer.sortableChildren = !0, this.clipContainer.addChild(this.clipsEffectContainer), this.clipsNormalContainer = new oe(), this.clipsNormalContainer.label = "ClipsNormal", this.clipsNormalContainer.zIndex = 10, this.clipsNormalContainer.sortableChildren = !0, this.clipContainer.addChild(this.clipsNormalContainer), this.transFromTexture = Pe.create({
      width: this.opts.width,
      height: this.opts.height
    }), this.transToTexture = Pe.create({
      width: this.opts.width,
      height: this.opts.height
    }), this.transBgGraphics = new fe(), this.transBgGraphics.rect(0, 0, this.opts.width, this.opts.height).fill({
      color: 0,
      alpha: 0
    }), this.clipContainer.sortableChildren = !0, this.updateArtboardLayout(), t.renderer.on("resize", () => {
      this.handleResize();
    });
  }
  /**
   * Get studio options
   */
  getOptions() {
    return this.opts;
  }
  /**
   * Update studio dimensions
   */
  updateDimensions(e, t) {
    this.opts.width = e, this.opts.height = t, this.artboardBg && this.artboardBg.clear().rect(0, 0, e, t).fill({ color: 3355443 }), this.artboardMask && this.artboardMask.clear().rect(0, 0, e, t).fill({ color: 16777215 }), this.transFromTexture && this.transFromTexture.resize(e, t), this.transToTexture && this.transToTexture.resize(e, t), this.transBgGraphics && this.transBgGraphics.clear().rect(0, 0, e, t).fill({ color: 0, alpha: 0 }), this.updateArtboardLayout(), this.updateFrame(this.currentTime);
  }
  handleResize = () => {
    this.destroyed || !this.pixiApp || this.updateArtboardLayout();
  };
  updateArtboardLayout() {
    if (!this.pixiApp || !this.artboard) return;
    const e = this.pixiApp.canvas.width, t = this.pixiApp.canvas.height, s = this.opts.width, r = this.opts.height, n = this.pixiApp.canvas.parentElement?.clientWidth || e, o = this.pixiApp.canvas.parentElement?.clientHeight || t, a = n / s, l = o / r, c = Math.min(a, l);
    this.artboard.scale.set(c), this.artboard.x = (n - s * c) / 2, this.artboard.y = (o - r * c) / 2;
  }
  /**
   * Get the canvas element (creates one if not provided)
   */
  getCanvas() {
    if (this.opts.canvas)
      return this.opts.canvas;
    if (this.pixiApp?.canvas)
      return this.pixiApp.canvas;
    throw new Error(
      "Canvas not initialized yet. Wait for initPixiApp to complete."
    );
  }
  /**
   * Add a Media clip (Video/Image) to the main track with ripple effect
   */
  /**
   * Add a Media clip (Video/Image) to the main track with ripple effect
   */
  async addMedia(e) {
    return this.timeline.addMedia(e);
  }
  async addTransition(e, t = 2e6, s, r) {
    return this.timeline.addTransition(
      e,
      t,
      s,
      r
    );
  }
  findTrackIdByClipId(e) {
    return this.timeline.findTrackIdByClipId(e);
  }
  /**
   * Add a clip (or clips) to the studio
   * @param clipOrClips The clip or array of clips to add
   * @param options Options for addition (trackId, etc.)
   */
  async addClip(e, t) {
    return this.timeline.addClip(e, t);
  }
  /**
   * Add a new track to the studio
   */
  addTrack(e) {
    return this.timeline.addTrack(e);
  }
  async setTracks(e) {
    return this.timeline.setTracks(e);
  }
  async removeTrack(e) {
    return this.timeline.removeTrack(e);
  }
  /**
   * Get a clip by its ID
   */
  getClipById(e) {
    return this.timeline.getClipById(e);
  }
  async updateClip(e, t) {
    return this.timeline.updateClip(e, t);
  }
  async updateClips(e) {
    this.suspendRendering(), await this.timeline.updateClips(e), this.resumeRendering(), this.updateFrame(this.currentTime);
  }
  suspendRendering() {
    this.renderingSuspended = !0;
  }
  resumeRendering() {
    this.renderingSuspended = !1;
  }
  getTracks() {
    return this.timeline.tracks;
  }
  getClip(e) {
    return this.timeline.getClipById(e);
  }
  /**
   * Setup sprite interactivity for click selection
   * Delegated to SelectionManager
   */
  setupSpriteInteractivity(e) {
    this.selection.setupSpriteInteractivity(e);
  }
  /**
   * Setup playback element for a clip (if it supports playback)
   */
  /**
   * Remove a clip from the studio
   */
  async removeClip(e) {
    return this.timeline.removeClip(e);
  }
  async removeClipById(e) {
    return this.timeline.removeClipById(e);
  }
  async deleteSelected() {
    return this.timeline.deleteSelected();
  }
  /**
   * Duplicate all currently selected clips
   */
  async duplicateSelected() {
    return this.timeline.duplicateSelected();
  }
  async splitSelected(e) {
    return this.timeline.splitSelected(e);
  }
  async trimSelected(e) {
    return this.timeline.trimSelected(e);
  }
  async updateSelected(e) {
    return this.timeline.updateSelected(e);
  }
  /**
   * Clear all clips from the studio
   */
  async clear() {
    await this.timeline.clear(), this.transFromTexture && (this.transFromTexture.destroy(!0), this.transFromTexture = null), this.transToTexture && (this.transToTexture.destroy(!0), this.transToTexture = null), this.transBgGraphics && (this.transBgGraphics.destroy(!0), this.transBgGraphics = null), this.emit("reset");
  }
  /**
   * Start playback
   */
  async play() {
    return this.transport.play();
  }
  /**
   * Pause playback
   */
  pause() {
    this.transport.pause();
  }
  /**
   * Stop playback and reset to start
   */
  async stop() {
    return this.transport.stop();
  }
  /**
   * Seek to a specific time (in microseconds)
   */
  async seek(e) {
    return this.transport.seek(e);
  }
  /**
   * Get current playback time (in microseconds)
   */
  getCurrentTime() {
    return this.transport.currentTime;
  }
  /**
   * Get maximum duration (in microseconds)
   */
  getMaxDuration() {
    return this.transport.maxDuration;
  }
  /**
   * Check if currently playing
   */
  getIsPlaying() {
    return this.transport.isPlaying;
  }
  /**
   * Get currently selected clips
   */
  getSelectedClips() {
    return Array.from(this.selectedClips);
  }
  // renderLoop deleted (moved to PlaybackController)
  getVideoTexture(e) {
    let t = this.videoTextureCache.get(e);
    return t || (t = L.from(e), this.videoTextureCache.set(e, t)), t;
  }
  isPlaybackCapable(e) {
    return "createPlaybackElement" in e && "play" in e && "pause" in e && "seek" in e && "syncPlayback" in e && "cleanupPlayback" in e;
  }
  async updateFrame(e) {
    if (this.destroyed || this.pixiApp == null || this.renderingSuspended)
      return;
    this.updateActiveGlobalEffect(e);
    const t = /* @__PURE__ */ new Set(), s = this.tracks.length;
    for (const n of this.clips) {
      const o = this.getTrackIndex(n.id);
      if (o !== -1) {
        const a = (s - o) * 10;
        n.zIndex = a;
        const l = this.spriteRenderers.get(n);
        if (l) {
          const c = l.getRoot();
          c && (c.zIndex = a);
        }
      }
    }
    const r = [...this.clips].sort((n, o) => n.zIndex - o.zIndex);
    for (const n of r) {
      if (e < n.display.from) {
        const p = this.spriteRenderers.get(n);
        p != null && await p.updateFrame(null);
        const x = this.playbackElements.get(n);
        x != null && this.isPlaybackCapable(n) && n.pause(x.element);
        continue;
      }
      if (n.display.to > 0 && e >= n.display.to) {
        const p = this.spriteRenderers.get(n);
        p != null && await p.updateFrame(null);
        const x = this.playbackElements.get(n);
        x != null && this.isPlaybackCapable(n) && n.pause(x.element);
        continue;
      }
      const o = e - n.display.from, a = o * n.playbackRate;
      n.animate(a);
      const l = await n.ready, c = n.duration || l.duration;
      if (c > 0 && o >= c) {
        const p = this.spriteRenderers.get(n);
        p != null && await p.updateFrame(null);
        const x = this.playbackElements.get(n);
        x != null && this.isPlaybackCapable(n) && n.pause(x.element);
        continue;
      }
      const h = this.playbackElements.get(n), u = n instanceof xe || n instanceof Se, d = n.transition ? n.transition.start : 0, f = n.transition ? n.transition.end : 0, m = u && n.transition && e >= d && e < f;
      if (h != null && this.isPlaybackCapable(n)) {
        const p = o / 1e6;
        if (n.syncPlayback(
          h.element,
          this.isPlaying,
          p
        ), n instanceof xe) {
          const x = this.videoSprites.get(n);
          if (x != null) {
            const y = n.meta.duration / 1e6;
            if (this.spriteRenderers.has(n))
              x.visible = !1;
            else if (x.visible = !m && p >= 0 && p < y, x.visible && D3(n, x), !m)
              continue;
          }
        } else
          continue;
      }
      if (m) {
        this.transFromTexture || (this.transFromTexture = Pe.create({
          width: this.opts.width,
          height: this.opts.height
        })), this.transToTexture || (this.transToTexture = Pe.create({
          width: this.opts.width,
          height: this.opts.height
        })), this.transBgGraphics || (this.transBgGraphics = new fe(), this.transBgGraphics.rect(0, 0, this.opts.width, this.opts.height).fill({ color: 0, alpha: 0 }));
        const p = this.getClipById(n?.transition?.fromClipId), x = this.getClipById(n?.transition?.toClipId);
        let y = null, v = null;
        if (p) {
          const _ = Math.max(
            0,
            e - p.display.from
          ), { video: b } = await p.getFrame(_);
          b instanceof HTMLVideoElement ? y = this.getVideoTexture(b) : y = b, y && (this.lastFromFrame = y);
        }
        if (x) {
          const _ = Math.max(0, e - x.display.from), { video: b } = await x.getFrame(_);
          b instanceof HTMLVideoElement ? v = this.getVideoTexture(b) : v = b, v && (this.lastToFrame = v);
        }
        if (y || (y = this.lastFromFrame), v || (v = this.lastToFrame), !y || !v)
          continue;
        if (y && v && this.pixiApp && this.transFromTexture && this.transToTexture) {
          const _ = (e - d) / n?.transition?.duration;
          p && y && this.renderClipToTransitionTexture(
            p,
            y,
            this.transFromTexture
          ), x && v && this.renderClipToTransitionTexture(
            x,
            v,
            this.transToTexture
          );
          let b = this.transitionRenderers.get(n.id);
          if (!b)
            try {
              b = eg({
                name: n?.transition?.name,
                renderer: this.pixiApp.renderer
              }), this.transitionRenderers.set(n.id, b);
            } catch (T) {
              console.error(
                "[Studio] Failed to create transition renderer:",
                T
              );
            }
          if (b) {
            const T = b.render({
              width: this.opts.width,
              height: this.opts.height,
              from: this.transFromTexture,
              to: this.transToTexture,
              progress: _
            });
            let w = this.transitionSprites.get(n.id);
            w || (w = new Me(), w.label = `TransitionSprite_${n.id}`, this.transitionSprites.set(n.id, w), this.clipsNormalContainer && this.clipsNormalContainer.addChild(w)), w.texture = T, w.visible = !0, w.x = 0, w.y = 0, w.width = this.opts.width, w.height = this.opts.height, w.anchor.set(0, 0), w.zIndex = n.zIndex, t.add(n.id);
            const A = this.spriteRenderers.get(n);
            A?.getRoot() && (A.getRoot().visible = !1);
            const k = this.videoSprites.get(n);
            if (k && (k.visible = !1), p) {
              const S = this.spriteRenderers.get(p);
              S?.getRoot() && (S.getRoot().visible = !1);
              const C = this.videoSprites.get(p);
              C && (C.visible = !1);
            }
            continue;
          }
        }
      }
      const g = this.spriteRenderers.get(n);
      if (g != null) {
        const p = this.selectedClips.has(n);
        if (n instanceof Se) {
          const y = n.getTexture();
          if (y != null) {
            await g.updateFrame(y), p || g.updateTransforms();
            continue;
          }
        }
        if (n instanceof et) {
          const y = await n.getTexture();
          if (y != null) {
            await g.updateFrame(y), p || g.updateTransforms();
            continue;
          }
        }
        if (n instanceof Ft) {
          n.updateState(o);
          const y = await n.getTexture();
          if (y != null) {
            await g.updateFrame(y), p || g.updateTransforms(), this.opts.interactivity && this.selection.setupSpriteInteractivity(n);
            continue;
          } else
            console.log(
              "[Studio] CaptionClip texture is null, falling back to traditional path"
            );
        }
        const { video: x } = await n.getFrame(o);
        await g.updateFrame(x), p || g.updateTransforms(), this.opts.interactivity && this.selection.setupSpriteInteractivity(n);
      }
    }
    if (this.activeGlobalEffect && this.clipsNormalContainer && this.clipsEffectContainer) {
      const { startTime: n, duration: o } = this.activeGlobalEffect, a = e - n, l = Math.min(Math.max(a / o, 0), 1);
      if (l > 0 && l < 1) {
        try {
          for (const h of this.clips)
            this.moveClipToEffectContainer(h, !1);
          const c = this.clips.some(
            (h) => h.id === this.activeGlobalEffect.id && h instanceof tt
          );
          for (const h of this.clips) {
            let u = !1;
            if (c) {
              const d = this.activeGlobalEffect.trackIndex ?? -1, f = this.getTrackIndex(h.id);
              u = h.id !== this.activeGlobalEffect.id && !(h instanceof tt) && f > d;
            } else {
              const d = h.effects;
              u = Array.isArray(d) && d.some(
                (f) => f && f.id === this.activeGlobalEffect.id
              );
            }
            u && this.moveClipToEffectContainer(h, !0);
          }
        } catch (c) {
          console.warn(
            "Failed to reparent clips for effect; falling back to full-scene render",
            c
          );
        }
        this.clipsNormalContainer.visible = !0, await this.applyGlobalEffectIfNeeded(e);
      } else {
        for (const c of this.clips)
          try {
            this.moveClipToEffectContainer(c, !1);
          } catch {
          }
        this.clipsNormalContainer.visible = !0, this.currentGlobalEffectSprite && (this.currentGlobalEffectSprite.parent && this.currentGlobalEffectSprite.parent.removeChild(
          this.currentGlobalEffectSprite
        ), this.currentGlobalEffectSprite.destroy(), this.currentGlobalEffectSprite = null);
      }
    } else if (this.clipsNormalContainer) {
      for (const n of this.clips)
        try {
          this.moveClipToEffectContainer(n, !1);
        } catch {
        }
      this.clipsNormalContainer.visible = !0, this.currentGlobalEffectSprite && (this.currentGlobalEffectSprite.parent && this.currentGlobalEffectSprite.parent.removeChild(
        this.currentGlobalEffectSprite
      ), this.currentGlobalEffectSprite.destroy(), this.currentGlobalEffectSprite = null);
    }
    for (const [n, o] of this.transitionSprites.entries())
      t.has(n) || (o.visible = !1);
    this.pixiApp != null && this.pixiApp.render();
  }
  /**
   * Apply global effect to the current scene
   */
  moveClipToEffectContainer(e, t = !0) {
    if (!this.clipsNormalContainer || !this.clipsEffectContainer) return;
    const s = t ? this.clipsEffectContainer : this.clipsNormalContainer, r = this.spriteRenderers.get(e);
    if (r) {
      const o = r.getRoot();
      if (o && o.parent !== s) {
        try {
          o.parent && o.parent.removeChild && o.parent.removeChild(o);
        } catch (a) {
          console.warn(
            "moveClipToEffectContainer: could not remove root from parent",
            a
          );
        }
        s.addChild(o);
      }
    }
    const n = this.transitionSprites.get(e.id);
    if (n && n.parent !== s) {
      try {
        n.parent && n.parent.removeChild && n.parent.removeChild(n);
      } catch (o) {
        console.warn(
          "moveClipToEffectContainer: could not remove transSprite from parent",
          o
        );
      }
      s.addChild(n);
    }
  }
  applyGlobalEffect(e, t, s) {
    const r = t.id || `${e}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, n = {
      id: r,
      key: e,
      startTime: t.startTime,
      duration: t.duration ?? 1e6
    };
    for (const o of s)
      o instanceof Se && o.addEffect(n), o instanceof xe && o.addEffect(n), o instanceof et && o.addEffect(n), o instanceof Ft && o.addEffect(n);
    return this.globalEffects.set(r, n), r;
  }
  getTrackIndex(e) {
    return this.tracks.findIndex((t) => t.clipIds.includes(e));
  }
  /**
   * Get the frame from the previous clip on the same track for transition
   */
  async getTransitionFromFrame(e, t) {
    let s = null;
    if (e.transition?.prevClipId && (s = this.clips.find((a) => a.id === e.transition.prevClipId) || null), s || (s = this.getPreviousClipOnTrack(e)), !s) return null;
    const r = s.duration > 0 ? s.duration : 0, n = Math.max(
      0,
      Math.min(t - s.display.from, r)
    ), { video: o } = await s.getFrame(n);
    return o;
  }
  getPreviousClipOnTrack(e) {
    const t = this.getTrackIndex(e.id);
    return t === -1 ? null : this.clips.filter(
      (s) => s.id !== e.id && this.getTrackIndex(s.id) === t && s.display.from < e.display.from && (s instanceof xe || s instanceof Se)
    ).sort((s, r) => r.display.to - s.display.to)[0] || null;
  }
  /**
   * Renders a clip frame onto a transition texture with red background
   */
  renderClipToTransitionTexture(e, t, s) {
    if (!this.pixiApp || !this.transBgGraphics) return;
    const r = this.pixiApp.renderer.background.alpha;
    this.pixiApp.renderer.background.alpha = 0, this.pixiApp.renderer.render({
      container: this.transBgGraphics,
      target: s,
      clear: !0
    }), this.pixiApp.renderer.background.alpha = r;
    const n = new Me(
      t instanceof L ? t : L.from(t)
    );
    n.x = e.center.x, n.y = e.center.y, n.anchor.set(0.5, 0.5);
    const o = n.texture.width || 1, a = n.texture.height || 1, l = e.width && e.width !== 0 ? Math.abs(e.width) / o : 1, c = e.height && e.height !== 0 ? Math.abs(e.height) / a : 1;
    e.flip === "horizontal" ? (n.scale.x = -l, n.scale.y = c) : e.flip === "vertical" ? (n.scale.x = l, n.scale.y = -c) : (n.scale.x = l, n.scale.y = c), n.rotation = (e.flip == null ? 1 : -1) * e.angle, n.alpha = e.opacity, this.pixiApp.renderer.render({
      container: n,
      target: s,
      clear: !1
    }), t instanceof L || n.texture.destroy(!0), n.destroy();
  }
  removeGlobalEffect(e) {
    this.globalEffects.delete(e);
  }
  clearGlobalEffects() {
    this.globalEffects.clear();
  }
  updateActiveGlobalEffect(e) {
    let t = null;
    for (const s of this.clips)
      if (s instanceof tt && e >= s.display.from && (s.display.to === 0 || e < s.display.to)) {
        t = {
          id: s.id,
          key: s.effect.key,
          startTime: s.display.from,
          duration: s.duration > 0 ? s.duration : s.display.to - s.display.from,
          trackIndex: this.getTrackIndex(s.id)
        };
        break;
      }
    if (!t)
      for (const s of this.globalEffects.values()) {
        const r = s.startTime + s.duration;
        if (e >= s.startTime && e < r) {
          t = {
            id: s.id,
            key: s.key,
            startTime: s.startTime,
            duration: s.duration,
            trackIndex: -1
            // Global effects apply to everything
          };
          break;
        }
      }
    this.activeGlobalEffect = t;
  }
  async applyGlobalEffectIfNeeded(e) {
    if (this.currentGlobalEffectSprite && (this.currentGlobalEffectSprite.parent && this.currentGlobalEffectSprite.parent.removeChild(
      this.currentGlobalEffectSprite
    ), this.currentGlobalEffectSprite.destroy(), this.currentGlobalEffectSprite = null), !this.activeGlobalEffect || !this.pixiApp || !this.clipContainer || !this.artboard || !this.clipsNormalContainer || !this.clipsEffectContainer)
      return;
    const { key: t, startTime: s, duration: r } = this.activeGlobalEffect, n = e - s, o = Math.min(Math.max(n / r, 0), 1);
    if (o <= 0 || o >= 1) return;
    this.clipsEffectContainer.visible = !0;
    let a = this.effectFilters.get(t);
    if (!a)
      try {
        if (a = Qm({
          name: t.toLowerCase(),
          renderer: this.pixiApp.renderer
        }), a)
          this.effectFilters.set(t, a);
        else
          return;
      } catch (f) {
        console.error(f);
        return;
      }
    const l = this.opts.width, c = this.opts.height, h = Pe.create({
      width: l,
      height: c
    });
    this.pixiApp.renderer.render({
      container: this.clipsEffectContainer,
      target: h,
      clear: !0
    }), this.clipsEffectContainer.visible = !1;
    const u = a.render({
      canvasTexture: h,
      progress: o,
      width: l,
      height: c
    }), d = new Me(u);
    d.x = 0, d.y = 0, d.width = l, d.height = c, d.scale.set(1), d.zIndex = 5, this.clipContainer.addChild(d), this.currentGlobalEffectSprite = d, h.destroy(!0);
  }
  /**
   * Destroy the studio and clean up resources
   */
  destroy() {
    if (!this.destroyed) {
      window.removeEventListener("resize", this.handleResize), this.destroyed = !0, this.stop(), this.clear(), this.transitionRenderers.clear(), this.transFromTexture && (this.transFromTexture.destroy(!0), this.transFromTexture = null), this.transToTexture && (this.transToTexture.destroy(!0), this.transToTexture = null), this.transBgGraphics && (this.transBgGraphics.destroy(!0), this.transBgGraphics = null);
      for (const e of this.transitionSprites.values())
        e.destroy();
      this.transitionSprites.clear(), this.pixiApp && (this.pixiApp.destroy(!0, {
        children: !0,
        texture: !0
      }), this.pixiApp = null);
    }
  }
  /**
   * Select a clip and show transform controls
   * Delegated to InteractionManager
   */
  selectClip(e, t = !1) {
    this.selection.selectClip(e, t);
  }
  // createTransformer deleted (moved to manager)
  /**
   * Set the selection to a specific list of clips
   */
  setSelection(e) {
    this.selection.setSelection(e);
  }
  /**
   * Select clips by their IDs
   */
  selectClipsByIds(e) {
    this.selection.selectClipsByIds(e);
  }
  /**
   * Deselect the current clip and hide transform controls
   */
  deselectClip() {
    this.selection.deselectClip();
  }
  /**
   * Export current studio state to JSON
   * @param sourceUrlMap Optional map of clips to their source URLs (required for proper serialization)
   */
  exportToJSON() {
    return this.timeline.exportToJSON();
  }
  async loadFromJSON(e) {
    return this.timeline.loadFromJSON(e);
  }
  // End of class Studio (removed legacy commented out code)
}
export {
  hi as $,
  am as A,
  ze as B,
  oe as C,
  re as D,
  O as E,
  mr as F,
  yi as G,
  it as H,
  di as I,
  Zu as J,
  Me as K,
  R2 as L,
  W as M,
  $2 as N,
  os as O,
  q as P,
  de as Q,
  ji as R,
  W2 as S,
  zi as T,
  Ph as U,
  G as V,
  c1 as W,
  Ju as X,
  Hc as Y,
  ju as Z,
  f2 as _,
  rt as a,
  pe as a0,
  u2 as a1,
  kp as a2,
  Pe as a3,
  lm as a4,
  N as a5,
  J as a6,
  p1 as a7,
  D1 as a8,
  E1 as a9,
  et as aA,
  tt as aB,
  pi as aC,
  uk as aD,
  dk as aE,
  K as aF,
  Zs as aG,
  Ks as aH,
  XI as aI,
  Qm as aJ,
  ck as aK,
  eg as aL,
  hk as aM,
  sw as aa,
  nw as ab,
  hw as ac,
  dw as ad,
  fw as ae,
  wm as af,
  fd as ag,
  ud as ah,
  lr as ai,
  Ge as aj,
  Pm as ak,
  ne as al,
  fe as am,
  Rb as an,
  Ze as ao,
  qd as ap,
  Cm as aq,
  ZS as ar,
  ak as as,
  lk as at,
  sk as au,
  rk as av,
  Ne as aw,
  Ft as ax,
  Se as ay,
  xe as az,
  k1 as b,
  is as c,
  $s as d,
  ke as e,
  dd as f,
  C1 as g,
  lu as h,
  rm as i,
  Dp as j,
  Ke as k,
  Jp as l,
  rs as m,
  iw as n,
  rw as o,
  lw as p,
  uw as q,
  qb as r,
  pr as s,
  L as t,
  Ub as u,
  xi as v,
  se as w,
  pw as x,
  Xe as y,
  Cp as z
};
