(function(re,bi){typeof exports=="object"&&typeof module<"u"?bi(exports):typeof define=="function"&&define.amd?define(["exports"],bi):(re=typeof globalThis<"u"?globalThis:re||self,bi(re.core={}))})(this,(function(re){"use strict";var bi=i=>{throw TypeError(i)},yn=(i,e,t)=>e.has(i)||bi("Cannot "+t),gv=(i,e,t)=>(yn(i,e,"read from private field"),t?t.call(i):e.get(i)),pf=(i,e,t)=>e.has(i)?bi("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(i):e.set(i,t),_v=(i,e,t,s)=>(yn(i,e,"write to private field"),e.set(i,t),t),mf=(i,e,t)=>(yn(i,e,"access private method"),t),xv=Object.defineProperty,gf=(i,e)=>{for(var t in e)xv(i,t,{get:e[t],enumerable:!0})},bn=Math.pow(2,32),Ae=Math.pow(2,32)-1,vv=1,yv=2,bv=4,js=1,Zs=2,Js=8,Qs=16,er=32,_f=131072,es=1,tr=4,ts=256,is=512,ss=1024,rs=2048,xf=-1,Vt=0,Ve=1,yt=class Wx extends ArrayBuffer{constructor(e){super(e),this.fileStart=0,this.usedBytes=0}static fromArrayBuffer(e,t){const s=new Wx(e.byteLength);return new Uint8Array(s).set(new Uint8Array(e)),s.fileStart=t,s}},vf=(i=>(i[i.BIG_ENDIAN=1]="BIG_ENDIAN",i[i.LITTLE_ENDIAN=2]="LITTLE_ENDIAN",i))(vf||{}),ir,Tn,j,Pe=(j=class{constructor(i,e,t){pf(this,ir),this._byteLength=0,this.failurePosition=0,this._dynamicSize=1,this._byteOffset=e||0,i instanceof ArrayBuffer?this.buffer=yt.fromArrayBuffer(i,0):i instanceof DataView?(this.dataView=i,e&&(this._byteOffset+=e)):this.buffer=new yt(i||0),this.position=0,this.endianness=t||1}getPosition(){return this.position}_realloc(i){if(!this._dynamicSize)return;const e=this._byteOffset+this.position+i;let t=this._buffer.byteLength;if(e<=t){e>this._byteLength&&(this._byteLength=e);return}for(t<1&&(t=1);e>t;)t*=2;const s=new yt(t),r=new Uint8Array(this._buffer);new Uint8Array(s,0,r.length).set(r),this.buffer=s,this._byteLength=e}_trimAlloc(){if(this._byteLength===this._buffer.byteLength)return;const i=new yt(this._byteLength),e=new Uint8Array(i),t=new Uint8Array(this._buffer,0,e.length);e.set(t),this.buffer=i}get byteLength(){return this._byteLength-this._byteOffset}get buffer(){return this._trimAlloc(),this._buffer}set buffer(i){this._buffer=i,this._dataView=new DataView(i,this._byteOffset),this._byteLength=i.byteLength}get byteOffset(){return this._byteOffset}set byteOffset(i){this._byteOffset=i,this._dataView=new DataView(this._buffer,this._byteOffset),this._byteLength=this._buffer.byteLength}get dataView(){return this._dataView}set dataView(i){this._byteOffset=i.byteOffset,this._buffer=yt.fromArrayBuffer(i.buffer,0),this._dataView=new DataView(this._buffer,this._byteOffset),this._byteLength=this._byteOffset+i.byteLength}seek(i){const e=Math.max(0,Math.min(this.byteLength,i));this.position=isNaN(e)||!isFinite(e)?0:e}isEof(){return this.position>=this._byteLength}mapUint8Array(i){this._realloc(i*1);const e=new Uint8Array(this._buffer,this.byteOffset+this.position,i);return this.position+=i*1,e}readInt32Array(i,e){i=i===void 0?this.byteLength-this.position/4:i;const t=new Int32Array(i);return j.memcpy(t.buffer,0,this.buffer,this.byteOffset+this.position,i*t.BYTES_PER_ELEMENT),j.arrayToNative(t,e??this.endianness),this.position+=t.byteLength,t}readInt16Array(i,e){i=i===void 0?this.byteLength-this.position/2:i;const t=new Int16Array(i);return j.memcpy(t.buffer,0,this.buffer,this.byteOffset+this.position,i*t.BYTES_PER_ELEMENT),j.arrayToNative(t,e??this.endianness),this.position+=t.byteLength,t}readInt8Array(i){i=i===void 0?this.byteLength-this.position:i;const e=new Int8Array(i);return j.memcpy(e.buffer,0,this.buffer,this.byteOffset+this.position,i*e.BYTES_PER_ELEMENT),this.position+=e.byteLength,e}readUint32Array(i,e){i=i===void 0?this.byteLength-this.position/4:i;const t=new Uint32Array(i);return j.memcpy(t.buffer,0,this.buffer,this.byteOffset+this.position,i*t.BYTES_PER_ELEMENT),j.arrayToNative(t,e??this.endianness),this.position+=t.byteLength,t}readUint16Array(i,e){i=i===void 0?this.byteLength-this.position/2:i;const t=new Uint16Array(i);return j.memcpy(t.buffer,0,this.buffer,this.byteOffset+this.position,i*t.BYTES_PER_ELEMENT),j.arrayToNative(t,e??this.endianness),this.position+=t.byteLength,t}readUint8Array(i){i=i===void 0?this.byteLength-this.position:i;const e=new Uint8Array(i);return j.memcpy(e.buffer,0,this.buffer,this.byteOffset+this.position,i*e.BYTES_PER_ELEMENT),this.position+=e.byteLength,e}readFloat64Array(i,e){i=i===void 0?this.byteLength-this.position/8:i;const t=new Float64Array(i);return j.memcpy(t.buffer,0,this.buffer,this.byteOffset+this.position,i*t.BYTES_PER_ELEMENT),j.arrayToNative(t,e??this.endianness),this.position+=t.byteLength,t}readFloat32Array(i,e){i=i===void 0?this.byteLength-this.position/4:i;const t=new Float32Array(i);return j.memcpy(t.buffer,0,this.buffer,this.byteOffset+this.position,i*t.BYTES_PER_ELEMENT),j.arrayToNative(t,e??this.endianness),this.position+=t.byteLength,t}readInt32(i){const e=this._dataView.getInt32(this.position,(i??this.endianness)===2);return this.position+=4,e}readInt16(i){const e=this._dataView.getInt16(this.position,(i??this.endianness)===2);return this.position+=2,e}readInt8(){const i=this._dataView.getInt8(this.position);return this.position+=1,i}readUint32(i){const e=this._dataView.getUint32(this.position,(i??this.endianness)===2);return this.position+=4,e}readUint16(i){const e=this._dataView.getUint16(this.position,(i??this.endianness)===2);return this.position+=2,e}readUint8(){const i=this._dataView.getUint8(this.position);return this.position+=1,i}readFloat32(i){const e=this._dataView.getFloat32(this.position,(i??this.endianness)===2);return this.position+=4,e}readFloat64(i){const e=this._dataView.getFloat64(this.position,(i??this.endianness)===2);return this.position+=8,e}static memcpy(i,e,t,s,r){const n=new Uint8Array(i,e,r),o=new Uint8Array(t,s,r);n.set(o)}static arrayToNative(i,e){return e===j.ENDIANNESS?i:this.flipArrayEndianness(i)}static nativeToEndian(i,e){return e&&j.ENDIANNESS===2?i:this.flipArrayEndianness(i)}static flipArrayEndianness(i){const e=new Uint8Array(i.buffer,i.byteOffset,i.byteLength);for(let t=0;t<i.byteLength;t+=i.BYTES_PER_ELEMENT)for(let s=t+i.BYTES_PER_ELEMENT-1,r=t;s>r;s--,r++){const n=e[r];e[r]=e[s],e[s]=n}return i}readString(i,e){return e===void 0||e==="ASCII"?yf(this.mapUint8Array(i===void 0?this.byteLength-this.position:i)):new TextDecoder(e).decode(this.mapUint8Array(i))}readCString(i){let e=0;const t=this.byteLength-this.position,s=new Uint8Array(this._buffer,this._byteOffset+this.position),r=i!==void 0?Math.min(i,t):t;for(;e<r&&s[e]!==0;e++);const n=yf(this.mapUint8Array(e));return i!==void 0?this.position+=r-e:e!==t&&(this.position+=1),n}readInt64(){return this.readInt32()*bn+this.readUint32()}readUint64(){return this.readUint32()*bn+this.readUint32()}readUint24(){return(this.readUint8()<<16)+(this.readUint8()<<8)+this.readUint8()}save(i){const e=new Blob([this.buffer]);if(typeof window<"u"&&typeof document<"u")if(window.URL&&URL.createObjectURL){const t=window.URL.createObjectURL(e),s=document.createElement("a");document.body.appendChild(s),s.setAttribute("href",t),s.setAttribute("download",i),s.setAttribute("target","_self"),s.click(),window.URL.revokeObjectURL(t),document.body.removeChild(s)}else throw new Error("DataStream.save: Can't create object URL.");return e}get dynamicSize(){return this._dynamicSize}set dynamicSize(i){i||this._trimAlloc(),this._dynamicSize=i}shift(i){const e=new yt(this._byteLength-i),t=new Uint8Array(e),s=new Uint8Array(this._buffer,i,t.length);t.set(s),this.buffer=e,this.position-=i}writeInt32Array(i,e){if(this._realloc(i.length*4),i instanceof Int32Array&&this.byteOffset+this.position%i.BYTES_PER_ELEMENT===0)j.memcpy(this._buffer,this.byteOffset+this.position,i.buffer,0,i.byteLength),this.mapInt32Array(i.length,e);else for(let t=0;t<i.length;t++)this.writeInt32(i[t],e)}writeInt16Array(i,e){if(this._realloc(i.length*2),i instanceof Int16Array&&this.byteOffset+this.position%i.BYTES_PER_ELEMENT===0)j.memcpy(this._buffer,this.byteOffset+this.position,i.buffer,0,i.byteLength),this.mapInt16Array(i.length,e);else for(let t=0;t<i.length;t++)this.writeInt16(i[t],e)}writeInt8Array(i){if(this._realloc(i.length*1),i instanceof Int8Array&&this.byteOffset+this.position%i.BYTES_PER_ELEMENT===0)j.memcpy(this._buffer,this.byteOffset+this.position,i.buffer,0,i.byteLength),this.mapInt8Array(i.length);else for(let e=0;e<i.length;e++)this.writeInt8(i[e])}writeUint32Array(i,e){if(this._realloc(i.length*4),i instanceof Uint32Array&&this.byteOffset+this.position%i.BYTES_PER_ELEMENT===0)j.memcpy(this._buffer,this.byteOffset+this.position,i.buffer,0,i.byteLength),this.mapUint32Array(i.length,e);else for(let t=0;t<i.length;t++)this.writeUint32(i[t],e)}writeUint16Array(i,e){if(this._realloc(i.length*2),i instanceof Uint16Array&&this.byteOffset+this.position%i.BYTES_PER_ELEMENT===0)j.memcpy(this._buffer,this.byteOffset+this.position,i.buffer,0,i.byteLength),this.mapUint16Array(i.length,e);else for(let t=0;t<i.length;t++)this.writeUint16(i[t],e)}writeUint8Array(i){if(this._realloc(i.length*1),i instanceof Uint8Array&&this.byteOffset+this.position%i.BYTES_PER_ELEMENT===0)j.memcpy(this._buffer,this.byteOffset+this.position,i.buffer,0,i.byteLength),this.mapUint8Array(i.length);else for(let e=0;e<i.length;e++)this.writeUint8(i[e])}writeFloat64Array(i,e){if(this._realloc(i.length*8),i instanceof Float64Array&&this.byteOffset+this.position%i.BYTES_PER_ELEMENT===0)j.memcpy(this._buffer,this.byteOffset+this.position,i.buffer,0,i.byteLength),this.mapFloat64Array(i.length,e);else for(let t=0;t<i.length;t++)this.writeFloat64(i[t],e)}writeFloat32Array(i,e){if(this._realloc(i.length*4),i instanceof Float32Array&&this.byteOffset+this.position%i.BYTES_PER_ELEMENT===0)j.memcpy(this._buffer,this.byteOffset+this.position,i.buffer,0,i.byteLength),this.mapFloat32Array(i.length,e);else for(let t=0;t<i.length;t++)this.writeFloat32(i[t],e)}writeInt64(i,e){this._realloc(8),this._dataView.setBigInt64(this.position,BigInt(i),(e??this.endianness)===2),this.position+=8}writeInt32(i,e){this._realloc(4),this._dataView.setInt32(this.position,i,(e??this.endianness)===2),this.position+=4}writeInt16(i,e){this._realloc(2),this._dataView.setInt16(this.position,i,(e??this.endianness)===2),this.position+=2}writeInt8(i){this._realloc(1),this._dataView.setInt8(this.position,i),this.position+=1}writeUint32(i,e){this._realloc(4),this._dataView.setUint32(this.position,i,(e??this.endianness)===2),this.position+=4}writeUint16(i,e){this._realloc(2),this._dataView.setUint16(this.position,i,(e??this.endianness)===2),this.position+=2}writeUint8(i){this._realloc(1),this._dataView.setUint8(this.position,i),this.position+=1}writeFloat32(i,e){this._realloc(4),this._dataView.setFloat32(this.position,i,(e??this.endianness)===2),this.position+=4}writeFloat64(i,e){this._realloc(8),this._dataView.setFloat64(this.position,i,(e??this.endianness)===2),this.position+=8}writeUCS2String(i,e,t){t===void 0&&(t=i.length);let s;for(s=0;s<i.length&&s<t;s++)this.writeUint16(i.charCodeAt(s),e);for(;s<t;s++)this.writeUint16(0)}writeString(i,e,t){let s=0;if(e===void 0||e==="ASCII")if(t!==void 0){const r=Math.min(i.length,t);for(s=0;s<r;s++)this.writeUint8(i.charCodeAt(s));for(;s<t;s++)this.writeUint8(0)}else for(s=0;s<i.length;s++)this.writeUint8(i.charCodeAt(s));else this.writeUint8Array(new TextEncoder(e).encode(i.substring(0,t)))}writeCString(i,e){let t=0;if(e!==void 0){const s=Math.min(i.length,e);for(t=0;t<s;t++)this.writeUint8(i.charCodeAt(t));for(;t<e;t++)this.writeUint8(0)}else{for(t=0;t<i.length;t++)this.writeUint8(i.charCodeAt(t));this.writeUint8(0)}}writeStruct(i,e){for(let t=0;t<i.length;t++){const[s,r]=i[t],n=e[s];this.writeType(r,n,e)}}writeType(i,e,t){if(typeof i=="function")return i(this,e);if(typeof i=="object"&&!(i instanceof Array))return i.set(this,e,t);let s,r="ASCII";const n=this.position;let o=i;if(typeof i=="string"&&/:/.test(i)){const a=i.split(":");o=a[0],s=parseInt(a[1])}if(typeof o=="string"&&/,/.test(o)){const a=o.split(",");o=a[0],r=a[1]}switch(o){case"uint8":this.writeUint8(e);break;case"int8":this.writeInt8(e);break;case"uint16":this.writeUint16(e,this.endianness);break;case"int16":this.writeInt16(e,this.endianness);break;case"uint32":this.writeUint32(e,this.endianness);break;case"int32":this.writeInt32(e,this.endianness);break;case"float32":this.writeFloat32(e,this.endianness);break;case"float64":this.writeFloat64(e,this.endianness);break;case"uint16be":this.writeUint16(e,1);break;case"int16be":this.writeInt16(e,1);break;case"uint32be":this.writeUint32(e,1);break;case"int32be":this.writeInt32(e,1);break;case"float32be":this.writeFloat32(e,1);break;case"float64be":this.writeFloat64(e,1);break;case"uint16le":this.writeUint16(e,2);break;case"int16le":this.writeInt16(e,2);break;case"uint32le":this.writeUint32(e,2);break;case"int32le":this.writeInt32(e,2);break;case"float32le":this.writeFloat32(e,2);break;case"float64le":this.writeFloat64(e,2);break;case"cstring":this.writeCString(e,s);break;case"string":this.writeString(e,r,s);break;case"u16string":this.writeUCS2String(e,this.endianness,s);break;case"u16stringle":this.writeUCS2String(e,2,s);break;case"u16stringbe":this.writeUCS2String(e,1,s);break;default:if(mf(this,ir,Tn).call(this,o)){const[,a]=o;for(let l=0;l<e.length;l++)this.writeType(a,e[l]);break}else{this.writeStruct(o,e);break}}s&&(this.position=n,this._realloc(s),this.position=n+s)}writeUint64(i){const e=Math.floor(i/bn);this.writeUint32(e),this.writeUint32(i&4294967295)}writeUint24(i){this.writeUint8((i&16711680)>>16),this.writeUint8((i&65280)>>8),this.writeUint8(i&255)}adjustUint32(i,e){const t=this.position;this.seek(i),this.writeUint32(e),this.seek(t)}readStruct(i){const e={},t=this.position;for(let s=0;s<i.length;s+=1){const r=i[s][1],n=this.readType(r,e);if(!n){this.failurePosition===0&&(this.failurePosition=this.position),this.position=t;return}e[i[s][0]]=n}return e}readUCS2String(i,e){return String.fromCharCode.apply(void 0,this.readUint16Array(i,e))}readType(i,e){if(typeof i=="function")return i(this,e);if(typeof i=="object"&&!(i instanceof Array))return i.get(this,e);if(i instanceof Array&&i.length!==3)return this.readStruct(i);let t,s,r="ASCII";const n=this.position;let o=i;if(typeof o=="string"&&/:/.test(o)){const a=o.split(":");o=a[0],s=parseInt(a[1])}if(typeof o=="string"&&/,/.test(o)){const a=o.split(",");o=a[0],r=a[1]}switch(o){case"uint8":t=this.readUint8();break;case"int8":t=this.readInt8();break;case"uint16":t=this.readUint16(this.endianness);break;case"int16":t=this.readInt16(this.endianness);break;case"uint32":t=this.readUint32(this.endianness);break;case"int32":t=this.readInt32(this.endianness);break;case"float32":t=this.readFloat32(this.endianness);break;case"float64":t=this.readFloat64(this.endianness);break;case"uint16be":t=this.readUint16(1);break;case"int16be":t=this.readInt16(1);break;case"uint32be":t=this.readUint32(1);break;case"int32be":t=this.readInt32(1);break;case"float32be":t=this.readFloat32(1);break;case"float64be":t=this.readFloat64(1);break;case"uint16le":t=this.readUint16(2);break;case"int16le":t=this.readInt16(2);break;case"uint32le":t=this.readUint32(2);break;case"int32le":t=this.readInt32(2);break;case"float32le":t=this.readFloat32(2);break;case"float64le":t=this.readFloat64(2);break;case"cstring":t=this.readCString(s);break;case"string":t=this.readString(s,r);break;case"u16string":t=this.readUCS2String(s,this.endianness);break;case"u16stringle":t=this.readUCS2String(s,2);break;case"u16stringbe":t=this.readUCS2String(s,1);break;default:if(mf(this,ir,Tn).call(this,o)){const[,a,l]=o,c=typeof l=="function"?l(e,this,o):typeof l=="string"&&e[l]!==void 0?parseInt(e[l]):typeof l=="number"?l:l==="*"?void 0:parseInt(l);if(typeof a=="string"){const h=a.replace(/(le|be)$/,"");let u;switch(/le$/.test(a)?u=2:/be$/.test(a)&&(u=1),h){case"uint8":t=this.readUint8Array(c);break;case"uint16":t=this.readUint16Array(c,u);break;case"uint32":t=this.readUint32Array(c,u);break;case"int8":t=this.readInt8Array(c);break;case"int16":t=this.readInt16Array(c,u);break;case"int32":t=this.readInt32Array(c,u);break;case"float32":t=this.readFloat32Array(c,u);break;case"float64":t=this.readFloat64Array(c,u);break;case"cstring":case"utf16string":case"string":if(c){t=new Array(c);for(let d=0;d<c;d++)t[d]=this.readType(a,e)}else for(t=[];!this.isEof();){const d=this.readType(a,e);if(!d)break;t.push(d)}break}}else if(c){t=new Array(c);for(let h=0;h<c;h++){const u=this.readType(a,e);if(!u)return;t[h]=u}}else for(t=[];;){const h=this.position;try{const u=this.readType(a,e);if(!u){this.position=h;break}t.push(u)}catch{this.position=h;break}}break}}return s&&(this.position=n+s),t}mapInt32Array(i,e){this._realloc(i*4);const t=new Int32Array(this._buffer,this.byteOffset+this.position,i);return j.arrayToNative(t,e??this.endianness),this.position+=i*4,t}mapInt16Array(i,e){this._realloc(i*2);const t=new Int16Array(this._buffer,this.byteOffset+this.position,i);return j.arrayToNative(t,e??this.endianness),this.position+=i*2,t}mapInt8Array(i,e){this._realloc(i*1);const t=new Int8Array(this._buffer,this.byteOffset+this.position,i);return this.position+=i*1,t}mapUint32Array(i,e){this._realloc(i*4);const t=new Uint32Array(this._buffer,this.byteOffset+this.position,i);return j.arrayToNative(t,e??this.endianness),this.position+=i*4,t}mapUint16Array(i,e){this._realloc(i*2);const t=new Uint16Array(this._buffer,this.byteOffset+this.position,i);return j.arrayToNative(t,e??this.endianness),this.position+=i*2,t}mapFloat64Array(i,e){this._realloc(i*8);const t=new Float64Array(this._buffer,this.byteOffset+this.position,i);return j.arrayToNative(t,e??this.endianness),this.position+=i*8,t}mapFloat32Array(i,e){this._realloc(i*4);const t=new Float32Array(this._buffer,this.byteOffset+this.position,i);return j.arrayToNative(t,e??this.endianness),this.position+=i*4,t}},ir=new WeakSet,Tn=function(i){return Array.isArray(i)&&i.length===3&&i[0]==="[]"},j.ENDIANNESS=new Int8Array(new Int16Array([1]).buffer)[0]>0?2:1,j);function yf(i){const e=[];for(let t=0;t<i.length;t++)e[t]=i[t];return String.fromCharCode.apply(void 0,e)}var sr=new Date,wn=4,bf=3,Tf=2,wf=1,$t=wn,I={setLogLevel(i){i===this.debug?$t=wf:i===this.info?$t=Tf:i===this.warn?$t=bf:(this.error,$t=wn)},debug(i,e){console.debug===void 0&&(console.debug=console.log),wf>=$t&&console.debug("["+I.getDurationString(new Date().getTime()-sr.getTime(),1e3)+"]","["+i+"]",e)},log(i,e){this.debug(i.msg)},info(i,e){Tf>=$t&&console.info("["+I.getDurationString(new Date().getTime()-sr.getTime(),1e3)+"]","["+i+"]",e)},warn(i,e){bf>=$t&&console.warn("["+I.getDurationString(new Date().getTime()-sr.getTime(),1e3)+"]","["+i+"]",e)},error(i,e,t){t?.onError?t.onError(i,e):wn>=$t&&console.error("["+I.getDurationString(new Date().getTime()-sr.getTime(),1e3)+"]","["+i+"]",e)},getDurationString(i,e){let t;function s(l,c){const h=(""+l).split(".");for(;h[0].length<c;)h[0]="0"+h[0];return h.join(".")}i<0?(t=!0,i=-i):t=!1;let r=i/(e||1);const n=Math.floor(r/3600);r-=n*3600;const o=Math.floor(r/60);r-=o*60;let a=r*1e3;return r=Math.floor(r),a-=r*1e3,a=Math.floor(a),(t?"-":"")+n+":"+s(o,2)+":"+s(r,2)+"."+s(a,3)},printRanges(i){const e=i.length;if(e>0){let t="";for(let s=0;s<e;s++)s>0&&(t+=","),t+="["+I.getDurationString(i.start(s))+","+I.getDurationString(i.end(s))+"]";return t}else return"(empty)"}};function Tv(i,e){I.debug("ArrayBuffer","Trying to create a new buffer of size: "+(i.byteLength+e.byteLength));const t=new Uint8Array(i.byteLength+e.byteLength);return t.set(new Uint8Array(i),0),t.set(new Uint8Array(e),i.byteLength),t.buffer}var Ti=class extends Pe{constructor(i){super(new ArrayBuffer,0),this.buffers=[],this.bufferIndex=-1,i&&(this.insertBuffer(i),this.bufferIndex=0)}initialized(){if(this.bufferIndex>-1)return!0;if(this.buffers.length>0){const i=this.buffers[0];return i.fileStart===0?(this.buffer=i,this.bufferIndex=0,I.debug("MultiBufferStream","Stream ready for parsing"),!0):(I.warn("MultiBufferStream","The first buffer should have a fileStart of 0"),this.logBufferLevel(),!1)}else return I.warn("MultiBufferStream","No buffer to start parsing from"),this.logBufferLevel(),!1}reduceBuffer(i,e,t){const s=new Uint8Array(t);return s.set(new Uint8Array(i,e,t)),s.buffer.fileStart=i.fileStart+e,s.buffer.usedBytes=0,s.buffer}insertBuffer(i){let e=!0,t=0;for(;t<this.buffers.length;t++){const s=this.buffers[t];if(i.fileStart<=s.fileStart){if(i.fileStart===s.fileStart)if(i.byteLength>s.byteLength){this.buffers.splice(t,1),t--;continue}else I.warn("MultiBufferStream","Buffer (fileStart: "+i.fileStart+" - Length: "+i.byteLength+") already appended, ignoring");else i.fileStart+i.byteLength<=s.fileStart||(i=this.reduceBuffer(i,0,s.fileStart-i.fileStart)),I.debug("MultiBufferStream","Appending new buffer (fileStart: "+i.fileStart+" - Length: "+i.byteLength+")"),this.buffers.splice(t,0,i),t===0&&(this.buffer=i);e=!1;break}else if(i.fileStart<s.fileStart+s.byteLength){const r=s.fileStart+s.byteLength-i.fileStart,n=i.byteLength-r;if(n>0)i=this.reduceBuffer(i,r,n);else{e=!1;break}}}e&&(I.debug("MultiBufferStream","Appending new buffer (fileStart: "+i.fileStart+" - Length: "+i.byteLength+")"),this.buffers.push(i),t===0&&(this.buffer=i))}logBufferLevel(i){const e=[];let t="",s,r=0,n=0;for(let a=0;a<this.buffers.length;a++){const l=this.buffers[a];a===0?(s={start:l.fileStart,end:l.fileStart+l.byteLength},e.push(s),t+="["+s.start+"-"):s.end===l.fileStart?s.end=l.fileStart+l.byteLength:(s={start:l.fileStart,end:l.fileStart+l.byteLength},t+=e[e.length-1].end-1+"], ["+s.start+"-",e.push(s)),r+=l.usedBytes,n+=l.byteLength}e.length>0&&(t+=s.end-1+"]");const o=i?I.info:I.debug;this.buffers.length===0?o("MultiBufferStream","No more buffer in memory"):o("MultiBufferStream",""+this.buffers.length+" stored buffer(s) ("+r+"/"+n+" bytes), continuous ranges: "+t)}cleanBuffers(){for(let i=0;i<this.buffers.length;i++){const e=this.buffers[i];e.usedBytes===e.byteLength&&(I.debug("MultiBufferStream","Removing buffer #"+i),this.buffers.splice(i,1),i--)}}mergeNextBuffer(){if(this.bufferIndex+1<this.buffers.length){const i=this.buffers[this.bufferIndex+1];if(i.fileStart===this.buffer.fileStart+this.buffer.byteLength){const e=this.buffer.byteLength,t=this.buffer.usedBytes,s=this.buffer.fileStart;return this.buffers[this.bufferIndex]=Tv(this.buffer,i),this.buffer=this.buffers[this.bufferIndex],this.buffers.splice(this.bufferIndex+1,1),this.buffer.usedBytes=t,this.buffer.fileStart=s,I.debug("ISOFile","Concatenating buffer for box parsing (length: "+e+"->"+this.buffer.byteLength+")"),!0}else return!1}else return!1}findPosition(i,e,t){let s=-1,r=i===!0?0:this.bufferIndex;for(;r<this.buffers.length;){const o=this.buffers[r];if(o&&o.fileStart<=e)s=r,t&&(o.fileStart+o.byteLength<=e?o.usedBytes=o.byteLength:o.usedBytes=e-o.fileStart,this.logBufferLevel());else break;r++}if(s===-1)return-1;const n=this.buffers[s];return n.fileStart+n.byteLength>=e?(I.debug("MultiBufferStream","Found position in existing buffer #"+s),s):-1}findEndContiguousBuf(i){const e=i!==void 0?i:this.bufferIndex;let t=this.buffers[e];if(this.buffers.length>e+1)for(let s=e+1;s<this.buffers.length;s++){const r=this.buffers[s];if(r.fileStart===t.fileStart+t.byteLength)t=r;else break}return t.fileStart+t.byteLength}getEndFilePositionAfter(i){const e=this.findPosition(!0,i,!1);return e!==-1?this.findEndContiguousBuf(e):i}addUsedBytes(i){this.buffer.usedBytes+=i,this.logBufferLevel()}setAllUsedBytes(){this.buffer.usedBytes=this.buffer.byteLength,this.logBufferLevel()}seek(i,e,t){const s=this.findPosition(e,i,t);return s!==-1?(this.buffer=this.buffers[s],this.bufferIndex=s,this.position=i-this.buffer.fileStart,I.debug("MultiBufferStream","Repositioning parser at buffer position: "+this.position),!0):(I.debug("MultiBufferStream","Position "+i+" not found in buffered data"),!1)}getPosition(){return this.bufferIndex===-1||this.buffers[this.bufferIndex]===void 0?0:this.buffers[this.bufferIndex].fileStart+this.position}getLength(){return this.byteLength}getEndPosition(){return this.bufferIndex===-1||this.buffers[this.bufferIndex]===void 0?0:this.buffers[this.bufferIndex].fileStart+this.byteLength}getAbsoluteEndPosition(){if(this.buffers.length===0)return 0;const i=this.buffers[this.buffers.length-1];return i.fileStart+i.byteLength}},rr,Sn,U=(Sn=class{constructor(i=0){pf(this,rr),this.size=i}get type(){return this.constructor.fourcc??gv(this,rr)}set type(i){_v(this,rr,i)}addBox(i){return this.boxes||(this.boxes=[]),this.boxes.push(i),this[i.type+"s"]?this[i.type+"s"].push(i):this[i.type]=i,i}set(i,e){return this[i]=e,this}addEntry(i,e){const t=e||"entries";return this[t]||(this[t]=[]),this[t].push(i),this}writeHeader(i,e){if(this.size+=8,(this.size>Ae||this.original_size===1)&&(this.size+=8),this.type==="uuid"&&(this.size+=16),I.debug("BoxWriter","Writing box "+this.type+" of size: "+this.size+" at position "+i.getPosition()+(e||"")),this.original_size===0?i.writeUint32(0):this.size>Ae||this.original_size===1?i.writeUint32(1):(this.sizePosition=i.getPosition(),i.writeUint32(this.size)),i.writeString(this.type,void 0,4),this.type==="uuid"){const t=new Uint8Array(16);for(let s=0;s<16;s++)t[s]=parseInt(this.uuid.substring(s*2,s*2+2),16);i.writeUint8Array(t)}(this.size>Ae||this.original_size===1)&&(this.sizePosition=i.getPosition(),i.writeUint64(this.size))}write(i){if(this.type==="mdat"){const e=this;if(e.stream){this.size=e.stream.getAbsoluteEndPosition(),this.writeHeader(i);for(const t of e.stream.buffers){const s=new Uint8Array(t);i.writeUint8Array(s)}}else e.data&&(this.size=e.data.length,this.writeHeader(i),i.writeUint8Array(e.data))}else this.size=this.data?this.data.length:0,this.writeHeader(i),this.data&&i.writeUint8Array(this.data)}printHeader(i){this.size+=8,this.size>Ae&&(this.size+=8),this.type==="uuid"&&(this.size+=16),i.log(i.indent+"size:"+this.size),i.log(i.indent+"type:"+this.type)}print(i){this.printHeader(i)}parse(i){this.type!=="mdat"?this.data=i.readUint8Array(this.size-this.hdr_size):this.size===0?i.seek(i.getEndPosition()):i.seek(this.start+this.size)}parseDataAndRewind(i){this.data=i.readUint8Array(this.size-this.hdr_size),i.seek(this.start+this.hdr_size)}parseLanguage(i){this.language=i.readUint16();const e=[];e[0]=this.language>>10&31,e[1]=this.language>>5&31,e[2]=this.language&31,this.languageString=String.fromCharCode(e[0]+96,e[1]+96,e[2]+96)}computeSize(i){const e=i||new Ti;this.write(e)}isEndOfBox(i){const e=i.getPosition(),t=this.start+this.size;return e===t}},rr=new WeakMap,Sn.registryId=Symbol.for("BoxIdentifier"),Sn),R=class extends U{constructor(){super(...arguments),this.flags=0,this.version=0}writeHeader(e){this.size+=4,super.writeHeader(e," v="+this.version+" f="+this.flags),e.writeUint8(this.version),e.writeUint24(this.flags)}printHeader(e){this.size+=4,super.printHeader(e),e.log(e.indent+"version:"+this.version),e.log(e.indent+"flags:"+this.flags)}parseDataAndRewind(e){this.parseFullHeader(e),this.data=e.readUint8Array(this.size-this.hdr_size),this.hdr_size-=4,e.seek(this.start+this.hdr_size)}parseFullHeader(e){this.version=e.readUint8(),this.flags=e.readUint24(),this.hdr_size+=4}parse(e){this.parseFullHeader(e),this.data=e.readUint8Array(this.size-this.hdr_size)}},Cn,ve=(Cn=class{constructor(i){this.grouping_type=i}write(i){i.writeUint8Array(this.data)}parse(i){I.warn("BoxParser",`Unknown sample group type: '${this.grouping_type}'`),this.data=i.readUint8Array(this.description_length)}},Cn.registryId=Symbol.for("SampleGroupEntryIdentifier"),Cn),Sf=class extends R{parse(i){this.parseFullHeader(i),this.track_group_id=i.readUint32()}},Cf=class extends U{constructor(i,e,t,s,r){super(e),this.box_name=t,this.hdr_size=s,this.start=r,this.type=i}parse(i){this.from_item_ID=i.readUint16();const e=i.readUint16();this.references=[];for(let t=0;t<e;t++)this.references[t]={to_item_ID:i.readUint16()}}},Af=class extends U{constructor(i,e,t,s,r){super(e),this.box_name=t,this.hdr_size=s,this.start=r,this.type=i}parse(i){this.from_item_ID=i.readUint32();const e=i.readUint16();this.references=[];for(let t=0;t<e;t++)this.references[t]={to_item_ID:i.readUint32()}}},Ef=class extends U{constructor(i,e,t,s){super(e),this.hdr_size=t,this.start=s,this.type=i}parse(i){this.track_ids=i.readUint32Array((this.size-this.hdr_size)/4)}write(i){this.size=this.track_ids.length*4,this.writeHeader(i),i.writeUint32Array(this.track_ids)}},nr=["boxes","entries","references","subsamples","items","item_infos","extents","associations","subsegments","ranges","seekLists","seekPoints","esd","levels"],If=["compatible_brands","matrix","opcolor","sample_counts","sample_deltas","first_chunk","samples_per_chunk","sample_sizes","chunk_offsets","sample_offsets","sample_description_index","sample_duration"];function Pf(i,e){if(i&&!e)return!1;let t;for(t in i)if(!nr.find(s=>s===t)){if(i[t]instanceof U||e[t]instanceof U||typeof i[t]>"u"||typeof e[t]>"u"||typeof i[t]=="function"||typeof e[t]=="function"||"subBoxNames"in i&&i.subBoxNames.indexOf(t.slice(0,4))>-1||"subBoxNames"in e&&e.subBoxNames.indexOf(t.slice(0,4))>-1||t==="data"||t==="start"||t==="size"||t==="creation_time"||t==="modification_time"||If.find(s=>s===t))continue;if(i[t]!==e[t])return!1}return!0}function An(i,e){if(!Pf(i,e))return!1;for(let t=0;t<nr.length;t++){const s=nr[t];if(i[s]&&e[s]&&!An(i[s],e[s]))return!1}return!0}function En(i){let e=i;for(;e;){if("registryId"in e)return e.registryId;e=Object.getPrototypeOf(e)}}var wv=i=>{const e=Symbol.for("SampleGroupEntryIdentifier");return En(i)===e},Sv=i=>{const e=Symbol.for("SampleEntryIdentifier");return En(i)===e},Cv=i=>{const e=Symbol.for("BoxIdentifier");return En(i)===e},$e={uuid:{},sampleEntry:{},sampleGroupEntry:{},box:{}};function Av(i){const e={uuid:{},sampleEntry:{},sampleGroupEntry:{},box:{}};for(const[t,s]of Object.entries(i)){if(wv(s)){const r="grouping_type"in s?s.grouping_type:void 0;if(!r)throw new Error(`SampleGroupEntry class ${t} does not have a valid static grouping_type. Please ensure it is defined correctly.`);if(r in e.sampleGroupEntry)throw new Error(`SampleGroupEntry class ${t} has a grouping_type that is already registered. Please ensure it is unique.`);e.sampleGroupEntry[r]=s;continue}if(Sv(s)){const r="fourcc"in s?s.fourcc:void 0;if(!r)throw new Error(`SampleEntry class ${t} does not have a valid static fourcc. Please ensure it is defined correctly.`);if(r in e.sampleEntry)throw new Error(`SampleEntry class ${t} has a fourcc that is already registered. Please ensure it is unique.`);e.sampleEntry[r]=s;continue}if(Cv(s)){const r="fourcc"in s?s.fourcc:void 0,n="uuid"in s?s.uuid:void 0;if(r==="uuid"){if(!n)throw new Error(`Box class ${t} has a fourcc of 'uuid' but does not have a valid uuid. Please ensure it is defined correctly.`);if(n in e.uuid)throw new Error(`Box class ${t} has a uuid that is already registered. Please ensure it is unique.`);e.uuid[n]=s;continue}e.box[r]=s;continue}throw new Error(`Box class ${t} does not have a valid static fourcc, uuid, or grouping_type. Please ensure it is defined correctly.`)}return $e.uuid={...e.uuid},$e.sampleEntry={...e.sampleEntry},$e.sampleGroupEntry={...e.sampleGroupEntry},$e.box={...e.box},$e}var or={};function Ev(i){return Object.entries(i).forEach(([e,t])=>or[e]=t),or}function Iv(i){return ri(i)}function ri(i){let e="";for(let t=0;t<16;t++){const s=i.readUint8().toString(16);e+=s.length===1?"0"+s:s}return e}function dt(i,e,t){let s,r;const n=i.getPosition();let o=0,a;if(i.getEndPosition()-n<8)return I.debug("BoxParser","Not enough data in stream to parse the type and size of the box"),{code:Vt};if(t&&t<8)return I.debug("BoxParser","Not enough bytes left in the parent box to parse a new box"),{code:Vt};let l=i.readUint32();const c=i.readString(4);if(c.length!==4||!/^[\x20-\x7E]{4}$/.test(c))return I.error("BoxParser",`Invalid box type: '${c}'`),{code:xf,start:n,type:c};let h=c;if(I.debug("BoxParser","Found box of type '"+c+"' and size "+l+" at position "+n),o=8,c==="uuid"){if(i.getEndPosition()-i.getPosition()<16||t-o<16)return i.seek(n),I.debug("BoxParser","Not enough bytes left in the parent box to parse a UUID box"),{code:Vt};a=Iv(i),o+=16,h=a}if(l===1){if(i.getEndPosition()-i.getPosition()<8||t&&t-o<8)return i.seek(n),I.warn("BoxParser",'Not enough data in stream to parse the extended size of the "'+c+'" box'),{code:Vt};r=l,l=i.readUint64(),o+=8}else if(l===0){if(t)l=t;else if(c!=="mdat")return I.error("BoxParser","Unlimited box size not supported for type: '"+c+"'"),s=new U(l),s.type=c,{code:Ve,box:s,size:s.size}}if(l!==0&&l<o)return I.error("BoxParser","Box of type "+c+" has an invalid size "+l+" (too small to be a box)"),{code:Vt,type:c,size:l,hdr_size:o,start:n};if(l!==0&&t&&l>t)return I.error("BoxParser","Box of type '"+c+"' has a size "+l+" greater than its container size "+t),{code:Vt,type:c,size:l,hdr_size:o,start:n};if(l!==0&&n+l>i.getEndPosition())return i.seek(n),I.info("BoxParser","Not enough data in stream to parse the entire '"+c+"' box"),{code:Vt,type:c,size:l,hdr_size:o,start:n,original_size:r};if(e)return{code:Ve,type:c,size:l,hdr_size:o,start:n};c in $e.box?s=new $e.box[c](l):c!=="uuid"?(I.warn("BoxParser",`Unknown box type: '${c}'`),s=new U(l),s.type=c,s.has_unparsed_data=!0):a in $e.uuid?s=new $e.uuid[a](l):(I.warn("BoxParser",`Unknown UUID box type: '${a}'`),s=new U(l),s.type=c,s.uuid=a,s.has_unparsed_data=!0),s.original_size=r,s.hdr_size=o,s.start=n,s.write===U.prototype.write&&s.type!=="mdat"&&(I.info("BoxParser","'"+h+"' box writing not yet implemented, keeping unparsed data in memory for later write"),s.parseDataAndRewind(i)),s.parse(i);const u=i.getPosition()-(s.start+s.size);return u<0?(I.warn("BoxParser","Parsing of box '"+h+"' did not read the entire indicated box data size (missing "+-u+" bytes), seeking forward"),i.seek(s.start+s.size)):u>0&&s.size!==0&&(I.error("BoxParser","Parsing of box '"+h+"' read "+u+" more bytes than the indicated box data size, seeking backwards"),i.seek(s.start+s.size)),{code:Ve,box:s,size:s.size}}var Q=class extends U{write(e){if(this.size=0,this.writeHeader(e),this.boxes)for(let t=0;t<this.boxes.length;t++)this.boxes[t]&&(this.boxes[t].write(e),this.size+=this.boxes[t].size);I.debug("BoxWriter","Adjusting box "+this.type+" with new size "+this.size),e.adjustUint32(this.sizePosition,this.size)}print(e){this.printHeader(e);for(let t=0;t<this.boxes.length;t++)if(this.boxes[t]){const s=e.indent;e.indent+=" ",this.boxes[t].print(e),e.indent=s}}parse(e){let t;for(;e.getPosition()<this.start+this.size;)if(t=dt(e,!1,this.size-(e.getPosition()-this.start)),t.code===Ve){const s=t.box;if(this.boxes||(this.boxes=[]),this.boxes.push(s),this.subBoxNames&&this.subBoxNames.indexOf(s.type)!==-1){const r=this.subBoxNames[this.subBoxNames.indexOf(s.type)]+"s";this[r]||(this[r]=[]),this[r].push(s)}else{const r=s.type!=="uuid"?s.type:s.uuid;this[r]?I.warn("ContainerBox",`Box of type ${r} already exists in container box ${this.type}.`):this[r]=s}}else return}},In,bt=(In=class extends Q{constructor(i,e,t){super(i),this.hdr_size=e,this.start=t}isVideo(){return!1}isAudio(){return!1}isSubtitle(){return!1}isMetadata(){return!1}isHint(){return!1}getCodec(){return this.type.replace(".","")}getWidth(){return""}getHeight(){return""}getChannelCount(){return""}getSampleRate(){return""}getSampleSize(){return""}parseHeader(i){i.readUint8Array(6),this.data_reference_index=i.readUint16(),this.hdr_size+=8}parse(i){this.parseHeader(i),this.data=i.readUint8Array(this.size-this.hdr_size)}parseDataAndRewind(i){this.parseHeader(i),this.data=i.readUint8Array(this.size-this.hdr_size),this.hdr_size-=8,i.seek(this.start+this.hdr_size)}parseFooter(i){super.parse(i)}writeHeader(i){this.size=8,super.writeHeader(i),i.writeUint8(0),i.writeUint8(0),i.writeUint8(0),i.writeUint8(0),i.writeUint8(0),i.writeUint8(0),i.writeUint16(this.data_reference_index)}writeFooter(i){if(this.boxes)for(let e=0;e<this.boxes.length;e++)this.boxes[e].write(i),this.size+=this.boxes[e].size;I.debug("BoxWriter","Adjusting box "+this.type+" with new size "+this.size),i.adjustUint32(this.sizePosition,this.size)}write(i){this.writeHeader(i),i.writeUint8Array(this.data),this.size+=this.data.length,I.debug("BoxWriter","Adjusting box "+this.type+" with new size "+this.size),i.adjustUint32(this.sizePosition,this.size)}},In.registryId=Symbol.for("SampleEntryIdentifier"),In),Pn=class extends bt{},ni=class extends bt{isMetadata(){return!0}},Xt=class extends bt{isSubtitle(){return!0}},Rf=class extends bt{},fe=class extends bt{parse(e){this.parseHeader(e),e.readUint16(),e.readUint16(),e.readUint32Array(3),this.width=e.readUint16(),this.height=e.readUint16(),this.horizresolution=e.readUint32(),this.vertresolution=e.readUint32(),e.readUint32(),this.frame_count=e.readUint16();const t=Math.min(31,e.readUint8());this.compressorname=e.readString(t),t<31&&e.readString(31-t),this.depth=e.readUint16(),e.readUint16(),this.parseFooter(e)}isVideo(){return!0}getWidth(){return this.width}getHeight(){return this.height}write(e){this.writeHeader(e),this.size+=70,e.writeUint16(0),e.writeUint16(0),e.writeUint32(0),e.writeUint32(0),e.writeUint32(0),e.writeUint16(this.width),e.writeUint16(this.height),e.writeUint32(this.horizresolution),e.writeUint32(this.vertresolution),e.writeUint32(0),e.writeUint16(this.frame_count),e.writeUint8(Math.min(31,this.compressorname.length)),e.writeString(this.compressorname,void 0,31),e.writeUint16(this.depth),e.writeInt16(-1),this.writeFooter(e)}},Le=class extends bt{parse(e){this.parseHeader(e),this.version=e.readUint16(),e.readUint16(),e.readUint32(),this.channel_count=e.readUint16(),this.samplesize=e.readUint16(),e.readUint16(),e.readUint16(),this.samplerate=e.readUint32()/65536,e.isofile?.ftyp?.major_brand.includes("qt")&&(this.version===1?this.extensions=e.readUint8Array(16):this.version===2&&(this.extensions=e.readUint8Array(36))),this.parseFooter(e)}isAudio(){return!0}getChannelCount(){return this.channel_count}getSampleRate(){return this.samplerate}getSampleSize(){return this.samplesize}write(e){this.writeHeader(e),this.size+=20,e.writeUint32(0),e.writeUint32(0),e.writeUint16(this.channel_count),e.writeUint16(this.samplesize),e.writeUint16(0),e.writeUint16(0),e.writeUint32(this.samplerate<<16),this.writeFooter(e)}},ar=class extends bt{parse(i){this.parseHeader(i),this.parseFooter(i)}write(i){this.writeHeader(i),this.writeFooter(i)}},kf=class extends Array{toString(){let i="<table class='inner-table'>";i+="<thead><tr><th>length</th><th>nalu_data</th></tr></thead>",i+="<tbody>";for(let e=0;e<this.length;e++){const t=this[e];i+="<tr>",i+="<td>"+t.length+"</td>",i+="<td>",i+=t.data.reduce(function(s,r){return s+r.toString(16).padStart(2,"0")},"0x"),i+="</td></tr>"}return i+="</tbody></table>",i}},Rn,Mf=(Rn=class extends U{constructor(){super(...arguments),this.box_name="AVCConfigurationBox"}parse(i){this.configurationVersion=i.readUint8(),this.AVCProfileIndication=i.readUint8(),this.profile_compatibility=i.readUint8(),this.AVCLevelIndication=i.readUint8(),this.lengthSizeMinusOne=i.readUint8()&3,this.nb_SPS_nalus=i.readUint8()&31;let e=this.size-this.hdr_size-6;this.SPS=new kf;for(let t=0;t<this.nb_SPS_nalus;t++){const s=i.readUint16();this.SPS.push({length:s,data:i.readUint8Array(s)}),e-=2+s}this.nb_PPS_nalus=i.readUint8(),e--,this.PPS=new kf;for(let t=0;t<this.nb_PPS_nalus;t++){const s=i.readUint16();this.PPS.push({length:s,data:i.readUint8Array(s)}),e-=2+s}e>0&&(this.ext=i.readUint8Array(e))}write(i){this.size=7;for(let e=0;e<this.SPS.length;e++)this.size+=2+this.SPS[e].length;for(let e=0;e<this.PPS.length;e++)this.size+=2+this.PPS[e].length;this.ext&&(this.size+=this.ext.length),this.writeHeader(i),i.writeUint8(this.configurationVersion),i.writeUint8(this.AVCProfileIndication),i.writeUint8(this.profile_compatibility),i.writeUint8(this.AVCLevelIndication),i.writeUint8(this.lengthSizeMinusOne+252),i.writeUint8(this.SPS.length+224);for(let e=0;e<this.SPS.length;e++)i.writeUint16(this.SPS[e].length),i.writeUint8Array(this.SPS[e].data);i.writeUint8(this.PPS.length);for(let e=0;e<this.PPS.length;e++)i.writeUint16(this.PPS[e].length),i.writeUint8Array(this.PPS[e].data);this.ext&&i.writeUint8Array(this.ext)}},Rn.fourcc="avcC",Rn),kn,lr=(kn=class extends U{constructor(){super(...arguments),this.box_name="MediaDataBox"}},kn.fourcc="mdat",kn),Mn,Pv=(Mn=class extends U{constructor(){super(...arguments),this.box_name="ItemDataBox"}},Mn.fourcc="idat",Mn),Fn,Rv=(Fn=class extends U{constructor(){super(...arguments),this.box_name="FreeSpaceBox"}},Fn.fourcc="free",Fn),Un,kv=(Un=class extends U{constructor(){super(...arguments),this.box_name="FreeSpaceBox"}},Un.fourcc="skip",Un),Bn,Ff=(Bn=class extends R{constructor(){super(...arguments),this.box_name="HintMediaHeaderBox"}},Bn.fourcc="hmhd",Bn),On,cr=(On=class extends R{constructor(){super(...arguments),this.box_name="NullMediaHeaderBox"}},On.fourcc="nmhd",On),Dn,Mv=(Dn=class extends R{constructor(){super(...arguments),this.box_name="ObjectDescriptorBox"}},Dn.fourcc="iods",Dn),Gn,Fv=(Gn=class extends R{constructor(){super(...arguments),this.box_name="XMLBox"}},Gn.fourcc="xml ",Gn),zn,Uv=(zn=class extends R{constructor(){super(...arguments),this.box_name="BinaryXMLBox"}},zn.fourcc="bxml",zn),Ln,Bv=(Ln=class extends R{constructor(){super(...arguments),this.box_name="ItemProtectionBox",this.sinfs=[]}get protections(){return this.sinfs}},Ln.fourcc="ipro",Ln),Nn,Hn=(Nn=class extends Q{constructor(){super(...arguments),this.box_name="MovieBox",this.traks=[],this.psshs=[],this.subBoxNames=["trak","pssh"]}},Nn.fourcc="moov",Nn),Wn,Uf=(Wn=class extends Q{constructor(){super(...arguments),this.box_name="TrackBox",this.samples=[]}},Wn.fourcc="trak",Wn),Vn,Ov=(Vn=class extends Q{constructor(){super(...arguments),this.box_name="EditBox"}},Vn.fourcc="edts",Vn),$n,Bf=($n=class extends Q{constructor(){super(...arguments),this.box_name="MediaBox"}},$n.fourcc="mdia",$n),Xn,Of=(Xn=class extends Q{constructor(){super(...arguments),this.box_name="MediaInformationBox"}},Xn.fourcc="minf",Xn),Yn,Df=(Yn=class extends Q{constructor(){super(...arguments),this.box_name="DataInformationBox"}},Yn.fourcc="dinf",Yn),qn,Gf=(qn=class extends Q{constructor(){super(...arguments),this.box_name="SampleTableBox",this.sgpds=[],this.sbgps=[],this.subBoxNames=["sgpd","sbgp"]}},qn.fourcc="stbl",qn),Kn,jn=(Kn=class extends Q{constructor(){super(...arguments),this.box_name="MovieExtendsBox",this.trexs=[],this.subBoxNames=["trex"]}},Kn.fourcc="mvex",Kn),Zn,zf=(Zn=class extends Q{constructor(){super(...arguments),this.box_name="MovieFragmentBox",this.trafs=[],this.subBoxNames=["traf"]}},Zn.fourcc="moof",Zn),Jn,Lf=(Jn=class extends Q{constructor(){super(...arguments),this.box_name="TrackFragmentBox",this.truns=[],this.sgpds=[],this.sbgps=[],this.subBoxNames=["trun","sgpd","sbgp"]}},Jn.fourcc="traf",Jn),Qn,Dv=(Qn=class extends Q{constructor(){super(...arguments),this.box_name="VTTCueBox"}},Qn.fourcc="vttc",Qn),eo,Gv=(eo=class extends Q{constructor(){super(...arguments),this.box_name="MovieFragmentRandomAccessBox",this.tfras=[],this.subBoxNames=["tfra"]}},eo.fourcc="mfra",eo),to,zv=(to=class extends Q{constructor(){super(...arguments),this.box_name="AdditionalMetadataContainerBox"}},to.fourcc="meco",to),io,Lv=(io=class extends Q{constructor(){super(...arguments),this.box_name="trackhintinformation",this.subBoxNames=["sdp ","rtp "]}},io.fourcc="hnti",io),so,Nv=(so=class extends Q{constructor(){super(...arguments),this.box_name="hintstatisticsbox",this.maxrs=[],this.subBoxNames=["maxr"]}},so.fourcc="hinf",so),ro,Hv=(ro=class extends Q{constructor(){super(...arguments),this.box_name="SubTrackBox"}},ro.fourcc="strk",ro),no,Wv=(no=class extends Q{constructor(){super(...arguments),this.box_name="SubTrackDefinitionBox"}},no.fourcc="strd",no),oo,Vv=(oo=class extends Q{constructor(){super(...arguments),this.box_name="ProtectionSchemeInfoBox"}},oo.fourcc="sinf",oo),ao,$v=(ao=class extends Q{constructor(){super(...arguments),this.box_name="RestrictedSchemeInfoBox"}},ao.fourcc="rinf",ao),lo,Xv=(lo=class extends Q{constructor(){super(...arguments),this.box_name="SchemeInformationBox"}},lo.fourcc="schi",lo),co,Yv=(co=class extends Q{constructor(){super(...arguments),this.box_name="TrackGroupBox"}},co.fourcc="trgr",co),ho,qv=(ho=class extends Q{constructor(){super(...arguments),this.box_name="UserDataBox",this.kinds=[],this.strks=[],this.subBoxNames=["kind","strk"]}},ho.fourcc="udta",ho),uo,Kv=(uo=class extends Q{constructor(){super(...arguments),this.box_name="ItemPropertiesBox",this.ipmas=[],this.subBoxNames=["ipma"]}},uo.fourcc="iprp",uo),fo,jv=(fo=class extends Q{constructor(){super(...arguments),this.box_name="ItemPropertyContainerBox",this.hvcCs=[],this.ispes=[],this.claps=[],this.irots=[],this.subBoxNames=["hvcC","ispe","clap","irot"]}},fo.fourcc="ipco",fo),po,Zv=(po=class extends Q{constructor(){super(...arguments),this.box_name="GroupsListBox"}},po.fourcc="grpl",po),mo,Jv=(mo=class extends Q{constructor(){super(...arguments),this.box_name="J2KHeaderInfoBox"}},mo.fourcc="j2kH",mo),go,Qv=(go=class extends Q{constructor(){super(...arguments),this.box_name="ExtendedTypeBox",this.tycos=[],this.subBoxNames=["tyco"]}},go.fourcc="etyp",go),_o,ey=(_o=class extends Q{constructor(){super(...arguments),this.box_name="ProjectedOmniVideoBox",this.subBoxNames=["prfr"]}},_o.fourcc="povd",_o),xo,Nf=(xo=class extends R{constructor(){super(...arguments),this.box_name="DataReferenceBox"}parse(i){this.parseFullHeader(i),this.entries=[];const e=i.readUint32();for(let t=0;t<e;t++){const s=dt(i,!1,this.size-(i.getPosition()-this.start));if(s.code===Ve){const r=s.box;this.entries.push(r)}else return}}write(i){this.version=0,this.flags=0,this.size=4,this.writeHeader(i),i.writeUint32(this.entries.length);for(let e=0;e<this.entries.length;e++)this.entries[e].write(i),this.size+=this.entries[e].size;I.debug("BoxWriter","Adjusting box "+this.type+" with new size "+this.size),i.adjustUint32(this.sizePosition,this.size)}},xo.fourcc="dref",xo),vo,Hf=(vo=class extends R{constructor(){super(...arguments),this.box_name="ExtendedLanguageBox"}parse(i){this.parseFullHeader(i),this.extended_language=i.readString(this.size-this.hdr_size)}write(i){this.version=0,this.flags=0,this.size=this.extended_language.length,this.writeHeader(i),i.writeString(this.extended_language)}},vo.fourcc="elng",vo),yo,Wf=(yo=class extends U{constructor(){super(...arguments),this.box_name="FileTypeBox"}parse(i){let e=this.size-this.hdr_size;this.major_brand=i.readString(4),this.minor_version=i.readUint32(),e-=8,this.compatible_brands=[];let t=0;for(;e>=4;)this.compatible_brands[t]=i.readString(4),e-=4,t++}write(i){this.size=8+4*this.compatible_brands.length,this.writeHeader(i),i.writeString(this.major_brand,void 0,4),i.writeUint32(this.minor_version);for(let e=0;e<this.compatible_brands.length;e++)i.writeString(this.compatible_brands[e],void 0,4)}},yo.fourcc="ftyp",yo),bo,Vf=(bo=class extends R{constructor(){super(...arguments),this.box_name="HandlerBox"}parse(i){if(this.parseFullHeader(i),this.version===0&&(i.readUint32(),this.handler=i.readString(4),i.readUint32Array(3),!this.isEndOfBox(i))){const e=this.start+this.size-i.getPosition();this.name=i.readCString();const t=this.start+this.size-1;i.seek(t),i.readUint8()!==0&&e>1&&(I.info("BoxParser","Warning: hdlr name is not null-terminated, possibly length-prefixed string. Trimming first byte."),this.name=this.name.slice(1))}}write(i){this.size=20+this.name.length+1,this.version=0,this.flags=0,this.writeHeader(i),i.writeUint32(0),i.writeString(this.handler,void 0,4),i.writeUint32Array([0,0,0]),i.writeCString(this.name)}},bo.fourcc="hdlr",bo),To,$f=(To=class extends U{constructor(){super(...arguments),this.box_name="HEVCConfigurationBox"}parse(i){this.configurationVersion=i.readUint8();let e=i.readUint8();this.general_profile_space=e>>6,this.general_tier_flag=(e&32)>>5,this.general_profile_idc=e&31,this.general_profile_compatibility=i.readUint32(),this.general_constraint_indicator=i.readUint8Array(6),this.general_level_idc=i.readUint8(),this.min_spatial_segmentation_idc=i.readUint16()&4095,this.parallelismType=i.readUint8()&3,this.chroma_format_idc=i.readUint8()&3,this.bit_depth_luma_minus8=i.readUint8()&7,this.bit_depth_chroma_minus8=i.readUint8()&7,this.avgFrameRate=i.readUint16(),e=i.readUint8(),this.constantFrameRate=e>>6,this.numTemporalLayers=(e&13)>>3,this.temporalIdNested=(e&4)>>2,this.lengthSizeMinusOne=e&3,this.nalu_arrays=[];const t=i.readUint8();for(let s=0;s<t;s++){const r=[];this.nalu_arrays.push(r),e=i.readUint8(),r.completeness=(e&128)>>7,r.nalu_type=e&63;const n=i.readUint16();for(let o=0;o<n;o++){const a=i.readUint16();r.push({data:i.readUint8Array(a)})}}}write(i){this.size=23;for(let e=0;e<this.nalu_arrays.length;e++){this.size+=3;for(let t=0;t<this.nalu_arrays[e].length;t++)this.size+=2+this.nalu_arrays[e][t].data.length}this.writeHeader(i),i.writeUint8(this.configurationVersion),i.writeUint8((this.general_profile_space<<6)+(this.general_tier_flag<<5)+this.general_profile_idc),i.writeUint32(this.general_profile_compatibility),i.writeUint8Array(this.general_constraint_indicator),i.writeUint8(this.general_level_idc),i.writeUint16(this.min_spatial_segmentation_idc+(15<<24)),i.writeUint8(this.parallelismType+252),i.writeUint8(this.chroma_format_idc+252),i.writeUint8(this.bit_depth_luma_minus8+248),i.writeUint8(this.bit_depth_chroma_minus8+248),i.writeUint16(this.avgFrameRate),i.writeUint8((this.constantFrameRate<<6)+(this.numTemporalLayers<<3)+(this.temporalIdNested<<2)+this.lengthSizeMinusOne),i.writeUint8(this.nalu_arrays.length);for(let e=0;e<this.nalu_arrays.length;e++){i.writeUint8((this.nalu_arrays[e].completeness<<7)+this.nalu_arrays[e].nalu_type),i.writeUint16(this.nalu_arrays[e].length);for(let t=0;t<this.nalu_arrays[e].length;t++)i.writeUint16(this.nalu_arrays[e][t].data.length),i.writeUint8Array(this.nalu_arrays[e][t].data)}}},To.fourcc="hvcC",To),wo,Xf=(wo=class extends R{constructor(){super(...arguments),this.box_name="MediaHeaderBox"}parse(i){this.parseFullHeader(i),this.version===1?(this.creation_time=i.readUint64(),this.modification_time=i.readUint64(),this.timescale=i.readUint32(),this.duration=i.readUint64()):(this.creation_time=i.readUint32(),this.modification_time=i.readUint32(),this.timescale=i.readUint32(),this.duration=i.readUint32()),this.parseLanguage(i),i.readUint16()}write(i){const e=this.modification_time>Ae||this.creation_time>Ae||this.duration>Ae||this.version===1;this.version=e?1:0,this.size=20,this.size+=e?12:0,this.flags=0,this.writeHeader(i),e?(i.writeUint64(this.creation_time),i.writeUint64(this.modification_time),i.writeUint32(this.timescale),i.writeUint64(this.duration)):(i.writeUint32(this.creation_time),i.writeUint32(this.modification_time),i.writeUint32(this.timescale),i.writeUint32(this.duration)),i.writeUint16(this.language),i.writeUint16(0)}},wo.fourcc="mdhd",wo),So,Yf=(So=class extends R{constructor(){super(...arguments),this.box_name="MovieExtendsHeaderBox"}parse(i){this.parseFullHeader(i),this.flags&1&&(I.warn("BoxParser","mehd box incorrectly uses flags set to 1, converting version to 1"),this.version=1),this.version===1?this.fragment_duration=i.readUint64():this.fragment_duration=i.readUint32()}write(i){const e=this.fragment_duration>Ae||this.version===1;this.version=e?1:0,this.size=4,this.size+=e?4:0,this.flags=0,this.writeHeader(i),e?i.writeUint64(this.fragment_duration):i.writeUint32(this.fragment_duration)}},So.fourcc="mehd",So),Co,ty=(Co=class extends R{constructor(){super(...arguments),this.box_name="ItemInfoEntry"}parse(i){if(this.parseFullHeader(i),(this.version===0||this.version===1)&&(this.item_ID=i.readUint16(),this.item_protection_index=i.readUint16(),this.item_name=i.readCString(),this.content_type=i.readCString(),this.isEndOfBox(i)||(this.content_encoding=i.readCString())),this.version===1){this.extension_type=i.readString(4),I.warn("BoxParser","Cannot parse extension type"),i.seek(this.start+this.size);return}this.version>=2&&(this.version===2?this.item_ID=i.readUint16():this.version===3&&(this.item_ID=i.readUint32()),this.item_protection_index=i.readUint16(),this.item_type=i.readString(4),this.item_name=i.readCString(),this.item_type==="mime"?(this.content_type=i.readCString(),this.content_encoding=i.readCString()):this.item_type==="uri "&&(this.item_uri_type=i.readCString()))}},Co.fourcc="infe",Co),Ao,iy=(Ao=class extends R{constructor(){super(...arguments),this.box_name="ItemInfoBox"}parse(i){this.parseFullHeader(i),this.version===0?this.entry_count=i.readUint16():this.entry_count=i.readUint32(),this.item_infos=[];for(let e=0;e<this.entry_count;e++){const t=dt(i,!1,this.size-(i.getPosition()-this.start));if(t.code===Ve){const s=t.box;s.type==="infe"?this.item_infos[e]=s:I.error("BoxParser","Expected 'infe' box, got "+t.box.type,i.isofile)}else return}}},Ao.fourcc="iinf",Ao),Eo,sy=(Eo=class extends R{constructor(){super(...arguments),this.box_name="ItemLocationBox"}parse(i){this.parseFullHeader(i);let e;e=i.readUint8(),this.offset_size=e>>4&15,this.length_size=e&15,e=i.readUint8(),this.base_offset_size=e>>4&15,this.version===1||this.version===2?this.index_size=e&15:this.index_size=0,this.items=[];let t=0;if(this.version<2)t=i.readUint16();else if(this.version===2)t=i.readUint32();else throw new Error("version of iloc box not supported");for(let s=0;s<t;s++){let r=0,n=0,o=0;if(this.version<2)r=i.readUint16();else if(this.version===2)r=i.readUint32();else throw new Error("version of iloc box not supported");this.version===1||this.version===2?n=i.readUint16()&15:n=0;const a=i.readUint16();switch(this.base_offset_size){case 0:o=0;break;case 4:o=i.readUint32();break;case 8:o=i.readUint64();break;default:throw new Error("Error reading base offset size")}const l=[],c=i.readUint16();for(let h=0;h<c;h++){let u=0,d=0,f=0;if(this.version===1||this.version===2)switch(this.index_size){case 0:u=0;break;case 4:u=i.readUint32();break;case 8:u=i.readUint64();break;default:throw new Error("Error reading extent index")}switch(this.offset_size){case 0:d=0;break;case 4:d=i.readUint32();break;case 8:d=i.readUint64();break;default:throw new Error("Error reading extent index")}switch(this.length_size){case 0:f=0;break;case 4:f=i.readUint32();break;case 8:f=i.readUint64();break;default:throw new Error("Error reading extent index")}l.push({extent_index:u,extent_length:f,extent_offset:d})}this.items.push({base_offset:o,construction_method:n,item_ID:r,data_reference_index:a,extents:l})}}},Eo.fourcc="iloc",Eo),ry={auxl:"Auxiliary image item",base:"Pre-derived image item base",cdsc:"Item describes referenced item",dimg:"Derived image item",dpnd:"Item coding dependency",eroi:"Region",evir:"EVC slice",exbl:"Scalable image item","fdl ":"File delivery",font:"Font item",iloc:"Item data location",mask:"Region mask",mint:"Data integrity",pred:"Predictively coded item",prem:"Pre-multiplied item",tbas:"HEVC tile track base item",text:"Text item",thmb:"Thumbnail image item"},ns,ny=(ns=class extends R{constructor(){super(...arguments),this.box_name="ItemReferenceBox",this.references=[]}parse(i){for(this.parseFullHeader(i),this.references=[];i.getPosition()<this.start+this.size;){const e=dt(i,!0,this.size-(i.getPosition()-this.start));if(e.code===Ve){let t="Unknown item reference";ns.allowed_types.includes(e.type)?t=ry[e.type]:I.warn("BoxParser",`Unknown item reference type: '${e.type}'`);const s=this.version===0?new Cf(e.type,e.size,t,e.hdr_size,e.start):new Af(e.type,e.size,t,e.hdr_size,e.start);s.write===U.prototype.write&&s.type!=="mdat"&&(I.warn("BoxParser",s.type+" box writing not yet implemented, keeping unparsed data in memory for later write"),s.parseDataAndRewind(i)),s.parse(i),this.references.push(s)}else return}}},ns.fourcc="iref",ns.allowed_types=["auxl","base","cdsc","dimg","dpnd","eroi","evir","exbl","fdl ","font","iloc","mask","mint","pred","prem","tbas","text","thmb"],ns),Io,oy=(Io=class extends R{constructor(){super(...arguments),this.box_name="PrimaryItemBox"}parse(i){this.parseFullHeader(i),this.version===0?this.item_id=i.readUint16():this.item_id=i.readUint32()}},Io.fourcc="pitm",Io),Po,ay=(Po=class extends R{constructor(){super(...arguments),this.box_name="MetaBox",this.isQT=!1}parse(i){const e=i.getPosition();if(this.size>8){switch(i.readUint32(),i.readString(4)){case"hdlr":case"mhdr":case"keys":case"ilst":case"ctry":case"lang":this.isQT=!0;break}i.seek(e)}this.isQT||this.parseFullHeader(i),Q.prototype.parse.call(this,i)}},Po.fourcc="meta",Po),Ro,qf=(Ro=class extends R{constructor(){super(...arguments),this.box_name="MovieFragmentHeaderBox"}parse(i){this.parseFullHeader(i),this.sequence_number=i.readUint32()}write(i){this.version=0,this.flags=0,this.size=4,this.writeHeader(i),i.writeUint32(this.sequence_number)}},Ro.fourcc="mfhd",Ro),ko,Kf=(ko=class extends R{constructor(){super(...arguments),this.box_name="MovieHeaderBox"}parse(i){this.parseFullHeader(i),this.version===1?(this.creation_time=i.readUint64(),this.modification_time=i.readUint64(),this.timescale=i.readUint32(),this.duration=i.readUint64()):(this.creation_time=i.readUint32(),this.modification_time=i.readUint32(),this.timescale=i.readUint32(),this.duration=i.readUint32()),this.rate=i.readUint32(),this.volume=i.readUint16()>>8,i.readUint16(),i.readUint32Array(2),this.matrix=i.readInt32Array(9),i.readUint32Array(6),this.next_track_id=i.readUint32()}write(i){const e=this.modification_time>Ae||this.creation_time>Ae||this.duration>Ae||this.version===1;this.version=e?1:0,this.size=96,this.size+=e?12:0,this.flags=0,this.writeHeader(i),e?(i.writeUint64(this.creation_time),i.writeUint64(this.modification_time),i.writeUint32(this.timescale),i.writeUint64(this.duration)):(i.writeUint32(this.creation_time),i.writeUint32(this.modification_time),i.writeUint32(this.timescale),i.writeUint32(this.duration)),i.writeUint32(this.rate),i.writeUint16(this.volume<<8),i.writeUint16(0),i.writeUint32(0),i.writeUint32(0),i.writeInt32Array(this.matrix),i.writeUint32(0),i.writeUint32(0),i.writeUint32(0),i.writeUint32(0),i.writeUint32(0),i.writeUint32(0),i.writeUint32(this.next_track_id)}print(i){super.printHeader(i),i.log(i.indent+"creation_time: "+this.creation_time),i.log(i.indent+"modification_time: "+this.modification_time),i.log(i.indent+"timescale: "+this.timescale),i.log(i.indent+"duration: "+this.duration),i.log(i.indent+"rate: "+this.rate),i.log(i.indent+"volume: "+(this.volume>>8)),i.log(i.indent+"matrix: "+this.matrix.join(", ")),i.log(i.indent+"next_track_id: "+this.next_track_id)}},ko.fourcc="mvhd",ko),Mo,ly=(Mo=class extends ni{parse(i){this.parseHeader(i),this.content_encoding=i.readCString(),this.mime_format=i.readCString(),this.parseFooter(i)}},Mo.fourcc="mett",Mo),Fo,cy=(Fo=class extends ni{parse(i){this.parseHeader(i),this.content_encoding=i.readCString(),this.namespace=i.readCString(),this.schema_location=i.readCString(),this.parseFooter(i)}},Fo.fourcc="metx",Fo),Uo,hy=(Uo=class extends U{constructor(){super(...arguments),this.box_name="AV1CodecConfigurationBox"}parse(i){let e=i.readUint8();if((e>>7&1)!==1){I.error("BoxParser","av1C marker problem",i.isofile);return}if(this.version=e&127,this.version!==1){I.error("BoxParser","av1C version "+this.version+" not supported",i.isofile);return}if(e=i.readUint8(),this.seq_profile=e>>5&7,this.seq_level_idx_0=e&31,e=i.readUint8(),this.seq_tier_0=e>>7&1,this.high_bitdepth=e>>6&1,this.twelve_bit=e>>5&1,this.monochrome=e>>4&1,this.chroma_subsampling_x=e>>3&1,this.chroma_subsampling_y=e>>2&1,this.chroma_sample_position=e&3,e=i.readUint8(),this.reserved_1=e>>5&7,this.reserved_1!==0){I.error("BoxParser","av1C reserved_1 parsing problem",i.isofile);return}if(this.initial_presentation_delay_present=e>>4&1,this.initial_presentation_delay_present===1)this.initial_presentation_delay_minus_one=e&15;else if(this.reserved_2=e&15,this.reserved_2!==0){I.error("BoxParser","av1C reserved_2 parsing problem",i.isofile);return}const t=this.size-this.hdr_size-4;this.configOBUs=i.readUint8Array(t)}},Uo.fourcc="av1C",Uo),Bo,uy=(Bo=class extends R{constructor(){super(...arguments),this.box_name="ElementaryStreamDescriptorBox"}parse(i){this.parseFullHeader(i);const e=i.readUint8Array(this.size-this.hdr_size);if("MPEG4DescriptorParser"in or){const t=new or.MPEG4DescriptorParser;this.esd=t.parseOneDescriptor(new Pe(e.buffer,0))}}},Bo.fourcc="esds",Bo),Oo,dy=(Oo=class extends R{constructor(){super(...arguments),this.box_name="VPCodecConfigurationRecord"}parse(i){if(this.parseFullHeader(i),this.version===1){this.profile=i.readUint8(),this.level=i.readUint8();const e=i.readUint8();this.bitDepth=e>>4,this.chromaSubsampling=e>>1&7,this.videoFullRangeFlag=e&1,this.colourPrimaries=i.readUint8(),this.transferCharacteristics=i.readUint8(),this.matrixCoefficients=i.readUint8(),this.codecIntializationDataSize=i.readUint16(),this.codecIntializationData=i.readUint8Array(this.codecIntializationDataSize)}else{this.profile=i.readUint8(),this.level=i.readUint8();let e=i.readUint8();this.bitDepth=e>>4&15,this.colorSpace=e&15,e=i.readUint8(),this.chromaSubsampling=e>>4&15,this.transferFunction=e>>1&7,this.videoFullRangeFlag=e&1,this.codecIntializationDataSize=i.readUint16(),this.codecIntializationData=i.readUint8Array(this.codecIntializationDataSize)}}},Oo.fourcc="vpcC",Oo),Do,fy=(Do=class extends R{constructor(){super(...arguments),this.box_name="VvcConfigurationBox"}parse(i){this.parseFullHeader(i);const e={held_bits:void 0,num_held_bits:0,stream_read_1_bytes:function(n){this.held_bits=n.readUint8(),this.num_held_bits=8},stream_read_2_bytes:function(n){this.held_bits=n.readUint16(),this.num_held_bits=16},extract_bits:function(n){const o=this.held_bits>>this.num_held_bits-n&(1<<n)-1;return this.num_held_bits-=n,o}};if(e.stream_read_1_bytes(i),e.extract_bits(5),this.lengthSizeMinusOne=e.extract_bits(2),this.ptl_present_flag=e.extract_bits(1),this.ptl_present_flag){e.stream_read_2_bytes(i),this.ols_idx=e.extract_bits(9),this.num_sublayers=e.extract_bits(3),this.constant_frame_rate=e.extract_bits(2),this.chroma_format_idc=e.extract_bits(2),e.stream_read_1_bytes(i),this.bit_depth_minus8=e.extract_bits(3),e.extract_bits(5);{if(e.stream_read_2_bytes(i),e.extract_bits(2),this.num_bytes_constraint_info=e.extract_bits(6),this.general_profile_idc=e.extract_bits(7),this.general_tier_flag=e.extract_bits(1),this.general_level_idc=i.readUint8(),e.stream_read_1_bytes(i),this.ptl_frame_only_constraint_flag=e.extract_bits(1),this.ptl_multilayer_enabled_flag=e.extract_bits(1),this.general_constraint_info=new Uint8Array(this.num_bytes_constraint_info),this.num_bytes_constraint_info){for(let n=0;n<this.num_bytes_constraint_info-1;n++){const o=e.extract_bits(6);e.stream_read_1_bytes(i);const a=e.extract_bits(2);this.general_constraint_info[n]=o<<2|a}this.general_constraint_info[this.num_bytes_constraint_info-1]=e.extract_bits(6)}else e.extract_bits(6);if(this.num_sublayers>1){e.stream_read_1_bytes(i),this.ptl_sublayer_present_mask=0;for(let n=this.num_sublayers-2;n>=0;--n){const o=e.extract_bits(1);this.ptl_sublayer_present_mask|=o<<n}for(let n=this.num_sublayers;n<=8&&this.num_sublayers>1;++n)e.extract_bits(1);this.sublayer_level_idc=[];for(let n=this.num_sublayers-2;n>=0;--n)this.ptl_sublayer_present_mask&1<<n&&(this.sublayer_level_idc[n]=i.readUint8())}if(this.ptl_num_sub_profiles=i.readUint8(),this.general_sub_profile_idc=[],this.ptl_num_sub_profiles)for(let n=0;n<this.ptl_num_sub_profiles;n++)this.general_sub_profile_idc.push(i.readUint32())}this.max_picture_width=i.readUint16(),this.max_picture_height=i.readUint16(),this.avg_frame_rate=i.readUint16()}const t=12,s=13;this.nalu_arrays=[];const r=i.readUint8();for(let n=0;n<r;n++){const o=[];this.nalu_arrays.push(o),e.stream_read_1_bytes(i),o.completeness=e.extract_bits(1),e.extract_bits(2),o.nalu_type=e.extract_bits(5);let a=1;o.nalu_type!==s&&o.nalu_type!==t&&(a=i.readUint16());for(let l=0;l<a;l++){const c=i.readUint16();o.push({data:i.readUint8Array(c),length:c})}}}},Do.fourcc="vvcC",Do),Go,py=(Go=class extends U{constructor(){super(...arguments),this.box_name="ColourInformationBox"}parse(i){if(this.colour_type=i.readString(4),this.colour_type==="nclx"){this.colour_primaries=i.readUint16(),this.transfer_characteristics=i.readUint16(),this.matrix_coefficients=i.readUint16();const e=i.readUint8();this.full_range_flag=e>>7}else this.colour_type==="rICC"?this.ICC_profile=i.readUint8Array(this.size-4):this.colour_type==="prof"&&(this.ICC_profile=i.readUint8Array(this.size-4))}},Go.fourcc="colr",Go);function wi(i,e){let t=Number(i).toString(16);for(e=typeof e>"u"?2:e;t.length<e;)t="0"+t;return t}var hr=class extends fe{getCodec(){const i=super.getCodec();return this.avcC?`${i}.${wi(this.avcC.AVCProfileIndication)}${wi(this.avcC.profile_compatibility)}${wi(this.avcC.AVCLevelIndication)}`:i}},zo,my=(zo=class extends hr{constructor(){super(...arguments),this.box_name="AVCSampleEntry"}},zo.fourcc="avc1",zo),Lo,gy=(Lo=class extends hr{constructor(){super(...arguments),this.box_name="AVC2SampleEntry"}},Lo.fourcc="avc2",Lo),No,_y=(No=class extends hr{constructor(){super(...arguments),this.box_name="AVCSampleEntry"}},No.fourcc="avc3",No),Ho,xy=(Ho=class extends hr{constructor(){super(...arguments),this.box_name="AVC2SampleEntry"}},Ho.fourcc="avc4",Ho),Wo,vy=(Wo=class extends fe{constructor(){super(...arguments),this.box_name="AV1SampleEntry"}getCodec(){const i=super.getCodec(),e=this.av1C.seq_level_idx_0,t=e<10?"0"+e:e;let s;return this.av1C.seq_profile===2&&this.av1C.high_bitdepth===1?s=this.av1C.twelve_bit===1?"12":"10":this.av1C.seq_profile<=2&&(s=this.av1C.high_bitdepth===1?"10":"08"),i+"."+this.av1C.seq_profile+"."+t+(this.av1C.seq_tier_0?"H":"M")+"."+s}},Wo.fourcc="av01",Wo),Vo,yy=(Vo=class extends fe{},Vo.fourcc="dav1",Vo),ur=class extends fe{getCodec(){let i=super.getCodec();if(this.hvcC){switch(i+=".",this.hvcC.general_profile_space){case 0:i+="";break;case 1:i+="A";break;case 2:i+="B";break;case 3:i+="C";break}i+=this.hvcC.general_profile_idc,i+=".";let e=this.hvcC.general_profile_compatibility,t=0;for(let n=0;n<32&&(t|=e&1,n!==31);n++)t<<=1,e>>=1;i+=wi(t,0),i+=".",this.hvcC.general_tier_flag===0?i+="L":i+="H",i+=this.hvcC.general_level_idc;let s=!1,r="";for(let n=5;n>=0;n--)(this.hvcC.general_constraint_indicator[n]||s)&&(r="."+wi(this.hvcC.general_constraint_indicator[n],0)+r,s=!0);i+=r}return i}},$o,by=($o=class extends ur{constructor(){super(...arguments),this.box_name="HEVCSampleEntry"}},$o.fourcc="hvc1",$o),Xo,Ty=(Xo=class extends ur{},Xo.fourcc="hvc2",Xo),Yo,wy=(Yo=class extends ur{constructor(){super(...arguments),this.box_name="HEVCSampleEntry",this.colrs=[],this.subBoxNames=["colr"]}},Yo.fourcc="hev1",Yo),qo,Sy=(qo=class extends ur{},qo.fourcc="hev2",qo),Ko,Cy=(Ko=class extends fe{constructor(){super(...arguments),this.box_name="HEVCTileSampleSampleEntry"}},Ko.fourcc="hvt1",Ko),jo,Ay=(jo=class extends fe{constructor(){super(...arguments),this.box_name="LHEVCSampleEntry"}},jo.fourcc="lhe1",jo),Zo,Ey=(Zo=class extends fe{constructor(){super(...arguments),this.box_name="LHEVCSampleEntry"}},Zo.fourcc="lhv1",Zo),Jo,Iy=(Jo=class extends fe{},Jo.fourcc="dvh1",Jo),Qo,Py=(Qo=class extends fe{},Qo.fourcc="dvhe",Qo),jf=class extends fe{getCodec(){let i=super.getCodec();if(this.vvcC){i+="."+this.vvcC.general_profile_idc,this.vvcC.general_tier_flag?i+=".H":i+=".L",i+=this.vvcC.general_level_idc;let e="";if(this.vvcC.general_constraint_info){const t=[];let s=0;s|=this.vvcC.ptl_frame_only_constraint_flag<<7,s|=this.vvcC.ptl_multilayer_enabled_flag<<6;let r;for(let n=0;n<this.vvcC.general_constraint_info.length;++n)s|=this.vvcC.general_constraint_info[n]>>2&63,t.push(s),s&&(r=n),s=this.vvcC.general_constraint_info[n]>>2&3;if(r===void 0)e=".CA";else{e=".C";const n="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";let o=0,a=0;for(let l=0;l<=r;++l)for(o=o<<8|t[l],a+=8;a>=5;){const c=o>>a-5&31;e+=n[c],a-=5,o&=(1<<a)-1}a&&(o<<=5-a,e+=n[o&31])}}i+=e}return i}},ea,Ry=(ea=class extends jf{constructor(){super(...arguments),this.box_name="VvcSampleEntry"}},ea.fourcc="vvc1",ea),ta,ky=(ta=class extends jf{constructor(){super(...arguments),this.box_name="VvcSampleEntry"}},ta.fourcc="vvi1",ta),ia,My=(ia=class extends fe{constructor(){super(...arguments),this.box_name="VvcSampleEntry"}},ia.fourcc="vvs1",ia),sa,Fy=(sa=class extends fe{constructor(){super(...arguments),this.box_name="VvcNonVCLSampleEntry"}},sa.fourcc="vvcN",sa),Zf=class extends fe{getCodec(){const i=super.getCodec();let e=this.vpcC.level;e===0&&(e="00");let t=this.vpcC.bitDepth;return t===8&&(t="08"),`${i}.0${this.vpcC.profile}.${e}.${t}`}},ra,Uy=(ra=class extends Zf{},ra.fourcc="vp08",ra),na,By=(na=class extends Zf{},na.fourcc="vp09",na),oa,Oy=(oa=class extends fe{},oa.fourcc="avs3",oa),aa,Dy=(aa=class extends fe{constructor(){super(...arguments),this.box_name="J2KSampleEntry"}},aa.fourcc="j2ki",aa),la,Gy=(la=class extends fe{},la.fourcc="mjp2",la),ca,zy=(ca=class extends fe{},ca.fourcc="mjpg",ca),ha,Ly=(ha=class extends fe{constructor(){super(...arguments),this.box_name="UncompressedVideoSampleEntry"}},ha.fourcc="uncv",ha),ua,Ny=(ua=class extends fe{constructor(){super(...arguments),this.box_name="MP4VisualSampleEntry"}},ua.fourcc="mp4v",ua),da,Hy=(da=class extends Le{constructor(){super(...arguments),this.box_name="MP4AudioSampleEntry"}getCodec(){const i=super.getCodec();if(this.esds&&this.esds.esd){const e=this.esds.esd.getOTI(),t=this.esds.esd.getAudioConfig();return i+"."+wi(e)+(t?"."+t:"")}else return i}},da.fourcc="mp4a",da),fa,Wy=(fa=class extends Le{},fa.fourcc="m4ae",fa),pa,Vy=(pa=class extends Le{},pa.fourcc="ac-3",pa),ma,$y=(ma=class extends Le{},ma.fourcc="ac-4",ma),ga,Xy=(ga=class extends Le{},ga.fourcc="ec-3",ga),_a,Yy=(_a=class extends Le{},_a.fourcc="Opus",_a),xa,qy=(xa=class extends Le{},xa.fourcc="mha1",xa),va,Ky=(va=class extends Le{},va.fourcc="mha2",va),ya,jy=(ya=class extends Le{},ya.fourcc="mhm1",ya),ba,Zy=(ba=class extends Le{},ba.fourcc="mhm2",ba),Ta,Jy=(Ta=class extends Le{},Ta.fourcc="fLaC",Ta),wa,Qy=(wa=class extends fe{},wa.fourcc="encv",wa),Sa,eb=(Sa=class extends Le{},Sa.fourcc="enca",Sa),Ca,tb=(Ca=class extends Xt{constructor(){super(...arguments),this.subBoxNames=["sinf"],this.sinfs=[]}},Ca.fourcc="encu",Ca),Aa,ib=(Aa=class extends ar{constructor(){super(...arguments),this.subBoxNames=["sinf"],this.sinfs=[]}},Aa.fourcc="encs",Aa),Ea,sb=(Ea=class extends ar{},Ea.fourcc="mp4s",Ea),Ia,rb=(Ia=class extends Rf{constructor(){super(...arguments),this.subBoxNames=["sinf"],this.sinfs=[]}},Ia.fourcc="enct",Ia),Pa,nb=(Pa=class extends ni{constructor(){super(...arguments),this.subBoxNames=["sinf"],this.sinfs=[]}},Pa.fourcc="encm",Pa),Ra,ob=(Ra=class extends fe{constructor(){super(...arguments),this.box_name="RestrictedVideoSampleEntry"}},Ra.fourcc="resv",Ra),ka,ab=(ka=class extends Xt{parse(i){this.parseHeader(i),this.content_encoding=i.readCString(),this.mime_format=i.readCString(),this.parseFooter(i)}},ka.fourcc="sbtt",ka),Ma,Jf=(Ma=class extends Xt{parse(i){this.parseHeader(i),this.namespace=i.readCString(),this.schema_location=i.readCString(),this.auxiliary_mime_types=i.readCString(),this.parseFooter(i)}write(i){this.writeHeader(i),this.size+=this.namespace.length+1+this.schema_location.length+1+this.auxiliary_mime_types.length+1,i.writeCString(this.namespace),i.writeCString(this.schema_location),i.writeCString(this.auxiliary_mime_types),this.writeFooter(i)}},Ma.fourcc="stpp",Ma),Fa,lb=(Fa=class extends Xt{parse(i){this.parseHeader(i),this.content_encoding=i.readCString(),this.mime_format=i.readCString(),this.parseFooter(i)}getCodec(){const i=super.getCodec();return this.mime_format?i+"."+this.mime_format:i}},Fa.fourcc="stxt",Fa),Ua,cb=(Ua=class extends Xt{parse(i){this.parseHeader(i),this.displayFlags=i.readUint32(),this.horizontal_justification=i.readInt8(),this.vertical_justification=i.readInt8(),this.bg_color_rgba=i.readUint8Array(4),this.box_record=i.readInt16Array(4),this.style_record=i.readUint8Array(12),this.parseFooter(i)}},Ua.fourcc="tx3g",Ua),Ba,hb=(Ba=class extends ni{parse(i){this.parseHeader(i),this.parseFooter(i)}},Ba.fourcc="wvtt",Ba),Oa,ub=(Oa=class extends R{constructor(){super(...arguments),this.box_name="SampleToGroupBox"}parse(i){this.parseFullHeader(i),this.grouping_type=i.readString(4),this.version===1?this.grouping_type_parameter=i.readUint32():this.grouping_type_parameter=0,this.entries=[];const e=i.readUint32();for(let t=0;t<e;t++)this.entries.push({sample_count:i.readInt32(),group_description_index:i.readInt32()})}write(i){this.grouping_type_parameter?this.version=1:this.version=0,this.flags=0,this.size=8+8*this.entries.length+(this.version===1?4:0),this.writeHeader(i),i.writeString(this.grouping_type,void 0,4),this.version===1&&i.writeUint32(this.grouping_type_parameter),i.writeUint32(this.entries.length);for(let e=0;e<this.entries.length;e++){const t=this.entries[e];i.writeInt32(t.sample_count),i.writeInt32(t.group_description_index)}}},Oa.fourcc="sbgp",Oa),Da,db=(Da=class extends R{constructor(){super(...arguments),this.box_name="SampleDependencyTypeBox"}parse(i){this.parseFullHeader(i);const e=this.size-this.hdr_size;this.is_leading=[],this.sample_depends_on=[],this.sample_is_depended_on=[],this.sample_has_redundancy=[];for(let t=0;t<e;t++){const s=i.readUint8();this.is_leading[t]=s>>6,this.sample_depends_on[t]=s>>4&3,this.sample_is_depended_on[t]=s>>2&3,this.sample_has_redundancy[t]=s&3}}},Da.fourcc="sdtp",Da),Ga,fb=(Ga=class extends R{constructor(){super(...arguments),this.box_name="SampleGroupDescriptionBox"}parse(i){this.parseFullHeader(i),this.grouping_type=i.readString(4),I.debug("BoxParser","Found Sample Groups of type "+this.grouping_type),this.version===1?this.default_length=i.readUint32():this.default_length=0,this.version>=2&&(this.default_group_description_index=i.readUint32()),this.entries=[];const e=i.readUint32();for(let t=0;t<e;t++){let s;this.grouping_type in $e.sampleGroupEntry?s=new $e.sampleGroupEntry[this.grouping_type](this.grouping_type):s=new ve(this.grouping_type),this.entries.push(s),this.version===1?this.default_length===0?s.description_length=i.readUint32():s.description_length=this.default_length:s.description_length=this.default_length,s.write===ve.prototype.write&&(I.info("BoxParser","SampleGroup for type "+this.grouping_type+" writing not yet implemented, keeping unparsed data in memory for later write"),s.data=i.readUint8Array(s.description_length),i.seek(i.getPosition()-s.description_length)),s.parse(i)}}write(i){this.flags=0,this.size=12;for(let e=0;e<this.entries.length;e++){const t=this.entries[e];this.version===1&&(this.default_length===0&&(this.size+=4),this.size+=t.data.length)}this.writeHeader(i),i.writeString(this.grouping_type,void 0,4),this.version===1&&i.writeUint32(this.default_length),this.version>=2&&i.writeUint32(this.default_sample_description_index),i.writeUint32(this.entries.length);for(let e=0;e<this.entries.length;e++){const t=this.entries[e];this.version===1&&this.default_length===0&&i.writeUint32(t.description_length),t.write(i)}}},Ga.fourcc="sgpd",Ga),za,pb=(za=class extends R{constructor(){super(...arguments),this.box_name="CompressedSegmentIndexBox"}parse(i){this.parseFullHeader(i),this.reference_ID=i.readUint32(),this.timescale=i.readUint32(),this.version===0?(this.earliest_presentation_time=i.readUint32(),this.first_offset=i.readUint32()):(this.earliest_presentation_time=i.readUint64(),this.first_offset=i.readUint64()),i.readUint16(),this.references=[];const e=i.readUint16();for(let t=0;t<e;t++){const s=i.readUint32(),r=i.readUint32(),n=i.readUint32();this.references.push({reference_type:s>>31&1,referenced_size:s&2147483647,subsegment_duration:r,starts_with_SAP:n>>31&1,SAP_type:n>>28&7,SAP_delta_time:n&268435455})}}write(i){const e=this.earliest_presentation_time>Ae||this.first_offset>Ae||this.version===1;this.version=e?1:0,this.size=12+12*this.references.length,this.size+=e?16:8,this.flags=0,this.writeHeader(i),i.writeUint32(this.reference_ID),i.writeUint32(this.timescale),e?(i.writeUint64(this.earliest_presentation_time),i.writeUint64(this.first_offset)):(i.writeUint32(this.earliest_presentation_time),i.writeUint32(this.first_offset)),i.writeUint16(0),i.writeUint16(this.references.length);for(let t=0;t<this.references.length;t++){const s=this.references[t];i.writeUint32(s.reference_type<<31|s.referenced_size),i.writeUint32(s.subsegment_duration),i.writeUint32(s.starts_with_SAP<<31|s.SAP_type<<28|s.SAP_delta_time)}}},za.fourcc="sidx",za),La,Qf=(La=class extends R{constructor(){super(...arguments),this.box_name="SoundMediaHeaderBox"}parse(i){this.parseFullHeader(i),this.balance=i.readUint16(),i.readUint16()}write(i){this.version=0,this.size=4,this.writeHeader(i),i.writeUint16(this.balance),i.writeUint16(0)}},La.fourcc="smhd",La),Na,ep=(Na=class extends R{constructor(){super(...arguments),this.box_name="ChunkOffsetBox"}parse(i){this.parseFullHeader(i);const e=i.readUint32();if(this.chunk_offsets=[],this.version===0)for(let t=0;t<e;t++)this.chunk_offsets.push(i.readUint32())}write(i){this.version=0,this.flags=0,this.size=4+4*this.chunk_offsets.length,this.writeHeader(i),i.writeUint32(this.chunk_offsets.length),i.writeUint32Array(this.chunk_offsets)}unpack(i){for(let e=0;e<this.chunk_offsets.length;e++)i[e].offset=this.chunk_offsets[e]}},Na.fourcc="stco",Na),Ha,tp=(Ha=class extends R{constructor(){super(...arguments),this.box_name="SubtitleMediaHeaderBox"}},Ha.fourcc="sthd",Ha),Wa,ip=(Wa=class extends R{constructor(){super(...arguments),this.box_name="SampleToChunkBox"}parse(i){this.parseFullHeader(i);const e=i.readUint32();if(this.first_chunk=[],this.samples_per_chunk=[],this.sample_description_index=[],this.version===0)for(let t=0;t<e;t++)this.first_chunk.push(i.readUint32()),this.samples_per_chunk.push(i.readUint32()),this.sample_description_index.push(i.readUint32())}write(i){this.version=0,this.flags=0,this.size=4+12*this.first_chunk.length,this.writeHeader(i),i.writeUint32(this.first_chunk.length);for(let e=0;e<this.first_chunk.length;e++)i.writeUint32(this.first_chunk[e]),i.writeUint32(this.samples_per_chunk[e]),i.writeUint32(this.sample_description_index[e])}unpack(i){let e=0,t=0;for(let s=0;s<this.first_chunk.length;s++)for(let r=0;r<(s+1<this.first_chunk.length?this.first_chunk[s+1]:1/0);r++){t++;for(let n=0;n<this.samples_per_chunk[s];n++){if(i[e])i[e].description_index=this.sample_description_index[s],i[e].chunk_index=t;else return;e++}}}},Wa.fourcc="stsc",Wa),Va,sp=(Va=class extends R{constructor(){super(...arguments),this.box_name="SampleDescriptionBox"}parse(i){this.parseFullHeader(i),this.entries=[];const e=i.readUint32();for(let t=1;t<=e;t++){const s=dt(i,!0,this.size-(i.getPosition()-this.start));if(s.code===Ve){let r;s.type in $e.sampleEntry?(r=new $e.sampleEntry[s.type](s.size),r.hdr_size=s.hdr_size,r.start=s.start):(I.warn("BoxParser",`Unknown sample entry type: '${s.type}'`),r=new bt(s.size,s.hdr_size,s.start),r.type=s.type),r.write===bt.prototype.write&&(I.info("BoxParser","SampleEntry "+r.type+" box writing not yet implemented, keeping unparsed data in memory for later write"),r.parseDataAndRewind(i)),r.parse(i),this.entries.push(r)}else return}}write(i){this.version=0,this.flags=0,this.size=0,this.writeHeader(i),i.writeUint32(this.entries.length),this.size+=4;for(let e=0;e<this.entries.length;e++)this.entries[e].write(i),this.size+=this.entries[e].size;I.debug("BoxWriter","Adjusting box "+this.type+" with new size "+this.size),i.adjustUint32(this.sizePosition,this.size)}},Va.fourcc="stsd",Va),$a,rp=($a=class extends R{constructor(){super(...arguments),this.box_name="SampleSizeBox"}parse(i){if(this.parseFullHeader(i),this.sample_sizes=[],this.version===0){this.sample_size=i.readUint32(),this.sample_count=i.readUint32();for(let e=0;e<this.sample_count;e++)this.sample_size===0?this.sample_sizes.push(i.readUint32()):this.sample_sizes[e]=this.sample_size}}write(i){let e=!0;if(this.version=0,this.flags=0,this.sample_sizes.length>0){let t=0;for(;t+1<this.sample_sizes.length;)if(this.sample_sizes[t+1]!==this.sample_sizes[0]){e=!1;break}else t++}else e=!1;this.size=8,e||(this.size+=4*this.sample_sizes.length),this.writeHeader(i),e?i.writeUint32(this.sample_sizes[0]):i.writeUint32(0),i.writeUint32(this.sample_sizes.length),e||i.writeUint32Array(this.sample_sizes)}unpack(i){for(let e=0;e<this.sample_sizes.length;e++)i[e].size=this.sample_sizes[e]}},$a.fourcc="stsz",$a),Xa,np=(Xa=class extends R{constructor(){super(...arguments),this.box_name="TimeToSampleBox",this.sample_counts=[],this.sample_deltas=[]}parse(i){this.parseFullHeader(i);const e=i.readUint32();if(this.sample_counts.length=0,this.sample_deltas.length=0,this.version===0)for(let t=0;t<e;t++){this.sample_counts.push(i.readUint32());let s=i.readInt32();s<0&&(I.warn("BoxParser","File uses negative stts sample delta, using value 1 instead, sync may be lost!"),s=1),this.sample_deltas.push(s)}}write(i){this.version=0,this.flags=0,this.size=4+8*this.sample_counts.length,this.writeHeader(i),i.writeUint32(this.sample_counts.length);for(let e=0;e<this.sample_counts.length;e++)i.writeUint32(this.sample_counts[e]),i.writeUint32(this.sample_deltas[e])}unpack(i){let e=0;for(let t=0;t<this.sample_counts.length;t++)for(let s=0;s<this.sample_counts[t];s++)e===0?i[e].dts=0:i[e].dts=i[e-1].dts+this.sample_deltas[t],e++}},Xa.fourcc="stts",Xa),Ya,op=(Ya=class extends R{constructor(){super(...arguments),this.box_name="TrackFragmentBaseMediaDecodeTimeBox"}parse(i){this.parseFullHeader(i),this.version===1?this.baseMediaDecodeTime=i.readUint64():this.baseMediaDecodeTime=i.readUint32()}write(i){const e=this.baseMediaDecodeTime>Ae||this.version===1;this.version=e?1:0,this.size=4,this.size+=e?4:0,this.flags=0,this.writeHeader(i),e?i.writeUint64(this.baseMediaDecodeTime):i.writeUint32(this.baseMediaDecodeTime)}},Ya.fourcc="tfdt",Ya),qa,ap=(qa=class extends R{constructor(){super(...arguments),this.box_name="TrackFragmentHeaderBox"}parse(i){this.parseFullHeader(i);let e=0;this.track_id=i.readUint32(),this.size-this.hdr_size>e&&this.flags&js?(this.base_data_offset=i.readUint64(),e+=8):this.base_data_offset=0,this.size-this.hdr_size>e&&this.flags&Zs?(this.default_sample_description_index=i.readUint32(),e+=4):this.default_sample_description_index=0,this.size-this.hdr_size>e&&this.flags&Js?(this.default_sample_duration=i.readUint32(),e+=4):this.default_sample_duration=0,this.size-this.hdr_size>e&&this.flags&Qs?(this.default_sample_size=i.readUint32(),e+=4):this.default_sample_size=0,this.size-this.hdr_size>e&&this.flags&er?(this.default_sample_flags=i.readUint32(),e+=4):this.default_sample_flags=0}write(i){this.version=0,this.size=4,this.flags&js&&(this.size+=8),this.flags&Zs&&(this.size+=4),this.flags&Js&&(this.size+=4),this.flags&Qs&&(this.size+=4),this.flags&er&&(this.size+=4),this.writeHeader(i),i.writeUint32(this.track_id),this.flags&js&&i.writeUint64(this.base_data_offset),this.flags&Zs&&i.writeUint32(this.default_sample_description_index),this.flags&Js&&i.writeUint32(this.default_sample_duration),this.flags&Qs&&i.writeUint32(this.default_sample_size),this.flags&er&&i.writeUint32(this.default_sample_flags)}},qa.fourcc="tfhd",qa),Ka,lp=(Ka=class extends R{constructor(){super(...arguments),this.box_name="TrackHeaderBox",this.layer=0,this.alternate_group=0}parse(i){this.parseFullHeader(i),this.version===1?(this.creation_time=i.readUint64(),this.modification_time=i.readUint64(),this.track_id=i.readUint32(),i.readUint32(),this.duration=i.readUint64()):(this.creation_time=i.readUint32(),this.modification_time=i.readUint32(),this.track_id=i.readUint32(),i.readUint32(),this.duration=i.readUint32()),i.readUint32Array(2),this.layer=i.readInt16(),this.alternate_group=i.readInt16(),this.volume=i.readInt16()>>8,i.readUint16(),this.matrix=i.readInt32Array(9),this.width=i.readUint32(),this.height=i.readUint32()}write(i){const e=this.modification_time>Ae||this.creation_time>Ae||this.duration>Ae||this.version===1;this.version=e?1:0,this.size=80,this.size+=e?12:0,this.flags=this.flags??3,this.writeHeader(i),e?(i.writeUint64(this.creation_time),i.writeUint64(this.modification_time),i.writeUint32(this.track_id),i.writeUint32(0),i.writeUint64(this.duration)):(i.writeUint32(this.creation_time),i.writeUint32(this.modification_time),i.writeUint32(this.track_id),i.writeUint32(0),i.writeUint32(this.duration)),i.writeUint32Array([0,0]),i.writeInt16(this.layer),i.writeInt16(this.alternate_group),i.writeInt16(this.volume<<8),i.writeInt16(0),i.writeInt32Array(this.matrix),i.writeUint32(this.width),i.writeUint32(this.height)}print(i){super.printHeader(i),i.log(i.indent+"creation_time: "+this.creation_time),i.log(i.indent+"modification_time: "+this.modification_time),i.log(i.indent+"track_id: "+this.track_id),i.log(i.indent+"duration: "+this.duration),i.log(i.indent+"volume: "+(this.volume>>8)),i.log(i.indent+"matrix: "+this.matrix.join(", ")),i.log(i.indent+"layer: "+this.layer),i.log(i.indent+"alternate_group: "+this.alternate_group),i.log(i.indent+"width: "+this.width),i.log(i.indent+"height: "+this.height)}},Ka.fourcc="tkhd",Ka),ja,Za=(ja=class extends R{constructor(){super(...arguments),this.box_name="TrackExtendsBox"}parse(i){this.parseFullHeader(i),this.track_id=i.readUint32(),this.default_sample_description_index=i.readUint32(),this.default_sample_duration=i.readUint32(),this.default_sample_size=i.readUint32(),this.default_sample_flags=i.readUint32()}write(i){this.version=0,this.flags=0,this.size=20,this.writeHeader(i),i.writeUint32(this.track_id),i.writeUint32(this.default_sample_description_index),i.writeUint32(this.default_sample_duration),i.writeUint32(this.default_sample_size),i.writeUint32(this.default_sample_flags)}},ja.fourcc="trex",ja),Ja,cp=(Ja=class extends R{constructor(){super(...arguments),this.box_name="TrackRunBox",this.sample_duration=[],this.sample_size=[],this.sample_flags=[],this.sample_composition_time_offset=[]}parse(i){this.parseFullHeader(i);let e=0;if(this.sample_count=i.readUint32(),e+=4,this.size-this.hdr_size>e&&this.flags&es?(this.data_offset=i.readInt32(),e+=4):this.data_offset=0,this.size-this.hdr_size>e&&this.flags&tr?(this.first_sample_flags=i.readUint32(),e+=4):this.first_sample_flags=0,this.sample_duration=[],this.sample_size=[],this.sample_flags=[],this.sample_composition_time_offset=[],this.size-this.hdr_size>e)for(let t=0;t<this.sample_count;t++)this.flags&ts&&(this.sample_duration[t]=i.readUint32()),this.flags&is&&(this.sample_size[t]=i.readUint32()),this.flags&ss&&(this.sample_flags[t]=i.readUint32()),this.flags&rs&&(this.version===0?this.sample_composition_time_offset[t]=i.readUint32():this.sample_composition_time_offset[t]=i.readInt32())}write(i){this.size=4,this.flags&es&&(this.size+=4),this.flags&tr&&(this.size+=4),this.flags&ts&&(this.size+=4*this.sample_duration.length),this.flags&is&&(this.size+=4*this.sample_size.length),this.flags&ss&&(this.size+=4*this.sample_flags.length),this.flags&rs&&(this.size+=4*this.sample_composition_time_offset.length),this.writeHeader(i),i.writeUint32(this.sample_count),this.flags&es&&(this.data_offset_position=i.getPosition(),i.writeInt32(this.data_offset)),this.flags&tr&&i.writeUint32(this.first_sample_flags);for(let e=0;e<this.sample_count;e++)this.flags&ts&&i.writeUint32(this.sample_duration[e]),this.flags&is&&i.writeUint32(this.sample_size[e]),this.flags&ss&&i.writeUint32(this.sample_flags[e]),this.flags&rs&&(this.version===0?i.writeUint32(this.sample_composition_time_offset[e]):i.writeInt32(this.sample_composition_time_offset[e]))}},Ja.fourcc="trun",Ja),Qa,hp=(Qa=class extends R{constructor(){super(...arguments),this.box_name="DataEntryUrlBox"}parse(i){this.parseFullHeader(i),this.flags!==1&&(this.location=i.readCString())}write(i){this.version=0,this.location?(this.flags=0,this.size=this.location.length+1):(this.flags=1,this.size=0),this.writeHeader(i),this.location&&i.writeCString(this.location)}},Qa.fourcc="url ",Qa),el,up=(el=class extends R{constructor(){super(...arguments),this.box_name="VideoMediaHeaderBox"}parse(i){this.parseFullHeader(i),this.graphicsmode=i.readUint16(),this.opcolor=i.readUint16Array(3)}write(i){this.version=0,this.size=8,this.writeHeader(i),i.writeUint16(this.graphicsmode),i.writeUint16Array(this.opcolor)}},el.fourcc="vmhd",el),dr=class{constructor(i,e,t){this.grouping_type=i,this.grouping_type_parameter=e,this.sbgp=t,this.last_sample_in_run=-1,this.entry_index=-1}},dp=class si{constructor(e,t=!0){this.boxes=[],this.mdats=[],this.moofs=[],this.isProgressive=!1,this.moovStartFound=!1,this.moovStartSent=!1,this.readySent=!1,this.sampleListBuilt=!1,this.fragmentedTracks=[],this.extractedTracks=[],this.isFragmentationInitialized=!1,this.sampleProcessingStarted=!1,this.nextMoofNumber=0,this.itemListBuilt=!1,this.sidxSent=!1,this.items=[],this.entity_groups=[],this.itemsDataSize=0,this.lastMoofIndex=0,this.samplesDataSize=0,this.lastBoxStartPosition=0,this.nextParsePosition=0,this.discardMdatData=!0,this.discardMdatData=t,e?(this.stream=e,this.parse()):this.stream=new Ti,this.stream.isofile=this}setSegmentOptions(e,t,s){const{sizePerSegment:r=Number.MAX_SAFE_INTEGER,rapAlignement:n=!0}=s;let o=s.nbSamples??s.nbSamplesPerFragment??1e3;const a=s.nbSamplesPerFragment??o;if(o<=0||a<=0||r<=0){I.error("ISOFile",`Invalid segment options: nbSamples=${o}, nbSamplesPerFragment=${a}, sizePerSegment=${r}`);return}if(o<a&&(I.warn("ISOFile",`nbSamples (${o}) is less than nbSamplesPerFragment (${a}), setting nbSamples to nbSamplesPerFragment`),o=a),this.fragmentedTracks.some(c=>c.nb_samples!==o)){I.error("ISOFile",`Cannot set segment options for track ${e}: nbSamples (${o}) does not match existing tracks`);return}const l=this.getTrackById(e);if(l){const c={id:e,user:t,trak:l,segmentStream:void 0,nb_samples:o,nb_samples_per_fragment:a,size_per_segment:r,rapAlignement:n,state:{lastFragmentSampleNumber:0,lastSegmentSampleNumber:0,accumulatedSize:0}};this.fragmentedTracks.push(c),l.nextSample=0}this.discardMdatData&&I.warn("ISOFile","Segmentation options set but discardMdatData is true, samples will not be segmented")}unsetSegmentOptions(e){let t=-1;for(let s=0;s<this.fragmentedTracks.length;s++)this.fragmentedTracks[s].id===e&&(t=s);t>-1&&this.fragmentedTracks.splice(t,1)}setExtractionOptions(e,t,{nbSamples:s=1e3}={}){const r=this.getTrackById(e);r&&(this.extractedTracks.push({id:e,user:t,trak:r,nb_samples:s,samples:[]}),r.nextSample=0),this.discardMdatData&&I.warn("ISOFile","Extraction options set but discardMdatData is true, samples will not be extracted")}unsetExtractionOptions(e){let t=-1;for(let s=0;s<this.extractedTracks.length;s++)this.extractedTracks[s].id===e&&(t=s);t>-1&&this.extractedTracks.splice(t,1)}parse(){if(!(this.restoreParsePosition&&!this.restoreParsePosition()))for(;;)if(this.hasIncompleteMdat&&this.hasIncompleteMdat()){if(this.processIncompleteMdat())continue;return}else{this.saveParsePosition&&this.saveParsePosition();const e=dt(this.stream,!1);if(e.code===Vt)if(this.processIncompleteBox){if(this.processIncompleteBox(e))continue;return}else return;else if(e.code===Ve){const t=e.box;if(this.boxes.push(t),t.type==="uuid")this[t.uuid]!==void 0&&I.warn("ISOFile","Duplicate Box of uuid: "+t.uuid+", overriding previous occurrence"),this[t.uuid]=t;else switch(t.type){case"mdat":this.mdats.push(t),this.transferMdatData(t);break;case"moof":this.moofs.push(t);break;case"free":case"skip":break;case"moov":this.moovStartFound=!0,this.mdats.length===0&&(this.isProgressive=!0);default:this[t.type]!==void 0?Array.isArray(this[t.type+"s"])?(I.info("ISOFile",`Found multiple boxes of type ${t.type} in ISOFile, adding to array`),this[t.type+"s"].push(t)):(I.warn("ISOFile",`Found multiple boxes of type ${t.type} but no array exists. Creating array dynamically.`),this[t.type+"s"]=[this[t.type],t]):(this[t.type]=t,Array.isArray(this[t.type+"s"])&&this[t.type+"s"].push(t));break}this.updateUsedBytes&&this.updateUsedBytes(t,e)}else if(e.code===xf){I.error("ISOFile",`Invalid data found while parsing box of type '${e.type}' at position ${e.start}. Aborting parsing.`,this);break}}}checkBuffer(e){if(!e)throw new Error("Buffer must be defined and non empty");return e.byteLength===0?(I.warn("ISOFile","Ignoring empty buffer (fileStart: "+e.fileStart+")"),this.stream.logBufferLevel(),!1):(I.info("ISOFile","Processing buffer (fileStart: "+e.fileStart+")"),e.usedBytes=0,this.stream.insertBuffer(e),this.stream.logBufferLevel(),this.stream.initialized()?!0:(I.warn("ISOFile","Not ready to start parsing"),!1))}appendBuffer(e,t){let s;if(this.checkBuffer(e))return this.parse(),this.moovStartFound&&!this.moovStartSent&&(this.moovStartSent=!0,this.onMoovStart&&this.onMoovStart()),this.moov?(this.sampleListBuilt||(this.buildSampleLists(),this.sampleListBuilt=!0),this.updateSampleLists(),this.onReady&&!this.readySent&&(this.readySent=!0,this.onReady(this.getInfo())),this.processSamples(t),this.nextSeekPosition?(s=this.nextSeekPosition,this.nextSeekPosition=void 0):s=this.nextParsePosition,this.stream.getEndFilePositionAfter&&(s=this.stream.getEndFilePositionAfter(s))):this.nextParsePosition?s=this.nextParsePosition:s=0,this.sidx&&this.onSidx&&!this.sidxSent&&(this.onSidx(this.sidx),this.sidxSent=!0),this.meta&&(this.flattenItemInfo&&!this.itemListBuilt&&(this.flattenItemInfo(),this.itemListBuilt=!0),this.processItems&&this.processItems(this.onItem)),this.stream.cleanBuffers&&(I.info("ISOFile","Done processing buffer (fileStart: "+e.fileStart+") - next buffer to fetch should have a fileStart position of "+s),this.stream.logBufferLevel(),this.stream.cleanBuffers(),this.stream.logBufferLevel(!0),I.info("ISOFile","Sample data size in memory: "+this.getAllocatedSampleDataSize())),s}getFragmentDuration(){const e=this.getBox("mvex");if(!e)return;if(e.mehd)return{num:e.mehd.fragment_duration,den:this.moov.mvhd.timescale};const t=this.getBoxes("trak",!1);let s={num:0,den:1};for(const r of t){const n=r.samples_duration,o=r.mdia.mdhd.timescale;n&&o&&n/o>s.num/s.den&&(s={num:n,den:o})}return s}getInfo(){if(!this.moov)return{hasMoov:!1,mime:""};const e=new Date("1904-01-01T00:00:00Z").getTime(),t=this.getBox("mvex")!==void 0,s={hasMoov:!0,duration:this.moov.mvhd.duration,timescale:this.moov.mvhd.timescale,isFragmented:t,fragment_duration:this.getFragmentDuration(),isProgressive:this.isProgressive,hasIOD:this.moov.iods!==void 0,brands:[this.ftyp.major_brand].concat(this.ftyp.compatible_brands),created:new Date(e+this.moov.mvhd.creation_time*1e3),modified:new Date(e+this.moov.mvhd.modification_time*1e3),tracks:[],audioTracks:[],videoTracks:[],subtitleTracks:[],metadataTracks:[],hintTracks:[],otherTracks:[],mime:""};for(let r=0;r<this.moov.traks.length;r++){const n=this.moov.traks[r],o=n.mdia.minf.stbl.stsd.entries[0],a=n.samples_size,l=n.mdia.mdhd.timescale,c=n.samples_duration,h=a*8*l/c,u={samples_duration:c,bitrate:h,size:a,timescale:l,alternate_group:n.tkhd.alternate_group,codec:o.getCodec(),created:new Date(e+n.tkhd.creation_time*1e3),cts_shift:n.mdia.minf.stbl.cslg,duration:n.mdia.mdhd.duration,id:n.tkhd.track_id,kind:n.udta&&n.udta.kinds.length?n.udta.kinds[0]:{schemeURI:"",value:""},language:n.mdia.elng?n.mdia.elng.extended_language:n.mdia.mdhd.languageString,layer:n.tkhd.layer,matrix:n.tkhd.matrix,modified:new Date(e+n.tkhd.modification_time*1e3),movie_duration:n.tkhd.duration,movie_timescale:s.timescale,name:n.mdia.hdlr.name,nb_samples:n.samples.length,references:[],track_height:n.tkhd.height/65536,track_width:n.tkhd.width/65536,volume:n.tkhd.volume};if(s.tracks.push(u),n.tref)for(let d=0;d<n.tref.references.length;d++)u.references.push({type:n.tref.references[d].type,track_ids:n.tref.references[d].track_ids});n.edts!==void 0&&n.edts.elst!==void 0&&(u.edits=n.edts.elst.entries),o instanceof Le?(u.type="audio",s.audioTracks.push(u),u.audio={sample_rate:o.getSampleRate(),channel_count:o.getChannelCount(),sample_size:o.getSampleSize()}):o instanceof fe?(u.type="video",s.videoTracks.push(u),u.video={width:o.getWidth(),height:o.getHeight()}):o instanceof Xt?(u.type="subtitles",s.subtitleTracks.push(u)):o instanceof Pn?(u.type="metadata",s.hintTracks.push(u)):o instanceof ni?(u.type="metadata",s.metadataTracks.push(u)):(u.type="metadata",s.otherTracks.push(u))}s.videoTracks&&s.videoTracks.length>0?s.mime+='video/mp4; codecs="':s.audioTracks&&s.audioTracks.length>0?s.mime+='audio/mp4; codecs="':s.mime+='application/mp4; codecs="';for(let r=0;r<s.tracks.length;r++)r!==0&&(s.mime+=","),s.mime+=s.tracks[r].codec;return s.mime+='"; profiles="',s.mime+=this.ftyp.compatible_brands.join(),s.mime+='"',s}setNextSeekPositionFromSample(e){e&&(this.nextSeekPosition?this.nextSeekPosition=Math.min(e.offset+e.alreadyRead,this.nextSeekPosition):this.nextSeekPosition=e.offset+e.alreadyRead)}processSamples(e){if(this.sampleProcessingStarted){if(this.isFragmentationInitialized&&this.onSegment!==void 0){const t=new Set;for(;t.size<this.fragmentedTracks.length&&this.fragmentedTracks.some(s=>s.trak.nextSample<s.trak.samples.length)&&this.sampleProcessingStarted;)for(const s of this.fragmentedTracks){const r=s.trak;if(!t.has(s.id)){const n=r.nextSample<r.samples.length?this.getSample(r,r.nextSample):void 0;if(!n){this.setNextSeekPositionFromSample(r.samples[r.nextSample]),t.add(s.id);continue}s.state.accumulatedSize+=n.size;const o=r.nextSample+1,a=o-s.state.lastFragmentSampleNumber>s.nb_samples_per_fragment,l=o-s.state.lastSegmentSampleNumber>s.nb_samples;let c=a||o%s.nb_samples_per_fragment===0,h=l||o%s.nb_samples===0,u=s.state.accumulatedSize>=s.size_per_segment;const d=!s.rapAlignement||n.is_sync,f=e||r.nextSample+1>=r.samples.length;if(f&&!d&&I.warn("ISOFile","Flushing track #"+s.id+" at sample #"+r.nextSample+" which is not a RAP, this may lead to playback issues"),c=c&&d,h=h&&d,u=u&&d,c||u||f){a?I.warn("ISOFile","Fragment on track #"+s.id+" is overdue, creating it with samples ["+s.state.lastFragmentSampleNumber+", "+r.nextSample+"]"):I.debug("ISOFile","Creating media fragment on track #"+s.id+" for samples ["+s.state.lastFragmentSampleNumber+", "+r.nextSample+"]");const m=this.createFragment(s.id,s.state.lastFragmentSampleNumber,r.nextSample,s.segmentStream);if(m)s.segmentStream=m,s.state.lastFragmentSampleNumber=r.nextSample+1;else{t.add(s.id);continue}}(h||u||f)&&(l?I.warn("ISOFile","Segment on track #"+s.id+" is overdue, sending it with samples ["+Math.max(0,r.nextSample-s.nb_samples)+", "+(r.nextSample-1)+"]"):I.info("ISOFile","Sending fragmented data on track #"+s.id+" for samples ["+Math.max(0,r.nextSample-s.nb_samples)+", "+(r.nextSample-1)+"]"),I.info("ISOFile","Sample data size in memory: "+this.getAllocatedSampleDataSize()),this.onSegment&&this.onSegment(s.id,s.user,s.segmentStream.buffer,r.nextSample+1,e||r.nextSample+1>=r.samples.length),s.segmentStream=void 0,s.state.accumulatedSize=0,s.state.lastSegmentSampleNumber=r.nextSample+1),r.nextSample++}}}if(this.onSamples!==void 0)for(let t=0;t<this.extractedTracks.length;t++){const s=this.extractedTracks[t],r=s.trak;for(;r.nextSample<r.samples.length&&this.sampleProcessingStarted;){I.debug("ISOFile","Exporting on track #"+s.id+" sample #"+r.nextSample);const n=this.getSample(r,r.nextSample);if(n)r.nextSample++,s.samples.push(n);else{this.setNextSeekPositionFromSample(r.samples[r.nextSample]);break}if((r.nextSample%s.nb_samples===0||r.nextSample>=r.samples.length)&&(I.debug("ISOFile","Sending samples on track #"+s.id+" for sample "+r.nextSample),this.onSamples&&this.onSamples(s.id,s.user,s.samples),s.samples=[],s!==this.extractedTracks[t]))break}}}}getBox(e){const t=this.getBoxes(e,!0);return t.length?t[0]:void 0}getBoxes(e,t){const s=[],r=n=>{n instanceof U&&n.type&&n.type===e&&s.push(n);const o=[];n.boxes&&o.push(...n.boxes),n.entries&&o.push(...n.entries),n.item_infos&&o.push(...n.item_infos),n.references&&o.push(...n.references);for(const a of o){if(s.length&&t)return;r(a)}};return r(this),s}getTrackSamplesInfo(e){const t=this.getTrackById(e);if(t)return t.samples}getTrackSample(e,t){const s=this.getTrackById(e);return this.getSample(s,t)}releaseUsedSamples(e,t){let s=0;const r=this.getTrackById(e);r.lastValidSample||(r.lastValidSample=0);for(let n=r.lastValidSample;n<t;n++)s+=this.releaseSample(r,n);I.info("ISOFile","Track #"+e+" released samples up to "+t+" (released size: "+s+", remaining: "+this.samplesDataSize+")"),r.lastValidSample=t}start(){this.sampleProcessingStarted=!0,this.processSamples(!1)}stop(){this.sampleProcessingStarted=!1}flush(){I.info("ISOFile","Flushing remaining samples"),this.updateSampleLists(),this.processSamples(!0),this.stream.cleanBuffers(),this.stream.logBufferLevel(!0)}seekTrack(e,t,s){let r=0,n=0,o;if(s.samples.length===0)return I.info("ISOFile","No sample in track, cannot seek! Using time "+I.getDurationString(0,1)+" and offset: 0"),{offset:0,time:0};for(let l=0;l<s.samples.length;l++){const c=s.samples[l];if(l===0)n=0,o=c.timescale;else if(c.cts>e*c.timescale){n=l-1;break}t&&c.is_sync&&(r=l)}for(t&&(n=r),e=s.samples[n].cts,s.nextSample=n;s.samples[n].alreadyRead===s.samples[n].size&&s.samples[n+1];)n++;const a=s.samples[n].offset+s.samples[n].alreadyRead;return I.info("ISOFile","Seeking to "+(t?"RAP":"")+" sample #"+s.nextSample+" on track "+s.tkhd.track_id+", time "+I.getDurationString(e,o)+" and offset: "+a),{offset:a,time:e/o}}getTrackDuration(e){if(!e.samples)return 1/0;const t=e.samples[e.samples.length-1];return(t.cts+t.duration)/t.timescale}seek(e,t){const s=this.moov;let r={offset:1/0,time:1/0};if(this.moov){for(let n=0;n<s.traks.length;n++){const o=s.traks[n];if(e>this.getTrackDuration(o))continue;const a=this.seekTrack(e,t,o);a.offset<r.offset&&(r.offset=a.offset),a.time<r.time&&(r.time=a.time)}return I.info("ISOFile","Seeking at time "+I.getDurationString(r.time,1)+" needs a buffer with a fileStart position of "+r.offset),r.offset===1/0?r={offset:this.nextParsePosition,time:0}:r.offset=this.stream.getEndFilePositionAfter(r.offset),I.info("ISOFile","Adjusted seek position (after checking data already in buffer): "+r.offset),r}else throw new Error("Cannot seek: moov not received!")}equal(e){let t=0;for(;t<this.boxes.length&&t<e.boxes.length;){const s=this.boxes[t],r=e.boxes[t];if(!An(s,r))return!1;t++}return!0}write(e){for(let t=0;t<this.boxes.length;t++)this.boxes[t].write(e)}createFragment(e,t,s,r){const n=[];for(let h=t;h<=s;h++){const u=this.getTrackById(e),d=this.getSample(u,h);if(!d){this.setNextSeekPositionFromSample(u.samples[h]);return}n.push(d)}const o=r||new Pe,a=this.createMoof(n);a.write(o),a.trafs[0].truns[0].data_offset=a.size+8,I.debug("MP4Box","Adjusting data_offset with new value "+a.trafs[0].truns[0].data_offset),o.adjustUint32(a.trafs[0].truns[0].data_offset_position,a.trafs[0].truns[0].data_offset);const l=new lr;l.stream=new Ti;let c=0;for(const h of n)if(h.data){const u=yt.fromArrayBuffer(h.data.buffer,c);l.stream.insertBuffer(u),c+=h.data.byteLength}return l.write(o),o}static writeInitializationSegment(e,t,s){I.debug("ISOFile","Generating initialization segment");const r=new Pe;e.write(r);const n=t.addBox(new jn);if(s){const o=n.addBox(new Yf);o.fragment_duration=s}for(let o=0;o<t.traks.length;o++){const a=n.addBox(new Za);a.track_id=t.traks[o].tkhd.track_id,a.default_sample_description_index=1,a.default_sample_duration=t.traks[o].samples[0]?.duration??0,a.default_sample_size=0,a.default_sample_flags=65536}return t.write(r),r.buffer}save(e){const t=new Pe;return t.isofile=this,this.write(t),t.save(e)}getBuffer(){const e=new Pe;return e.isofile=this,this.write(e),e}initializeSegmentation(){this.onSegment||I.warn("MP4Box","No segmentation callback set!"),this.isFragmentationInitialized||(this.isFragmentationInitialized=!0,this.resetTables());const e=new Hn;e.addBox(this.moov.mvhd);for(let t=0;t<this.fragmentedTracks.length;t++){const s=this.getTrackById(this.fragmentedTracks[t].id);if(!s){I.warn("ISOFile",`Track with id ${this.fragmentedTracks[t].id} not found, skipping fragmentation initialization`);continue}e.addBox(s)}return{tracks:e.traks.map((t,s)=>({id:t.tkhd.track_id,user:this.fragmentedTracks[s].user})),buffer:si.writeInitializationSegment(this.ftyp,e,this.moov?.mvex?.mehd.fragment_duration)}}resetTables(){this.initial_duration=this.moov.mvhd.duration,this.moov.mvhd.duration=0;for(let e=0;e<this.moov.traks.length;e++){const t=this.moov.traks[e];t.tkhd.duration=0,t.mdia.mdhd.duration=0;const s=t.mdia.minf.stbl.stco||t.mdia.minf.stbl.co64;s.chunk_offsets=[];const r=t.mdia.minf.stbl.stsc;r.first_chunk=[],r.samples_per_chunk=[],r.sample_description_index=[];const n=t.mdia.minf.stbl.stsz||t.mdia.minf.stbl.stz2;n.sample_sizes=[];const o=t.mdia.minf.stbl.stts;o.sample_counts=[],o.sample_deltas=[];const a=t.mdia.minf.stbl.ctts;a&&(a.sample_counts=[],a.sample_offsets=[]);const l=t.mdia.minf.stbl.stss,c=t.mdia.minf.stbl.boxes.indexOf(l);c!==-1&&(t.mdia.minf.stbl.boxes[c]=void 0)}}static initSampleGroups(e,t,s,r,n){t&&(t.sample_groups_info=[]),e.sample_groups_info||(e.sample_groups_info=[]);for(let o=0;o<s.length;o++){const a=s[o].grouping_type+"/"+s[o].grouping_type_parameter,l=new dr(s[o].grouping_type,s[o].grouping_type_parameter,s[o]);t&&(t.sample_groups_info[a]=l),e.sample_groups_info[a]||(e.sample_groups_info[a]=l);for(let c=0;c<r.length;c++)r[c].grouping_type===s[o].grouping_type&&(l.description=r[c],l.description.used=!0);if(n)for(let c=0;c<n.length;c++)n[c].grouping_type===s[o].grouping_type&&(l.fragment_description=n[c],l.fragment_description.used=!0,l.is_fragment=!0)}if(t){if(n){for(let o=0;o<n.length;o++)if(!n[o].used&&n[o].version>=2){const a=n[o].grouping_type+"/0",l=new dr(n[o].grouping_type,0);l.is_fragment=!0,t.sample_groups_info[a]||(t.sample_groups_info[a]=l)}}}else for(let o=0;o<r.length;o++)if(!r[o].used&&r[o].version>=2){const a=r[o].grouping_type+"/0",l=new dr(r[o].grouping_type,0);e.sample_groups_info[a]||(e.sample_groups_info[a]=l)}}static setSampleGroupProperties(e,t,s,r){t.sample_groups=[];for(const n in r)if(t.sample_groups[n]={grouping_type:r[n].grouping_type,grouping_type_parameter:r[n].grouping_type_parameter},s>=r[n].last_sample_in_run&&(r[n].last_sample_in_run<0&&(r[n].last_sample_in_run=0),r[n].entry_index++,r[n].entry_index<=r[n].sbgp.entries.length-1&&(r[n].last_sample_in_run+=r[n].sbgp.entries[r[n].entry_index].sample_count)),r[n].entry_index<=r[n].sbgp.entries.length-1?t.sample_groups[n].group_description_index=r[n].sbgp.entries[r[n].entry_index].group_description_index:t.sample_groups[n].group_description_index=-1,t.sample_groups[n].group_description_index!==0){let o;if(r[n].fragment_description?o=r[n].fragment_description:o=r[n].description,t.sample_groups[n].group_description_index>0){let a;t.sample_groups[n].group_description_index>65535?a=(t.sample_groups[n].group_description_index>>16)-1:a=t.sample_groups[n].group_description_index-1,o&&a>=0&&(t.sample_groups[n].description=o.entries[a])}else o&&o.version>=2&&o.default_group_description_index>0&&(t.sample_groups[n].description=o.entries[o.default_group_description_index-1])}}static process_sdtp(e,t,s){t&&(e?(t.is_leading=e.is_leading[s],t.depends_on=e.sample_depends_on[s],t.is_depended_on=e.sample_is_depended_on[s],t.has_redundancy=e.sample_has_redundancy[s]):(t.is_leading=0,t.depends_on=0,t.is_depended_on=0,t.has_redundancy=0))}buildSampleLists(){for(let e=0;e<this.moov.traks.length;e++)this.buildTrakSampleLists(this.moov.traks[e])}buildTrakSampleLists(e){let t,s,r,n,o,a;e.samples=[],e.samples_duration=0,e.samples_size=0;const l=e.mdia.minf.stbl.stco||e.mdia.minf.stbl.co64,c=e.mdia.minf.stbl.stsc,h=e.mdia.minf.stbl.stsz||e.mdia.minf.stbl.stz2,u=e.mdia.minf.stbl.stts,d=e.mdia.minf.stbl.ctts,f=e.mdia.minf.stbl.stss,m=e.mdia.minf.stbl.stsd,g=e.mdia.minf.stbl.subs,p=e.mdia.minf.stbl.stdp,_=e.mdia.minf.stbl.sbgps,x=e.mdia.minf.stbl.sgpds;let v=-1,y=-1,T=-1,S=-1,w=0,E=0,P=0;if(si.initSampleGroups(e,void 0,_,x),!(typeof h>"u")){for(t=0;t<h.sample_sizes.length;t++){const C={number:t,track_id:e.tkhd.track_id,timescale:e.mdia.mdhd.timescale,alreadyRead:0,size:h.sample_sizes[t]};e.samples[t]=C,e.samples_size+=C.size,t===0?(r=1,s=0,C.chunk_index=r,C.chunk_run_index=s,a=c.samples_per_chunk[s],o=0,s+1<c.first_chunk.length?n=c.first_chunk[s+1]-1:n=1/0):t<a?(C.chunk_index=r,C.chunk_run_index=s):(r++,C.chunk_index=r,o=0,r<=n||(s++,s+1<c.first_chunk.length?n=c.first_chunk[s+1]-1:n=1/0),C.chunk_run_index=s,a+=c.samples_per_chunk[s]),C.description_index=c.sample_description_index[C.chunk_run_index]-1,C.description=m.entries[C.description_index],C.offset=l.chunk_offsets[C.chunk_index-1]+o,o+=C.size,t>v&&(y++,v<0&&(v=0),v+=u.sample_counts[y]),t>0?(e.samples[t-1].duration=u.sample_deltas[y],e.samples_duration+=e.samples[t-1].duration,C.dts=e.samples[t-1].dts+e.samples[t-1].duration):C.dts=0,d?(t>=T&&(S++,T<0&&(T=0),T+=d.sample_counts[S]),C.cts=e.samples[t].dts+d.sample_offsets[S]):C.cts=C.dts,f?(t===f.sample_numbers[w]-1?(C.is_sync=!0,w++):(C.is_sync=!1,C.degradation_priority=0),g&&g.entries[E].sample_delta+P===t+1&&(C.subsamples=g.entries[E].subsamples,P+=g.entries[E].sample_delta,E++)):C.is_sync=!0,si.process_sdtp(e.mdia.minf.stbl.sdtp,C,C.number),p?C.degradation_priority=p.priority[t]:C.degradation_priority=0,g&&g.entries[E].sample_delta+P===t&&(C.subsamples=g.entries[E].subsamples,P+=g.entries[E].sample_delta),(_.length>0||x.length>0)&&si.setSampleGroupProperties(e,C,t,e.sample_groups_info)}t>0&&(e.samples[t-1].duration=Math.max(e.mdia.mdhd.duration-e.samples[t-1].dts,0),e.samples_duration+=e.samples[t-1].duration)}}updateSampleLists(){let e,t,s,r,n;if(this.moov!==void 0)for(;this.lastMoofIndex<this.moofs.length;){const o=this.moofs[this.lastMoofIndex];if(this.lastMoofIndex++,o.type==="moof"){const a=o;for(let l=0;l<a.trafs.length;l++){const c=a.trafs[l],h=this.getTrackById(c.tfhd.track_id),u=this.getTrexById(c.tfhd.track_id);c.tfhd.flags&Zs?e=c.tfhd.default_sample_description_index:e=u?u.default_sample_description_index:1,c.tfhd.flags&Js?t=c.tfhd.default_sample_duration:t=u?u.default_sample_duration:0,c.tfhd.flags&Qs?s=c.tfhd.default_sample_size:s=u?u.default_sample_size:0,c.tfhd.flags&er?r=c.tfhd.default_sample_flags:r=u?u.default_sample_flags:0,c.sample_number=0,c.sbgps.length>0&&si.initSampleGroups(h,c,c.sbgps,h.mdia.minf.stbl.sgpds,c.sgpds);for(let d=0;d<c.truns.length;d++){const f=c.truns[d];for(let m=0;m<f.sample_count;m++){const g=e-1;let p=r;f.flags&ss?p=f.sample_flags[m]:m===0&&f.flags&tr&&(p=f.first_sample_flags);let _=s;f.flags&is&&(_=f.sample_size[m]),h.samples_size+=_;let x=t;f.flags&ts&&(x=f.sample_duration[m]),h.samples_duration+=x;let v;h.first_traf_merged||m>0?v=h.samples[h.samples.length-1].dts+h.samples[h.samples.length-1].duration:(c.tfdt?v=c.tfdt.baseMediaDecodeTime:v=0,h.first_traf_merged=!0);let y=v;f.flags&rs&&(y=v+f.sample_composition_time_offset[m]);const T=!!(c.tfhd.flags&js),S=!!(c.tfhd.flags&_f),w=!!(f.flags&es);let E=0;T?E=c.tfhd.base_data_offset:S||d===0?E=a.start:E=n;let P;d===0&&m===0?w?P=E+f.data_offset:P=E:P=n,n=P+_;const C=c.sample_number;c.sample_number++;const A={cts:y,description_index:g,description:h.mdia.minf.stbl.stsd.entries[g],dts:v,duration:x,moof_number:this.lastMoofIndex,number_in_traf:C,number:h.samples.length,offset:P,size:_,timescale:h.mdia.mdhd.timescale,track_id:h.tkhd.track_id,is_sync:!(p>>16&1),is_leading:p>>26&3,depends_on:p>>24&3,is_depended_on:p>>22&3,has_redundancy:p>>20&3,degradation_priority:p&65535};c.first_sample_index=h.samples.length,h.samples.push(A),(c.sbgps.length>0||c.sgpds.length>0||h.mdia.minf.stbl.sbgps.length>0||h.mdia.minf.stbl.sgpds.length>0)&&si.setSampleGroupProperties(h,A,A.number_in_traf,c.sample_groups_info)}}if(c.subs){h.has_fragment_subsamples=!0;let d=c.first_sample_index;for(let f=0;f<c.subs.entries.length;f++){d+=c.subs.entries[f].sample_delta;const m=h.samples[d-1];m.subsamples=c.subs.entries[f].subsamples}}}}}}getSample(e,t){const s=e.samples[t];if(this.moov){if(!s.data)s.data=new Uint8Array(s.size),s.alreadyRead=0,this.samplesDataSize+=s.size,I.debug("ISOFile","Allocating sample #"+t+" on track #"+e.tkhd.track_id+" of size "+s.size+" (total: "+this.samplesDataSize+")");else if(s.alreadyRead===s.size)return s;for(;;){let r=this.stream,n=r.findPosition(!0,s.offset+s.alreadyRead,!1),o,a;if(n>-1)o=r.buffers[n],a=o.fileStart;else for(const l of this.mdats){if(!l.stream){I.debug("ISOFile","mdat stream not yet fully read for #"+this.mdats.indexOf(l)+" mdat");continue}if(n=l.stream.findPosition(!0,s.offset+s.alreadyRead-l.start-l.hdr_size,!1),n>-1){r=l.stream,o=l.stream.buffers[n],a=l.start+l.hdr_size+o.fileStart;break}}if(o){const l=o.byteLength-(s.offset+s.alreadyRead-a);if(s.size-s.alreadyRead<=l)return I.debug("ISOFile","Getting sample #"+t+" data (alreadyRead: "+s.alreadyRead+" offset: "+(s.offset+s.alreadyRead-a)+" read size: "+(s.size-s.alreadyRead)+" full size: "+s.size+")"),Pe.memcpy(s.data.buffer,s.alreadyRead,o,s.offset+s.alreadyRead-a,s.size-s.alreadyRead),o.usedBytes+=s.size-s.alreadyRead,r.logBufferLevel(),s.alreadyRead=s.size,s;if(l===0)return;I.debug("ISOFile","Getting sample #"+t+" partial data (alreadyRead: "+s.alreadyRead+" offset: "+(s.offset+s.alreadyRead-a)+" read size: "+l+" full size: "+s.size+")"),Pe.memcpy(s.data.buffer,s.alreadyRead,o,s.offset+s.alreadyRead-a,l),s.alreadyRead+=l,o.usedBytes+=l,r.logBufferLevel()}else return}}}releaseSample(e,t){const s=e.samples[t];return s.data?(this.samplesDataSize-=s.size,s.data=void 0,s.alreadyRead=0,s.size):0}getAllocatedSampleDataSize(){return this.samplesDataSize}getCodecs(){let e="";for(let t=0;t<this.moov.traks.length;t++){const s=this.moov.traks[t];t>0&&(e+=","),e+=s.mdia.minf.stbl.stsd.entries[0].getCodec()}return e}getTrexById(e){if(!(!this.moov||!this.moov.mvex))for(let t=0;t<this.moov.mvex.trexs.length;t++){const s=this.moov.mvex.trexs[t];if(s.track_id===e)return s}}getTrackById(e){if(this.moov)for(let t=0;t<this.moov.traks.length;t++){const s=this.moov.traks[t];if(s.tkhd.track_id===e)return s}}flattenItemInfo(){const e=this.items,t=this.entity_groups,s=this.meta;if(!(!s||!s.hdlr||!s.iinf)){for(let r=0;r<s.iinf.item_infos.length;r++){const n=s.iinf.item_infos[r].item_ID;e[n]={id:n,name:s.iinf.item_infos[r].item_name,ref_to:[],content_type:s.iinf.item_infos[r].content_type,content_encoding:s.iinf.item_infos[r].content_encoding,item_uri_type:s.iinf.item_infos[r].item_uri_type,type:s.iinf.item_infos[r].item_type?s.iinf.item_infos[r].item_type:"mime",protection:s.iinf.item_infos[r].item_protection_index>0?s.ipro.protections[s.iinf.item_infos[r].item_protection_index-1]:void 0}}if(s.grpl)for(let r=0;r<s.grpl.boxes.length;r++){const n=s.grpl.boxes[r];t[n.group_id]={id:n.group_id,entity_ids:n.entity_ids,type:n.type}}if(s.iloc)for(let r=0;r<s.iloc.items.length;r++){const n=s.iloc.items[r],o=e[n.item_ID];n.data_reference_index!==0&&(I.warn("Item storage with reference to other files: not supported"),o.source=s.dinf.boxes[n.data_reference_index-1]),o.extents=[],o.size=0;for(let a=0;a<n.extents.length;a++)o.extents[a]={offset:n.extents[a].extent_offset+n.base_offset,length:n.extents[a].extent_length,alreadyRead:0},n.construction_method===1&&(o.extents[a].offset+=s.idat.start+s.idat.hdr_size),o.size+=o.extents[a].length}if(s.pitm&&(e[s.pitm.item_id].primary=!0),s.iref)for(let r=0;r<s.iref.references.length;r++){const n=s.iref.references[r];for(let o=0;o<n.references.length;o++)e[n.from_item_ID].ref_to.push({type:n.type,id:n.references[o]})}if(s.iprp)for(let r=0;r<s.iprp.ipmas.length;r++){const n=s.iprp.ipmas[r];for(let o=0;o<n.associations.length;o++){const a=n.associations[o],l=e[a.id]??t[a.id];if(l){l.properties===void 0&&(l.properties={boxes:[]});for(let c=0;c<a.props.length;c++){const h=a.props[c];if(h.property_index>0&&h.property_index-1<s.iprp.ipco.boxes.length){const u=s.iprp.ipco.boxes[h.property_index-1];l.properties[u.type]=u,l.properties.boxes.push(u)}}}}}}}getItem(e){if(!this.meta)return;const t=this.items[e];if(!t.data&&t.size)t.data=new Uint8Array(t.size),t.alreadyRead=0,this.itemsDataSize+=t.size,I.debug("ISOFile","Allocating item #"+e+" of size "+t.size+" (total: "+this.itemsDataSize+")");else if(t.alreadyRead===t.size)return t;for(let s=0;s<t.extents.length;s++){const r=t.extents[s];if(r.alreadyRead!==r.length){const n=this.stream.findPosition(!0,r.offset+r.alreadyRead,!1);if(n>-1){const o=this.stream.buffers[n],a=o.byteLength-(r.offset+r.alreadyRead-o.fileStart);if(r.length-r.alreadyRead<=a)I.debug("ISOFile","Getting item #"+e+" extent #"+s+" data (alreadyRead: "+r.alreadyRead+" offset: "+(r.offset+r.alreadyRead-o.fileStart)+" read size: "+(r.length-r.alreadyRead)+" full extent size: "+r.length+" full item size: "+t.size+")"),Pe.memcpy(t.data.buffer,t.alreadyRead,o,r.offset+r.alreadyRead-o.fileStart,r.length-r.alreadyRead),(!this.parsingMdat||this.discardMdatData)&&(o.usedBytes+=r.length-r.alreadyRead),this.stream.logBufferLevel(),t.alreadyRead+=r.length-r.alreadyRead,r.alreadyRead=r.length;else{I.debug("ISOFile","Getting item #"+e+" extent #"+s+" partial data (alreadyRead: "+r.alreadyRead+" offset: "+(r.offset+r.alreadyRead-o.fileStart)+" read size: "+a+" full extent size: "+r.length+" full item size: "+t.size+")"),Pe.memcpy(t.data.buffer,t.alreadyRead,o,r.offset+r.alreadyRead-o.fileStart,a),r.alreadyRead+=a,t.alreadyRead+=a,(!this.parsingMdat||this.discardMdatData)&&(o.usedBytes+=a),this.stream.logBufferLevel();return}}else return}}if(t.alreadyRead===t.size)return t}releaseItem(e){const t=this.items[e];if(t.data){this.itemsDataSize-=t.size,t.data=void 0,t.alreadyRead=0;for(let s=0;s<t.extents.length;s++){const r=t.extents[s];r.alreadyRead=0}return t.size}else return 0}processItems(e){for(const t in this.items){const s=this.items[t];this.getItem(s.id),e&&!s.sent&&(e(s),s.sent=!0,s.data=void 0)}}hasItem(e){for(const t in this.items){const s=this.items[t];if(s.name===e)return s.id}return-1}getMetaHandler(){if(this.meta)return this.meta.hdlr.handler}getPrimaryItem(){if(this.meta&&this.meta.pitm)return this.getItem(this.meta.pitm.item_id)}itemToFragmentedTrackFile({itemId:e}={}){let t;if(e?t=this.getItem(e):t=this.getPrimaryItem(),!t)return;const s=new si;s.discardMdatData=!1;const r={type:t.type,description_boxes:t.properties.boxes};t.properties.ispe&&(r.width=t.properties.ispe.image_width,r.height=t.properties.ispe.image_height);const n=s.addTrack(r);if(n)return s.addSample(n,t.data),s}processIncompleteBox(e){if(e.type==="mdat"){const t=new lr(e.size);return this.parsingMdat=t,this.boxes.push(t),this.mdats.push(t),t.start=e.start,t.hdr_size=e.hdr_size,t.original_size=e.original_size,this.stream.addUsedBytes(t.hdr_size),this.lastBoxStartPosition=t.start+t.size,this.stream.seek(t.start+t.size,!1,this.discardMdatData)?(this.transferMdatData(),this.parsingMdat=void 0,!0):(this.moovStartFound?this.nextParsePosition=this.stream.findEndContiguousBuf():this.nextParsePosition=t.start+t.size,!1)}else return e.type==="moov"&&(this.moovStartFound=!0,this.mdats.length===0&&(this.isProgressive=!0)),this.stream.mergeNextBuffer&&this.stream.mergeNextBuffer()?(this.nextParsePosition=this.stream.getEndPosition(),!0):(e.type?this.moovStartFound?this.nextParsePosition=this.stream.getEndPosition():this.nextParsePosition=this.stream.getPosition()+e.size:this.nextParsePosition=this.stream.getEndPosition(),!1)}hasIncompleteMdat(){return this.parsingMdat!==void 0}transferMdatData(e){const t=e??this.parsingMdat;if(this.discardMdatData){I.debug("ISOFile","Discarding 'mdat' data, not transferring it to the mdat box stream");return}if(!t){I.warn("ISOFile","Cannot transfer 'mdat' data, no mdat box is being parsed");return}const s=this.stream.findPosition(!0,t.start+t.hdr_size,!1),r=this.stream.findPosition(!0,t.start+t.size,!1);if(s===-1||r===-1){I.warn("ISOFile","Cannot transfer 'mdat' data, start or end buffer not found");return}t.stream=new Ti;for(let n=s;n<=r;n++){const o=this.stream.buffers[n],a=n===s?t.start+t.hdr_size-o.fileStart:0,l=n===r?t.start+t.size-o.fileStart:o.byteLength;if(l>a){I.debug("ISOFile","Transferring 'mdat' data from buffer #"+n+" ("+a+" to "+l+")");const c=l-a,h=new yt(c),u=t.stream.getAbsoluteEndPosition();Pe.memcpy(h,0,o,a,c),h.fileStart=u,t.stream.insertBuffer(h),o.usedBytes+=c}}}processIncompleteMdat(){const e=this.parsingMdat;return this.stream.seek(e.start+e.size,!1,this.discardMdatData)?(I.debug("ISOFile","Found 'mdat' end in buffered data"),this.transferMdatData(),this.parsingMdat=void 0,!0):(this.nextParsePosition=this.stream.findEndContiguousBuf(),!1)}restoreParsePosition(){return this.stream.seek(this.lastBoxStartPosition,!0,this.discardMdatData)}saveParsePosition(){this.lastBoxStartPosition=this.stream.getPosition()}updateUsedBytes(e,t){this.stream.addUsedBytes&&(e.type==="mdat"?(this.stream.addUsedBytes(e.hdr_size),this.discardMdatData&&this.stream.addUsedBytes(e.size-e.hdr_size)):this.stream.addUsedBytes(e.size))}addBox(e){return U.prototype.addBox.call(this,e)}init(e={}){const t=this.addBox(new Wf);t.major_brand=e.brands&&e.brands[0]||"iso4",t.minor_version=0,t.compatible_brands=e.brands||["iso4"];const s=this.addBox(new Hn);s.addBox(new jn);const r=s.addBox(new Kf);return r.timescale=e.timescale||600,r.rate=e.rate||65536,r.creation_time=0,r.modification_time=0,r.duration=e.duration||0,r.volume=e.width?0:256,r.matrix=[65536,0,0,0,65536,0,0,0,1073741824],r.next_track_id=1,this}addTrack(e={}){this.moov||this.init(e);const t=e||{};t.width=t.width||320,t.height=t.height||320,t.id=t.id||this.moov.mvhd.next_track_id,t.type=t.type||"avc1";const s=this.moov.addBox(new Uf);this.moov.mvhd.next_track_id=t.id+1;const r=s.addBox(new lp);r.flags=vv|yv|bv,r.creation_time=0,r.modification_time=0,r.track_id=t.id,r.duration=t.duration||0,r.layer=t.layer||0,r.alternate_group=0,r.volume=1,r.matrix=[65536,0,0,0,65536,0,0,0,1073741824],r.width=t.width<<16,r.height=t.height<<16;const n=s.addBox(new Bf),o=n.addBox(new Xf);o.creation_time=0,o.modification_time=0,o.timescale=t.timescale||1,o.duration=t.media_duration||0,o.language=t.language||"und";const a=n.addBox(new Vf);a.handler=t.hdlr||"vide",a.name=t.name||"Track created with MP4Box.js";const l=n.addBox(new Hf);l.extended_language=t.language||"fr-FR";const c=n.addBox(new Of),h=$e.sampleEntry[t.type];if(!h)return;const u=new h;if(u.data_reference_index=1,u instanceof fe){const y=u,T=c.addBox(new up);T.graphicsmode=0,T.opcolor=[0,0,0],y.width=t.width,y.height=t.height,y.horizresolution=72<<16,y.vertresolution=72<<16,y.frame_count=1,y.compressorname=t.type+" Compressor",y.depth=24,t.avcDecoderConfigRecord?y.addBox(new Mf(t.avcDecoderConfigRecord.byteLength)).parse(new Pe(t.avcDecoderConfigRecord)):t.hevcDecoderConfigRecord&&y.addBox(new $f(t.hevcDecoderConfigRecord.byteLength)).parse(new Pe(t.hevcDecoderConfigRecord))}else if(u instanceof Le){const y=u,T=c.addBox(new Qf);T.balance=t.balance||0,y.channel_count=t.channel_count||2,y.samplesize=t.samplesize||16,y.samplerate=t.samplerate||65536}else u instanceof Pn?c.addBox(new Ff):u instanceof Xt?(c.addBox(new tp),u instanceof Jf&&(u.namespace=t.namespace||"nonamespace",u.schema_location=t.schema_location||"",u.auxiliary_mime_types=t.auxiliary_mime_types||"")):u instanceof ni?c.addBox(new cr):u instanceof ar?c.addBox(new cr):c.addBox(new cr);t.description&&u.addBox.call(u,t.description),t.description_boxes&&t.description_boxes.forEach(function(y){u.addBox.call(u,y)});const d=c.addBox(new Df).addBox(new Nf),f=new hp;f.flags=1,d.addEntry(f);const m=c.addBox(new Gf);m.addBox(new sp).addEntry(u);const g=m.addBox(new np);g.sample_counts=[],g.sample_deltas=[];const p=m.addBox(new ip);p.first_chunk=[],p.samples_per_chunk=[],p.sample_description_index=[];const _=m.addBox(new ep);_.chunk_offsets=[];const x=m.addBox(new rp);x.sample_sizes=[];const v=this.moov.mvex.addBox(new Za);return v.track_id=t.id,v.default_sample_description_index=t.default_sample_description_index||1,v.default_sample_duration=t.default_sample_duration||0,v.default_sample_size=t.default_sample_size||0,v.default_sample_flags=t.default_sample_flags||0,this.buildTrakSampleLists(s),t.id}addSample(e,t,{sample_description_index:s,duration:r=1,cts:n=0,dts:o=0,is_sync:a=!1,is_leading:l=0,depends_on:c=0,is_depended_on:h=0,has_redundancy:u=0,degradation_priority:d=0,subsamples:f,offset:m=0}={}){const g=this.getTrackById(e);if(g===void 0)return;const p=s?s-1:0,_={number:g.samples.length,track_id:g.tkhd.track_id,timescale:g.mdia.mdhd.timescale,description_index:p,description:g.mdia.minf.stbl.stsd.entries[p],data:t,size:t.byteLength,alreadyRead:t.byteLength,duration:r,cts:n,dts:o,is_sync:a,is_leading:l,depends_on:c,is_depended_on:h,has_redundancy:u,degradation_priority:d,offset:m,subsamples:f};g.samples.push(_),g.samples_size+=_.size,g.samples_duration+=_.duration,g.first_dts===void 0&&(g.first_dts=o),this.processSamples();const x=this.addBox(this.createMoof([_]));x.computeSize(),x.trafs[0].truns[0].data_offset=x.size+8;const v=this.addBox(new lr);return v.data=new Uint8Array(t),_}createMoof(e){if(e.length===0)return;if(e.some(h=>h.track_id!==e[0].track_id))throw new Error("Cannot create moof for samples from different tracks: "+e.map(h=>h.track_id).join(", "));const t=e[0].track_id,s=this.getTrackById(t);if(!s)throw new Error("Cannot create moof for non-existing track: "+t);const r=new zf,n=r.addBox(new qf);n.sequence_number=++this.nextMoofNumber;const o=r.addBox(new Lf),a=o.addBox(new ap);a.track_id=t,a.flags=_f;const l=o.addBox(new op);l.baseMediaDecodeTime=e[0].dts-(s.first_dts||0);const c=o.addBox(new cp);c.flags=es|ts|is|ss|rs,c.data_offset=0,c.first_sample_flags=0,c.sample_count=e.length;for(const h of e){let u=0;h.is_sync?u=1<<25:u=65536,c.sample_duration.push(h.duration),c.sample_size.push(h.size),c.sample_flags.push(u),c.sample_composition_time_offset.push(h.cts-h.dts)}return r}print(e){e.indent="";for(let t=0;t<this.boxes.length;t++)this.boxes[t]&&this.boxes[t].print(e)}};function fp(i=!1,e){return new dp(e,!i)}var pp={};gf(pp,{Descriptor:()=>Yt,ES_Descriptor:()=>il,MPEG4DescriptorParser:()=>_p});var mp=3,fr=4,tl=5,gp=6,Yt=class Vx{constructor(e,t){this.tag=e,this.size=t,this.descs=[]}parse(e){this.data=e.readUint8Array(this.size)}findDescriptor(e){for(let t=0;t<this.descs.length;t++)if(this.descs[t].tag===e)return this.descs[t]}parseOneDescriptor(e){let t=0;const s=e.readUint8();let r=e.readUint8();for(;r&128;)t=(t<<7)+(r&127),r=e.readUint8();t=(t<<7)+(r&127),I.debug("Descriptor","Found "+(pr[s]||"Descriptor "+s)+", size "+t+" at position "+e.getPosition());const n=pr[s]?new xb[pr[s]](t):new Vx(t);return n.parse(e),n}parseRemainingDescriptors(e){const t=e.getPosition();for(;e.getPosition()<t+this.size;){const s=this.parseOneDescriptor?.(e);this.descs.push(s)}}},il=class extends Yt{constructor(i){super(mp,i)}parse(i){if(this.ES_ID=i.readUint16(),this.flags=i.readUint8(),this.size-=3,this.flags&128?(this.dependsOn_ES_ID=i.readUint16(),this.size-=2):this.dependsOn_ES_ID=0,this.flags&64){const e=i.readUint8();this.URL=i.readString(e),this.size-=e+1}else this.URL="";this.flags&32?(this.OCR_ES_ID=i.readUint16(),this.size-=2):this.OCR_ES_ID=0,this.parseRemainingDescriptors(i)}getOTI(){const i=this.findDescriptor(fr);return i?i.oti:0}getAudioConfig(){const i=this.findDescriptor(fr);if(!i)return;const e=i.findDescriptor(tl);if(e&&e.data){let t=(e.data[0]&248)>>3;return t===31&&e.data.length>=2&&(t=32+((e.data[0]&7)<<3)+((e.data[1]&224)>>5)),t}}},mb=class extends Yt{constructor(i){super(fr,i)}parse(i){this.oti=i.readUint8(),this.streamType=i.readUint8(),this.upStream=(this.streamType>>1&1)!==0,this.streamType=this.streamType>>>2,this.bufferSize=i.readUint24(),this.maxBitrate=i.readUint32(),this.avgBitrate=i.readUint32(),this.size-=13,this.parseRemainingDescriptors(i)}},gb=class extends Yt{constructor(i){super(tl,i)}},_b=class extends Yt{constructor(i){super(gp,i)}},xb={Descriptor:Yt,ES_Descriptor:il,DecoderConfigDescriptor:mb,DecoderSpecificInfo:gb,SLConfigDescriptor:_b},pr={[mp]:"ES_Descriptor",[fr]:"DecoderConfigDescriptor",[tl]:"DecoderSpecificInfo",[gp]:"SLConfigDescriptor"},_p=class{constructor(){this.parseOneDescriptor=Yt.prototype.parseOneDescriptor}getDescriptorName(i){return pr[i]}},vb=class{parseSample(i){const e=[],t=new Ti(yt.fromArrayBuffer(i.buffer,0));for(;!t.isEof();){const s=dt(t,!1);s.code===Ve&&s.box?.type==="vttc"&&e.push(s.box)}return e}getText(i,e,t){function s(a,l){const c=a.toString();return c.length>=l?c:new Array(l-c.length+1).join("0")+c}function r(a){const l=Math.floor(a/3600),c=Math.floor((a-l*3600)/60),h=Math.floor(a-l*3600-c*60),u=Math.floor((a-l*3600-c*60-h)*1e3);return""+s(l,2)+":"+s(c,2)+":"+s(h,2)+"."+s(u,3)}const n=this.parseSample(t);let o="";for(let a=0;a<n.length;a++){const l=n[a];o+=r(i)+" --> "+r(e)+`\r
`,o+=l.payl.text}return o}},yb=class{parseSample(i){const e={resources:[],documentString:"",document:void 0},t=new Pe(i.data.buffer);if(!i.subsamples||i.subsamples.length===0)e.documentString=t.readString(i.data.length);else if(e.documentString=t.readString(i.subsamples[0].size),i.subsamples.length>1)for(let s=1;s<i.subsamples.length;s++)e.resources[s]=t.readUint8Array(i.subsamples[s].size);return typeof DOMParser<"u"&&(e.document=new DOMParser().parseFromString(e.documentString,"application/xml")),e}},bb=class{parseSample(i){return new Pe(i.data.buffer).readString(i.data.length)}parseConfig(i){const e=new Pe(i.buffer);return e.readUint32(),e.readCString()}},Tb=class{parseSample(i){const e=new Pe(i.data.buffer),t=e.readUint16();if(t!==0)return e.readString(t)}},xp={};gf(xp,{CoLLBox:()=>Bb,ItemContentIDPropertyBox:()=>h1,OpusSampleEntry:()=>Yy,SmDmBox:()=>aT,a1lxBox:()=>wb,a1opBox:()=>Sb,ac_3SampleEntry:()=>Vy,ac_4SampleEntry:()=>$y,aebrBox:()=>Qb,afbrBox:()=>e2,albcBox:()=>t2,alstSampleGroupEntry:()=>zT,altrBox:()=>i2,auxCBox:()=>Cb,av01SampleEntry:()=>vy,av1CBox:()=>hy,avc1SampleEntry:()=>my,avc2SampleEntry:()=>gy,avc3SampleEntry:()=>_y,avc4SampleEntry:()=>xy,avcCBox:()=>Mf,avllSampleGroupEntry:()=>LT,avs3SampleEntry:()=>Oy,avssSampleGroupEntry:()=>NT,brstBox:()=>s2,btrtBox:()=>Ab,bxmlBox:()=>Uv,ccstBox:()=>Eb,cdefBox:()=>Ib,clapBox:()=>Pb,clefBox:()=>$2,clliBox:()=>Rb,cmexBox:()=>kb,cminBox:()=>Mb,cmpdBox:()=>Fb,co64Box:()=>Ub,colrBox:()=>py,coviBox:()=>Gb,cprtBox:()=>zb,cschBox:()=>Lb,cslgBox:()=>Nb,cttsBox:()=>Hb,dOpsBox:()=>Kb,dac3Box:()=>Wb,dataBox:()=>as,dav1SampleEntry:()=>yy,dec3Box:()=>Vb,dfLaBox:()=>$b,dimmBox:()=>Xb,dinfBox:()=>Df,dmax:()=>Yb,dmedBox:()=>qb,dobrBox:()=>r2,drefBox:()=>Nf,drepBox:()=>jb,dtrtSampleGroupEntry:()=>HT,dvh1SampleEntry:()=>Iy,dvheSampleEntry:()=>Py,ec_3SampleEntry:()=>Xy,edtsBox:()=>Ov,elngBox:()=>Hf,elstBox:()=>Zb,emsgBox:()=>Jb,encaSampleEntry:()=>eb,encmSampleEntry:()=>nb,encsSampleEntry:()=>ib,enctSampleEntry:()=>rb,encuSampleEntry:()=>tb,encvSampleEntry:()=>Qy,enofBox:()=>Y2,eqivBox:()=>n2,esdsBox:()=>uy,etypBox:()=>Qv,fLaCSampleEntry:()=>Jy,favcBox:()=>o2,fielBox:()=>g2,fobrBox:()=>a2,freeBox:()=>Rv,frmaBox:()=>_2,ftypBox:()=>Wf,grplBox:()=>Zv,hdlrBox:()=>Vf,hev1SampleEntry:()=>wy,hev2SampleEntry:()=>Sy,hinfBox:()=>Nv,hmhdBox:()=>Ff,hntiBox:()=>Lv,hvc1SampleEntry:()=>by,hvc2SampleEntry:()=>Ty,hvcCBox:()=>$f,hvt1SampleEntry:()=>Cy,iaugBox:()=>l2,idatBox:()=>Pv,iinfBox:()=>iy,ilocBox:()=>sy,ilstBox:()=>q2,imirBox:()=>x2,infeBox:()=>ty,iodsBox:()=>Mv,ipcoBox:()=>jv,ipmaBox:()=>v2,iproBox:()=>Bv,iprpBox:()=>Kv,irefBox:()=>ny,irotBox:()=>y2,ispeBox:()=>b2,itaiBox:()=>T2,j2kHBox:()=>Jv,j2kiSampleEntry:()=>Dy,keysBox:()=>K2,kindBox:()=>w2,levaBox:()=>S2,lhe1SampleEntry:()=>Ay,lhv1SampleEntry:()=>Ey,lhvCBox:()=>C2,lselBox:()=>A2,m4aeSampleEntry:()=>Wy,maxrBox:()=>E2,mdatBox:()=>lr,mdcvBox:()=>I2,mdhdBox:()=>Xf,mdiaBox:()=>Bf,mecoBox:()=>zv,mehdBox:()=>Yf,metaBox:()=>ay,mettSampleEntry:()=>ly,metxSampleEntry:()=>cy,mfhdBox:()=>qf,mfraBox:()=>Gv,mfroBox:()=>P2,mha1SampleEntry:()=>qy,mha2SampleEntry:()=>Ky,mhm1SampleEntry:()=>jy,mhm2SampleEntry:()=>Zy,minfBox:()=>Of,mjp2SampleEntry:()=>Gy,mjpgSampleEntry:()=>zy,moofBox:()=>zf,moovBox:()=>Hn,mp4aSampleEntry:()=>Hy,mp4sSampleEntry:()=>sb,mp4vSampleEntry:()=>Ny,mskCBox:()=>R2,msrcTrackGroupTypeBox:()=>ET,mvexBox:()=>jn,mvhdBox:()=>Kf,mvifSampleGroupEntry:()=>WT,nmhdBox:()=>cr,npckBox:()=>k2,numpBox:()=>M2,padbBox:()=>U2,panoBox:()=>c2,paspBox:()=>B2,paylBox:()=>O2,paytBox:()=>D2,pdinBox:()=>G2,piffLsmBox:()=>r1,piffPsshBox:()=>n1,piffSencBox:()=>o1,piffTencBox:()=>a1,piffTfrfBox:()=>l1,piffTfxdBox:()=>c1,pitmBox:()=>oy,pixiBox:()=>z2,pmaxBox:()=>L2,povdBox:()=>ey,prdiBox:()=>N2,prfrBox:()=>H2,prftBox:()=>W2,prgrBox:()=>p2,profBox:()=>j2,prolSampleGroupEntry:()=>VT,psshBox:()=>V2,pymdBox:()=>m2,rapSampleGroupEntry:()=>$T,rashSampleGroupEntry:()=>XT,resvSampleEntry:()=>ob,rinfBox:()=>$v,rollSampleGroupEntry:()=>YT,rtp_Box:()=>Q2,saioBox:()=>eT,saizBox:()=>tT,sbgpBox:()=>ub,sbpmBox:()=>sT,sbttSampleEntry:()=>ab,schiBox:()=>Xv,schmBox:()=>rT,scifSampleGroupEntry:()=>qT,scnmSampleGroupEntry:()=>KT,sdp_Box:()=>nT,sdtpBox:()=>db,seigSampleGroupEntry:()=>jT,sencBox:()=>oT,sgpdBox:()=>fb,sidxBox:()=>pb,sinfBox:()=>Vv,skipBox:()=>kv,slidBox:()=>h2,smhdBox:()=>Qf,sratBox:()=>lT,ssixBox:()=>cT,stblBox:()=>Gf,stcoBox:()=>ep,stdpBox:()=>hT,sterBox:()=>u2,sthdBox:()=>tp,stppSampleEntry:()=>Jf,strdBox:()=>Wv,striBox:()=>uT,strkBox:()=>Hv,stsaSampleGroupEntry:()=>ZT,stscBox:()=>ip,stsdBox:()=>sp,stsgBox:()=>dT,stshBox:()=>fT,stssBox:()=>pT,stszBox:()=>rp,sttsBox:()=>np,stviBox:()=>mT,stxtSampleEntry:()=>lb,stypBox:()=>gT,stz2Box:()=>_T,subsBox:()=>xT,syncSampleGroupEntry:()=>JT,taicBox:()=>vT,taptBox:()=>Z2,teleSampleGroupEntry:()=>QT,tencBox:()=>yT,tfdtBox:()=>op,tfhdBox:()=>ap,tfraBox:()=>bT,tkhdBox:()=>lp,tmaxBox:()=>TT,tminBox:()=>wT,totlBox:()=>ST,tpayBox:()=>CT,tpylBox:()=>AT,trafBox:()=>Lf,trakBox:()=>Uf,trefBox:()=>IT,trepBox:()=>PT,trexBox:()=>Za,trgrBox:()=>Yv,trpyBox:()=>RT,trunBox:()=>cp,tsasSampleGroupEntry:()=>e1,tsclSampleGroupEntry:()=>t1,tselBox:()=>kT,tsynBox:()=>d2,tx3gSampleEntry:()=>cb,txtcBox:()=>MT,tycoBox:()=>FT,udesBox:()=>UT,udtaBox:()=>qv,uncCBox:()=>BT,uncvSampleEntry:()=>Ly,urlBox:()=>hp,urnBox:()=>OT,viprSampleGroupEntry:()=>i1,vmhdBox:()=>up,vp08SampleEntry:()=>Uy,vp09SampleEntry:()=>By,vpcCBox:()=>dy,vttCBox:()=>DT,vttcBox:()=>Dv,vvc1SampleEntry:()=>Ry,vvcCBox:()=>fy,vvcNSampleEntry:()=>Fy,vvi1SampleEntry:()=>ky,vvnCBox:()=>GT,vvs1SampleEntry:()=>My,waveBox:()=>J2,wbbrBox:()=>f2,wvttSampleEntry:()=>hb,xmlBox:()=>Fv});var sl,wb=(sl=class extends U{constructor(){super(...arguments),this.box_name="AV1LayeredImageIndexingProperty"}parse(i){const e=((i.readUint8()&1&1)+1)*16;this.layer_size=[];for(let t=0;t<3;t++)e===16?this.layer_size[t]=i.readUint16():this.layer_size[t]=i.readUint32()}},sl.fourcc="a1lx",sl),rl,Sb=(rl=class extends U{constructor(){super(...arguments),this.box_name="OperatingPointSelectorProperty"}parse(i){this.op_index=i.readUint8()}},rl.fourcc="a1op",rl),nl,Cb=(nl=class extends R{constructor(){super(...arguments),this.box_name="AuxiliaryTypeProperty"}parse(i){this.parseFullHeader(i),this.aux_type=i.readCString();const e=this.size-this.hdr_size-(this.aux_type.length+1);this.aux_subtype=i.readUint8Array(e)}},nl.fourcc="auxC",nl),ol,Ab=(ol=class extends U{constructor(){super(...arguments),this.box_name="BitRateBox"}parse(i){this.bufferSizeDB=i.readUint32(),this.maxBitrate=i.readUint32(),this.avgBitrate=i.readUint32()}},ol.fourcc="btrt",ol),al,Eb=(al=class extends R{constructor(){super(...arguments),this.box_name="CodingConstraintsBox"}parse(i){this.parseFullHeader(i);const e=i.readUint8();this.all_ref_pics_intra=(e&128)===128,this.intra_pred_used=(e&64)===64,this.max_ref_per_pic=(e&63)>>2,i.readUint24()}},al.fourcc="ccst",al),ll,Ib=(ll=class extends U{constructor(){super(...arguments),this.box_name="ComponentDefinitionBox"}parse(i){this.channel_count=i.readUint16(),this.channel_indexes=[],this.channel_types=[],this.channel_associations=[];for(let e=0;e<this.channel_count;e++)this.channel_indexes.push(i.readUint16()),this.channel_types.push(i.readUint16()),this.channel_associations.push(i.readUint16())}},ll.fourcc="cdef",ll),cl,Pb=(cl=class extends U{constructor(){super(...arguments),this.box_name="CleanApertureBox"}parse(i){this.cleanApertureWidthN=i.readUint32(),this.cleanApertureWidthD=i.readUint32(),this.cleanApertureHeightN=i.readUint32(),this.cleanApertureHeightD=i.readUint32(),this.horizOffN=i.readUint32(),this.horizOffD=i.readUint32(),this.vertOffN=i.readUint32(),this.vertOffD=i.readUint32()}},cl.fourcc="clap",cl),hl,Rb=(hl=class extends U{constructor(){super(...arguments),this.box_name="ContentLightLevelBox"}parse(i){this.max_content_light_level=i.readUint16(),this.max_pic_average_light_level=i.readUint16()}},hl.fourcc="clli",hl),ul,kb=(ul=class extends U{constructor(){super(...arguments),this.box_name="CameraExtrinsicMatrixProperty"}parse(i){this.flags&1&&(this.pos_x=i.readInt32()),this.flags&2&&(this.pos_y=i.readInt32()),this.flags&4&&(this.pos_z=i.readInt32()),this.flags&8&&(this.version===0?this.flags&16?(this.quat_x=i.readInt32(),this.quat_y=i.readInt32(),this.quat_z=i.readInt32()):(this.quat_x=i.readInt16(),this.quat_y=i.readInt16(),this.quat_z=i.readInt16()):this.version),this.flags&32&&(this.id=i.readUint32())}},ul.fourcc="cmex",ul),dl,Mb=(dl=class extends U{constructor(){super(...arguments),this.box_name="CameraIntrinsicMatrixProperty"}parse(i){this.focal_length_x=i.readInt32(),this.principal_point_x=i.readInt32(),this.principal_point_y=i.readInt32(),this.flags&1&&(this.focal_length_y=i.readInt32(),this.skew_factor=i.readInt32())}},dl.fourcc="cmin",dl),fl,Fb=(fl=class extends U{constructor(){super(...arguments),this.box_name="ComponentDefinitionBox"}parse(i){this.component_count=i.readUint32(),this.component_types=[],this.component_type_urls=[];for(let e=0;e<this.component_count;e++){const t=i.readUint16();this.component_types.push(t),t>=32768&&this.component_type_urls.push(i.readCString())}}},fl.fourcc="cmpd",fl),pl,Ub=(pl=class extends R{constructor(){super(...arguments),this.box_name="ChunkLargeOffsetBox"}parse(i){this.parseFullHeader(i);const e=i.readUint32();if(this.chunk_offsets=[],this.version===0)for(let t=0;t<e;t++)this.chunk_offsets.push(i.readUint64())}write(i){this.version=0,this.flags=0,this.size=4+8*this.chunk_offsets.length,this.writeHeader(i),i.writeUint32(this.chunk_offsets.length);for(let e=0;e<this.chunk_offsets.length;e++)i.writeUint64(this.chunk_offsets[e])}},pl.fourcc="co64",pl),ml,Bb=(ml=class extends R{constructor(){super(...arguments),this.box_name="ContentLightLevelBox"}parse(i){this.parseFullHeader(i),this.maxCLL=i.readUint16(),this.maxFALL=i.readUint16()}},ml.fourcc="CoLL",ml),Ob=class{toString(){let i="centre_azimuth: ";return i+=this.centre_azimuth,i+=" (",i+=this.centre_azimuth*2**-16,i+="), centre_elevation: ",i+=this.centre_elevation,i+=" (",i+=this.centre_elevation*2**-16,i+="), centre_tilt: ",i+=this.centre_tilt,i+=" (",i+=this.centre_tilt*2**-16,i+=")",this.range_included_flag&&(i+=", azimuth_range: ",i+=this.azimuth_range,i+=" (",i+=this.azimuth_range*2**-16,i+="), elevation_range: ",i+=this.elevation_range,i+=" (",i+=this.elevation_range*2**-16,i+=")"),this.interpolate_included_flag&&(i+=", interpolate: ",i+=this.interpolate),i}},Db=class{toString(){let i="";return this.view_idc&&(i+="view_idc: ",i+=this.view_idc,i+=", "),i+="sphere_region: {",i+=this.sphere_region,i+="}",i}},gl,Gb=(gl=class extends R{constructor(){super(...arguments),this.box_name="CoverageInformationBox"}parse(i){this.parseFullHeader(i),this.coverage_shape_type=i.readUint8();const e=i.readUint8(),t=i.readInt8(),s=t&128;s&&(this.default_view_idc=(t&96)>>5),this.coverage_regions=new Array;for(let r=0;r<e;r++){const n=new Db;s&&(n.view_idc=i.readUint8()>>6),n.sphere_region=this.parseSphereRegion(i,!0,!0),this.coverage_regions.push(n)}}parseSphereRegion(i,e,t){const s=new Ob;return s.centre_azimuth=i.readInt32(),s.centre_elevation=i.readInt32(),s.centre_tilt=i.readInt32(),s.range_included_flag=e,e&&(s.azimuth_range=i.readUint32(),s.elevation_range=i.readUint32()),s.interpolate_included_flag=t,t&&(s.interpolate=(i.readUint8()&128)===128),s}},gl.fourcc="covi",gl),_l,zb=(_l=class extends R{constructor(){super(...arguments),this.box_name="CopyrightBox"}parse(i){this.parseFullHeader(i),this.parseLanguage(i),this.notice=i.readCString()}},_l.fourcc="cprt",_l),xl,Lb=(xl=class extends R{constructor(){super(...arguments),this.box_name="CompatibleSchemeTypeBox"}parse(i){this.parseFullHeader(i),this.scheme_type=i.readString(4),this.scheme_version=i.readUint32(),this.flags&1&&(this.scheme_uri=i.readCString())}},xl.fourcc="csch",xl),os=2147483647,vl,Nb=(vl=class extends R{constructor(){super(...arguments),this.box_name="CompositionToDecodeBox"}parse(i){this.parseFullHeader(i),this.version===0?(this.compositionToDTSShift=i.readInt32(),this.leastDecodeToDisplayDelta=i.readInt32(),this.greatestDecodeToDisplayDelta=i.readInt32(),this.compositionStartTime=i.readInt32(),this.compositionEndTime=i.readInt32()):this.version===1&&(this.compositionToDTSShift=i.readInt64(),this.leastDecodeToDisplayDelta=i.readInt64(),this.greatestDecodeToDisplayDelta=i.readInt64(),this.compositionStartTime=i.readInt64(),this.compositionEndTime=i.readInt64())}write(i){this.version=0,(this.compositionToDTSShift>os||this.leastDecodeToDisplayDelta>os||this.greatestDecodeToDisplayDelta>os||this.compositionStartTime>os||this.compositionEndTime>os)&&(this.version=1),this.flags=0,this.version===0?(this.size=20,this.writeHeader(i),i.writeInt32(this.compositionToDTSShift),i.writeInt32(this.leastDecodeToDisplayDelta),i.writeInt32(this.greatestDecodeToDisplayDelta),i.writeInt32(this.compositionStartTime),i.writeInt32(this.compositionEndTime)):this.version===1&&(this.size=40,this.writeHeader(i),i.writeInt64(this.compositionToDTSShift),i.writeInt64(this.leastDecodeToDisplayDelta),i.writeInt64(this.greatestDecodeToDisplayDelta),i.writeInt64(this.compositionStartTime),i.writeInt64(this.compositionEndTime))}},vl.fourcc="cslg",vl),yl,Hb=(yl=class extends R{constructor(){super(...arguments),this.box_name="CompositionOffsetBox"}parse(i){this.parseFullHeader(i);const e=i.readUint32();if(this.sample_counts=[],this.sample_offsets=[],this.version===0)for(let t=0;t<e;t++){this.sample_counts.push(i.readUint32());const s=i.readInt32();s<0&&I.warn("BoxParser","ctts box uses negative values without using version 1"),this.sample_offsets.push(s)}else if(this.version===1)for(let t=0;t<e;t++)this.sample_counts.push(i.readUint32()),this.sample_offsets.push(i.readInt32())}write(i){this.version=this.sample_offsets.some(e=>e<0)?1:0,this.flags=0,this.size=4+8*this.sample_counts.length,this.writeHeader(i),i.writeUint32(this.sample_counts.length);for(let e=0;e<this.sample_counts.length;e++)i.writeUint32(this.sample_counts[e]),this.version===1?i.writeInt32(this.sample_offsets[e]):i.writeUint32(this.sample_offsets[e])}unpack(i){let e=0;for(let t=0;t<this.sample_counts.length;t++)for(let s=0;s<this.sample_counts[t];s++)i[e].pts=i[e].dts+this.sample_offsets[t],e++}},yl.fourcc="ctts",yl),bl,Wb=(bl=class extends U{constructor(){super(...arguments),this.box_name="AC3SpecificBox"}parse(i){const e=i.readUint8(),t=i.readUint8(),s=i.readUint8();this.fscod=e>>6,this.bsid=e>>1&31,this.bsmod=(e&1)<<2|t>>6&3,this.acmod=t>>3&7,this.lfeon=t>>2&1,this.bit_rate_code=t&3|s>>5&7}},bl.fourcc="dac3",bl),Tl,Vb=(Tl=class extends U{constructor(){super(...arguments),this.box_name="EC3SpecificBox"}parse(i){const e=i.readUint16();this.data_rate=e>>3,this.num_ind_sub=e&7,this.ind_subs=[];for(let t=0;t<this.num_ind_sub+1;t++){const s=i.readUint8(),r=i.readUint8(),n=i.readUint8(),o={fscod:s>>6,bsid:s>>1&31,bsmod:(s&1)<<4|r>>4&15,acmod:r>>1&7,lfeon:r&1,num_dep_sub:n>>1&15};this.ind_subs.push(o),o.num_dep_sub>0&&(o.chan_loc=(n&1)<<8|i.readUint8())}}},Tl.fourcc="dec3",Tl),wl,$b=(wl=class extends R{constructor(){super(...arguments),this.box_name="FLACSpecificBox"}parse(i){this.parseFullHeader(i);const e=127,t=128,s=[],r=["STREAMINFO","PADDING","APPLICATION","SEEKTABLE","VORBIS_COMMENT","CUESHEET","PICTURE","RESERVED"];let n;do{n=i.readUint8();const o=Math.min(n&e,r.length-1);o?i.readUint8Array(i.readUint24()):(i.readUint8Array(13),this.samplerate=i.readUint32()>>12,i.readUint8Array(20)),s.push(r[o])}while(n&t);this.numMetadataBlocks=s.length+" ("+s.join(", ")+")"}},wl.fourcc="dfLa",wl),Sl,Xb=(Sl=class extends U{constructor(){super(...arguments),this.box_name="hintimmediateBytesSent"}parse(i){this.bytessent=i.readUint64()}},Sl.fourcc="dimm",Sl),Cl,Yb=(Cl=class extends U{constructor(){super(...arguments),this.box_name="hintlongestpacket"}parse(i){this.time=i.readUint32()}},Cl.fourcc="dmax",Cl),Al,qb=(Al=class extends U{constructor(){super(...arguments),this.box_name="hintmediaBytesSent"}parse(i){this.bytessent=i.readUint64()}},Al.fourcc="dmed",Al),El,Kb=(El=class extends U{constructor(){super(...arguments),this.box_name="OpusSpecificBox"}parse(i){if(this.Version=i.readUint8(),this.OutputChannelCount=i.readUint8(),this.PreSkip=i.readUint16(),this.InputSampleRate=i.readUint32(),this.OutputGain=i.readInt16(),this.ChannelMappingFamily=i.readUint8(),this.ChannelMappingFamily!==0){this.StreamCount=i.readUint8(),this.CoupledCount=i.readUint8(),this.ChannelMapping=[];for(let e=0;e<this.OutputChannelCount;e++)this.ChannelMapping[e]=i.readUint8()}}write(i){if(this.size=11,this.ChannelMappingFamily!==0&&(this.size+=2+this.OutputChannelCount),this.writeHeader(i),i.writeUint8(this.Version),i.writeUint8(this.OutputChannelCount),i.writeUint16(this.PreSkip),i.writeUint32(this.InputSampleRate),i.writeInt16(this.OutputGain),i.writeUint8(this.ChannelMappingFamily),this.ChannelMappingFamily!==0){i.writeUint8(this.StreamCount),i.writeUint8(this.CoupledCount);for(let e=0;e<this.OutputChannelCount;e++)i.writeUint8(this.ChannelMapping[e])}}},El.fourcc="dOps",El),Il,jb=(Il=class extends U{constructor(){super(...arguments),this.box_name="hintrepeatedBytesSent"}parse(i){this.bytessent=i.readUint64()}},Il.fourcc="drep",Il),Pl,Zb=(Pl=class extends R{constructor(){super(...arguments),this.box_name="EditListBox"}parse(i){this.parseFullHeader(i),this.entries=[];const e=i.readUint32();for(let t=0;t<e;t++){const s={segment_duration:this.version===1?i.readUint64():i.readUint32(),media_time:this.version===1?i.readInt64():i.readInt32(),media_rate_integer:i.readInt16(),media_rate_fraction:i.readInt16()};this.entries.push(s)}}write(i){const e=this.entries.some(t=>t.segment_duration>Ae||t.media_time>Ae)||this.version===1;this.version=e?1:0,this.size=4+12*this.entries.length,this.size+=e?8*this.entries.length:0,this.writeHeader(i),i.writeUint32(this.entries.length);for(let t=0;t<this.entries.length;t++){const s=this.entries[t];e?(i.writeUint64(s.segment_duration),i.writeInt64(s.media_time)):(i.writeUint32(s.segment_duration),i.writeInt32(s.media_time)),i.writeInt16(s.media_rate_integer),i.writeInt16(s.media_rate_fraction)}}},Pl.fourcc="elst",Pl),Rl,Jb=(Rl=class extends R{constructor(){super(...arguments),this.box_name="EventMessageBox"}parse(i){this.parseFullHeader(i),this.version===1?(this.timescale=i.readUint32(),this.presentation_time=i.readUint64(),this.event_duration=i.readUint32(),this.id=i.readUint32(),this.scheme_id_uri=i.readCString(),this.value=i.readCString()):(this.scheme_id_uri=i.readCString(),this.value=i.readCString(),this.timescale=i.readUint32(),this.presentation_time_delta=i.readUint32(),this.event_duration=i.readUint32(),this.id=i.readUint32());let e=this.size-this.hdr_size-(16+(this.scheme_id_uri.length+1)+(this.value.length+1));this.version===1&&(e-=4),this.message_data=i.readUint8Array(e)}write(i){this.version=0,this.flags=0,this.size=16+this.message_data.length+(this.scheme_id_uri.length+1)+(this.value.length+1),this.writeHeader(i),i.writeCString(this.scheme_id_uri),i.writeCString(this.value),i.writeUint32(this.timescale),i.writeUint32(this.presentation_time_delta),i.writeUint32(this.event_duration),i.writeUint32(this.id),i.writeUint8Array(this.message_data)}},Rl.fourcc="emsg",Rl),Me=class extends R{parse(e){this.parseFullHeader(e),this.group_id=e.readUint32(),this.num_entities_in_group=e.readUint32(),this.entity_ids=[];for(let t=0;t<this.num_entities_in_group;t++){const s=e.readUint32();this.entity_ids.push(s)}}},kl,Qb=(kl=class extends Me{constructor(){super(...arguments),this.box_name="Auto exposure bracketing"}},kl.fourcc="aebr",kl),Ml,e2=(Ml=class extends Me{constructor(){super(...arguments),this.box_name="Flash exposure information"}},Ml.fourcc="afbr",Ml),Fl,t2=(Fl=class extends Me{constructor(){super(...arguments),this.box_name="Album collection"}},Fl.fourcc="albc",Fl),Ul,i2=(Ul=class extends Me{constructor(){super(...arguments),this.box_name="Alternative entity"}},Ul.fourcc="altr",Ul),Bl,s2=(Bl=class extends Me{constructor(){super(...arguments),this.box_name="Burst image"}},Bl.fourcc="brst",Bl),Ol,r2=(Ol=class extends Me{constructor(){super(...arguments),this.box_name="Depth of field bracketing"}},Ol.fourcc="dobr",Ol),Dl,n2=(Dl=class extends Me{constructor(){super(...arguments),this.box_name="Equivalent entity"}},Dl.fourcc="eqiv",Dl),Gl,o2=(Gl=class extends Me{constructor(){super(...arguments),this.box_name="Favorites collection"}},Gl.fourcc="favc",Gl),zl,a2=(zl=class extends Me{constructor(){super(...arguments),this.box_name="Focus bracketing"}},zl.fourcc="fobr",zl),Ll,l2=(Ll=class extends Me{constructor(){super(...arguments),this.box_name="Image item with an audio track"}},Ll.fourcc="iaug",Ll),Nl,c2=(Nl=class extends Me{constructor(){super(...arguments),this.box_name="Panorama"}},Nl.fourcc="pano",Nl),Hl,h2=(Hl=class extends Me{constructor(){super(...arguments),this.box_name="Slideshow"}},Hl.fourcc="slid",Hl),Wl,u2=(Wl=class extends Me{constructor(){super(...arguments),this.box_name="Stereo"}},Wl.fourcc="ster",Wl),Vl,d2=(Vl=class extends Me{constructor(){super(...arguments),this.box_name="Time-synchronized capture"}},Vl.fourcc="tsyn",Vl),$l,f2=($l=class extends Me{constructor(){super(...arguments),this.box_name="White balance bracketing"}},$l.fourcc="wbbr",$l),Xl,p2=(Xl=class extends Me{constructor(){super(...arguments),this.box_name="Progressive rendering"}},Xl.fourcc="prgr",Xl),Yl,m2=(Yl=class extends Me{constructor(){super(...arguments),this.box_name="Image pyramid"}parse(i){this.parseFullHeader(i),this.group_id=i.readUint32(),this.num_entities_in_group=i.readUint32(),this.entity_ids=[];for(let e=0;e<this.num_entities_in_group;e++){const t=i.readUint32();this.entity_ids.push(t)}this.tile_size_x=i.readUint16(),this.tile_size_y=i.readUint16(),this.layer_binning=[],this.tiles_in_layer_column_minus1=[],this.tiles_in_layer_row_minus1=[];for(let e=0;e<this.num_entities_in_group;e++)this.layer_binning[e]=i.readUint16(),this.tiles_in_layer_row_minus1[e]=i.readUint16(),this.tiles_in_layer_column_minus1[e]=i.readUint16()}},Yl.fourcc="pymd",Yl),ql,g2=(ql=class extends U{constructor(){super(...arguments),this.box_name="FieldHandlingBox"}parse(i){this.fieldCount=i.readUint8(),this.fieldOrdering=i.readUint8()}},ql.fourcc="fiel",ql),Kl,_2=(Kl=class extends U{constructor(){super(...arguments),this.box_name="OriginalFormatBox"}parse(i){this.data_format=i.readString(4)}},Kl.fourcc="frma",Kl),jl,x2=(jl=class extends U{constructor(){super(...arguments),this.box_name="ImageMirror"}parse(i){const e=i.readUint8();this.reserved=e>>7,this.axis=e&1}},jl.fourcc="imir",jl),Zl,v2=(Zl=class extends R{constructor(){super(...arguments),this.box_name="ItemPropertyAssociationBox"}parse(i){this.parseFullHeader(i);const e=i.readUint32();this.associations=[];for(let t=0;t<e;t++){const s=this.version<1?i.readUint16():i.readUint32(),r=[],n=i.readUint8();for(let o=0;o<n;o++){const a=i.readUint8();r.push({essential:(a&128)>>7===1,property_index:this.flags&1?(a&127)<<8|i.readUint8():a&127})}this.associations.push({id:s,props:r})}}},Zl.fourcc="ipma",Zl),Jl,y2=(Jl=class extends U{constructor(){super(...arguments),this.box_name="ImageRotation"}parse(i){this.angle=i.readUint8()&3}},Jl.fourcc="irot",Jl),Ql,b2=(Ql=class extends R{constructor(){super(...arguments),this.box_name="ImageSpatialExtentsProperty"}parse(i){this.parseFullHeader(i),this.image_width=i.readUint32(),this.image_height=i.readUint32()}},Ql.fourcc="ispe",Ql),ec,T2=(ec=class extends R{constructor(){super(...arguments),this.box_name="TAITimestampBox"}parse(i){this.TAI_timestamp=i.readUint64();const e=i.readUint8();this.sychronization_state=e>>7&1,this.timestamp_generation_failure=e>>6&1,this.timestamp_is_modified=e>>5&1}},ec.fourcc="itai",ec),tc,w2=(tc=class extends R{constructor(){super(...arguments),this.box_name="KindBox"}parse(i){this.parseFullHeader(i),this.schemeURI=i.readCString(),this.isEndOfBox(i)||(this.value=i.readCString())}write(i){this.version=0,this.flags=0,this.size=this.schemeURI.length+1+(this.value?this.value.length+1:0),this.writeHeader(i),i.writeCString(this.schemeURI),this.value&&i.writeCString(this.value)}},tc.fourcc="kind",tc),ic,S2=(ic=class extends R{constructor(){super(...arguments),this.box_name="LevelAssignmentBox"}parse(i){this.parseFullHeader(i);const e=i.readUint8();this.levels=[];for(let t=0;t<e;t++){const s={};this.levels[t]=s,s.track_ID=i.readUint32();const r=i.readUint8();switch(s.padding_flag=r>>7,s.assignment_type=r&127,s.assignment_type){case 0:s.grouping_type=i.readString(4);break;case 1:s.grouping_type=i.readString(4),s.grouping_type_parameter=i.readUint32();break;case 2:break;case 3:break;case 4:s.sub_track_id=i.readUint32();break;default:I.warn("BoxParser",`Unknown level assignment type: ${s.assignment_type}`)}}}},ic.fourcc="leva",ic),sc,C2=(sc=class extends U{constructor(){super(...arguments),this.box_name="LHEVCConfigurationBox"}parse(i){this.configurationVersion=i.readUint8(),this.min_spatial_segmentation_idc=i.readUint16()&4095,this.parallelismType=i.readUint8()&3;let e=i.readUint8();this.numTemporalLayers=(e&13)>>3,this.temporalIdNested=(e&4)>>2,this.lengthSizeMinusOne=e&3,this.nalu_arrays=[];const t=i.readUint8();for(let s=0;s<t;s++){const r=[];this.nalu_arrays.push(r),e=i.readUint8(),r.completeness=(e&128)>>7,r.nalu_type=e&63;const n=i.readUint16();for(let o=0;o<n;o++){const a=i.readUint16();r.push({data:i.readUint8Array(a)})}}}},sc.fourcc="lhvC",sc),rc,A2=(rc=class extends U{constructor(){super(...arguments),this.box_name="LayerSelectorProperty"}parse(i){this.layer_id=i.readUint16()}},rc.fourcc="lsel",rc),nc,E2=(nc=class extends U{constructor(){super(...arguments),this.box_name="hintmaxrate"}parse(i){this.period=i.readUint32(),this.bytes=i.readUint32()}},nc.fourcc="maxr",nc),mr=class{constructor(i,e){this.x=i,this.y=e}toString(){return"("+this.x+","+this.y+")"}},oc,I2=(oc=class extends U{constructor(){super(...arguments),this.box_name="MasteringDisplayColourVolumeBox"}parse(i){this.display_primaries=[],this.display_primaries[0]=new mr(i.readUint16(),i.readUint16()),this.display_primaries[1]=new mr(i.readUint16(),i.readUint16()),this.display_primaries[2]=new mr(i.readUint16(),i.readUint16()),this.white_point=new mr(i.readUint16(),i.readUint16()),this.max_display_mastering_luminance=i.readUint32(),this.min_display_mastering_luminance=i.readUint32()}},oc.fourcc="mdcv",oc),ac,P2=(ac=class extends R{constructor(){super(...arguments),this.box_name="MovieFragmentRandomAccessOffsetBox"}parse(i){this.parseFullHeader(i),this._size=i.readUint32()}},ac.fourcc="mfro",ac),lc,R2=(lc=class extends R{constructor(){super(...arguments),this.box_name="MaskConfigurationProperty"}parse(i){this.parseFullHeader(i),this.bits_per_pixel=i.readUint8()}},lc.fourcc="mskC",lc),cc,k2=(cc=class extends U{constructor(){super(...arguments),this.box_name="hintPacketsSent"}parse(i){this.packetssent=i.readUint32()}},cc.fourcc="npck",cc),hc,M2=(hc=class extends U{constructor(){super(...arguments),this.box_name="hintPacketsSent"}parse(i){this.packetssent=i.readUint64()}},hc.fourcc="nump",hc),F2=class{constructor(i,e){this.pad1=i,this.pad2=e}},uc,U2=(uc=class extends R{constructor(){super(...arguments),this.box_name="PaddingBitsBox"}parse(i){this.parseFullHeader(i);const e=i.readUint32();this.padbits=[];for(let t=0;t<Math.floor((e+1)/2);t++){const s=i.readUint8(),r=(s&112)>>4,n=s&7;this.padbits.push(new F2(r,n))}}},uc.fourcc="padb",uc),dc,B2=(dc=class extends U{constructor(){super(...arguments),this.box_name="PixelAspectRatioBox"}parse(i){this.hSpacing=i.readUint32(),this.vSpacing=i.readUint32()}},dc.fourcc="pasp",dc),fc,O2=(fc=class extends U{constructor(){super(...arguments),this.box_name="CuePayloadBox"}parse(i){this.text=i.readString(this.size-this.hdr_size)}},fc.fourcc="payl",fc),pc,D2=(pc=class extends U{constructor(){super(...arguments),this.box_name="hintpayloadID"}parse(i){this.payloadID=i.readUint32();const e=i.readUint8();this.rtpmap_string=i.readString(e)}},pc.fourcc="payt",pc),mc,G2=(mc=class extends R{constructor(){super(...arguments),this.box_name="ProgressiveDownloadInfoBox",this.rate=[],this.initial_delay=[]}parse(i){this.parseFullHeader(i);const e=(this.size-this.hdr_size)/8;for(let t=0;t<e;t++)this.rate[t]=i.readUint32(),this.initial_delay[t]=i.readUint32()}},mc.fourcc="pdin",mc),gc,z2=(gc=class extends R{constructor(){super(...arguments),this.box_name="PixelInformationProperty"}parse(i){this.parseFullHeader(i),this.num_channels=i.readUint8(),this.bits_per_channels=[];for(let e=0;e<this.num_channels;e++)this.bits_per_channels[e]=i.readUint8()}},gc.fourcc="pixi",gc),_c,L2=(_c=class extends U{constructor(){super(...arguments),this.box_name="hintlargestpacket"}parse(i){this.bytes=i.readUint32()}},_c.fourcc="pmax",_c),xc,N2=(xc=class extends R{constructor(){super(...arguments),this.box_name="ProgressiveDerivedImageItemInformationProperty"}parse(i){if(this.parseFullHeader(i),this.step_count=i.readUint16(),this.item_count=[],this.flags&2)for(let e=0;e<this.step_count;e++)this.item_count[e]=i.readUint16()}},xc.fourcc="prdi",xc),vc,H2=(vc=class extends R{constructor(){super(...arguments),this.box_name="ProjectionFormatBox"}parse(i){this.parseFullHeader(i),this.projection_type=i.readUint8()&31}},vc.fourcc="prfr",vc),yc,W2=(yc=class extends R{constructor(){super(...arguments),this.box_name="ProducerReferenceTimeBox"}parse(i){this.parseFullHeader(i),this.ref_track_id=i.readUint32(),this.ntp_timestamp=i.readUint64(),this.version===0?this.media_time=i.readUint32():this.media_time=i.readUint64()}},yc.fourcc="prft",yc),bc,V2=(bc=class extends R{constructor(){super(...arguments),this.box_name="ProtectionSystemSpecificHeaderBox"}parse(i){if(this.parseFullHeader(i),this.system_id=ri(i),this.kid=[],this.version>0){const t=i.readUint32();for(let s=0;s<t;s++)this.kid[s]=ri(i)}const e=i.readUint32();e>0&&(this.protection_data=i.readUint8Array(e))}},bc.fourcc="pssh",bc),Tc,$2=(Tc=class extends R{constructor(){super(...arguments),this.box_name="TrackCleanApertureDimensionsBox"}parse(i){this.parseFullHeader(i),this.width=i.readUint32(),this.height=i.readUint32()}},Tc.fourcc="clef",Tc);function X2(i,e){if(i===as.Types.UTF8)return new TextDecoder("utf-8").decode(e);const t=new DataView(e.buffer);if(i===as.Types.BE_UNSIGNED_INT){if(e.length===1)return t.getUint8(0);if(e.length===2)return t.getUint16(0,!1);if(e.length===4)return t.getUint32(0,!1);if(e.length===8)return t.getBigUint64(0,!1);throw new Error("Unsupported ITIF_TYPE_BE_UNSIGNED_INT length "+e.length)}else if(i===as.Types.BE_SIGNED_INT){if(e.length===1)return t.getInt8(0);if(e.length===2)return t.getInt16(0,!1);if(e.length===4)return t.getInt32(0,!1);if(e.length===8)return t.getBigInt64(0,!1);throw new Error("Unsupported ITIF_TYPE_BE_SIGNED_INT length "+e.length)}else if(i===as.Types.BE_FLOAT32)return t.getFloat32(0,!1);I.warn("DataBox","Unsupported or unimplemented itif data type: "+i)}var gr,as=(gr=class extends U{constructor(){super(...arguments),this.box_name="DataBox"}parse(i){this.valueType=i.readUint32(),this.country=i.readUint16(),this.country>255&&(i.seek(i.getPosition()-2),this.countryString=i.readString(2)),this.language=i.readUint16(),this.language>255&&(i.seek(i.getPosition()-2),this.parseLanguage(i)),this.raw=i.readUint8Array(this.size-this.hdr_size-8),this.value=X2(this.valueType,this.raw)}},gr.fourcc="data",gr.Types={RESERVED:0,UTF8:1,UTF16:2,SJIS:3,UTF8_SORT:4,UTF16_SORT:5,JPEG:13,PNG:14,BE_SIGNED_INT:21,BE_UNSIGNED_INT:22,BE_FLOAT32:23,BE_FLOAT64:24,BMP:27,QT_ATOM:28,BE_SIGNED_INT8:65,BE_SIGNED_INT16:66,BE_SIGNED_INT32:67,BE_FLOAT32_POINT:70,BE_FLOAT32_DIMENSIONS:71,BE_FLOAT32_RECT:72,BE_SIGNED_INT64:74,BE_UNSIGNED_INT8:75,BE_UNSIGNED_INT16:76,BE_UNSIGNED_INT32:77,BE_UNSIGNED_INT64:78,BE_FLOAT64_AFFINE_TRANSFORM:79},gr),wc,Y2=(wc=class extends R{constructor(){super(...arguments),this.box_name="TrackEncodedPixelsDimensionsBox"}parse(i){this.parseFullHeader(i),this.width=i.readUint32(),this.height=i.readUint32()}},wc.fourcc="enof",wc),Sc,q2=(Sc=class extends U{constructor(){super(...arguments),this.box_name="IlstBox"}parse(i){this.list={};let e=this.size-this.hdr_size;for(;e>0;){const t=i.readUint32(),s=i.readUint32(),r=dt(i,!1,t-8);r.code===Ve&&(this.list[s]=r.box),e-=t}}},Sc.fourcc="ilst",Sc),Cc,K2=(Cc=class extends R{constructor(){super(...arguments),this.box_name="KeysBox"}parse(i){this.parseFullHeader(i),this.count=i.readUint32(),this.keys={};for(let e=0;e<this.count;e++){const t=i.readUint32();this.keys[e+1]=i.readString(t-4)}}},Cc.fourcc="keys",Cc),Ac,j2=(Ac=class extends R{constructor(){super(...arguments),this.box_name="TrackProductionApertureDimensionsBox"}parse(i){this.parseFullHeader(i),this.width=i.readUint32(),this.height=i.readUint32()}},Ac.fourcc="prof",Ac),Ec,Z2=(Ec=class extends Q{constructor(){super(...arguments),this.box_name="TrackApertureModeDimensionsBox",this.clefs=[],this.profs=[],this.enofs=[],this.subBoxNames=["clef","prof","enof"]}},Ec.fourcc="tapt",Ec),Ic,J2=(Ic=class extends Q{constructor(){super(...arguments),this.box_name="siDecompressionParamBox"}},Ic.fourcc="wave",Ic),Pc,Q2=(Pc=class extends U{constructor(){super(...arguments),this.box_name="rtpmoviehintinformation"}parse(i){this.descriptionformat=i.readString(4),this.sdptext=i.readString(this.size-this.hdr_size-4)}},Pc.fourcc="rtp ",Pc),Rc,eT=(Rc=class extends R{constructor(){super(...arguments),this.box_name="SampleAuxiliaryInformationOffsetsBox"}parse(i){this.parseFullHeader(i),this.flags&1&&(this.aux_info_type=i.readString(4),this.aux_info_type_parameter=i.readUint32());const e=i.readUint32();this.offset=[];for(let t=0;t<e;t++)this.version===0?this.offset[t]=i.readUint32():this.offset[t]=i.readUint64()}},Rc.fourcc="saio",Rc),kc,tT=(kc=class extends R{constructor(){super(...arguments),this.box_name="SampleAuxiliaryInformationSizesBox"}parse(i){if(this.parseFullHeader(i),this.flags&1&&(this.aux_info_type=i.readString(4),this.aux_info_type_parameter=i.readUint32()),this.default_sample_info_size=i.readUint8(),this.sample_count=i.readUint32(),this.sample_info_size=[],this.default_sample_info_size===0)for(let e=0;e<this.sample_count;e++)this.sample_info_size[e]=i.readUint8()}},kc.fourcc="saiz",kc),iT=class{constructor(i,e){this.bad_pixel_row=i,this.bad_pixel_column=e}toString(){return"[row: "+this.bad_pixel_row+", column: "+this.bad_pixel_column+"]"}},Mc,sT=(Mc=class extends R{constructor(){super(...arguments),this.box_name="SensorBadPixelsMapBox"}parse(i){this.parseFullHeader(i),this.component_count=i.readUint16(),this.component_index=[];for(let t=0;t<this.component_count;t++)this.component_index.push(i.readUint16());const e=i.readUint8();this.correction_applied=(e&128)===128,this.num_bad_rows=i.readUint32(),this.num_bad_cols=i.readUint32(),this.num_bad_pixels=i.readUint32(),this.bad_rows=[],this.bad_columns=[],this.bad_pixels=[];for(let t=0;t<this.num_bad_rows;t++)this.bad_rows.push(i.readUint32());for(let t=0;t<this.num_bad_cols;t++)this.bad_columns.push(i.readUint32());for(let t=0;t<this.num_bad_pixels;t++){const s=i.readUint32(),r=i.readUint32();this.bad_pixels.push(new iT(s,r))}}},Mc.fourcc="sbpm",Mc),Fc,rT=(Fc=class extends R{constructor(){super(...arguments),this.box_name="SchemeTypeBox"}parse(i){this.parseFullHeader(i),this.scheme_type=i.readString(4),this.scheme_version=i.readUint32(),this.flags&1&&(this.scheme_uri=i.readString(this.size-this.hdr_size-8))}},Fc.fourcc="schm",Fc),Uc,nT=(Uc=class extends U{constructor(){super(...arguments),this.box_name="rtptracksdphintinformation"}parse(i){this.sdptext=i.readString(this.size-this.hdr_size)}},Uc.fourcc="sdp ",Uc),Bc,oT=(Bc=class extends R{constructor(){super(...arguments),this.box_name="SampleEncryptionBox"}},Bc.fourcc="senc",Bc),Oc,aT=(Oc=class extends R{constructor(){super(...arguments),this.box_name="SMPTE2086MasteringDisplayMetadataBox"}parse(i){this.parseFullHeader(i),this.primaryRChromaticity_x=i.readUint16(),this.primaryRChromaticity_y=i.readUint16(),this.primaryGChromaticity_x=i.readUint16(),this.primaryGChromaticity_y=i.readUint16(),this.primaryBChromaticity_x=i.readUint16(),this.primaryBChromaticity_y=i.readUint16(),this.whitePointChromaticity_x=i.readUint16(),this.whitePointChromaticity_y=i.readUint16(),this.luminanceMax=i.readUint32(),this.luminanceMin=i.readUint32()}},Oc.fourcc="SmDm",Oc),Dc,lT=(Dc=class extends R{constructor(){super(...arguments),this.box_name="SamplingRateBox"}parse(i){this.parseFullHeader(i),this.sampling_rate=i.readUint32()}},Dc.fourcc="srat",Dc),Gc,cT=(Gc=class extends R{constructor(){super(...arguments),this.box_name="CompressedSubsegmentIndexBox"}parse(i){this.parseFullHeader(i),this.subsegments=[];const e=i.readUint32();for(let t=0;t<e;t++){const s={};this.subsegments.push(s),s.ranges=[];const r=i.readUint32();for(let n=0;n<r;n++){const o={};s.ranges.push(o),o.level=i.readUint8(),o.range_size=i.readUint24()}}}},Gc.fourcc="ssix",Gc),zc,hT=(zc=class extends R{constructor(){super(...arguments),this.box_name="DegradationPriorityBox"}parse(i){this.parseFullHeader(i);const e=(this.size-this.hdr_size)/2;this.priority=[];for(let t=0;t<e;t++)this.priority[t]=i.readUint16()}},zc.fourcc="stpd",zc),Lc,uT=(Lc=class extends R{constructor(){super(...arguments),this.box_name="SubTrackInformationBox"}parse(i){this.parseFullHeader(i),this.switch_group=i.readUint16(),this.alternate_group=i.readUint16(),this.sub_track_id=i.readUint32();const e=(this.size-this.hdr_size-8)/4;this.attribute_list=[];for(let t=0;t<e;t++)this.attribute_list[t]=i.readUint32()}},Lc.fourcc="stri",Lc),Nc,dT=(Nc=class extends R{constructor(){super(...arguments),this.box_name="SubTrackSampleGroupBox"}parse(i){this.parseFullHeader(i),this.grouping_type=i.readUint32();const e=i.readUint16();this.group_description_index=[];for(let t=0;t<e;t++)this.group_description_index[t]=i.readUint32()}},Nc.fourcc="stsg",Nc),Hc,fT=(Hc=class extends R{constructor(){super(...arguments),this.box_name="ShadowSyncSampleBox"}parse(i){this.parseFullHeader(i);const e=i.readUint32();if(this.shadowed_sample_numbers=[],this.sync_sample_numbers=[],this.version===0)for(let t=0;t<e;t++)this.shadowed_sample_numbers.push(i.readUint32()),this.sync_sample_numbers.push(i.readUint32())}write(i){this.version=0,this.flags=0,this.size=4+8*this.shadowed_sample_numbers.length,this.writeHeader(i),i.writeUint32(this.shadowed_sample_numbers.length);for(let e=0;e<this.shadowed_sample_numbers.length;e++)i.writeUint32(this.shadowed_sample_numbers[e]),i.writeUint32(this.sync_sample_numbers[e])}},Hc.fourcc="stsh",Hc),Wc,pT=(Wc=class extends R{constructor(){super(...arguments),this.box_name="SyncSampleBox"}parse(i){this.parseFullHeader(i);const e=i.readUint32();if(this.version===0){this.sample_numbers=[];for(let t=0;t<e;t++)this.sample_numbers.push(i.readUint32())}}write(i){this.version=0,this.flags=0,this.size=4+4*this.sample_numbers.length,this.writeHeader(i),i.writeUint32(this.sample_numbers.length),i.writeUint32Array(this.sample_numbers)}},Wc.fourcc="stss",Wc),Vc,mT=(Vc=class extends R{constructor(){super(...arguments),this.box_name="StereoVideoBox"}parse(i){this.parseFullHeader(i);const e=i.readUint32();this.single_view_allowed=e&3,this.stereo_scheme=i.readUint32();const t=i.readUint32();for(this.stereo_indication_type=i.readString(t),this.boxes=[];i.getPosition()<this.start+this.size;){const s=dt(i,!1,this.size-(i.getPosition()-this.start));if(s.code===Ve){const r=s.box;this.boxes.push(r),this[r.type]=r}else return}}},Vc.fourcc="stvi",Vc),$c,gT=($c=class extends U{constructor(){super(...arguments),this.box_name="SegmentTypeBox"}parse(i){let e=this.size-this.hdr_size;this.major_brand=i.readString(4),this.minor_version=i.readUint32(),e-=8,this.compatible_brands=[];let t=0;for(;e>=4;)this.compatible_brands[t]=i.readString(4),e-=4,t++}write(i){this.size=8+4*this.compatible_brands.length,this.writeHeader(i),i.writeString(this.major_brand,void 0,4),i.writeUint32(this.minor_version);for(let e=0;e<this.compatible_brands.length;e++)i.writeString(this.compatible_brands[e],void 0,4)}},$c.fourcc="styp",$c),Xc,_T=(Xc=class extends R{constructor(){super(...arguments),this.box_name="CompactSampleSizeBox"}parse(i){if(this.parseFullHeader(i),this.sample_sizes=[],this.version===0){this.reserved=i.readUint24(),this.field_size=i.readUint8();const e=i.readUint32();if(this.field_size===4)for(let t=0;t<e;t+=2){const s=i.readUint8();this.sample_sizes[t]=s>>4&15,this.sample_sizes[t+1]=s&15}else if(this.field_size===8)for(let t=0;t<e;t++)this.sample_sizes[t]=i.readUint8();else if(this.field_size===16)for(let t=0;t<e;t++)this.sample_sizes[t]=i.readUint16();else I.error("BoxParser","Error in length field in stz2 box",i.isofile)}}},Xc.fourcc="stz2",Xc),Yc,xT=(Yc=class extends R{constructor(){super(...arguments),this.box_name="SubSampleInformationBox"}parse(i){this.parseFullHeader(i);const e=i.readUint32();this.entries=[];let t;for(let s=0;s<e;s++){const r={};if(this.entries[s]=r,r.sample_delta=i.readUint32(),r.subsamples=[],t=i.readUint16(),t>0)for(let n=0;n<t;n++){const o={};r.subsamples.push(o),this.version===1?o.size=i.readUint32():o.size=i.readUint16(),o.priority=i.readUint8(),o.discardable=i.readUint8(),o.codec_specific_parameters=i.readUint32()}}}},Yc.fourcc="subs",Yc),qc,vT=(qc=class extends R{constructor(){super(...arguments),this.box_name="TAIClockInfoBox"}parse(i){this.time_uncertainty=i.readUint64(),this.clock_resolution=i.readUint32(),this.clock_drift_rate=i.readInt32();const e=i.readUint8();this.clock_type=(e&192)>>6}},qc.fourcc="taic",qc),Kc,yT=(Kc=class extends R{constructor(){super(...arguments),this.box_name="TrackEncryptionBox"}parse(i){if(this.parseFullHeader(i),i.readUint8(),this.version===0)i.readUint8();else{const e=i.readUint8();this.default_crypt_byte_block=e>>4&15,this.default_skip_byte_block=e&15}this.default_isProtected=i.readUint8(),this.default_Per_Sample_IV_Size=i.readUint8(),this.default_KID=ri(i),this.default_isProtected===1&&this.default_Per_Sample_IV_Size===0&&(this.default_constant_IV_size=i.readUint8(),this.default_constant_IV=i.readUint8Array(this.default_constant_IV_size))}},Kc.fourcc="tenc",Kc),jc,bT=(jc=class extends R{constructor(){super(...arguments),this.box_name="TrackFragmentRandomAccessBox"}parse(i){this.parseFullHeader(i),this.track_ID=i.readUint32(),i.readUint24();const e=i.readUint8();this.length_size_of_traf_num=e>>4&3,this.length_size_of_trun_num=e>>2&3,this.length_size_of_sample_num=e&3,this.entries=[];const t=i.readUint32();for(let s=0;s<t;s++)this.version===1?(this.time=i.readUint64(),this.moof_offset=i.readUint64()):(this.time=i.readUint32(),this.moof_offset=i.readUint32()),this.traf_number=i["readUint"+8*(this.length_size_of_traf_num+1)](),this.trun_number=i["readUint"+8*(this.length_size_of_trun_num+1)](),this.sample_number=i["readUint"+8*(this.length_size_of_sample_num+1)]()}},jc.fourcc="tfra",jc),Zc,TT=(Zc=class extends U{constructor(){super(...arguments),this.box_name="hintmaxrelativetime"}parse(i){this.time=i.readUint32()}},Zc.fourcc="tmax",Zc),Jc,wT=(Jc=class extends U{constructor(){super(...arguments),this.box_name="hintminrelativetime"}parse(i){this.time=i.readUint32()}},Jc.fourcc="tmin",Jc),Qc,ST=(Qc=class extends U{constructor(){super(...arguments),this.box_name="hintBytesSent"}parse(i){this.bytessent=i.readUint32()}},Qc.fourcc="totl",Qc),eh,CT=(eh=class extends U{constructor(){super(...arguments),this.box_name="hintBytesSent"}parse(i){this.bytessent=i.readUint32()}},eh.fourcc="tpay",eh),th,AT=(th=class extends U{constructor(){super(...arguments),this.box_name="hintBytesSent"}parse(i){this.bytessent=i.readUint64()}},th.fourcc="tpyl",th),ih,ET=(ih=class extends Sf{},ih.fourcc="msrc",ih),ls,IT=(ls=class extends U{constructor(){super(...arguments),this.box_name="TrackReferenceBox",this.references=[]}parse(i){for(;i.getPosition()<this.start+this.size;){const e=dt(i,!0,this.size-(i.getPosition()-this.start));if(e.code===Ve){ls.allowed_types.includes(e.type)||I.warn("BoxParser",`Unknown track reference type: '${e.type}'`);const t=new Ef(e.type,e.size,e.hdr_size,e.start);t.write===U.prototype.write&&t.type!=="mdat"&&(I.info("BoxParser","TrackReference "+t.type+" box writing not yet implemented, keeping unparsed data in memory for later write"),t.parseDataAndRewind(i)),t.parse(i),this.references.push(t)}else return}}},ls.fourcc="tref",ls.allowed_types=["hint","cdsc","font","hind","vdep","vplx","subt","thmb","auxl","cdtg","shsc","aest"],ls),sh,PT=(sh=class extends R{constructor(){super(...arguments),this.box_name="TrackExtensionPropertiesBox"}parse(i){for(this.parseFullHeader(i),this.track_ID=i.readUint32(),this.boxes=[];i.getPosition()<this.start+this.size;){const e=dt(i,!1,this.size-(i.getPosition()-this.start));if(e.code===Ve){const t=e.box;this.boxes.push(t)}else return}}},sh.fourcc="trep",sh),rh,RT=(rh=class extends U{constructor(){super(...arguments),this.box_name="hintBytesSent"}parse(i){this.bytessent=i.readUint64()}},rh.fourcc="trpy",rh),nh,kT=(nh=class extends R{constructor(){super(...arguments),this.box_name="TrackSelectionBox"}parse(i){this.parseFullHeader(i),this.switch_group=i.readUint32();const e=(this.size-this.hdr_size-4)/4;this.attribute_list=[];for(let t=0;t<e;t++)this.attribute_list[t]=i.readUint32()}},nh.fourcc="tsel",nh),oh,MT=(oh=class extends R{constructor(){super(...arguments),this.box_name="TextConfigBox"}parse(i){this.parseFullHeader(i),this.config=i.readCString()}},oh.fourcc="txtc",oh),ah,FT=(ah=class extends U{constructor(){super(...arguments),this.box_name="TypeCombinationBox"}parse(i){const e=(this.size-this.hdr_size)/4;this.compatible_brands=[];for(let t=0;t<e;t++)this.compatible_brands[t]=i.readString(4)}},ah.fourcc="tyco",ah),lh,UT=(lh=class extends R{constructor(){super(...arguments),this.box_name="UserDescriptionProperty"}parse(i){this.parseFullHeader(i),this.lang=i.readCString(),this.name=i.readCString(),this.description=i.readCString(),this.tags=i.readCString()}},lh.fourcc="udes",lh),ch,BT=(ch=class extends R{constructor(){super(...arguments),this.box_name="UncompressedFrameConfigBox"}parse(i){if(this.parseFullHeader(i),this.profile=i.readString(4),this.version!==1&&this.version===0){this.component_count=i.readUint32(),this.component_index=[],this.component_bit_depth_minus_one=[],this.component_format=[],this.component_align_size=[];for(let t=0;t<this.component_count;t++)this.component_index.push(i.readUint16()),this.component_bit_depth_minus_one.push(i.readUint8()),this.component_format.push(i.readUint8()),this.component_align_size.push(i.readUint8());this.sampling_type=i.readUint8(),this.interleave_type=i.readUint8(),this.block_size=i.readUint8();const e=i.readUint8();this.component_little_endian=e>>7&1,this.block_pad_lsb=e>>6&1,this.block_little_endian=e>>5&1,this.block_reversed=e>>4&1,this.pad_unknown=e>>3&1,this.pixel_size=i.readUint32(),this.row_align_size=i.readUint32(),this.tile_align_size=i.readUint32(),this.num_tile_cols_minus_one=i.readUint32(),this.num_tile_rows_minus_one=i.readUint32()}}},ch.fourcc="uncC",ch),hh,OT=(hh=class extends R{constructor(){super(...arguments),this.box_name="DataEntryUrnBox"}parse(i){this.parseFullHeader(i),this.name=i.readCString(),this.size-this.hdr_size-this.name.length-1>0&&(this.location=i.readCString())}write(i){this.version=0,this.flags=0,this.size=this.name.length+1+(this.location?this.location.length+1:0),this.writeHeader(i),i.writeCString(this.name),this.location&&i.writeCString(this.location)}},hh.fourcc="urn ",hh),uh,DT=(uh=class extends U{constructor(){super(...arguments),this.box_name="WebVTTConfigurationBox"}parse(i){this.text=i.readString(this.size-this.hdr_size)}},uh.fourcc="vttC",uh),dh,GT=(dh=class extends R{constructor(){super(...arguments),this.box_name="VvcNALUConfigBox"}parse(i){this.parseFullHeader(i);const e=i.readUint8();this.lengthSizeMinusOne=e&3}},dh.fourcc="vvnC",dh),fh,zT=(fh=class extends ve{parse(i){const e=i.readUint16();this.first_output_sample=i.readUint16(),this.sample_offset=[];for(let s=0;s<e;s++)this.sample_offset[s]=i.readUint32();const t=this.description_length-4-4*e;this.num_output_samples=[],this.num_total_samples=[];for(let s=0;s<t/4;s++)this.num_output_samples[s]=i.readUint16(),this.num_total_samples[s]=i.readUint16()}},fh.grouping_type="alst",fh),ph,LT=(ph=class extends ve{parse(i){this.layerNumber=i.readUint8(),this.accurateStatisticsFlag=i.readUint8(),this.avgBitRate=i.readUint16(),this.avgFrameRate=i.readUint16()}},ph.grouping_type="avll",ph),mh,NT=(mh=class extends ve{parse(i){this.subSequenceIdentifier=i.readUint16(),this.layerNumber=i.readUint8();const e=i.readUint8();this.durationFlag=e>>7,this.avgRateFlag=e>>6&1,this.durationFlag&&(this.duration=i.readUint32()),this.avgRateFlag&&(this.accurateStatisticsFlag=i.readUint8(),this.avgBitRate=i.readUint16(),this.avgFrameRate=i.readUint16()),this.dependency=[];const t=i.readUint8();for(let s=0;s<t;s++)this.dependency.push({subSeqDirectionFlag:i.readUint8(),layerNumber:i.readUint8(),subSequenceIdentifier:i.readUint16()})}},mh.grouping_type="avss",mh),gh,HT=(gh=class extends ve{parse(i){I.warn("BoxParser","Sample Group type: "+this.grouping_type+" not fully parsed")}},gh.grouping_type="dtrt",gh),_h,WT=(_h=class extends ve{parse(i){I.warn("BoxParser","Sample Group type: "+this.grouping_type+" not fully parsed")}},_h.grouping_type="mvif",_h),xh,VT=(xh=class extends ve{parse(i){this.roll_distance=i.readInt16()}},xh.grouping_type="prol",xh),vh,$T=(vh=class extends ve{parse(i){const e=i.readUint8();this.num_leading_samples_known=e>>7,this.num_leading_samples=e&127}},vh.grouping_type="rap ",vh),yh,XT=(yh=class extends ve{parse(i){if(this.operation_point_count=i.readUint16(),this.description_length!==2+(this.operation_point_count===1?2:this.operation_point_count*6)+9)I.warn("BoxParser","Mismatch in "+this.grouping_type+" sample group length"),this.data=i.readUint8Array(this.description_length-2);else{if(this.operation_point_count===1)this.target_rate_share=i.readUint16();else{this.target_rate_share=[],this.available_bitrate=[];for(let e=0;e<this.operation_point_count;e++)this.available_bitrate[e]=i.readUint32(),this.target_rate_share[e]=i.readUint16()}this.maximum_bitrate=i.readUint32(),this.minimum_bitrate=i.readUint32(),this.discard_priority=i.readUint8()}}},yh.grouping_type="rash",yh),bh,YT=(bh=class extends ve{parse(i){this.roll_distance=i.readInt16()}},bh.grouping_type="roll",bh),Th,qT=(Th=class extends ve{parse(i){I.warn("BoxParser","Sample Group type: "+this.grouping_type+" not fully parsed")}},Th.grouping_type="scif",Th),wh,KT=(wh=class extends ve{parse(i){I.warn("BoxParser","Sample Group type: "+this.grouping_type+" not fully parsed")}},wh.grouping_type="scnm",wh),Sh,jT=(Sh=class extends ve{parse(i){this.reserved=i.readUint8();const e=i.readUint8();this.crypt_byte_block=e>>4,this.skip_byte_block=e&15,this.isProtected=i.readUint8(),this.Per_Sample_IV_Size=i.readUint8(),this.KID=ri(i),this.constant_IV_size=0,this.constant_IV=0,this.isProtected===1&&this.Per_Sample_IV_Size===0&&(this.constant_IV_size=i.readUint8(),this.constant_IV=i.readUint8Array(this.constant_IV_size))}},Sh.grouping_type="seig",Sh),Ch,ZT=(Ch=class extends ve{parse(i){I.warn("BoxParser","Sample Group type: "+this.grouping_type+" not fully parsed")}},Ch.grouping_type="stsa",Ch),Ah,JT=(Ah=class extends ve{parse(i){const e=i.readUint8();this.NAL_unit_type=e&63}},Ah.grouping_type="sync",Ah),Eh,QT=(Eh=class extends ve{parse(i){const e=i.readUint8();this.level_independently_decodable=e>>7}},Eh.grouping_type="tele",Eh),Ih,e1=(Ih=class extends ve{parse(i){I.warn("BoxParser","Sample Group type: "+this.grouping_type+" not fully parsed")}},Ih.grouping_type="tsas",Ih),Ph,t1=(Ph=class extends ve{parse(i){I.warn("BoxParser","Sample Group type: "+this.grouping_type+" not fully parsed")}},Ph.grouping_type="tscl",Ph),Rh,i1=(Rh=class extends ve{parse(i){I.warn("BoxParser","Sample Group type: "+this.grouping_type+" not fully parsed")}},Rh.grouping_type="vipr",Rh),kh,s1=(kh=class extends U{},kh.fourcc="uuid",kh),Mh,Si=(Mh=class extends R{},Mh.fourcc="uuid",Mh),Fh,r1=(Fh=class extends Si{constructor(){super(...arguments),this.box_name="LiveServerManifestBox"}parse(i){this.parseFullHeader(i),this.LiveServerManifest=i.readString(this.size-this.hdr_size).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;")}},Fh.uuid="a5d40b30e81411ddba2f0800200c9a66",Fh),Uh,n1=(Uh=class extends Si{constructor(){super(...arguments),this.box_name="PiffProtectionSystemSpecificHeaderBox"}parse(i){this.parseFullHeader(i),this.system_id=ri(i);const e=i.readUint32();e>0&&(this.data=i.readUint8Array(e))}},Uh.uuid="d08a4f1810f34a82b6c832d8aba183d3",Uh),Bh,o1=(Bh=class extends Si{constructor(){super(...arguments),this.box_name="PiffSampleEncryptionBox"}},Bh.uuid="a2394f525a9b4f14a2446c427c648df4",Bh),Oh,a1=(Oh=class extends Si{constructor(){super(...arguments),this.box_name="PiffTrackEncryptionBox"}parse(i){this.parseFullHeader(i),this.default_AlgorithmID=i.readUint24(),this.default_IV_size=i.readUint8(),this.default_KID=ri(i)}},Oh.uuid="8974dbce7be74c5184f97148f9882554",Oh),Dh,l1=(Dh=class extends Si{constructor(){super(...arguments),this.box_name="TfrfBox"}parse(i){this.parseFullHeader(i),this.fragment_count=i.readUint8(),this.entries=[];for(let e=0;e<this.fragment_count;e++){let t=0,s=0;this.version===1?(t=i.readUint64(),s=i.readUint64()):(t=i.readUint32(),s=i.readUint32()),this.entries.push({absolute_time:t,absolute_duration:s})}}},Dh.uuid="d4807ef2ca3946958e5426cb9e46a79f",Dh),Gh,c1=(Gh=class extends Si{constructor(){super(...arguments),this.box_name="TfxdBox"}parse(i){this.parseFullHeader(i),this.version===1?(this.absolute_time=i.readUint64(),this.duration=i.readUint64()):(this.absolute_time=i.readUint32(),this.duration=i.readUint32())}},Gh.uuid="6d1d9b0542d544e680e2141daff757b2",Gh),zh,h1=(zh=class extends s1{constructor(){super(...arguments),this.box_name="ItemContentIDProperty"}parse(i){this.content_id=i.readCString()}},zh.uuid="261ef3741d975bbaacbd9d2c8ea73522",zh),vp=Av(xp);Ev(pp);const oi=Object.freeze(Object.defineProperty({__proto__:null,AudioSampleEntry:Le,Box:U,BoxParser:vp,DIFF_BOXES_PROP_NAMES:nr,DIFF_PRIMITIVE_ARRAY_PROP_NAMES:If,DataStream:Pe,Descriptor:Yt,ES_Descriptor:il,Endianness:vf,FullBox:R,HintSampleEntry:Pn,ISOFile:dp,Log:I,MP4BoxBuffer:yt,MPEG4DescriptorParser:_p,MetadataSampleEntry:ni,MultiBufferStream:Ti,SampleEntry:bt,SampleGroupEntry:ve,SampleGroupInfo:dr,SingleItemTypeReferenceBox:Cf,SingleItemTypeReferenceBoxLarge:Af,SubtitleSampleEntry:Xt,SystemSampleEntry:ar,TX3GParser:Tb,TextSampleEntry:Rf,Textin4Parser:bb,TrackGroupTypeBox:Sf,TrackReferenceTypeBox:Ef,VTTin4Parser:vb,VisualSampleEntry:fe,XMLSubtitlein4Parser:yb,boxEqual:An,boxEqualFields:Pf,createFile:fp},Symbol.toStringTag,{value:"Module"})),u1=vp?.box?.esds,d1=fp;class f1{all=new Map;on(e,t){const s=this.all.get(e);return s?s.push(t):this.all.set(e,[t]),()=>this.off(e,t)}once(e,t){const s=this.on(e,r=>{s(),t(r)});return s}off(e,t){const s=this.all.get(e);s&&(t?s.splice(s.indexOf(t)>>>0,1):this.all.set(e,[]))}emit(e,t){let s=this.all.get(e);s&&s.slice().forEach(r=>{r(t)}),s=this.all.get("*"),s&&s.slice().forEach(r=>{r(e,t)})}}const p1={0:"debug",1:"info",2:"warn",3:"error"};function m1(i){if(i instanceof Error)return String(i);if(typeof i=="object"&&i!==null)try{return JSON.stringify(i,(e,t)=>t instanceof Error?String(t):t)}catch{return String(i)}return String(i)}function g1(){const i=new Date,e=s=>s.toString().padStart(2,"0"),t=i.getMilliseconds().toString().padStart(3,"0");return`${e(i.getHours())}:${e(i.getMinutes())}:${e(i.getSeconds())}.${t}`}class _1{threshold=1;history=[];debug=(...e)=>this.log(0,console.debug,e);info=(...e)=>this.log(1,console.info,e);warn=(...e)=>this.log(2,console.warn,e);error=(...e)=>this.log(3,console.error,e);log(e,t,s){e>=this.threshold&&(t(...s),this.history.push({level:p1[e],time:g1(),args:s}))}setThreshold(e){this.threshold=e}getThreshold(){return this.threshold}createTagged(e){return{debug:(...t)=>this.debug(e,...t),info:(...t)=>this.info(e,...t),warn:(...t)=>this.warn(e,...t),error:(...t)=>this.error(e,...t)}}dump(){return this.history.map(({level:e,time:t,args:s})=>`[${e.toUpperCase()}][${t}] ${s.map(m1).join(" ")}`).join(`
`)}}const Tt=new _1,Fe={debug:Tt.debug,info:Tt.info,warn:Tt.warn,error:Tt.error,setLogLevel:i=>{const e=i;e===Fe.debug?Tt.setThreshold(0):e===Fe.info?Tt.setThreshold(1):e===Fe.warn?Tt.setThreshold(2):e===Fe.error&&Tt.setThreshold(3)},create:i=>Tt.createTagged(i),dump:async()=>Tt.dump()};(async function(){if(!(typeof navigator>"u"||typeof document>"u")&&(Fe.info(`User Agent: ${navigator.userAgent}`),document.addEventListener("visibilitychange",()=>{Fe.info(`visibilitychange: ${document.visibilityState}`)}),"PressureObserver"in globalThis))try{let i="";new globalThis.PressureObserver(e=>{const t=JSON.stringify(e.map(s=>s.state));t!==i&&(Fe.info(`cpu state change: ${t}`),i=t)}).observe("cpu")}catch(i){Fe.debug("Failed to initialize PressureObserver",i)}})();let kt=class{buffer;view;offset=0;constructor(e){this.buffer=new Uint8Array(e),this.view=new DataView(this.buffer.buffer)}writeUint32(e){return this.view.setUint32(this.offset,e),this.offset+=4,this}writeUint16(e){return this.view.setUint16(this.offset,e),this.offset+=2,this}writeUint8(e){return this.view.setUint8(this.offset,e),this.offset+=1,this}writeType(e){for(let t=0;t<4;t++){const s=t<e.length?e.charCodeAt(t):0;this.buffer[this.offset+t]=s}return this.offset+=4,this}writeBytes(e){const t=e instanceof Uint8Array?e:new Uint8Array(e);return this.buffer.set(t,this.offset),this.offset+=t.byteLength,this}skip(e){return this.offset+=e,this}};const x1=()=>{const i=new TextEncoder().encode("mp4 handler"),e=32+i.byteLength+1;return new kt(e).writeUint32(e).writeType("hdlr").writeUint32(0).skip(4).writeType("mdta").skip(12).writeBytes(i).skip(1).buffer},v1=i=>{const e=new TextEncoder,t=i.map(n=>{const o=e.encode(n),a=8+o.byteLength;return new kt(a).writeUint32(a).writeType("mdta").writeBytes(o).buffer}),s=16+t.reduce((n,o)=>n+o.byteLength,0),r=new kt(s).writeUint32(s).writeType("keys").writeUint32(0).writeUint32(i.length);return t.forEach(n=>r.writeBytes(n)),r.buffer},y1=i=>{const e=new TextEncoder,t=Object.entries(i).map(([n,o],a)=>{const l=a+1,c=e.encode(o),h=16+c.byteLength,u=8+h;return new kt(u).writeUint32(u).writeUint32(l).writeUint32(h).writeType("data").writeUint32(1).skip(4).writeBytes(c).buffer}),s=8+t.reduce((n,o)=>n+o.byteLength,0),r=new kt(s).writeUint32(s).writeType("ilst");return t.forEach(n=>r.writeBytes(n)),r.buffer},b1=i=>{const e=x1(),t=v1(Object.keys(i)),s=y1(i),r=e.length+t.length+s.length;return new kt(r).writeBytes(e).writeBytes(t).writeBytes(s).buffer};function yp(i){const e=new ArrayBuffer(i.byteLength);i.copyTo(e);const t=i.timestamp;return{duration:i.duration??0,dts:t,cts:t,is_sync:i.type==="key",data:e}}function T1(i){const e=i.byteLength,t=i instanceof ArrayBuffer?new Uint8Array(i):new Uint8Array(i.buffer,i.byteOffset,i.byteLength),s=26+e+3;return new kt(s).writeUint8(3).writeUint8(23+e).writeUint16(1).writeUint8(0).writeUint8(4).writeUint8(15+e).writeUint8(64).writeUint8(21).writeBytes([0,0,0]).writeUint32(0).writeUint32(0).writeUint8(5).writeUint8(e).writeBytes(t).writeUint8(6).writeUint8(1).writeUint8(2).buffer}function w1(i){const e=new DataView(i instanceof ArrayBuffer?i:i.buffer,i.byteOffset||0),t=e.getUint8(9),s=e.getUint16(10,!0),r=e.getUint32(12,!0),n=e.getInt16(16,!0),o=e.getUint8(18);return new kt(11).writeUint8(0).writeUint8(t).writeUint16(s).writeUint32(r).writeUint16(n).writeUint8(o).buffer}function S1(i){const e=(i.codec||"vp09.00.40.08").split("."),t=parseInt(e[1]||"0",10),s=parseInt(e[2]||"40",10),r=parseInt(e[3]||"08",10),n={bt709:1,bt601:5,bt2020:9},o={bt709:1,srgb:13,pq:16,hlg:18},a={bt709:1,bt601:5,bt2020:9},l=n[i.colorSpace?.primaries||"bt709"]||1,c=o[i.colorSpace?.transfer||"bt709"]||1,h=a[i.colorSpace?.matrix||"bt709"]||1,u=i.colorSpace?.fullRange?1:0;return new kt(12).writeUint32(1<<24).writeUint8(t).writeUint8(s).writeUint8(r<<4|2|u).writeUint8(l).writeUint8(c).writeUint8(h).writeUint16(0).buffer.buffer}function C1(i){if(i.byteLength<7)return!1;const e=new DataView(i);let t=0;try{t+=6;const s=e.getUint8(5)&31;for(let n=0;n<s;n++){if(t+2>i.byteLength)return!1;const o=e.getUint16(t);t+=2+o}if(t+1>i.byteLength)return!1;const r=e.getUint8(t++);for(let n=0;n<r;n++){if(t+2>i.byteLength)return!1;const o=e.getUint16(t);t+=2+o}return t<=i.byteLength}catch{return!1}}function A1(i){if(!i||i.byteLength<3)return;const e=new Uint8Array(i);e[2]?.toString(2).slice(-2).includes("1")&&(e[2]=0)}class E1{constructor(e,t,s){this.opts=e,this.mp4File=t,this.avSyncTool=s,this.encoder=this.initEncoder(),this.avSyncTool.once("VideoReady",()=>{this.videoReady=!0,this.flushCache()})}encoder;trackId=-1;cache=[];videoReady=!1;initEncoder(){const e={codec:this.opts.codec==="aac"?"mp4a.40.2":"opus",sampleRate:this.opts.sampleRate,numberOfChannels:this.opts.channelCount,bitrate:128e3},t=new AudioEncoder({error:s=>{const r=`AudioEncoder error: ${s.message}, config: ${JSON.stringify(e)}`;throw Fe.error(r),Error(r)},output:(s,r)=>this.onOutput(s,r)});return t.configure(e),t}onOutput(e,t){this.trackId===-1&&this.setupTrack(t);const s=yp(e);this.videoReady?this.mp4File.addSample(this.trackId,new Uint8Array(s.data),s):this.cache.push(s)}setupTrack(e){const t=e?.decoderConfig?.description,s=this.opts.codec==="aac",r={timescale:1e6,samplerate:this.opts.sampleRate,channel_count:this.opts.channelCount,hdlr:"soun",type:s?"mp4a":"Opus",name:"Track created with designcombo",description:t==null?void 0:s?this.createESDS(t):this.createDOps(t)};this.trackId=this.mp4File.addTrack(r),this.avSyncTool.emit("AudioReady",void 0),Fe.info("AudioEncoder, audio track ready, trackId:",this.trackId)}createESDS(e){const t=new u1;return t.version=0,t.flags=0,t.data=T1(e),t}createDOps(e){const t=w1(e);return{type:"dOps",size:t.byteLength+8,hdr_size:8,start:0,data:t,write:function(s){s.writeUint32(this.size),s.writeString("dOps"),s.writeUint8Array(this.data)},parse:function(){}}}flushCache(){this.cache.forEach(e=>{this.mp4File.addSample(this.trackId,new Uint8Array(e.data),e)}),this.cache=[]}encode(e){this.encoder.encode(e)}async flush(){this.encoder.state==="configured"&&await this.encoder.flush()}close(){this.encoder.state==="configured"&&this.encoder.close()}get encodeQueueSize(){return this.encoder.encodeQueueSize}get state(){return this.encoder.state}}const I1=()=>{let i,e=16.6;self.onmessage=t=>{t.data.event==="start"&&(self.clearInterval(i),i=self.setInterval(()=>{self.postMessage({})},e)),t.data.event==="stop"&&self.clearInterval(i)}},P1=()=>{const i=new Blob([`(${I1.toString()})()`]),e=URL.createObjectURL(i);return new Worker(e)},Ci=new Map;let Lh=1,_r=null;globalThis.Worker!=null&&(_r=P1(),_r.onmessage=()=>{Lh+=1;for(const[i,e]of Ci)if(Lh%i===0)for(const t of e)t()});const R1=(i,e)=>{const t=Math.round(e/16.6),s=Ci.get(t)??new Set;return s.add(i),Ci.set(t,s),Ci.size===1&&s.size===1&&_r?.postMessage({event:"start"}),()=>{s.delete(i),s.size===0&&Ci.delete(t),Ci.size===0&&(Lh=0,_r?.postMessage({event:"stop"}))}};class k1{constructor(e,t,s){this.opts=e,this.mp4File=t,this.avSyncTool=s,this.frameDeltaTime=Math.floor(1e3/e.expectFPS*1e3),this.encoder0=this.initEncoder("encoder0"),this.encoder1=this.initEncoder("encoder1"),this.avSyncTool.once("AudioReady",()=>{this.audioReady=!0}),this.stopTimer=R1(()=>this.checkCache(),15)}encoder0;encoder1;trackId=-1;samplesCache={encoder0:[],encoder1:[]};currentEncoderId="encoder1";lastAddedSampleTime=0;audioReady=!1;gopId=0;stopTimer;frameDeltaTime;initEncoder(e){const t={codec:this.opts.codec,framerate:this.opts.expectFPS,hardwareAcceleration:this.opts.__unsafe_hardwareAcceleration__,bitrate:this.opts.bitrate,width:this.opts.width,height:this.opts.height,alpha:"discard",avc:{format:"avc"}},s=new VideoEncoder({error:r=>{throw Fe.error(`VideoEncoder error: ${r.message}`,t),Error(`VideoEncoder error: ${r.message}`)},output:(r,n)=>this.onOutput(e,r,n)});return s.configure(t),s}onOutput(e,t,s){this.trackId===-1&&s!=null&&this.setupTrack(s),this.samplesCache[e].push(yp(t))}setupTrack(e){if(!e.decoderConfig)return;let t=e.decoderConfig.description,s="avc1";if(this.opts.codec.startsWith("avc1")){if(A1(t),!C1(t)){Fe.warn("Invalid AVCC descriptor, waiting for next metadata");return}}else this.opts.codec.startsWith("vp09")&&(s="vp09",t=S1(e.decoderConfig));const r=this.getDecoderConfKey();if(!r||!t||t.byteLength<7){Fe.warn("VideoEncoder metadata missing valid configuration");return}const n={timescale:1e6,width:this.opts.width,height:this.opts.height,brands:["isom","iso2","avc1","mp42","mp41"],type:s,name:"Track created with designcombo"};n[r]=t;try{this.trackId=this.mp4File.addTrack(n),this.avSyncTool.emit("VideoReady",void 0),Fe.info("VideoEncoder, video track ready, trackId:",this.trackId)}catch(o){Fe.warn("mp4File.addTrack warning",o)}}getDecoderConfKey(){return this.opts.codec.startsWith("avc1")?"avcDecoderConfigRecord":this.opts.codec.startsWith("hvc1")?"hevcDecoderConfigRecord":this.opts.codec.startsWith("vp09")?"vpcDecoderConfigRecord":null}checkCache(){if(!this.audioReady||this.trackId===-1)return;const e=this.currentEncoderId==="encoder1"?"encoder0":"encoder1",t=this.samplesCache[this.currentEncoderId],s=this.samplesCache[e];if(t.length===0&&s.length===0)return;const r=t[0];if(r!=null&&(!r.is_sync||r.cts-this.lastAddedSampleTime<this.frameDeltaTime)){const o=this.addSampleToFile(t);o>this.lastAddedSampleTime&&(this.lastAddedSampleTime=o)}const n=s[0];if(n?.is_sync&&n.cts-this.lastAddedSampleTime<this.frameDeltaTime){this.currentEncoderId=e,this.checkCache();return}if(r?.is_sync&&n?.is_sync)if(r.cts<=n.cts){const o=this.addSampleToFile(t);o>this.lastAddedSampleTime&&(this.lastAddedSampleTime=o)}else this.currentEncoderId=e,this.checkCache()}addSampleToFile(e){let t=-1,s=0;for(;s<e.length;s++){const r=e[s];if(s>0&&r.is_sync)break;this.mp4File.addSample(this.trackId,new Uint8Array(r.data),r),t=r.cts+r.duration}return e.splice(0,s),t}encode(e,t){t.keyFrame&&this.gopId++,(this.gopId%2===0?this.encoder0:this.encoder1).encode(e,t)}async flush(){await Promise.all([this.encoder0.state==="configured"?this.encoder0.flush():null,this.encoder1.state==="configured"?this.encoder1.flush():null]),this.stopTimer(),this.checkCache()}close(){this.encoder0.state==="configured"&&this.encoder0.close(),this.encoder1.state==="configured"&&this.encoder1.close()}get encodeQueueSize(){return this.encoder0.encodeQueueSize+this.encoder1.encodeQueueSize}}function M1(i){Fe.info("recodemux opts:",i);const e=d1(),t=new f1,s=(l,c)=>{const h=l.add("udta").add("meta");h.data=b1(c),h.size=h.data.byteLength};let r=!1;const n=()=>{e.moov==null||r||(r=!0,i.metaDataTags&&s(e.moov,i.metaDataTags),i.duration!=null&&(e.moov.mvhd.duration=i.duration))};t.once("VideoReady",n),t.once("AudioReady",n);const o=i.video?new k1(i.video,e,t):null,a=i.audio?new E1(i.audio,e,t):null;return i.video||t.emit("VideoReady",void 0),i.audio||t.emit("AudioReady",void 0),{encodeVideo:(l,c)=>{o?.encode(l,c),l.close()},encodeAudio:l=>{if(a)try{a.encode(l),l.close()}catch(c){throw Fe.error("encode audio chunk error",c),c}},getEncodeQueueSize:()=>o?.encodeQueueSize??a?.encodeQueueSize??0,flush:async()=>{await Promise.all([o?.flush(),a?.flush()])},close:()=>{t.all.clear(),o?.close(),a?.close()},mp4file:e}}var bp=i=>{throw TypeError(i)},Tp=(i,e,t)=>e.has(i)||bp("Cannot "+t),Z=(i,e,t)=>(Tp(i,e,"read from private field"),t?t.call(i):e.get(i)),nt=(i,e,t)=>e.has(i)?bp("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(i):e.set(i,t),Ne=(i,e,t,s)=>(Tp(i,e,"write to private field"),e.set(i,t),t);const wp="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2Z1bmN0aW9uIHUobil7aWYobj09PSIvIilyZXR1cm57cGFyZW50Om51bGwsbmFtZToiIn07Y29uc3QgZT1uLnNwbGl0KCIvIikuZmlsdGVyKGk9PmkubGVuZ3RoPjApO2lmKGUubGVuZ3RoPT09MCl0aHJvdyBFcnJvcigiSW52YWxpZCBwYXRoIik7Y29uc3QgYT1lW2UubGVuZ3RoLTFdLHI9Ii8iK2Uuc2xpY2UoMCwtMSkuam9pbigiLyIpO3JldHVybntuYW1lOmEscGFyZW50OnJ9fWFzeW5jIGZ1bmN0aW9uIHcobixlKXtjb25zdHtwYXJlbnQ6YSxuYW1lOnJ9PXUobik7aWYoYT09bnVsbClyZXR1cm4gYXdhaXQgbmF2aWdhdG9yLnN0b3JhZ2UuZ2V0RGlyZWN0b3J5KCk7Y29uc3QgaT1hLnNwbGl0KCIvIikuZmlsdGVyKHQ9PnQubGVuZ3RoPjApO3RyeXtsZXQgdD1hd2FpdCBuYXZpZ2F0b3Iuc3RvcmFnZS5nZXREaXJlY3RvcnkoKTtmb3IoY29uc3QgcyBvZiBpKXQ9YXdhaXQgdC5nZXREaXJlY3RvcnlIYW5kbGUocyx7Y3JlYXRlOmUuY3JlYXRlfSk7aWYoZS5pc0ZpbGUpcmV0dXJuIGF3YWl0IHQuZ2V0RmlsZUhhbmRsZShyLHtjcmVhdGU6ZS5jcmVhdGV9KX1jYXRjaCh0KXtpZih0Lm5hbWU9PT0iTm90Rm91bmRFcnJvciIpcmV0dXJuIG51bGw7dGhyb3cgdH19Y29uc3QgZj17fTtzZWxmLm9ubWVzc2FnZT1hc3luYyBuPT57dmFyIGk7Y29uc3R7ZXZ0VHlwZTplLGFyZ3M6YX09bi5kYXRhO2xldCByPWZbYS5maWxlSWRdO3RyeXtsZXQgdDtjb25zdCBzPVtdO2lmKGU9PT0icmVnaXN0ZXIiKXtjb25zdCBsPWF3YWl0IHcoYS5maWxlUGF0aCx7Y3JlYXRlOiEwLGlzRmlsZTohMH0pO2lmKGw9PW51bGwpdGhyb3cgRXJyb3IoYG5vdCBmb3VuZCBmaWxlOiAke2EuZmlsZUlkfWApO3I9YXdhaXQgbC5jcmVhdGVTeW5jQWNjZXNzSGFuZGxlKHttb2RlOmEubW9kZX0pLGZbYS5maWxlSWRdPXJ9ZWxzZSBpZihlPT09ImNsb3NlIilhd2FpdCByLmNsb3NlKCksZGVsZXRlIGZbYS5maWxlSWRdO2Vsc2UgaWYoZT09PSJ0cnVuY2F0ZSIpYXdhaXQgci50cnVuY2F0ZShhLm5ld1NpemUpO2Vsc2UgaWYoZT09PSJ3cml0ZSIpe2NvbnN0e2RhdGE6bCxvcHRzOm99PW4uZGF0YS5hcmdzO3Q9YXdhaXQgci53cml0ZShsLG8pfWVsc2UgaWYoZT09PSJyZWFkIil7Y29uc3R7b2Zmc2V0Omwsc2l6ZTpvfT1uLmRhdGEuYXJncyxnPW5ldyBVaW50OEFycmF5KG8pLGQ9YXdhaXQgci5yZWFkKGcse2F0Omx9KSxjPWcuYnVmZmVyO3Q9ZD09PW8/YzooKGk9Yy50cmFuc2Zlcik9PW51bGw/dm9pZCAwOmkuY2FsbChjLGQpKT8/Yy5zbGljZSgwLGQpLHMucHVzaCh0KX1lbHNlIGU9PT0iZ2V0U2l6ZSI/dD1hd2FpdCByLmdldFNpemUoKTplPT09ImZsdXNoIiYmYXdhaXQgci5mbHVzaCgpO3NlbGYucG9zdE1lc3NhZ2Uoe2V2dFR5cGU6ImNhbGxiYWNrIixjYklkOm4uZGF0YS5jYklkLHJldHVyblZhbDp0fSxzKX1jYXRjaCh0KXtjb25zdCBzPXQ7c2VsZi5wb3N0TWVzc2FnZSh7ZXZ0VHlwZToidGhyb3dFcnJvciIsY2JJZDpuLmRhdGEuY2JJZCxlcnJNc2c6cy5uYW1lKyI6ICIrcy5tZXNzYWdlK2AKYCtKU09OLnN0cmluZ2lmeShuLmRhdGEpfSl9fX0pKCk7Ci8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZnMtd29ya2VyLUY0UldscWNfLmpzLm1hcAo=",F1=i=>Uint8Array.from(atob(i),e=>e.charCodeAt(0)),Sp=typeof self<"u"&&self.Blob&&new Blob([F1(wp)],{type:"text/javascript;charset=utf-8"});function U1(i){let e;try{if(e=Sp&&(self.URL||self.webkitURL).createObjectURL(Sp),!e)throw"";const t=new Worker(e,{name:i?.name});return t.addEventListener("error",()=>{(self.URL||self.webkitURL).revokeObjectURL(e)}),t}catch{return new Worker("data:text/javascript;base64,"+wp,{name:i?.name})}finally{e&&(self.URL||self.webkitURL).revokeObjectURL(e)}}async function B1(i,e,t){const s=O1();return await s("register",{fileId:i,filePath:e,mode:t}),{read:async(r,n)=>await s("read",{fileId:i,offset:r,size:n}),write:async(r,n)=>await s("write",{fileId:i,data:r,opts:n},[ArrayBuffer.isView(r)?r.buffer:r]),close:async()=>await s("close",{fileId:i}),truncate:async r=>await s("truncate",{fileId:i,newSize:r}),getSize:async()=>await s("getSize",{fileId:i}),flush:async()=>await s("flush",{fileId:i})}}const xr=[];let Nh=0;function O1(){if(xr.length<3){const e=i();return xr.push(e),e}else{const e=xr[Nh];return Nh=(Nh+1)%xr.length,e}function i(){const e=new U1;let t=0,s={};return e.onmessage=({data:r})=>{var n,o;r.evtType==="callback"?(n=s[r.cbId])==null||n.resolve(r.returnVal):r.evtType==="throwError"&&((o=s[r.cbId])==null||o.reject(Error(r.errMsg))),delete s[r.cbId]},async function(r,n,o=[]){t+=1;const a=new Promise((l,c)=>{s[t]={resolve:l,reject:c}});return e.postMessage({cbId:t,evtType:r,args:n},o),a}}}function vr(i){if(i==="/")return{parent:null,name:""};const e=i.split("/").filter(r=>r.length>0);if(e.length===0)throw Error("Invalid path");const t=e[e.length-1],s="/"+e.slice(0,-1).join("/");return{name:t,parent:s}}async function qt(i,e){const{parent:t,name:s}=vr(i);if(t==null)return await navigator.storage.getDirectory();const r=t.split("/").filter(n=>n.length>0);try{let n=await navigator.storage.getDirectory();for(const o of r)n=await n.getDirectoryHandle(o,{create:e.create});return e.isFile?await n.getFileHandle(s,{create:e.create}):await n.getDirectoryHandle(s,{create:e.create})}catch(n){if(n.name==="NotFoundError")return null;throw n}}async function Hh(i){const{parent:e,name:t}=vr(i);if(e==null){const r=await navigator.storage.getDirectory();for await(const n of r.keys())await r.removeEntry(n,{recursive:!0});return}const s=await qt(e,{create:!1,isFile:!1});if(s!=null)try{await s.removeEntry(t,{recursive:!0})}catch(r){if(r.name==="NotFoundError")return;throw r}}function Wh(i,e){return`${i}/${e}`.replace("//","/")}function Ai(i){return new Cp(i)}var wt,yr,cs;const D1=class $x{constructor(e){nt(this,wt),nt(this,yr),nt(this,cs),Ne(this,wt,e);const{parent:t,name:s}=vr(e);Ne(this,yr,s),Ne(this,cs,t)}get kind(){return"dir"}get name(){return Z(this,yr)}get path(){return Z(this,wt)}get parent(){return Z(this,cs)==null?null:Ai(Z(this,cs))}async create(){return await qt(Z(this,wt),{create:!0,isFile:!1}),Ai(Z(this,wt))}async exists(){return await qt(Z(this,wt),{create:!1,isFile:!1})instanceof FileSystemDirectoryHandle}async remove(e={}){for(const t of await this.children())try{await t.remove(e)}catch(s){console.warn(s)}try{await Hh(Z(this,wt))}catch(t){console.warn(t)}}async children(){const e=await qt(Z(this,wt),{create:!1,isFile:!1});if(e==null)return[];const t=[];for await(const s of e.values())t.push((s.kind==="file"?ai:Ai)(Wh(Z(this,wt),s.name)));return t}async copyTo(e){if(!await this.exists())throw Error(`dir ${this.path} not exists`);if(e instanceof $x){const t=await e.exists()?Ai(Wh(e.path,this.name)):e;return await t.create(),await Promise.all((await this.children()).map(s=>s.copyTo(t))),t}else if(e instanceof FileSystemDirectoryHandle)return await Promise.all((await this.children()).map(async t=>{t.kind==="file"?await t.copyTo(await e.getFileHandle(t.name,{create:!0})):await t.copyTo(await e.getDirectoryHandle(t.name,{create:!0}))})),null;throw Error("Illegal target type")}async moveTo(e){const t=await this.copyTo(e);return await this.remove(),t}};wt=new WeakMap,yr=new WeakMap,cs=new WeakMap;let Cp=D1;const Vh=new Map;function ai(i,e="rw"){if(e==="rw"){const t=Vh.get(i)??new Cr(i,e);return Vh.set(i,t),t}return new Cr(i,e)}async function Ei(i,e,t={overwrite:!0}){if(e instanceof Cr){await Ei(i,await e.stream(),t);return}const s=await(i instanceof Cr?i:ai(i,"rw")).createWriter();try{if(t.overwrite&&await s.truncate(0),e instanceof ReadableStream){const r=e.getReader();for(;;){const{done:n,value:o}=await r.read();if(n)break;await s.write(o)}}else await s.write(e)}catch(r){throw r}finally{await s.close()}}let G1=0;const z1=()=>++G1;var ot,hs,br,us,Tr,Mt,wr,Sr,Ii;const L1=class Xx{constructor(e,t){nt(this,ot),nt(this,hs),nt(this,br),nt(this,us),nt(this,Tr),nt(this,Mt,0),nt(this,wr,async()=>{}),nt(this,Sr,(()=>{let n=null;return()=>(Ne(this,Mt,Z(this,Mt)+1),n!=null||(n=new Promise(async(o,a)=>{try{const l=await B1(Z(this,Tr),Z(this,ot),Z(this,us));Ne(this,wr,async()=>{n!=null&&(n=null,Ne(this,Mt,0),await l.close().catch(console.error))}),o([l,async()=>{Ne(this,Mt,Z(this,Mt)-1),!(Z(this,Mt)>0)&&(n=null,await l.close())}])}catch(l){a(l)}})),n)})()),nt(this,Ii,!1),Ne(this,Tr,z1()),Ne(this,ot,e),Ne(this,us,{r:"read-only",rw:"readwrite","rw-unsafe":"readwrite-unsafe"}[t]);const{parent:s,name:r}=vr(e);if(s==null)throw Error("Invalid path");Ne(this,br,r),Ne(this,hs,s)}get kind(){return"file"}get path(){return Z(this,ot)}get name(){return Z(this,br)}get parent(){return Z(this,hs)==null?null:Ai(Z(this,hs))}async createWriter(){if(Z(this,us)==="read-only")throw Error("file is read-only");if(Z(this,Ii))throw Error("Other writer have not been closed");Ne(this,Ii,!0);try{const e=new TextEncoder,[t,s]=await Z(this,Sr).call(this);let r=await t.getSize(),n=!1;return{write:async(o,a={})=>{if(n)throw Error("Writer is closed");const l=typeof o=="string"?e.encode(o):o,c=a.at??r,h=l.byteLength;return r=c+h,await t.write(l,{at:c})},truncate:async o=>{if(n)throw Error("Writer is closed");await t.truncate(o),r>o&&(r=o)},flush:async()=>{if(n)throw Error("Writer is closed");await t.flush()},close:async()=>{if(n)throw Error("Writer is closed");n=!0,Ne(this,Ii,!1),await s()}}}catch(e){throw Ne(this,Ii,!1),e}}async createReader(){const[e,t]=await Z(this,Sr).call(this);let s=!1,r=0;return{read:async(n,o={})=>{if(s)throw Error("Reader is closed");const a=o.at??r,l=await e.read(a,n);return r=a+l.byteLength,l},getSize:async()=>{if(s)throw Error("Reader is closed");return await e.getSize()},close:async()=>{s||(s=!0,await t())}}}async text(){return new TextDecoder().decode(await this.arrayBuffer())}async arrayBuffer(){const e=await qt(Z(this,ot),{create:!1,isFile:!0});return e==null?new ArrayBuffer(0):(await e.getFile()).arrayBuffer()}async stream(){const e=await this.getOriginFile();return e==null?new ReadableStream({pull:t=>{t.close()}}):e.stream()}async getOriginFile(){var e;return(e=await qt(Z(this,ot),{create:!1,isFile:!0}))==null?void 0:e.getFile()}async getSize(){const e=await qt(Z(this,ot),{create:!1,isFile:!0});return e==null?0:(await e.getFile()).size}async exists(){return await qt(Z(this,ot),{create:!1,isFile:!0})instanceof FileSystemFileHandle}async remove(e={}){if(e.force===!0){await Z(this,wr).call(this),await Hh(Z(this,ot)),Vh.delete(Z(this,ot));return}if(Z(this,Mt)>0)throw Error("exists unclosed reader/writer");await Hh(Z(this,ot))}async copyTo(e){if(e instanceof Xx)return e.path===this.path?this:(await Ei(e,this),e);if(e instanceof Cp){if(!await this.exists())throw Error(`file ${this.path} not exists`);return await this.copyTo(ai(Wh(e.path,this.name)))}else if(e instanceof FileSystemFileHandle)return await(await this.stream()).pipeTo(await e.createWritable()),null;throw Error("Illegal target type")}async moveTo(e){const t=await this.copyTo(e);return await this.remove(),t}};ot=new WeakMap,hs=new WeakMap,br=new WeakMap,us=new WeakMap,Tr=new WeakMap,Mt=new WeakMap,wr=new WeakMap,Sr=new WeakMap,Ii=new WeakMap;let Cr=L1;const $h="/.opfs-tools-temp-dir";async function Ap(i){try{if(i.kind==="file"){if(!await i.exists())return!0;const e=await i.createWriter();await e.truncate(0),await e.close(),await i.remove()}else await i.remove();return!0}catch(e){return console.warn(e),!1}}function N1(){setInterval(async()=>{for(const i of await Ai($h).children()){const e=/^\d+-(\d+)$/.exec(i.name);(e==null||Date.now()-Number(e[1])>2592e5)&&await Ap(i)}},60*1e3)}const Xh=[];let Ep=!1;async function H1(){if(globalThis.localStorage==null)return;const i="OPFS_TOOLS_EXPIRES_TMP_FILES";Ep||(Ep=!0,globalThis.addEventListener("unload",()=>{Xh.length!==0&&localStorage.setItem(i,`${localStorage.getItem(i)??""},${Xh.join(",")}`)}));let e=localStorage.getItem(i)??"";for(const t of e.split(","))t.length!==0&&await Ap(ai(`${$h}/${t}`))&&(e=e.replace(t,""));localStorage.setItem(i,e.replace(/,{2,}/g,","))}(async function(){var i;globalThis.__opfs_tools_tmpfile_init__!==!0&&(globalThis.__opfs_tools_tmpfile_init__=!0,!(globalThis.FileSystemDirectoryHandle==null||globalThis.FileSystemFileHandle==null||((i=globalThis.navigator)==null?void 0:i.storage.getDirectory)==null)&&(N1(),await H1()))})();function Yh(){const i=`${Math.random().toString().slice(2)}-${Date.now()}`;return Xh.push(i),ai(`${$h}/${i}`)}const W1={0:"debug",1:"info",2:"warn",3:"error"};function V1(i){if(i instanceof Error)return String(i);if(typeof i=="object"&&i!==null)try{return JSON.stringify(i,(e,t)=>t instanceof Error?String(t):t)}catch{return String(i)}return String(i)}function $1(){const i=new Date,e=s=>s.toString().padStart(2,"0"),t=i.getMilliseconds().toString().padStart(3,"0");return`${e(i.getHours())}:${e(i.getMinutes())}:${e(i.getSeconds())}.${t}`}class X1{threshold=1;history=[];debug=(...e)=>this.log(0,console.debug,e);info=(...e)=>this.log(1,console.info,e);warn=(...e)=>this.log(2,console.warn,e);error=(...e)=>this.log(3,console.error,e);log(e,t,s){e>=this.threshold&&(t(...s),this.history.push({level:W1[e],time:$1(),args:s}))}setThreshold(e){this.threshold=e}getThreshold(){return this.threshold}createTagged(e){return{debug:(...t)=>this.debug(e,...t),info:(...t)=>this.info(e,...t),warn:(...t)=>this.warn(e,...t),error:(...t)=>this.error(e,...t)}}dump(){return this.history.map(({level:e,time:t,args:s})=>`[${e.toUpperCase()}][${t}] ${s.map(V1).join(" ")}`).join(`
`)}}const St=new X1,ee={debug:St.debug,info:St.info,warn:St.warn,error:St.error,setLogLevel:i=>{const e=i;e===ee.debug?St.setThreshold(0):e===ee.info?St.setThreshold(1):e===ee.warn?St.setThreshold(2):e===ee.error&&St.setThreshold(3)},create:i=>St.createTagged(i),dump:async()=>St.dump()};class Y1{constructor(e,t,s){this.length_=e,this.scaleFactor_=(e-1)/t,this.interpolate=this.cubic,s.method==="point"?this.interpolate=this.point:s.method==="linear"?this.interpolate=this.linear:s.method==="sinc"&&(this.interpolate=this.sinc),this.tangentFactor_=1-Math.max(0,Math.min(1,s.tension||0)),this.sincFilterSize_=s.sincFilterSize||1,this.kernel_=K1(s.sincWindow||q1)}point(e,t){return this.getClippedInput_(Math.round(this.scaleFactor_*e),t)}linear(e,t){e=this.scaleFactor_*e;let s=Math.floor(e);return e-=s,(1-e)*this.getClippedInput_(s,t)+e*this.getClippedInput_(s+1,t)}cubic(e,t){e=this.scaleFactor_*e;let s=Math.floor(e),r=[this.getTangent_(s,t),this.getTangent_(s+1,t)],n=[this.getClippedInput_(s,t),this.getClippedInput_(s+1,t)];e-=s;let o=e*e,a=e*o;return(2*a-3*o+1)*n[0]+(a-2*o+e)*r[0]+(-2*a+3*o)*n[1]+(a-o)*r[1]}sinc(e,t){e=this.scaleFactor_*e;let s=Math.floor(e),r=s-this.sincFilterSize_+1,n=s+this.sincFilterSize_,o=0;for(let a=r;a<=n;a++)o+=this.kernel_(e-a)*this.getClippedInput_(a,t);return o}getTangent_(e,t){return this.tangentFactor_*(this.getClippedInput_(e+1,t)-this.getClippedInput_(e-1,t))/2}getClippedInput_(e,t){return 0<=e&&e<this.length_?t[e]:0}}function q1(i){return Math.exp(-i/2*i/2)}function K1(i){return function(e){return j1(e)*i(e)}}function j1(i){return i===0?1:Math.sin(Math.PI*i)/(Math.PI*i)}class Z1{constructor(e,t,s){let r=2*Math.PI*s/t,n=0;this.filters=[];for(let o=0;o<=e;o++)o-e/2===0?this.filters[o]=r:(this.filters[o]=Math.sin(r*(o-e/2))/(o-e/2),this.filters[o]*=.54-.46*Math.cos(2*Math.PI*o/e)),n=n+this.filters[o];for(let o=0;o<=e;o++)this.filters[o]/=n;this.z=this.initZ_()}filter(e){this.z.buf[this.z.pointer]=e;let t=0;for(let s=0,r=this.z.buf.length;s<r;s++)t+=this.filters[s]*this.z.buf[(this.z.pointer+s)%this.z.buf.length];return this.z.pointer=(this.z.pointer+1)%this.z.buf.length,t}reset(){this.z=this.initZ_()}initZ_(){let e=[];for(let t=0;t<this.filters.length-1;t++)e.push(0);return{buf:e,pointer:0}}}class J1{constructor(e,t,s){let r=[];for(let n=0;n<e;n++)r.push(this.getCoeffs_({Fs:t,Fc:s,Q:.5/Math.sin(Math.PI/(e*2)*(n+.5))}));this.stages=[];for(let n=0;n<r.length;n++)this.stages[n]={b0:r[n].b[0],b1:r[n].b[1],b2:r[n].b[2],a1:r[n].a[0],a2:r[n].a[1],k:r[n].k,z:[0,0]}}filter(e){let t=e;for(let s=0,r=this.stages.length;s<r;s++)t=this.runStage_(s,t);return t}getCoeffs_(e){let t={};t.z=[0,0],t.a=[],t.b=[];let s=this.preCalc_(e,t);return t.k=1,t.b.push((1-s.cw)/(2*s.a0)),t.b.push(2*t.b[0]),t.b.push(t.b[0]),t}preCalc_(e,t){let s={},r=2*Math.PI*e.Fc/e.Fs;return s.alpha=Math.sin(r)/(2*e.Q),s.cw=Math.cos(r),s.a0=1+s.alpha,t.a0=s.a0,t.a.push(-2*s.cw/s.a0),t.k=1,t.a.push((1-s.alpha)/s.a0),s}runStage_(e,t){let s=t*this.stages[e].k-this.stages[e].a1*this.stages[e].z[0]-this.stages[e].a2*this.stages[e].z[1],r=this.stages[e].b0*s+this.stages[e].b1*this.stages[e].z[0]+this.stages[e].b2*this.stages[e].z[1];return this.stages[e].z[1]=this.stages[e].z[0],this.stages[e].z[0]=s,r}reset(){for(let e=0;e<this.stages.length;e++)this.stages[e].z=[0,0]}}const Q1={point:!1,linear:!1,cubic:!0,sinc:!0},Ip={IIR:16,FIR:71},ew={IIR:J1,FIR:Z1};function tw(i,e,t,s={}){let r=(t-e)/e+1,n=new Float64Array(i.length*r);s.method=s.method||"cubic";let o=new Y1(i.length,n.length,{method:s.method,tension:s.tension||0,sincFilterSize:s.sincFilterSize||6,sincWindow:s.sincWindow||void 0});if(s.LPF===void 0&&(s.LPF=Q1[s.method]),s.LPF){s.LPFType=s.LPFType||"IIR";const a=ew[s.LPFType];if(t>e){let l=new a(s.LPFOrder||Ip[s.LPFType],t,e/2);iw(i,n,o,l)}else{let l=new a(s.LPFOrder||Ip[s.LPFType],e,t/2);sw(i,n,o,l)}}else Pp(i,n,o);return n}function Pp(i,e,t){for(let s=0,r=e.length;s<r;s++)e[s]=t.interpolate(s,i)}function iw(i,e,t,s){for(let r=0,n=e.length;r<n;r++)e[r]=s.filter(t.interpolate(r,i));s.reset();for(let r=e.length-1;r>=0;r--)e[r]=s.filter(e[r])}function sw(i,e,t,s){for(let r=0,n=i.length;r<n;r++)i[r]=s.filter(i[r]);s.reset();for(let r=i.length-1;r>=0;r--)i[r]=s.filter(i[r]);Pp(i,e,t)}function rw(i){const e=new Float32Array(i.map(s=>s.length).reduce((s,r)=>s+r));let t=0;for(const s of i)e.set(s,t),t+=s.length;return e}function Rp(i){const e=[];for(let t=0;t<i.length;t+=1)for(let s=0;s<i[t].length;s+=1)e[s]==null&&(e[s]=[]),e[s].push(i[t][s]);return e.map(rw)}function kp(i){if(i.format==="f32-planar"){const e=[];for(let t=0;t<i.numberOfChannels;t+=1){const s=i.allocationSize({planeIndex:t}),r=new ArrayBuffer(s);i.copyTo(r,{planeIndex:t}),e.push(new Float32Array(r))}return e}else if(i.format==="f32"){const e=new ArrayBuffer(i.allocationSize({planeIndex:0}));return i.copyTo(e,{planeIndex:0}),ow(new Float32Array(e),i.numberOfChannels)}else if(i.format==="s16"){const e=new ArrayBuffer(i.allocationSize({planeIndex:0}));return i.copyTo(e,{planeIndex:0}),nw(new Int16Array(e),i.numberOfChannels)}throw Error("Unsupported audio data format")}function nw(i,e){const t=i.length/e,s=Array.from({length:e},()=>new Float32Array(t));for(let r=0;r<t;r++)for(let n=0;n<e;n++){const o=i[r*e+n];s[n][r]=o/32768}return s}function ow(i,e){const t=i.length/e,s=Array.from({length:e},()=>new Float32Array(t));for(let r=0;r<t;r++)for(let n=0;n<e;n++)s[n][r]=i[r*e+n];return s}function qh(i){return Array(i.numberOfChannels).fill(0).map((e,t)=>i.getChannelData(t))}function Mp(i){const e=Math.max(...i.map(s=>s[0]?.length??0)),t=new Float32Array(e*2);for(let s=0;s<e;s++){let r=0,n=0;for(let o=0;o<i.length;o++){const a=i[o][0]?.[s]??0,l=i[o][1]?.[s]??a;r+=a,n+=l}t[s]=r,t[s+e]=n}return t}async function aw(i,e,t){const s=i.length,r=Array(t.chanCount).fill(0).map(()=>new Float32Array(0));if(s===0)return r;const n=Math.max(...i.map(c=>c.length));if(n===0)return r;if(globalThis.OfflineAudioContext==null)return i.map(c=>new Float32Array(tw(c,e,t.rate,{method:"sinc",LPF:!1})));const o=new globalThis.OfflineAudioContext(t.chanCount,n*t.rate/e,t.rate),a=o.createBufferSource(),l=o.createBuffer(s,n,e);return i.forEach((c,h)=>l.copyToChannel(new Float32Array(c),h)),a.buffer=l,a.connect(o.destination),a.start(),qh(await o.startRendering())}function Kh(i,e,t){const s=t-e,r=new Float32Array(s);let n=0;for(;n<s;)r[n]=i[(e+n)%i.length],n+=1;return r}function Fp(i,e){const t=Math.floor(i.length/e),s=new Float32Array(t);for(let r=0;r<t;r++){const n=r*e,o=Math.floor(n),a=n-o;o+1<i.length?s[r]=i[o]*(1-a)+i[o+1]*a:s[r]=i[o]}return s}const lw=[{codec:"mp4a.40.2",codecType:"aac",sampleRate:48e3,channelCount:2},{codec:"opus",codecType:"opus",sampleRate:48e3,channelCount:2}];let Pi=null;function cw(){if(typeof navigator>"u")return"unknown";const i=navigator.userAgent.toLowerCase();return i.includes("linux")?"linux":i.includes("mac")?"macos":i.includes("win")?"windows":"unknown"}async function hw(i){if(typeof AudioEncoder>"u")return!1;try{return(await AudioEncoder.isConfigSupported({codec:i.codec,sampleRate:i.sampleRate,numberOfChannels:i.channelCount})).supported??!1}catch{return!1}}async function uw(){if(Pi!==null)return Pi;const i=cw();for(const t of lw)if(await hw(t))return Pi={...t},console.log(`[AudioCodec] Selected ${t.codec} for ${i}`),Pi;const e={codec:"opus",codecType:"opus",sampleRate:48e3,channelCount:2};return console.warn("[AudioCodec] No supported codec found, falling back to Opus"),Pi=e,e}function Ar(){return Pi}const dw=`#version 300 es
  layout (location = 0) in vec4 a_position;
  layout (location = 1) in vec2 a_texCoord;
  out vec2 v_texCoord;
  void main () {
    gl_Position = a_position;
    v_texCoord = a_texCoord;
  }
`,fw=`#version 300 es
precision mediump float;
out vec4 FragColor;
in vec2 v_texCoord;

uniform sampler2D frameTexture;
uniform vec3 keyColor;

// Chroma similarity calculation
uniform float similarity;
// Smoothness calculation for transparency
uniform float smoothness;
// Reduce green screen saturation to improve keying accuracy
uniform float spill;

vec2 RGBtoUV(vec3 rgb) {
  return vec2(
    rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5    + 0.5,
    rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081  + 0.5
  );
}

void main() {
  // Get current pixel RGBA value
  vec4 rgba = texture(frameTexture, v_texCoord);
  // Calculate chroma difference between current pixel and key color
  vec2 chromaVec = RGBtoUV(rgba.rgb) - RGBtoUV(keyColor);
  // Calculate chroma distance (vector length) between current pixel and key color, smaller distance means more similar
  float chromaDist = sqrt(dot(chromaVec, chromaVec));
  // Set similarity threshold, negative baseMask indicates green screen, positive indicates not green screen
  float baseMask = chromaDist - similarity;
  // If baseMask is negative, fullMask equals 0; if baseMask is positive, larger value means lower transparency
  float fullMask = pow(clamp(baseMask / smoothness, 0., 1.), 1.5);
  rgba.a = fullMask; // Set transparency
  // If baseMask is negative, spillVal equals 0; if baseMask is positive, smaller value means lower saturation
  float spillVal = pow(clamp(baseMask / spill, 0., 1.), 1.5);
  float desat = clamp(rgba.r * 0.2126 + rgba.g * 0.7152 + rgba.b * 0.0722, 0., 1.); // Calculate current pixel grayscale
  rgba.rgb = mix(vec3(desat, desat, desat), rgba.rgb, spillVal);
  FragColor = rgba;
}
`,pw=[-1,1,-1,-1,1,-1,1,-1,1,1,-1,1],mw=[0,1,0,0,1,0,1,0,1,1,0,1];function gw(i,e,t){const s=Up(i,i.VERTEX_SHADER,e),r=Up(i,i.FRAGMENT_SHADER,t),n=i.createProgram();if(i.attachShader(n,s),i.attachShader(n,r),i.linkProgram(n),!i.getProgramParameter(n,i.LINK_STATUS))throw Error(i.getProgramInfoLog(n)??"Unable to initialize the shader program");return n}function Up(i,e,t){const s=i.createShader(e);if(i.shaderSource(s,t),i.compileShader(s),!i.getShaderParameter(s,i.COMPILE_STATUS)){const r=i.getShaderInfoLog(s);throw i.deleteShader(s),Error(r??"An error occurred compiling the shaders")}return s}function _w(i,e,t){i.bindTexture(i.TEXTURE_2D,t),i.texImage2D(i.TEXTURE_2D,0,i.RGBA,i.RGBA,i.UNSIGNED_BYTE,e),i.drawArrays(i.TRIANGLES,0,6)}function xw(i){const e=i.createTexture();if(e==null)throw Error("Create WebGL texture error");i.bindTexture(i.TEXTURE_2D,e);const t=0,s=i.RGBA,r=1,n=1,o=0,a=i.RGBA,l=i.UNSIGNED_BYTE,c=new Uint8Array([0,0,255,255]);return i.texImage2D(i.TEXTURE_2D,t,s,r,n,o,a,l,c),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),e}function vw(i){const e="document"in globalThis?globalThis.document.createElement("canvas"):new OffscreenCanvas(i.width,i.height);e.width=i.width,e.height=i.height;const t=e.getContext("webgl2",{premultipliedAlpha:!1,alpha:!0});if(t==null)throw Error("Cant create gl context");const s=gw(t,dw,fw);t.useProgram(s),t.uniform3fv(t.getUniformLocation(s,"keyColor"),i.keyColor.map(l=>l/255)),t.uniform1f(t.getUniformLocation(s,"similarity"),i.similarity),t.uniform1f(t.getUniformLocation(s,"smoothness"),i.smoothness),t.uniform1f(t.getUniformLocation(s,"spill"),i.spill);const r=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,r),t.bufferData(t.ARRAY_BUFFER,new Float32Array(pw),t.STATIC_DRAW);const n=t.getAttribLocation(s,"a_position");t.vertexAttribPointer(n,2,t.FLOAT,!1,Float32Array.BYTES_PER_ELEMENT*2,0),t.enableVertexAttribArray(n);const o=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,o),t.bufferData(t.ARRAY_BUFFER,new Float32Array(mw),t.STATIC_DRAW);const a=t.getAttribLocation(s,"a_texCoord");return t.vertexAttribPointer(a,2,t.FLOAT,!1,Float32Array.BYTES_PER_ELEMENT*2,0),t.enableVertexAttribArray(a),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,1),{canvas:e,gl:t}}function yw(i){return i instanceof VideoFrame?{width:i.codedWidth,height:i.codedHeight}:{width:i.width,height:i.height}}function bw(i){const t=new OffscreenCanvas(1,1).getContext("2d");t.drawImage(i,0,0);const{data:[s,r,n]}=t.getImageData(0,0,1,1);return[s,r,n]}const Tw=i=>{let e=null,t=null,s=i.keyColor,r=null;return async n=>{if((e==null||t==null||r==null)&&(s==null&&(s=bw(n)),{canvas:e,gl:t}=vw({...yw(n),keyColor:s,...i}),r=xw(t)),_w(t,n,r),globalThis.VideoFrame!=null&&n instanceof globalThis.VideoFrame){const o=new VideoFrame(e,{alpha:"keep",timestamp:n.timestamp,duration:n.duration??void 0});return n.close(),o}return createImageBitmap(e,{imageOrientation:n instanceof ImageBitmap?"flipY":"none"})}},ww=()=>{let i,e=16.6;self.onmessage=t=>{t.data.event==="start"&&(self.clearInterval(i),i=self.setInterval(()=>{self.postMessage({})},e)),t.data.event==="stop"&&self.clearInterval(i)}},Sw=()=>{const i=new Blob([`(${ww.toString()})()`]),e=URL.createObjectURL(i);return new Worker(e)},Ri=new Map;let jh=1,Er=null;globalThis.Worker!=null&&(Er=Sw(),Er.onmessage=()=>{jh+=1;for(const[i,e]of Ri)if(jh%i===0)for(const t of e)t()});const Cw=(i,e)=>{const t=Math.round(e/16.6),s=Ri.get(t)??new Set;return s.add(i),Ri.set(t,s),Ri.size===1&&s.size===1&&Er?.postMessage({event:"start"}),()=>{s.delete(i),s.size===0&&Ri.delete(t),Ri.size===0&&(jh=0,Er?.postMessage({event:"stop"}))}};function Zh(i){return new Promise(e=>{const t=Cw(()=>{t(),e()},i)})}function Aw(i){return document.createElement(i)}function Ew(i){var e="",t=new Uint8Array(i),s=t.byteLength;for(let r=0;r<s;r++)e+=String.fromCharCode(t[r]);return window.btoa(e)}async function Iw(i,e,t={}){const s=Aw("pre");s.style.cssText=`margin: 0; ${e}; position: fixed;`,s.textContent=i,document.body.appendChild(s),t.onCreated?.(s);const{width:r,height:n}=s.getBoundingClientRect();s.remove();const o=new Image;o.width=r,o.height=n;const a=t.font==null?"":`
    @font-face {
      font-family: '${t.font.name}';
      src: url('data:font/woff2;base64,${Ew(await(await fetch(t.font.url)).arrayBuffer())}') format('woff2');
    }
  `,l=`
    <svg xmlns="http://www.w3.org/2000/svg" width="${r}" height="${n}">
      <style>
        ${a}
      </style>
      <foreignObject width="100%" height="100%">
        <div xmlns="http://www.w3.org/1999/xhtml">${s.outerHTML}</div>
      </foreignObject>
    </svg>
  `.replace(/\t/g,"").replace(/#/g,"%23");return o.src=`data:image/svg+xml;charset=utf-8,${l}`,await new Promise(c=>{o.onload=c}),o}async function Pw(i,e,t={}){const s=await Iw(i,e,t),r=new OffscreenCanvas(s.width,s.height);return r.getContext("2d")?.drawImage(s,0,0,s.width,s.height),await createImageBitmap(r)}async function Rw(i,e){const t={type:e,data:i},s=new ImageDecoder(t);await Promise.all([s.completed,s.tracks.ready]);const r=s.tracks.selectedTrack?.frameCount??1,n=[];for(let o=0;o<r;o+=1)n.push((await s.decode({frameIndex:o})).image);return n}let Jh=class{all=new Map;on(e,t){const s=this.all.get(e);return s?s.push(t):this.all.set(e,[t]),()=>this.off(e,t)}once(e,t){const s=this.on(e,r=>{s(),t(r)});return s}off(e,t){const s=this.all.get(e);s&&(t?s.splice(s.indexOf(t)>>>0,1):this.all.set(e,[]))}emit(e,t){let s=this.all.get(e);s&&s.slice().forEach(r=>{r(t)}),s=this.all.get("*"),s&&s.slice().forEach(r=>{r(e,t)})}};class kw extends Jh{id="";display={from:0,to:0};duration=0;playbackRate=1;trim={from:0,to:0};constructor(){super()}_left=0;get left(){return this._left}set left(e){const t=this._left!==e;this._left=e,t&&this.emit("propsChange",{left:e})}_top=0;get top(){return this._top}set top(e){const t=this._top!==e;this._top=e,t&&this.emit("propsChange",{top:e})}_width=0;get width(){return this._width}set width(e){const t=this._width!==e;this._width=e,t&&this.emit("propsChange",{width:e})}_height=0;get height(){return this._height}set height(e){const t=this._height!==e;this._height=e,t&&this.emit("propsChange",{height:e})}_angle=0;get angle(){return this._angle}set angle(e){const t=this._angle!==e;this._angle=e,t&&this.emit("propsChange",{angle:e})}get center(){return{x:this.left+this.width/2,y:this.top+this.height/2}}_zIndex=0;get zIndex(){return this._zIndex}set zIndex(e){const t=this._zIndex!==e;this._zIndex=e,t&&this.emit("propsChange",{zIndex:e})}_opacity=1;get opacity(){return this._opacity}set opacity(e){const t=this._opacity!==e;this._opacity=e,t&&this.emit("propsChange",{opacity:e})}_volume=1;get volume(){return this._volume}set volume(e){const t=this._volume!==e;this._volume=e,t&&this.emit("propsChange",{volume:e})}flip=null;effects=[];_style={};get style(){return this._style}set style(e){this._style=e}animatKeyFrame=null;animatOpts=null;ready=Promise.resolve();_render(e){const{center:t}=this;e.setTransform(this.flip==="horizontal"?-1:1,0,0,this.flip==="vertical"?-1:1,t.x,t.y);const s=this.angle*Math.PI/180;e.rotate((this.flip==null?1:-1)*s),e.globalAlpha=this.opacity}setAnimation(e,t){this.animatKeyFrame=Object.entries(e).map(([s,r])=>{const n={from:0,to:100}[s]??Number(s.slice(0,-1));if(isNaN(n)||n>100||n<0)throw Error("keyFrame must between 0~100");return[n/100,r]}),this.animatOpts=Object.assign({},this.animatOpts,{duration:t.duration,delay:t.delay??0,iterCount:t.iterCount??1/0})}animate(e){if(this.animatKeyFrame==null||this.animatOpts==null||e<this.animatOpts.delay)return;const t=Mw(e,this.animatKeyFrame,this.animatOpts);for(const s in t)switch(s){case"opacity":this.opacity=t[s];break;case"x":this.left=t[s];break;case"y":this.top=t[s];break;case"w":this.width=t[s];break;case"h":this.height=t[s];break;case"angle":this.angle=t[s];break}}copyStateTo(e){e.animatKeyFrame=this.animatKeyFrame,e.animatOpts=this.animatOpts,e.zIndex=this.zIndex,e.opacity=this.opacity,e.volume=this.volume,e.flip=this.flip,e.left=this.left,e.top=this.top,e.width=this.width,e.height=this.height,e.angle=this.angle,e.display={...this.display},e.duration=this.duration,e.playbackRate=this.playbackRate,e.trim={...this.trim},e.style=JSON.parse(JSON.stringify(this.style||{})),"src"in this&&"src"in e&&(e.src=this.src)}update(e){Object.assign(this,e),this.emit("propsChange",e)}destroy(){this.all.clear()}}function Mw(i,e,t){const s=i-t.delay,r=s%t.duration,n=s/t.duration>=t.iterCount||s===t.duration?1:r/t.duration,o=e.findIndex(f=>f[0]>=n);if(o===-1)return{};const a=e[o-1],l=e[o],c=l[1];if(a==null)return c;const h=a[1],u={},d=(n-a[0])/(l[0]-a[0]);for(const f in c){if(!Object.hasOwn(c,f)||typeof f!="string")continue;const m=f;h[m]!=null&&(u[m]=(c[m]-h[m])*d+h[m])}return u}class Kt extends kw{lastVf=null;destroyed=!1;src="";transition;constructor(){super()}async getFrame(e){const t=e*this.playbackRate,{video:s,audio:r,state:n}=await this.tick(t);let o=r??[];r!=null&&this.playbackRate!==1&&(o=r.map(l=>Fp(l,this.playbackRate)));let a=null;return s!=null?(this.lastVf?.close(),s instanceof VideoFrame?(a=await createImageBitmap(s),s.close()):a=s,this.lastVf=a):this.lastVf!=null&&(a=this.lastVf),{video:a,audio:o,done:n==="done"}}async offscreenRender(e,t){const s=t*this.playbackRate;this.animate(s),super._render(e);const{width:r,height:n}=this,{video:o,audio:a,state:l}=await this.tick(s);let c=a??[];if(a!=null&&this.playbackRate!==1&&(c=a.map(u=>Fp(u,this.playbackRate))),l==="done")return{audio:c,done:!0};const h=o??this.lastVf;if(h!=null){const u=this.style.borderRadius||0,d=this.style.dropShadow;if(e.save(),d&&(d.blur>0||d.distance>0)){const m=d.distance??0,g=d.angle??0;e.shadowColor=d.color||"#000000",e.shadowBlur=d.blur||0,e.shadowOffsetX=Math.cos(g)*m,e.shadowOffsetY=Math.sin(g)*m}if(u>0){const m=Math.min(u,r/2,n/2);e.beginPath(),e.roundRect(-r/2,-n/2,r,n,m),e.clip()}e.drawImage(h,-r/2,-n/2,r,n),e.restore();const f=this.style.stroke;if(f&&f.width>0){if(e.save(),e.strokeStyle=f.color,e.lineWidth=f.width,u>0){const m=Math.min(u,r/2,n/2);e.beginPath(),e.roundRect(-r/2,-n/2,r,n,m),e.stroke()}else e.strokeRect(-r/2,-n/2,r,n);e.restore()}}return o!=null&&(this.lastVf?.close(),o instanceof ImageBitmap&&(this.lastVf=o)),{audio:c,done:!1}}set(e,t=30){if(e.display&&(e.display.from!==void 0&&(this.display.from=e.display.from<1e6?e.display.from/t*1e6:e.display.from),e.display.to!==void 0&&(this.display.to=e.display.to<1e6?e.display.to/t*1e6:e.display.to)),e.x!==void 0&&(this.left=e.x),e.y!==void 0&&(this.top=e.y),e.width!==void 0&&(this.width=e.width),e.height!==void 0&&(this.height=e.height),e.duration!==void 0){const s=e.duration<1e6?e.duration/t*1e6:e.duration;this.duration=s,this.display.from!==void 0&&(this.display.to=this.display.from+s)}return this}toJSON(e=!1){const t=this.animatKeyFrame&&this.animatOpts?{keyFrames:this.animatKeyFrame.reduce((s,[r,n])=>{const o=r===0?"from":r===1?"to":`${Math.round(r*100)}%`;return s[o]=n,s},{}),opts:this.animatOpts}:void 0;return{type:this.constructor.name,src:this.src,display:{from:this.display.from,to:this.display.to},playbackRate:this.playbackRate,duration:this.duration,left:this.left,top:this.top,width:this.width,height:this.height,angle:this.angle,zIndex:this.zIndex,opacity:this.opacity,flip:this.flip,style:this.style,trim:{from:this.trim.from,to:this.trim.to},...t&&{animation:t},...e&&{main:!0}}}getVisibleHandles(){return["tl","tr","bl","br","ml","mr","mt","mb","rot"]}async scaleToFit(e,t){await this.ready;const{width:s,height:r}=this.meta;if(s===0||r===0)return;const n=Math.min(e/s,t/r);this.width=s*n,this.height=r*n}async scaleToFill(e,t){await this.ready;const{width:s,height:r}=this.meta;if(s===0||r===0)return;const n=Math.max(e/s,t/r);this.width=s*n,this.height=r*n}centerInScene(e,t){this.left=(e-this.width)/2,this.top=(t-this.height)/2}destroy(){this.destroyed||(this.destroyed=!0,ee.info("BaseClip destroy"),super.destroy(),this.lastVf?.close(),this.lastVf=null)}}let Qh=null;async function Bp(){return Qh===null&&(Qh=uw()),await Qh}const he={get codec(){return Ar()?.codec??"mp4a.40.2"},get codecType(){return Ar()?.codecType??"aac"},get sampleRate(){return Ar()?.sampleRate??48e3},get channelCount(){return Ar()?.channelCount??2}};class je extends Kt{type="Audio";static ctx=null;ready;_meta={duration:0,width:0,height:0};get meta(){return{...this._meta,sampleRate:he.sampleRate,chanCount:2}}chan0Buf=new Float32Array;chan1Buf=new Float32Array;getPCMData(){return[this.chan0Buf,this.chan1Buf]}opts;loop=!1;static async fromUrl(e,t={}){const s=await fetch(e);if(!s.ok)throw new Error(`Failed to fetch audio from ${e}: ${s.status} ${s.statusText}`);const r=new je(s.body,t,e);return await r.ready,r}static async fromObject(e){if(e.type!=="Audio")throw new Error(`Expected Audio, got ${e.type}`);if(!e.src||e.src.trim()==="")throw new Error("AudioClip requires a valid source URL");const t={};e.loop!==void 0&&(t.loop=e.loop),e.volume!==void 0&&(t.volume=e.volume);const s=await je.fromUrl(e.src,t);return s.left=e.left,s.top=e.top,s.width=e.width,s.height=e.height,s.angle=e.angle,s.display.from=e.display.from,s.display.to=e.display.to,s.duration=e.duration,s.playbackRate=e.playbackRate,s.zIndex=e.zIndex,s.opacity=e.opacity,s.flip=e.flip,e.animation&&s.setAnimation(e.animation.keyFrames,e.animation.opts),s}constructor(e,t={},s){super(),this.src=s!==void 0?s:"",this.opts={loop:!1,volume:1,...t},this.loop=this.opts.loop??!1,this.volume=this.opts.volume??1,this.ready=this.init(e).then(r=>{const n={width:0,height:0,duration:t.loop?1/0:this._meta.duration};return this.width=this.width===0?n.width:this.width,this.height=this.height===0?n.height:this.height,this.duration=this.duration===0?n.duration:this.duration,this.display.to=this.display.from+this.duration,n})}async init(e){je.ctx==null&&(je.ctx=new AudioContext({sampleRate:he.sampleRate}));const t=performance.now(),s=e instanceof ReadableStream?await Uw(e,je.ctx):e;ee.info("Audio clip decoded complete:",performance.now()-t),this._meta.duration=s[0].length/he.sampleRate*1e6,this.chan0Buf=s[0],this.chan1Buf=s[1]??this.chan0Buf,ee.info("Audio clip convert to AudioData, time:",performance.now()-t)}tickInterceptor=async(e,t)=>t;timestamp=0;frameOffset=0;async tick(e){if(!this.opts.loop&&e>=this._meta.duration)return await this.tickInterceptor(e,{audio:[],state:"done"});const t=e-this.timestamp;if(e<this.timestamp||t>3e6)return this.timestamp=e,this.frameOffset=Math.ceil(this.timestamp/1e6*he.sampleRate),await this.tickInterceptor(e,{audio:[new Float32Array(0),new Float32Array(0)],state:"success"});this.timestamp=e;const s=Math.ceil(t/1e6*he.sampleRate),r=this.frameOffset+s,n=this.opts.loop?[Kh(this.chan0Buf,this.frameOffset,r),Kh(this.chan1Buf,this.frameOffset,r)]:[this.chan0Buf.slice(this.frameOffset,r),this.chan1Buf.slice(this.frameOffset,r)];if(this.volume!==1)for(const o of n)for(let a=0;a<o.length;a++)o[a]*=this.volume;return this.frameOffset=r,await this.tickInterceptor(e,{audio:n,state:"success"})}async split(e){await this.ready;const t=Math.ceil(e/1e6*he.sampleRate),s=new je(this.getPCMData().map(n=>n.slice(0,t)),this.opts,this.src),r=new je(this.getPCMData().map(n=>n.slice(t)),this.opts,this.src);return[s,r]}async clone(){await this.ready;const e=new je(this.getPCMData(),this.opts,this.src);return await e.ready,this.copyStateTo(e),e}destroy(){this.chan0Buf=new Float32Array(0),this.chan1Buf=new Float32Array(0),ee.info("---- audioclip destroy ----"),super.destroy()}toJSON(e=!1){return{...super.toJSON(e),type:"Audio",loop:this.loop,id:this.id,volume:this.volume}}static concatAudioClip=Fw;async createPlaybackElement(){if(await this.ready,!this.src||this.src.trim()==="")throw new Error("AudioClip requires a source URL for playback");const e=this.src.startsWith("blob:")?this.src:void 0,t=document.createElement("audio");return t.crossOrigin="anonymous",t.autoplay=!1,t.preload="auto",t.loop=this.opts.loop||!1,t.src=this.src,await new Promise((s,r)=>{const n=()=>{t.removeEventListener("loadeddata",n),t.removeEventListener("error",o),t.pause(),t.currentTime=0,s()},o=()=>{t.removeEventListener("loadeddata",n),t.removeEventListener("error",o),r(new Error("Failed to load audio"))};t.addEventListener("loadeddata",n,{once:!0}),t.addEventListener("error",o,{once:!0}),t.load()}),{element:t,objectUrl:e}}async play(e,t){const s=e;if(Math.abs(s.currentTime-t)>.1&&(s.currentTime=t),s.paused)try{await s.play()}catch{try{await s.play()}catch(n){console.warn("Failed to play audio:",n)}}}pause(e){e.pause()}async seek(e,t){const s=e;return s.pause(),s.currentTime=t,new Promise(r=>{if(Math.abs(s.currentTime-t)<.01){r();return}const n=()=>{s.removeEventListener("seeked",n),r()};s.addEventListener("seeked",n,{once:!0}),setTimeout(()=>{s.removeEventListener("seeked",n),r()},500)})}syncPlayback(e,t,s){const r=e,n=this.meta.duration/1e6,o=s>=0&&s<n;r.volume=this.volume,t&&o?r.paused&&this.play(r,s).catch(console.warn):(r.paused||r.pause(),o&&Math.abs(r.currentTime-s)>.1&&(r.currentTime=s))}cleanupPlayback(e,t){const s=e;s.pause(),s.removeAttribute("src"),s.load(),t&&t.startsWith("blob:")&&URL.revokeObjectURL(t)}}async function Fw(i,e){const t=[];for(const s of i)await s.ready,t.push(s.getPCMData());return new je(Rp(t),e)}async function Uw(i,e){const t=await new Response(i).arrayBuffer();return qh(await e.decodeAudioData(t))}var b=(i=>(i.Application="application",i.WebGLPipes="webgl-pipes",i.WebGLPipesAdaptor="webgl-pipes-adaptor",i.WebGLSystem="webgl-system",i.WebGPUPipes="webgpu-pipes",i.WebGPUPipesAdaptor="webgpu-pipes-adaptor",i.WebGPUSystem="webgpu-system",i.CanvasSystem="canvas-system",i.CanvasPipesAdaptor="canvas-pipes-adaptor",i.CanvasPipes="canvas-pipes",i.Asset="asset",i.LoadParser="load-parser",i.ResolveParser="resolve-parser",i.CacheParser="cache-parser",i.DetectionParser="detection-parser",i.MaskEffect="mask-effect",i.BlendMode="blend-mode",i.TextureSource="texture-source",i.Environment="environment",i.ShapeBuilder="shape-builder",i.Batcher="batcher",i))(b||{});const eu=i=>{if(typeof i=="function"||typeof i=="object"&&i.extension){if(!i.extension)throw new Error("Extension class must have an extension object");i={...typeof i.extension!="object"?{type:i.extension}:i.extension,ref:i}}if(typeof i=="object")i={...i};else throw new Error("Invalid extension type");return typeof i.type=="string"&&(i.type=[i.type]),i},Ir=(i,e)=>eu(i).priority??e,V={_addHandlers:{},_removeHandlers:{},_queue:{},remove(...i){return i.map(eu).forEach(e=>{e.type.forEach(t=>this._removeHandlers[t]?.(e))}),this},add(...i){return i.map(eu).forEach(e=>{e.type.forEach(t=>{const s=this._addHandlers,r=this._queue;s[t]?s[t]?.(e):(r[t]=r[t]||[],r[t]?.push(e))})}),this},handle(i,e,t){const s=this._addHandlers,r=this._removeHandlers;if(s[i]||r[i])throw new Error(`Extension type ${i} already has a handler`);s[i]=e,r[i]=t;const n=this._queue;return n[i]&&(n[i]?.forEach(o=>e(o)),delete n[i]),this},handleByMap(i,e){return this.handle(i,t=>{t.name&&(e[t.name]=t.ref)},t=>{t.name&&delete e[t.name]})},handleByNamedList(i,e,t=-1){return this.handle(i,s=>{e.findIndex(n=>n.name===s.name)>=0||(e.push({name:s.name,value:s.ref}),e.sort((n,o)=>Ir(o.value,t)-Ir(n.value,t)))},s=>{const r=e.findIndex(n=>n.name===s.name);r!==-1&&e.splice(r,1)})},handleByList(i,e,t=-1){return this.handle(i,s=>{e.includes(s.ref)||(e.push(s.ref),e.sort((r,n)=>Ir(n,t)-Ir(r,t)))},s=>{const r=e.indexOf(s.ref);r!==-1&&e.splice(r,1)})},mixin(i,...e){for(const t of e)Object.defineProperties(i.prototype,Object.getOwnPropertyDescriptors(t))}},Bw={extension:{type:b.Environment,name:"browser",priority:-1},test:()=>!0,load:async()=>{await Promise.resolve().then(()=>_M)}},Ow={extension:{type:b.Environment,name:"webworker",priority:0},test:()=>typeof self<"u"&&self.WorkerGlobalScope!==void 0,load:async()=>{await Promise.resolve().then(()=>xM)}};class Ue{constructor(e,t,s){this._x=t||0,this._y=s||0,this._observer=e}clone(e){return new Ue(e??this._observer,this._x,this._y)}set(e=0,t=e){return(this._x!==e||this._y!==t)&&(this._x=e,this._y=t,this._observer._onUpdate(this)),this}copyFrom(e){return(this._x!==e.x||this._y!==e.y)&&(this._x=e.x,this._y=e.y,this._observer._onUpdate(this)),this}copyTo(e){return e.set(this._x,this._y),e}equals(e){return e.x===this._x&&e.y===this._y}toString(){return`[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`}get x(){return this._x}set x(e){this._x!==e&&(this._x=e,this._observer._onUpdate(this))}get y(){return this._y}set y(e){this._y!==e&&(this._y=e,this._observer._onUpdate(this))}}function tu(i){return i&&i.__esModule&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i}var iu={exports:{}},Op;function Dw(){return Op||(Op=1,(function(i){var e=Object.prototype.hasOwnProperty,t="~";function s(){}Object.create&&(s.prototype=Object.create(null),new s().__proto__||(t=!1));function r(l,c,h){this.fn=l,this.context=c,this.once=h||!1}function n(l,c,h,u,d){if(typeof h!="function")throw new TypeError("The listener must be a function");var f=new r(h,u||l,d),m=t?t+c:c;return l._events[m]?l._events[m].fn?l._events[m]=[l._events[m],f]:l._events[m].push(f):(l._events[m]=f,l._eventsCount++),l}function o(l,c){--l._eventsCount===0?l._events=new s:delete l._events[c]}function a(){this._events=new s,this._eventsCount=0}a.prototype.eventNames=function(){var c=[],h,u;if(this._eventsCount===0)return c;for(u in h=this._events)e.call(h,u)&&c.push(t?u.slice(1):u);return Object.getOwnPropertySymbols?c.concat(Object.getOwnPropertySymbols(h)):c},a.prototype.listeners=function(c){var h=t?t+c:c,u=this._events[h];if(!u)return[];if(u.fn)return[u.fn];for(var d=0,f=u.length,m=new Array(f);d<f;d++)m[d]=u[d].fn;return m},a.prototype.listenerCount=function(c){var h=t?t+c:c,u=this._events[h];return u?u.fn?1:u.length:0},a.prototype.emit=function(c,h,u,d,f,m){var g=t?t+c:c;if(!this._events[g])return!1;var p=this._events[g],_=arguments.length,x,v;if(p.fn){switch(p.once&&this.removeListener(c,p.fn,void 0,!0),_){case 1:return p.fn.call(p.context),!0;case 2:return p.fn.call(p.context,h),!0;case 3:return p.fn.call(p.context,h,u),!0;case 4:return p.fn.call(p.context,h,u,d),!0;case 5:return p.fn.call(p.context,h,u,d,f),!0;case 6:return p.fn.call(p.context,h,u,d,f,m),!0}for(v=1,x=new Array(_-1);v<_;v++)x[v-1]=arguments[v];p.fn.apply(p.context,x)}else{var y=p.length,T;for(v=0;v<y;v++)switch(p[v].once&&this.removeListener(c,p[v].fn,void 0,!0),_){case 1:p[v].fn.call(p[v].context);break;case 2:p[v].fn.call(p[v].context,h);break;case 3:p[v].fn.call(p[v].context,h,u);break;case 4:p[v].fn.call(p[v].context,h,u,d);break;default:if(!x)for(T=1,x=new Array(_-1);T<_;T++)x[T-1]=arguments[T];p[v].fn.apply(p[v].context,x)}}return!0},a.prototype.on=function(c,h,u){return n(this,c,h,u,!1)},a.prototype.once=function(c,h,u){return n(this,c,h,u,!0)},a.prototype.removeListener=function(c,h,u,d){var f=t?t+c:c;if(!this._events[f])return this;if(!h)return o(this,f),this;var m=this._events[f];if(m.fn)m.fn===h&&(!d||m.once)&&(!u||m.context===u)&&o(this,f);else{for(var g=0,p=[],_=m.length;g<_;g++)(m[g].fn!==h||d&&!m[g].once||u&&m[g].context!==u)&&p.push(m[g]);p.length?this._events[f]=p.length===1?p[0]:p:o(this,f)}return this},a.prototype.removeAllListeners=function(c){var h;return c?(h=t?t+c:c,this._events[h]&&o(this,h)):(this._events=new s,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=t,a.EventEmitter=a,i.exports=a})(iu)),iu.exports}var Gw=Dw();const Ze=tu(Gw),zw=Math.PI*2,Lw=180/Math.PI,Nw=Math.PI/180;class X{constructor(e=0,t=0){this.x=0,this.y=0,this.x=e,this.y=t}clone(){return new X(this.x,this.y)}copyFrom(e){return this.set(e.x,e.y),this}copyTo(e){return e.set(this.x,this.y),e}equals(e){return e.x===this.x&&e.y===this.y}set(e=0,t=e){return this.x=e,this.y=t,this}toString(){return`[pixi.js/math:Point x=${this.x} y=${this.y}]`}static get shared(){return su.x=0,su.y=0,su}}const su=new X;class O{constructor(e=1,t=0,s=0,r=1,n=0,o=0){this.array=null,this.a=e,this.b=t,this.c=s,this.d=r,this.tx=n,this.ty=o}fromArray(e){this.a=e[0],this.b=e[1],this.c=e[3],this.d=e[4],this.tx=e[2],this.ty=e[5]}set(e,t,s,r,n,o){return this.a=e,this.b=t,this.c=s,this.d=r,this.tx=n,this.ty=o,this}toArray(e,t){this.array||(this.array=new Float32Array(9));const s=t||this.array;return e?(s[0]=this.a,s[1]=this.b,s[2]=0,s[3]=this.c,s[4]=this.d,s[5]=0,s[6]=this.tx,s[7]=this.ty,s[8]=1):(s[0]=this.a,s[1]=this.c,s[2]=this.tx,s[3]=this.b,s[4]=this.d,s[5]=this.ty,s[6]=0,s[7]=0,s[8]=1),s}apply(e,t){t=t||new X;const s=e.x,r=e.y;return t.x=this.a*s+this.c*r+this.tx,t.y=this.b*s+this.d*r+this.ty,t}applyInverse(e,t){t=t||new X;const s=this.a,r=this.b,n=this.c,o=this.d,a=this.tx,l=this.ty,c=1/(s*o+n*-r),h=e.x,u=e.y;return t.x=o*c*h+-n*c*u+(l*n-a*o)*c,t.y=s*c*u+-r*c*h+(-l*s+a*r)*c,t}translate(e,t){return this.tx+=e,this.ty+=t,this}scale(e,t){return this.a*=e,this.d*=t,this.c*=e,this.b*=t,this.tx*=e,this.ty*=t,this}rotate(e){const t=Math.cos(e),s=Math.sin(e),r=this.a,n=this.c,o=this.tx;return this.a=r*t-this.b*s,this.b=r*s+this.b*t,this.c=n*t-this.d*s,this.d=n*s+this.d*t,this.tx=o*t-this.ty*s,this.ty=o*s+this.ty*t,this}append(e){const t=this.a,s=this.b,r=this.c,n=this.d;return this.a=e.a*t+e.b*r,this.b=e.a*s+e.b*n,this.c=e.c*t+e.d*r,this.d=e.c*s+e.d*n,this.tx=e.tx*t+e.ty*r+this.tx,this.ty=e.tx*s+e.ty*n+this.ty,this}appendFrom(e,t){const s=e.a,r=e.b,n=e.c,o=e.d,a=e.tx,l=e.ty,c=t.a,h=t.b,u=t.c,d=t.d;return this.a=s*c+r*u,this.b=s*h+r*d,this.c=n*c+o*u,this.d=n*h+o*d,this.tx=a*c+l*u+t.tx,this.ty=a*h+l*d+t.ty,this}setTransform(e,t,s,r,n,o,a,l,c){return this.a=Math.cos(a+c)*n,this.b=Math.sin(a+c)*n,this.c=-Math.sin(a-l)*o,this.d=Math.cos(a-l)*o,this.tx=e-(s*this.a+r*this.c),this.ty=t-(s*this.b+r*this.d),this}prepend(e){const t=this.tx;if(e.a!==1||e.b!==0||e.c!==0||e.d!==1){const s=this.a,r=this.c;this.a=s*e.a+this.b*e.c,this.b=s*e.b+this.b*e.d,this.c=r*e.a+this.d*e.c,this.d=r*e.b+this.d*e.d}return this.tx=t*e.a+this.ty*e.c+e.tx,this.ty=t*e.b+this.ty*e.d+e.ty,this}decompose(e){const t=this.a,s=this.b,r=this.c,n=this.d,o=e.pivot,a=-Math.atan2(-r,n),l=Math.atan2(s,t),c=Math.abs(a+l);return c<1e-5||Math.abs(zw-c)<1e-5?(e.rotation=l,e.skew.x=e.skew.y=0):(e.rotation=0,e.skew.x=a,e.skew.y=l),e.scale.x=Math.sqrt(t*t+s*s),e.scale.y=Math.sqrt(r*r+n*n),e.position.x=this.tx+(o.x*t+o.y*r),e.position.y=this.ty+(o.x*s+o.y*n),e}invert(){const e=this.a,t=this.b,s=this.c,r=this.d,n=this.tx,o=e*r-t*s;return this.a=r/o,this.b=-t/o,this.c=-s/o,this.d=e/o,this.tx=(s*this.ty-r*n)/o,this.ty=-(e*this.ty-t*n)/o,this}isIdentity(){return this.a===1&&this.b===0&&this.c===0&&this.d===1&&this.tx===0&&this.ty===0}identity(){return this.a=1,this.b=0,this.c=0,this.d=1,this.tx=0,this.ty=0,this}clone(){const e=new O;return e.a=this.a,e.b=this.b,e.c=this.c,e.d=this.d,e.tx=this.tx,e.ty=this.ty,e}copyTo(e){return e.a=this.a,e.b=this.b,e.c=this.c,e.d=this.d,e.tx=this.tx,e.ty=this.ty,e}copyFrom(e){return this.a=e.a,this.b=e.b,this.c=e.c,this.d=e.d,this.tx=e.tx,this.ty=e.ty,this}equals(e){return e.a===this.a&&e.b===this.b&&e.c===this.c&&e.d===this.d&&e.tx===this.tx&&e.ty===this.ty}toString(){return`[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`}static get IDENTITY(){return Ww.identity()}static get shared(){return Hw.identity()}}const Hw=new O,Ww=new O,li=[1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1,0,1],ci=[0,1,1,1,0,-1,-1,-1,0,1,1,1,0,-1,-1,-1],hi=[0,-1,-1,-1,0,1,1,1,0,1,1,1,0,-1,-1,-1],ui=[1,1,0,-1,-1,-1,0,1,-1,-1,0,1,1,1,0,-1],ru=[],Dp=[],Pr=Math.sign;function Vw(){for(let i=0;i<16;i++){const e=[];ru.push(e);for(let t=0;t<16;t++){const s=Pr(li[i]*li[t]+hi[i]*ci[t]),r=Pr(ci[i]*li[t]+ui[i]*ci[t]),n=Pr(li[i]*hi[t]+hi[i]*ui[t]),o=Pr(ci[i]*hi[t]+ui[i]*ui[t]);for(let a=0;a<16;a++)if(li[a]===s&&ci[a]===r&&hi[a]===n&&ui[a]===o){e.push(a);break}}}for(let i=0;i<16;i++){const e=new O;e.set(li[i],ci[i],hi[i],ui[i],0,0),Dp.push(e)}}Vw();const oe={E:0,SE:1,S:2,SW:3,W:4,NW:5,N:6,NE:7,MIRROR_VERTICAL:8,MAIN_DIAGONAL:10,MIRROR_HORIZONTAL:12,REVERSE_DIAGONAL:14,uX:i=>li[i],uY:i=>ci[i],vX:i=>hi[i],vY:i=>ui[i],inv:i=>i&8?i&15:-i&7,add:(i,e)=>ru[i][e],sub:(i,e)=>ru[i][oe.inv(e)],rotate180:i=>i^4,isVertical:i=>(i&3)===2,byDirection:(i,e)=>Math.abs(i)*2<=Math.abs(e)?e>=0?oe.S:oe.N:Math.abs(e)*2<=Math.abs(i)?i>0?oe.E:oe.W:e>0?i>0?oe.SE:oe.SW:i>0?oe.NE:oe.NW,matrixAppendRotationInv:(i,e,t=0,s=0)=>{const r=Dp[oe.inv(e)];r.tx=t,r.ty=s,i.append(r)},transformRectCoords:(i,e,t,s)=>{const{x:r,y:n,width:o,height:a}=i,{x:l,y:c,width:h,height:u}=e;return t===oe.E?(s.set(r+l,n+c,o,a),s):t===oe.S?s.set(h-n-a+l,r+c,a,o):t===oe.W?s.set(h-r-o+l,u-n-a+c,o,a):t===oe.N?s.set(n+l,u-r-o+c,a,o):s.set(r+l,n+c,o,a)}},Rr=[new X,new X,new X,new X];class W{constructor(e=0,t=0,s=0,r=0){this.type="rectangle",this.x=Number(e),this.y=Number(t),this.width=Number(s),this.height=Number(r)}get left(){return this.x}get right(){return this.x+this.width}get top(){return this.y}get bottom(){return this.y+this.height}isEmpty(){return this.left===this.right||this.top===this.bottom}static get EMPTY(){return new W(0,0,0,0)}clone(){return new W(this.x,this.y,this.width,this.height)}copyFromBounds(e){return this.x=e.minX,this.y=e.minY,this.width=e.maxX-e.minX,this.height=e.maxY-e.minY,this}copyFrom(e){return this.x=e.x,this.y=e.y,this.width=e.width,this.height=e.height,this}copyTo(e){return e.copyFrom(this),e}contains(e,t){return this.width<=0||this.height<=0?!1:e>=this.x&&e<this.x+this.width&&t>=this.y&&t<this.y+this.height}strokeContains(e,t,s,r=.5){const{width:n,height:o}=this;if(n<=0||o<=0)return!1;const a=this.x,l=this.y,c=s*(1-r),h=s-c,u=a-c,d=a+n+c,f=l-c,m=l+o+c,g=a+h,p=a+n-h,_=l+h,x=l+o-h;return e>=u&&e<=d&&t>=f&&t<=m&&!(e>g&&e<p&&t>_&&t<x)}intersects(e,t){if(!t){const E=this.x<e.x?e.x:this.x;if((this.right>e.right?e.right:this.right)<=E)return!1;const C=this.y<e.y?e.y:this.y;return(this.bottom>e.bottom?e.bottom:this.bottom)>C}const s=this.left,r=this.right,n=this.top,o=this.bottom;if(r<=s||o<=n)return!1;const a=Rr[0].set(e.left,e.top),l=Rr[1].set(e.left,e.bottom),c=Rr[2].set(e.right,e.top),h=Rr[3].set(e.right,e.bottom);if(c.x<=a.x||l.y<=a.y)return!1;const u=Math.sign(t.a*t.d-t.b*t.c);if(u===0||(t.apply(a,a),t.apply(l,l),t.apply(c,c),t.apply(h,h),Math.max(a.x,l.x,c.x,h.x)<=s||Math.min(a.x,l.x,c.x,h.x)>=r||Math.max(a.y,l.y,c.y,h.y)<=n||Math.min(a.y,l.y,c.y,h.y)>=o))return!1;const d=u*(l.y-a.y),f=u*(a.x-l.x),m=d*s+f*n,g=d*r+f*n,p=d*s+f*o,_=d*r+f*o;if(Math.max(m,g,p,_)<=d*a.x+f*a.y||Math.min(m,g,p,_)>=d*h.x+f*h.y)return!1;const x=u*(a.y-c.y),v=u*(c.x-a.x),y=x*s+v*n,T=x*r+v*n,S=x*s+v*o,w=x*r+v*o;return!(Math.max(y,T,S,w)<=x*a.x+v*a.y||Math.min(y,T,S,w)>=x*h.x+v*h.y)}pad(e=0,t=e){return this.x-=e,this.y-=t,this.width+=e*2,this.height+=t*2,this}fit(e){const t=Math.max(this.x,e.x),s=Math.min(this.x+this.width,e.x+e.width),r=Math.max(this.y,e.y),n=Math.min(this.y+this.height,e.y+e.height);return this.x=t,this.width=Math.max(s-t,0),this.y=r,this.height=Math.max(n-r,0),this}ceil(e=1,t=.001){const s=Math.ceil((this.x+this.width-t)*e)/e,r=Math.ceil((this.y+this.height-t)*e)/e;return this.x=Math.floor((this.x+t)*e)/e,this.y=Math.floor((this.y+t)*e)/e,this.width=s-this.x,this.height=r-this.y,this}scale(e,t=e){return this.x*=e,this.y*=t,this.width*=e,this.height*=t,this}enlarge(e){const t=Math.min(this.x,e.x),s=Math.max(this.x+this.width,e.x+e.width),r=Math.min(this.y,e.y),n=Math.max(this.y+this.height,e.y+e.height);return this.x=t,this.width=s-t,this.y=r,this.height=n-r,this}getBounds(e){return e||(e=new W),e.copyFrom(this),e}containsRect(e){if(this.width<=0||this.height<=0)return!1;const t=e.x,s=e.y,r=e.x+e.width,n=e.y+e.height;return t>=this.x&&t<this.x+this.width&&s>=this.y&&s<this.y+this.height&&r>=this.x&&r<this.x+this.width&&n>=this.y&&n<this.y+this.height}set(e,t,s,r){return this.x=e,this.y=t,this.width=s,this.height=r,this}toString(){return`[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`}}const nu={default:-1};function le(i="default"){return nu[i]===void 0&&(nu[i]=-1),++nu[i]}const Gp=new Set,J="8.0.0",$w="8.3.4",ki={quiet:!1,noColor:!1},L=(i,e,t=3)=>{if(ki.quiet||Gp.has(e))return;let s=new Error().stack;const r=`${e}
Deprecated since v${i}`,n=typeof console.groupCollapsed=="function"&&!ki.noColor;typeof s>"u"?console.warn("PixiJS Deprecation Warning: ",r):(s=s.split(`
`).splice(t).join(`
`),n?(console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s","color:#614108;background:#fffbe6","font-weight:normal;color:#614108;background:#fffbe6",r),console.warn(s),console.groupEnd()):(console.warn("PixiJS Deprecation Warning: ",r),console.warn(s))),Gp.add(e)};Object.defineProperties(L,{quiet:{get:()=>ki.quiet,set:i=>{ki.quiet=i},enumerable:!0,configurable:!1},noColor:{get:()=>ki.noColor,set:i=>{ki.noColor=i},enumerable:!0,configurable:!1}});const zp=()=>{};function Mi(i){return i+=i===0?1:0,--i,i|=i>>>1,i|=i>>>2,i|=i>>>4,i|=i>>>8,i|=i>>>16,i+1}function Lp(i){return!(i&i-1)&&!!i}function Np(i){const e={};for(const t in i)i[t]!==void 0&&(e[t]=i[t]);return e}const Hp=Object.create(null);function Xw(i){const e=Hp[i];return e===void 0&&(Hp[i]=le("resource")),e}const Wp=class Yx extends Ze{constructor(e={}){super(),this._resourceType="textureSampler",this._touched=0,this._maxAnisotropy=1,this.destroyed=!1,e={...Yx.defaultOptions,...e},this.addressMode=e.addressMode,this.addressModeU=e.addressModeU??this.addressModeU,this.addressModeV=e.addressModeV??this.addressModeV,this.addressModeW=e.addressModeW??this.addressModeW,this.scaleMode=e.scaleMode,this.magFilter=e.magFilter??this.magFilter,this.minFilter=e.minFilter??this.minFilter,this.mipmapFilter=e.mipmapFilter??this.mipmapFilter,this.lodMinClamp=e.lodMinClamp,this.lodMaxClamp=e.lodMaxClamp,this.compare=e.compare,this.maxAnisotropy=e.maxAnisotropy??1}set addressMode(e){this.addressModeU=e,this.addressModeV=e,this.addressModeW=e}get addressMode(){return this.addressModeU}set wrapMode(e){L(J,"TextureStyle.wrapMode is now TextureStyle.addressMode"),this.addressMode=e}get wrapMode(){return this.addressMode}set scaleMode(e){this.magFilter=e,this.minFilter=e,this.mipmapFilter=e}get scaleMode(){return this.magFilter}set maxAnisotropy(e){this._maxAnisotropy=Math.min(e,16),this._maxAnisotropy>1&&(this.scaleMode="linear")}get maxAnisotropy(){return this._maxAnisotropy}get _resourceId(){return this._sharedResourceId||this._generateResourceId()}update(){this._sharedResourceId=null,this.emit("change",this)}_generateResourceId(){const e=`${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;return this._sharedResourceId=Xw(e),this._resourceId}destroy(){this.destroyed=!0,this.emit("destroy",this),this.emit("change",this),this.removeAllListeners()}};Wp.defaultOptions={addressMode:"clamp-to-edge",scaleMode:"linear"};let Ct=Wp;const Vp=class qx extends Ze{constructor(e={}){super(),this.options=e,this._gpuData=Object.create(null),this._gcLastUsed=-1,this.uid=le("textureSource"),this._resourceType="textureSource",this._resourceId=le("resource"),this.uploadMethodId="unknown",this._resolution=1,this.pixelWidth=1,this.pixelHeight=1,this.width=1,this.height=1,this.sampleCount=1,this.mipLevelCount=1,this.autoGenerateMipmaps=!1,this.format="rgba8unorm",this.dimension="2d",this.antialias=!1,this._touched=0,this._batchTick=-1,this._textureBindLocation=-1,e={...qx.defaultOptions,...e},this.label=e.label??"",this.resource=e.resource,this.autoGarbageCollect=e.autoGarbageCollect,this._resolution=e.resolution,e.width?this.pixelWidth=e.width*this._resolution:this.pixelWidth=this.resource?this.resourceWidth??1:1,e.height?this.pixelHeight=e.height*this._resolution:this.pixelHeight=this.resource?this.resourceHeight??1:1,this.width=this.pixelWidth/this._resolution,this.height=this.pixelHeight/this._resolution,this.format=e.format,this.dimension=e.dimensions,this.mipLevelCount=e.mipLevelCount,this.autoGenerateMipmaps=e.autoGenerateMipmaps,this.sampleCount=e.sampleCount,this.antialias=e.antialias,this.alphaMode=e.alphaMode,this.style=new Ct(Np(e)),this.destroyed=!1,this._refreshPOT()}get source(){return this}get style(){return this._style}set style(e){this.style!==e&&(this._style?.off("change",this._onStyleChange,this),this._style=e,this._style?.on("change",this._onStyleChange,this),this._onStyleChange())}set maxAnisotropy(e){this._style.maxAnisotropy=e}get maxAnisotropy(){return this._style.maxAnisotropy}get addressMode(){return this._style.addressMode}set addressMode(e){this._style.addressMode=e}get repeatMode(){return this._style.addressMode}set repeatMode(e){this._style.addressMode=e}get magFilter(){return this._style.magFilter}set magFilter(e){this._style.magFilter=e}get minFilter(){return this._style.minFilter}set minFilter(e){this._style.minFilter=e}get mipmapFilter(){return this._style.mipmapFilter}set mipmapFilter(e){this._style.mipmapFilter=e}get lodMinClamp(){return this._style.lodMinClamp}set lodMinClamp(e){this._style.lodMinClamp=e}get lodMaxClamp(){return this._style.lodMaxClamp}set lodMaxClamp(e){this._style.lodMaxClamp=e}_onStyleChange(){this.emit("styleChange",this)}update(){if(this.resource){const e=this._resolution;if(this.resize(this.resourceWidth/e,this.resourceHeight/e))return}this.emit("update",this)}destroy(){this.destroyed=!0,this.unload(),this.emit("destroy",this),this._style&&(this._style.destroy(),this._style=null),this.uploadMethodId=null,this.resource=null,this.removeAllListeners()}unload(){this._resourceId=le("resource"),this.emit("change",this),this.emit("unload",this);for(const e in this._gpuData)this._gpuData[e]?.destroy?.();this._gpuData=Object.create(null)}get resourceWidth(){const{resource:e}=this;return e.naturalWidth||e.videoWidth||e.displayWidth||e.width}get resourceHeight(){const{resource:e}=this;return e.naturalHeight||e.videoHeight||e.displayHeight||e.height}get resolution(){return this._resolution}set resolution(e){this._resolution!==e&&(this._resolution=e,this.width=this.pixelWidth/e,this.height=this.pixelHeight/e)}resize(e,t,s){s||(s=this._resolution),e||(e=this.width),t||(t=this.height);const r=Math.round(e*s),n=Math.round(t*s);return this.width=r/s,this.height=n/s,this._resolution=s,this.pixelWidth===r&&this.pixelHeight===n?!1:(this._refreshPOT(),this.pixelWidth=r,this.pixelHeight=n,this.emit("resize",this),this._resourceId=le("resource"),this.emit("change",this),!0)}updateMipmaps(){this.autoGenerateMipmaps&&this.mipLevelCount>1&&this.emit("updateMipmaps",this)}set wrapMode(e){this._style.wrapMode=e}get wrapMode(){return this._style.wrapMode}set scaleMode(e){this._style.scaleMode=e}get scaleMode(){return this._style.scaleMode}_refreshPOT(){this.isPowerOfTwo=Lp(this.pixelWidth)&&Lp(this.pixelHeight)}static test(e){throw new Error("Unimplemented")}};Vp.defaultOptions={resolution:1,format:"bgra8unorm",alphaMode:"premultiply-alpha-on-upload",dimensions:"2d",mipLevelCount:1,autoGenerateMipmaps:!1,sampleCount:1,antialias:!1,autoGarbageCollect:!1};let Ee=Vp;class ou extends Ee{constructor(e){const t=e.resource||new Float32Array(e.width*e.height*4);let s=e.format;s||(t instanceof Float32Array?s="rgba32float":t instanceof Int32Array||t instanceof Uint32Array?s="rgba32uint":t instanceof Int16Array||t instanceof Uint16Array?s="rgba16uint":(t instanceof Int8Array,s="bgra8unorm")),super({...e,resource:t,format:s}),this.uploadMethodId="buffer"}static test(e){return e instanceof Int8Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray||e instanceof Int16Array||e instanceof Uint16Array||e instanceof Int32Array||e instanceof Uint32Array||e instanceof Float32Array}}ou.extension=b.TextureSource;const $p=new O;class Xp{constructor(e,t){this.mapCoord=new O,this.uClampFrame=new Float32Array(4),this.uClampOffset=new Float32Array(2),this._textureID=-1,this._updateID=0,this.clampOffset=0,typeof t>"u"?this.clampMargin=e.width<10?0:.5:this.clampMargin=t,this.isSimple=!1,this.texture=e}get texture(){return this._texture}set texture(e){this.texture!==e&&(this._texture?.removeListener("update",this.update,this),this._texture=e,this._texture.addListener("update",this.update,this),this.update())}multiplyUvs(e,t){t===void 0&&(t=e);const s=this.mapCoord;for(let r=0;r<e.length;r+=2){const n=e[r],o=e[r+1];t[r]=n*s.a+o*s.c+s.tx,t[r+1]=n*s.b+o*s.d+s.ty}return t}update(){const e=this._texture;this._updateID++;const t=e.uvs;this.mapCoord.set(t.x1-t.x0,t.y1-t.y0,t.x3-t.x0,t.y3-t.y0,t.x0,t.y0);const s=e.orig,r=e.trim;r&&($p.set(s.width/r.width,0,0,s.height/r.height,-r.x/r.width,-r.y/r.height),this.mapCoord.append($p));const n=e.source,o=this.uClampFrame,a=this.clampMargin/n._resolution,l=this.clampOffset/n._resolution;return o[0]=(e.frame.x+a+l)/n.width,o[1]=(e.frame.y+a+l)/n.height,o[2]=(e.frame.x+e.frame.width-a+l)/n.width,o[3]=(e.frame.y+e.frame.height-a+l)/n.height,this.uClampOffset[0]=this.clampOffset/n.pixelWidth,this.uClampOffset[1]=this.clampOffset/n.pixelHeight,this.isSimple=e.frame.width===n.width&&e.frame.height===n.height&&e.rotate===0,!0}}class k extends Ze{constructor({source:e,label:t,frame:s,orig:r,trim:n,defaultAnchor:o,defaultBorders:a,rotate:l,dynamic:c}={}){if(super(),this.uid=le("texture"),this.uvs={x0:0,y0:0,x1:0,y1:0,x2:0,y2:0,x3:0,y3:0},this.frame=new W,this.noFrame=!1,this.dynamic=!1,this.isTexture=!0,this.label=t,this.source=e?.source??new Ee,this.noFrame=!s,s)this.frame.copyFrom(s);else{const{width:h,height:u}=this._source;this.frame.width=h,this.frame.height=u}this.orig=r||this.frame,this.trim=n,this.rotate=l??0,this.defaultAnchor=o,this.defaultBorders=a,this.destroyed=!1,this.dynamic=c||!1,this.updateUvs()}set source(e){this._source&&this._source.off("resize",this.update,this),this._source=e,e.on("resize",this.update,this),this.emit("update",this)}get source(){return this._source}get textureMatrix(){return this._textureMatrix||(this._textureMatrix=new Xp(this)),this._textureMatrix}get width(){return this.orig.width}get height(){return this.orig.height}updateUvs(){const{uvs:e,frame:t}=this,{width:s,height:r}=this._source,n=t.x/s,o=t.y/r,a=t.width/s,l=t.height/r;let c=this.rotate;if(c){const h=a/2,u=l/2,d=n+h,f=o+u;c=oe.add(c,oe.NW),e.x0=d+h*oe.uX(c),e.y0=f+u*oe.uY(c),c=oe.add(c,2),e.x1=d+h*oe.uX(c),e.y1=f+u*oe.uY(c),c=oe.add(c,2),e.x2=d+h*oe.uX(c),e.y2=f+u*oe.uY(c),c=oe.add(c,2),e.x3=d+h*oe.uX(c),e.y3=f+u*oe.uY(c)}else e.x0=n,e.y0=o,e.x1=n+a,e.y1=o,e.x2=n+a,e.y2=o+l,e.x3=n,e.y3=o+l}destroy(e=!1){this._source&&(this._source.off("resize",this.update,this),e&&(this._source.destroy(),this._source=null)),this._textureMatrix=null,this.destroyed=!0,this.emit("destroy",this),this.removeAllListeners()}update(){this.noFrame&&(this.frame.width=this._source.width,this.frame.height=this._source.height),this.updateUvs(),this.emit("update",this)}get baseTexture(){return L(J,"Texture.baseTexture is now Texture.source"),this._source}}k.EMPTY=new k({label:"EMPTY",source:new Ee({label:"EMPTY"})}),k.EMPTY.destroy=zp,k.WHITE=new k({source:new ou({resource:new Uint8Array([255,255,255,255]),width:1,height:1,alphaMode:"premultiply-alpha-on-upload",label:"WHITE"}),label:"WHITE"}),k.WHITE.destroy=zp;function Yp(i,e,t){const{width:s,height:r}=t.orig,n=t.trim;if(n){const o=n.width,a=n.height;i.minX=n.x-e._x*s,i.maxX=i.minX+o,i.minY=n.y-e._y*r,i.maxY=i.minY+a}else i.minX=-e._x*s,i.maxX=i.minX+s,i.minY=-e._y*r,i.maxY=i.minY+r}const qp=new O;class De{constructor(e=1/0,t=1/0,s=-1/0,r=-1/0){this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0,this.matrix=qp,this.minX=e,this.minY=t,this.maxX=s,this.maxY=r}isEmpty(){return this.minX>this.maxX||this.minY>this.maxY}get rectangle(){this._rectangle||(this._rectangle=new W);const e=this._rectangle;return this.minX>this.maxX||this.minY>this.maxY?(e.x=0,e.y=0,e.width=0,e.height=0):e.copyFromBounds(this),e}clear(){return this.minX=1/0,this.minY=1/0,this.maxX=-1/0,this.maxY=-1/0,this.matrix=qp,this}set(e,t,s,r){this.minX=e,this.minY=t,this.maxX=s,this.maxY=r}addFrame(e,t,s,r,n){n||(n=this.matrix);const o=n.a,a=n.b,l=n.c,c=n.d,h=n.tx,u=n.ty;let d=this.minX,f=this.minY,m=this.maxX,g=this.maxY,p=o*e+l*t+h,_=a*e+c*t+u;p<d&&(d=p),_<f&&(f=_),p>m&&(m=p),_>g&&(g=_),p=o*s+l*t+h,_=a*s+c*t+u,p<d&&(d=p),_<f&&(f=_),p>m&&(m=p),_>g&&(g=_),p=o*e+l*r+h,_=a*e+c*r+u,p<d&&(d=p),_<f&&(f=_),p>m&&(m=p),_>g&&(g=_),p=o*s+l*r+h,_=a*s+c*r+u,p<d&&(d=p),_<f&&(f=_),p>m&&(m=p),_>g&&(g=_),this.minX=d,this.minY=f,this.maxX=m,this.maxY=g}addRect(e,t){this.addFrame(e.x,e.y,e.x+e.width,e.y+e.height,t)}addBounds(e,t){this.addFrame(e.minX,e.minY,e.maxX,e.maxY,t)}addBoundsMask(e){this.minX=this.minX>e.minX?this.minX:e.minX,this.minY=this.minY>e.minY?this.minY:e.minY,this.maxX=this.maxX<e.maxX?this.maxX:e.maxX,this.maxY=this.maxY<e.maxY?this.maxY:e.maxY}applyMatrix(e){const t=this.minX,s=this.minY,r=this.maxX,n=this.maxY,{a:o,b:a,c:l,d:c,tx:h,ty:u}=e;let d=o*t+l*s+h,f=a*t+c*s+u;this.minX=d,this.minY=f,this.maxX=d,this.maxY=f,d=o*r+l*s+h,f=a*r+c*s+u,this.minX=d<this.minX?d:this.minX,this.minY=f<this.minY?f:this.minY,this.maxX=d>this.maxX?d:this.maxX,this.maxY=f>this.maxY?f:this.maxY,d=o*t+l*n+h,f=a*t+c*n+u,this.minX=d<this.minX?d:this.minX,this.minY=f<this.minY?f:this.minY,this.maxX=d>this.maxX?d:this.maxX,this.maxY=f>this.maxY?f:this.maxY,d=o*r+l*n+h,f=a*r+c*n+u,this.minX=d<this.minX?d:this.minX,this.minY=f<this.minY?f:this.minY,this.maxX=d>this.maxX?d:this.maxX,this.maxY=f>this.maxY?f:this.maxY}fit(e){return this.minX<e.left&&(this.minX=e.left),this.maxX>e.right&&(this.maxX=e.right),this.minY<e.top&&(this.minY=e.top),this.maxY>e.bottom&&(this.maxY=e.bottom),this}fitBounds(e,t,s,r){return this.minX<e&&(this.minX=e),this.maxX>t&&(this.maxX=t),this.minY<s&&(this.minY=s),this.maxY>r&&(this.maxY=r),this}pad(e,t=e){return this.minX-=e,this.maxX+=e,this.minY-=t,this.maxY+=t,this}ceil(){return this.minX=Math.floor(this.minX),this.minY=Math.floor(this.minY),this.maxX=Math.ceil(this.maxX),this.maxY=Math.ceil(this.maxY),this}clone(){return new De(this.minX,this.minY,this.maxX,this.maxY)}scale(e,t=e){return this.minX*=e,this.minY*=t,this.maxX*=e,this.maxY*=t,this}get x(){return this.minX}set x(e){const t=this.maxX-this.minX;this.minX=e,this.maxX=e+t}get y(){return this.minY}set y(e){const t=this.maxY-this.minY;this.minY=e,this.maxY=e+t}get width(){return this.maxX-this.minX}set width(e){this.maxX=this.minX+e}get height(){return this.maxY-this.minY}set height(e){this.maxY=this.minY+e}get left(){return this.minX}get right(){return this.maxX}get top(){return this.minY}get bottom(){return this.maxY}get isPositive(){return this.maxX-this.minX>0&&this.maxY-this.minY>0}get isValid(){return this.minX+this.minY!==1/0}addVertexData(e,t,s,r){let n=this.minX,o=this.minY,a=this.maxX,l=this.maxY;r||(r=this.matrix);const c=r.a,h=r.b,u=r.c,d=r.d,f=r.tx,m=r.ty;for(let g=t;g<s;g+=2){const p=e[g],_=e[g+1],x=c*p+u*_+f,v=h*p+d*_+m;n=x<n?x:n,o=v<o?v:o,a=x>a?x:a,l=v>l?v:l}this.minX=n,this.minY=o,this.maxX=a,this.maxY=l}containsPoint(e,t){return this.minX<=e&&this.minY<=t&&this.maxX>=e&&this.maxY>=t}toString(){return`[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`}copyFrom(e){return this.minX=e.minX,this.minY=e.minY,this.maxX=e.maxX,this.maxY=e.maxY,this}}var Yw={grad:.9,turn:360,rad:360/(2*Math.PI)},Ft=function(i){return typeof i=="string"?i.length>0:typeof i=="number"},Re=function(i,e,t){return e===void 0&&(e=0),t===void 0&&(t=Math.pow(10,e)),Math.round(t*i)/t+0},at=function(i,e,t){return e===void 0&&(e=0),t===void 0&&(t=1),i>t?t:i>e?i:e},Kp=function(i){return(i=isFinite(i)?i%360:0)>0?i:i+360},jp=function(i){return{r:at(i.r,0,255),g:at(i.g,0,255),b:at(i.b,0,255),a:at(i.a)}},au=function(i){return{r:Re(i.r),g:Re(i.g),b:Re(i.b),a:Re(i.a,3)}},qw=/^#([0-9a-f]{3,8})$/i,kr=function(i){var e=i.toString(16);return e.length<2?"0"+e:e},Zp=function(i){var e=i.r,t=i.g,s=i.b,r=i.a,n=Math.max(e,t,s),o=n-Math.min(e,t,s),a=o?n===e?(t-s)/o:n===t?2+(s-e)/o:4+(e-t)/o:0;return{h:60*(a<0?a+6:a),s:n?o/n*100:0,v:n/255*100,a:r}},Jp=function(i){var e=i.h,t=i.s,s=i.v,r=i.a;e=e/360*6,t/=100,s/=100;var n=Math.floor(e),o=s*(1-t),a=s*(1-(e-n)*t),l=s*(1-(1-e+n)*t),c=n%6;return{r:255*[s,a,o,o,l,s][c],g:255*[l,s,s,a,o,o][c],b:255*[o,o,l,s,s,a][c],a:r}},Qp=function(i){return{h:Kp(i.h),s:at(i.s,0,100),l:at(i.l,0,100),a:at(i.a)}},em=function(i){return{h:Re(i.h),s:Re(i.s),l:Re(i.l),a:Re(i.a,3)}},tm=function(i){return Jp((t=(e=i).s,{h:e.h,s:(t*=((s=e.l)<50?s:100-s)/100)>0?2*t/(s+t)*100:0,v:s+t,a:e.a}));var e,t,s},ds=function(i){return{h:(e=Zp(i)).h,s:(r=(200-(t=e.s))*(s=e.v)/100)>0&&r<200?t*s/100/(r<=100?r:200-r)*100:0,l:r/2,a:e.a};var e,t,s,r},Kw=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,jw=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,Zw=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,Jw=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,lu={string:[[function(i){var e=qw.exec(i);return e?(i=e[1]).length<=4?{r:parseInt(i[0]+i[0],16),g:parseInt(i[1]+i[1],16),b:parseInt(i[2]+i[2],16),a:i.length===4?Re(parseInt(i[3]+i[3],16)/255,2):1}:i.length===6||i.length===8?{r:parseInt(i.substr(0,2),16),g:parseInt(i.substr(2,2),16),b:parseInt(i.substr(4,2),16),a:i.length===8?Re(parseInt(i.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(i){var e=Zw.exec(i)||Jw.exec(i);return e?e[2]!==e[4]||e[4]!==e[6]?null:jp({r:Number(e[1])/(e[2]?100/255:1),g:Number(e[3])/(e[4]?100/255:1),b:Number(e[5])/(e[6]?100/255:1),a:e[7]===void 0?1:Number(e[7])/(e[8]?100:1)}):null},"rgb"],[function(i){var e=Kw.exec(i)||jw.exec(i);if(!e)return null;var t,s,r=Qp({h:(t=e[1],s=e[2],s===void 0&&(s="deg"),Number(t)*(Yw[s]||1)),s:Number(e[3]),l:Number(e[4]),a:e[5]===void 0?1:Number(e[5])/(e[6]?100:1)});return tm(r)},"hsl"]],object:[[function(i){var e=i.r,t=i.g,s=i.b,r=i.a,n=r===void 0?1:r;return Ft(e)&&Ft(t)&&Ft(s)?jp({r:Number(e),g:Number(t),b:Number(s),a:Number(n)}):null},"rgb"],[function(i){var e=i.h,t=i.s,s=i.l,r=i.a,n=r===void 0?1:r;if(!Ft(e)||!Ft(t)||!Ft(s))return null;var o=Qp({h:Number(e),s:Number(t),l:Number(s),a:Number(n)});return tm(o)},"hsl"],[function(i){var e=i.h,t=i.s,s=i.v,r=i.a,n=r===void 0?1:r;if(!Ft(e)||!Ft(t)||!Ft(s))return null;var o=(function(a){return{h:Kp(a.h),s:at(a.s,0,100),v:at(a.v,0,100),a:at(a.a)}})({h:Number(e),s:Number(t),v:Number(s),a:Number(n)});return Jp(o)},"hsv"]]},im=function(i,e){for(var t=0;t<e.length;t++){var s=e[t][0](i);if(s)return[s,e[t][1]]}return[null,void 0]},Qw=function(i){return typeof i=="string"?im(i.trim(),lu.string):typeof i=="object"&&i!==null?im(i,lu.object):[null,void 0]},cu=function(i,e){var t=ds(i);return{h:t.h,s:at(t.s+100*e,0,100),l:t.l,a:t.a}},hu=function(i){return(299*i.r+587*i.g+114*i.b)/1e3/255},sm=function(i,e){var t=ds(i);return{h:t.h,s:t.s,l:at(t.l+100*e,0,100),a:t.a}},uu=(function(){function i(e){this.parsed=Qw(e)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return i.prototype.isValid=function(){return this.parsed!==null},i.prototype.brightness=function(){return Re(hu(this.rgba),2)},i.prototype.isDark=function(){return hu(this.rgba)<.5},i.prototype.isLight=function(){return hu(this.rgba)>=.5},i.prototype.toHex=function(){return e=au(this.rgba),t=e.r,s=e.g,r=e.b,o=(n=e.a)<1?kr(Re(255*n)):"","#"+kr(t)+kr(s)+kr(r)+o;var e,t,s,r,n,o},i.prototype.toRgb=function(){return au(this.rgba)},i.prototype.toRgbString=function(){return e=au(this.rgba),t=e.r,s=e.g,r=e.b,(n=e.a)<1?"rgba("+t+", "+s+", "+r+", "+n+")":"rgb("+t+", "+s+", "+r+")";var e,t,s,r,n},i.prototype.toHsl=function(){return em(ds(this.rgba))},i.prototype.toHslString=function(){return e=em(ds(this.rgba)),t=e.h,s=e.s,r=e.l,(n=e.a)<1?"hsla("+t+", "+s+"%, "+r+"%, "+n+")":"hsl("+t+", "+s+"%, "+r+"%)";var e,t,s,r,n},i.prototype.toHsv=function(){return e=Zp(this.rgba),{h:Re(e.h),s:Re(e.s),v:Re(e.v),a:Re(e.a,3)};var e},i.prototype.invert=function(){return At({r:255-(e=this.rgba).r,g:255-e.g,b:255-e.b,a:e.a});var e},i.prototype.saturate=function(e){return e===void 0&&(e=.1),At(cu(this.rgba,e))},i.prototype.desaturate=function(e){return e===void 0&&(e=.1),At(cu(this.rgba,-e))},i.prototype.grayscale=function(){return At(cu(this.rgba,-1))},i.prototype.lighten=function(e){return e===void 0&&(e=.1),At(sm(this.rgba,e))},i.prototype.darken=function(e){return e===void 0&&(e=.1),At(sm(this.rgba,-e))},i.prototype.rotate=function(e){return e===void 0&&(e=15),this.hue(this.hue()+e)},i.prototype.alpha=function(e){return typeof e=="number"?At({r:(t=this.rgba).r,g:t.g,b:t.b,a:e}):Re(this.rgba.a,3);var t},i.prototype.hue=function(e){var t=ds(this.rgba);return typeof e=="number"?At({h:e,s:t.s,l:t.l,a:t.a}):Re(t.h)},i.prototype.isEqual=function(e){return this.toHex()===At(e).toHex()},i})(),At=function(i){return i instanceof uu?i:new uu(i)},rm=[],eS=function(i){i.forEach(function(e){rm.indexOf(e)<0&&(e(uu,lu),rm.push(e))})};function tS(i,e){var t={white:"#ffffff",bisque:"#ffe4c4",blue:"#0000ff",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",antiquewhite:"#faebd7",aqua:"#00ffff",azure:"#f0ffff",whitesmoke:"#f5f5f5",papayawhip:"#ffefd5",plum:"#dda0dd",blanchedalmond:"#ffebcd",black:"#000000",gold:"#ffd700",goldenrod:"#daa520",gainsboro:"#dcdcdc",cornsilk:"#fff8dc",cornflowerblue:"#6495ed",burlywood:"#deb887",aquamarine:"#7fffd4",beige:"#f5f5dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkkhaki:"#bdb76b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",peachpuff:"#ffdab9",darkmagenta:"#8b008b",darkred:"#8b0000",darkorchid:"#9932cc",darkorange:"#ff8c00",darkslateblue:"#483d8b",gray:"#808080",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",deeppink:"#ff1493",deepskyblue:"#00bfff",wheat:"#f5deb3",firebrick:"#b22222",floralwhite:"#fffaf0",ghostwhite:"#f8f8ff",darkviolet:"#9400d3",magenta:"#ff00ff",green:"#008000",dodgerblue:"#1e90ff",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",blueviolet:"#8a2be2",forestgreen:"#228b22",lawngreen:"#7cfc00",indianred:"#cd5c5c",indigo:"#4b0082",fuchsia:"#ff00ff",brown:"#a52a2a",maroon:"#800000",mediumblue:"#0000cd",lightcoral:"#f08080",darkturquoise:"#00ced1",lightcyan:"#e0ffff",ivory:"#fffff0",lightyellow:"#ffffe0",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",linen:"#faf0e6",mediumaquamarine:"#66cdaa",lemonchiffon:"#fffacd",lime:"#00ff00",khaki:"#f0e68c",mediumseagreen:"#3cb371",limegreen:"#32cd32",mediumspringgreen:"#00fa9a",lightskyblue:"#87cefa",lightblue:"#add8e6",midnightblue:"#191970",lightpink:"#ffb6c1",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",mintcream:"#f5fffa",lightslategray:"#778899",lightslategrey:"#778899",navajowhite:"#ffdead",navy:"#000080",mediumvioletred:"#c71585",powderblue:"#b0e0e6",palegoldenrod:"#eee8aa",oldlace:"#fdf5e6",paleturquoise:"#afeeee",mediumturquoise:"#48d1cc",mediumorchid:"#ba55d3",rebeccapurple:"#663399",lightsteelblue:"#b0c4de",mediumslateblue:"#7b68ee",thistle:"#d8bfd8",tan:"#d2b48c",orchid:"#da70d6",mediumpurple:"#9370db",purple:"#800080",pink:"#ffc0cb",skyblue:"#87ceeb",springgreen:"#00ff7f",palegreen:"#98fb98",red:"#ff0000",yellow:"#ffff00",slateblue:"#6a5acd",lavenderblush:"#fff0f5",peru:"#cd853f",palevioletred:"#db7093",violet:"#ee82ee",teal:"#008080",slategray:"#708090",slategrey:"#708090",aliceblue:"#f0f8ff",darkseagreen:"#8fbc8f",darkolivegreen:"#556b2f",greenyellow:"#adff2f",seagreen:"#2e8b57",seashell:"#fff5ee",tomato:"#ff6347",silver:"#c0c0c0",sienna:"#a0522d",lavender:"#e6e6fa",lightgreen:"#90ee90",orange:"#ffa500",orangered:"#ff4500",steelblue:"#4682b4",royalblue:"#4169e1",turquoise:"#40e0d0",yellowgreen:"#9acd32",salmon:"#fa8072",saddlebrown:"#8b4513",sandybrown:"#f4a460",rosybrown:"#bc8f8f",darksalmon:"#e9967a",lightgoldenrodyellow:"#fafad2",snow:"#fffafa",lightgrey:"#d3d3d3",lightgray:"#d3d3d3",dimgray:"#696969",dimgrey:"#696969",olivedrab:"#6b8e23",olive:"#808000"},s={};for(var r in t)s[t[r]]=r;var n={};i.prototype.toName=function(o){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return"transparent";var a,l,c=s[this.toHex()];if(c)return c;if(o?.closest){var h=this.toRgb(),u=1/0,d="black";if(!n.length)for(var f in t)n[f]=new i(t[f]).toRgb();for(var m in t){var g=(a=h,l=n[m],Math.pow(a.r-l.r,2)+Math.pow(a.g-l.g,2)+Math.pow(a.b-l.b,2));g<u&&(u=g,d=m)}return d}},e.string.push([function(o){var a=o.toLowerCase(),l=a==="transparent"?"#0000":t[a];return l?new i(l).toRgb():null},"name"])}eS([tS]);const Fi=class qs{constructor(e=16777215){this._value=null,this._components=new Float32Array(4),this._components.fill(1),this._int=16777215,this.value=e}get red(){return this._components[0]}get green(){return this._components[1]}get blue(){return this._components[2]}get alpha(){return this._components[3]}setValue(e){return this.value=e,this}set value(e){if(e instanceof qs)this._value=this._cloneSource(e._value),this._int=e._int,this._components.set(e._components);else{if(e===null)throw new Error("Cannot set Color#value to null");(this._value===null||!this._isSourceEqual(this._value,e))&&(this._value=this._cloneSource(e),this._normalize(this._value))}}get value(){return this._value}_cloneSource(e){return typeof e=="string"||typeof e=="number"||e instanceof Number||e===null?e:Array.isArray(e)||ArrayBuffer.isView(e)?e.slice(0):typeof e=="object"&&e!==null?{...e}:e}_isSourceEqual(e,t){const s=typeof e;if(s!==typeof t)return!1;if(s==="number"||s==="string"||e instanceof Number)return e===t;if(Array.isArray(e)&&Array.isArray(t)||ArrayBuffer.isView(e)&&ArrayBuffer.isView(t))return e.length!==t.length?!1:e.every((n,o)=>n===t[o]);if(e!==null&&t!==null){const n=Object.keys(e),o=Object.keys(t);return n.length!==o.length?!1:n.every(a=>e[a]===t[a])}return e===t}toRgba(){const[e,t,s,r]=this._components;return{r:e,g:t,b:s,a:r}}toRgb(){const[e,t,s]=this._components;return{r:e,g:t,b:s}}toRgbaString(){const[e,t,s]=this.toUint8RgbArray();return`rgba(${e},${t},${s},${this.alpha})`}toUint8RgbArray(e){const[t,s,r]=this._components;return this._arrayRgb||(this._arrayRgb=[]),e||(e=this._arrayRgb),e[0]=Math.round(t*255),e[1]=Math.round(s*255),e[2]=Math.round(r*255),e}toArray(e){this._arrayRgba||(this._arrayRgba=[]),e||(e=this._arrayRgba);const[t,s,r,n]=this._components;return e[0]=t,e[1]=s,e[2]=r,e[3]=n,e}toRgbArray(e){this._arrayRgb||(this._arrayRgb=[]),e||(e=this._arrayRgb);const[t,s,r]=this._components;return e[0]=t,e[1]=s,e[2]=r,e}toNumber(){return this._int}toBgrNumber(){const[e,t,s]=this.toUint8RgbArray();return(s<<16)+(t<<8)+e}toLittleEndianNumber(){const e=this._int;return(e>>16)+(e&65280)+((e&255)<<16)}multiply(e){const[t,s,r,n]=qs._temp.setValue(e)._components;return this._components[0]*=t,this._components[1]*=s,this._components[2]*=r,this._components[3]*=n,this._refreshInt(),this._value=null,this}premultiply(e,t=!0){return t&&(this._components[0]*=e,this._components[1]*=e,this._components[2]*=e),this._components[3]=e,this._refreshInt(),this._value=null,this}toPremultiplied(e,t=!0){if(e===1)return(255<<24)+this._int;if(e===0)return t?0:this._int;let s=this._int>>16&255,r=this._int>>8&255,n=this._int&255;return t&&(s=s*e+.5|0,r=r*e+.5|0,n=n*e+.5|0),(e*255<<24)+(s<<16)+(r<<8)+n}toHex(){const e=this._int.toString(16);return`#${"000000".substring(0,6-e.length)+e}`}toHexa(){const t=Math.round(this._components[3]*255).toString(16);return this.toHex()+"00".substring(0,2-t.length)+t}setAlpha(e){return this._components[3]=this._clamp(e),this}_normalize(e){let t,s,r,n;if((typeof e=="number"||e instanceof Number)&&e>=0&&e<=16777215){const o=e;t=(o>>16&255)/255,s=(o>>8&255)/255,r=(o&255)/255,n=1}else if((Array.isArray(e)||e instanceof Float32Array)&&e.length>=3&&e.length<=4)e=this._clamp(e),[t,s,r,n=1]=e;else if((e instanceof Uint8Array||e instanceof Uint8ClampedArray)&&e.length>=3&&e.length<=4)e=this._clamp(e,0,255),[t,s,r,n=255]=e,t/=255,s/=255,r/=255,n/=255;else if(typeof e=="string"||typeof e=="object"){if(typeof e=="string"){const a=qs.HEX_PATTERN.exec(e);a&&(e=`#${a[2]}`)}const o=At(e);o.isValid()&&({r:t,g:s,b:r,a:n}=o.rgba,t/=255,s/=255,r/=255)}if(t!==void 0)this._components[0]=t,this._components[1]=s,this._components[2]=r,this._components[3]=n,this._refreshInt();else throw new Error(`Unable to convert color ${e}`)}_refreshInt(){this._clamp(this._components);const[e,t,s]=this._components;this._int=(e*255<<16)+(t*255<<8)+(s*255|0)}_clamp(e,t=0,s=1){return typeof e=="number"?Math.min(Math.max(e,t),s):(e.forEach((r,n)=>{e[n]=Math.min(Math.max(r,t),s)}),e)}static isColorLike(e){return typeof e=="number"||typeof e=="string"||e instanceof Number||e instanceof qs||Array.isArray(e)||e instanceof Uint8Array||e instanceof Uint8ClampedArray||e instanceof Float32Array||e.r!==void 0&&e.g!==void 0&&e.b!==void 0||e.r!==void 0&&e.g!==void 0&&e.b!==void 0&&e.a!==void 0||e.h!==void 0&&e.s!==void 0&&e.l!==void 0||e.h!==void 0&&e.s!==void 0&&e.l!==void 0&&e.a!==void 0||e.h!==void 0&&e.s!==void 0&&e.v!==void 0||e.h!==void 0&&e.s!==void 0&&e.v!==void 0&&e.a!==void 0}};Fi.shared=new Fi,Fi._temp=new Fi,Fi.HEX_PATTERN=/^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;let ue=Fi;const iS={cullArea:null,cullable:!1,cullableChildren:!0};let du=0;const nm=500;function H(...i){du!==nm&&(du++,du===nm?console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS."):console.warn("PixiJS Warning: ",...i))}const Ui={_registeredResources:new Set,register(i){this._registeredResources.add(i)},unregister(i){this._registeredResources.delete(i)},release(){this._registeredResources.forEach(i=>i.clear())},get registeredCount(){return this._registeredResources.size},isRegistered(i){return this._registeredResources.has(i)},reset(){this._registeredResources.clear()}};class sS{constructor(e,t){this._pool=[],this._count=0,this._index=0,this._classType=e,t&&this.prepopulate(t)}prepopulate(e){for(let t=0;t<e;t++)this._pool[this._index++]=new this._classType;this._count+=e}get(e){let t;return this._index>0?t=this._pool[--this._index]:(t=new this._classType,this._count++),t.init?.(e),t}return(e){e.reset?.(),this._pool[this._index++]=e}get totalSize(){return this._count}get totalFree(){return this._index}get totalUsed(){return this._count-this._index}clear(){if(this._pool.length>0&&this._pool[0].destroy)for(let e=0;e<this._index;e++)this._pool[e].destroy();this._pool.length=0,this._count=0,this._index=0}}class rS{constructor(){this._poolsByClass=new Map}prepopulate(e,t){this.getPool(e).prepopulate(t)}get(e,t){return this.getPool(e).get(t)}return(e){this.getPool(e.constructor).return(e)}getPool(e){return this._poolsByClass.has(e)||this._poolsByClass.set(e,new sS(e)),this._poolsByClass.get(e)}stats(){const e={};return this._poolsByClass.forEach(t=>{const s=e[t._classType.name]?t._classType.name+t._classType.ID:t._classType.name;e[s]={free:t.totalFree,used:t.totalUsed,size:t.totalSize}}),e}clear(){this._poolsByClass.forEach(e=>e.clear()),this._poolsByClass.clear()}}const Se=new rS;Ui.register(Se);const nS={get isCachedAsTexture(){return!!this.renderGroup?.isCachedAsTexture},cacheAsTexture(i){typeof i=="boolean"&&i===!1?this.disableRenderGroup():(this.enableRenderGroup(),this.renderGroup.enableCacheAsTexture(i===!0?{}:i))},updateCacheTexture(){this.renderGroup?.updateCacheTexture()},get cacheAsBitmap(){return this.isCachedAsTexture},set cacheAsBitmap(i){L("v8.6.0","cacheAsBitmap is deprecated, use cacheAsTexture instead."),this.cacheAsTexture(i)}};function om(i,e,t){const s=i.length;let r;if(e>=s||t===0)return;t=e+t>s?s-e:t;const n=s-t;for(r=e;r<n;++r)i[r]=i[r+t];i.length=n}const oS={allowChildren:!0,removeChildren(i=0,e){const t=e??this.children.length,s=t-i,r=[];if(s>0&&s<=t){for(let o=t-1;o>=i;o--){const a=this.children[o];a&&(r.push(a),a.parent=null)}om(this.children,i,t);const n=this.renderGroup||this.parentRenderGroup;n&&n.removeChildren(r);for(let o=0;o<r.length;++o){const a=r[o];a.parentRenderLayer?.detach(a),this.emit("childRemoved",a,this,o),r[o].emit("removed",this)}return r.length>0&&this._didViewChangeTick++,r}else if(s===0&&this.children.length===0)return r;throw new RangeError("removeChildren: numeric values are outside the acceptable range.")},removeChildAt(i){const e=this.getChildAt(i);return this.removeChild(e)},getChildAt(i){if(i<0||i>=this.children.length)throw new Error(`getChildAt: Index (${i}) does not exist.`);return this.children[i]},setChildIndex(i,e){if(e<0||e>=this.children.length)throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`);this.getChildIndex(i),this.addChildAt(i,e)},getChildIndex(i){const e=this.children.indexOf(i);if(e===-1)throw new Error("The supplied Container must be a child of the caller");return e},addChildAt(i,e){this.allowChildren||L(J,"addChildAt: Only Containers will be allowed to add children in v8.0.0");const{children:t}=this;if(e<0||e>t.length)throw new Error(`${i}addChildAt: The index ${e} supplied is out of bounds ${t.length}`);if(i.parent){const r=i.parent.children.indexOf(i);if(i.parent===this&&r===e)return i;r!==-1&&i.parent.children.splice(r,1)}e===t.length?t.push(i):t.splice(e,0,i),i.parent=this,i.didChange=!0,i._updateFlags=15;const s=this.renderGroup||this.parentRenderGroup;return s&&s.addChild(i),this.sortableChildren&&(this.sortDirty=!0),this.emit("childAdded",i,this,e),i.emit("added",this),i},swapChildren(i,e){if(i===e)return;const t=this.getChildIndex(i),s=this.getChildIndex(e);this.children[t]=e,this.children[s]=i;const r=this.renderGroup||this.parentRenderGroup;r&&(r.structureDidChange=!0),this._didContainerChangeTick++},removeFromParent(){this.parent?.removeChild(this)},reparentChild(...i){return i.length===1?this.reparentChildAt(i[0],this.children.length):(i.forEach(e=>this.reparentChildAt(e,this.children.length)),i[0])},reparentChildAt(i,e){if(i.parent===this)return this.setChildIndex(i,e),i;const t=i.worldTransform.clone();i.removeFromParent(),this.addChildAt(i,e);const s=this.worldTransform.clone();return s.invert(),t.prepend(s),i.setFromMatrix(t),i},replaceChild(i,e){i.updateLocalTransform(),this.addChildAt(e,this.getChildIndex(i)),e.setFromMatrix(i.localTransform),e.updateLocalTransform(),this.removeChild(i)}},aS={collectRenderables(i,e,t){this.parentRenderLayer&&this.parentRenderLayer!==t||this.globalDisplayStatus<7||!this.includeInBuild||(this.sortableChildren&&this.sortChildren(),this.isSimple?this.collectRenderablesSimple(i,e,t):this.renderGroup?e.renderPipes.renderGroup.addRenderGroup(this.renderGroup,i):this.collectRenderablesWithEffects(i,e,t))},collectRenderablesSimple(i,e,t){const s=this.children,r=s.length;for(let n=0;n<r;n++)s[n].collectRenderables(i,e,t)},collectRenderablesWithEffects(i,e,t){const{renderPipes:s}=e;for(let r=0;r<this.effects.length;r++){const n=this.effects[r];s[n.pipe].push(n,this,i)}this.collectRenderablesSimple(i,e,t);for(let r=this.effects.length-1;r>=0;r--){const n=this.effects[r];s[n.pipe].pop(n,this,i)}}};class Mr{constructor(){this.pipe="filter",this.priority=1}destroy(){for(let e=0;e<this.filters.length;e++)this.filters[e].destroy();this.filters=null,this.filterArea=null}}class lS{constructor(){this._effectClasses=[],this._tests=[],this._initialized=!1}init(){this._initialized||(this._initialized=!0,this._effectClasses.forEach(e=>{this.add({test:e.test,maskClass:e})}))}add(e){this._tests.push(e)}getMaskEffect(e){this._initialized||this.init();for(let t=0;t<this._tests.length;t++){const s=this._tests[t];if(s.test(e))return Se.get(s.maskClass,e)}return e}returnMaskEffect(e){Se.return(e)}}const fu=new lS;V.handleByList(b.MaskEffect,fu._effectClasses);const cS={_maskEffect:null,_maskOptions:{inverse:!1},_filterEffect:null,effects:[],_markStructureAsChanged(){const i=this.renderGroup||this.parentRenderGroup;i&&(i.structureDidChange=!0)},addEffect(i){this.effects.indexOf(i)===-1&&(this.effects.push(i),this.effects.sort((t,s)=>t.priority-s.priority),this._markStructureAsChanged(),this._updateIsSimple())},removeEffect(i){const e=this.effects.indexOf(i);e!==-1&&(this.effects.splice(e,1),this._markStructureAsChanged(),this._updateIsSimple())},set mask(i){const e=this._maskEffect;e?.mask!==i&&(e&&(this.removeEffect(e),fu.returnMaskEffect(e),this._maskEffect=null),i!=null&&(this._maskEffect=fu.getMaskEffect(i),this.addEffect(this._maskEffect)))},get mask(){return this._maskEffect?.mask},setMask(i){this._maskOptions={...this._maskOptions,...i},i.mask&&(this.mask=i.mask),this._markStructureAsChanged()},set filters(i){!Array.isArray(i)&&i&&(i=[i]);const e=this._filterEffect||(this._filterEffect=new Mr);i=i;const t=i?.length>0,s=e.filters?.length>0,r=t!==s;i=Array.isArray(i)?i.slice(0):i,e.filters=Object.freeze(i),r&&(t?this.addEffect(e):(this.removeEffect(e),e.filters=i??null))},get filters(){return this._filterEffect?.filters},set filterArea(i){this._filterEffect||(this._filterEffect=new Mr),this._filterEffect.filterArea=i},get filterArea(){return this._filterEffect?.filterArea}},hS={label:null,get name(){return L(J,"Container.name property has been removed, use Container.label instead"),this.label},set name(i){L(J,"Container.name property has been removed, use Container.label instead"),this.label=i},getChildByName(i,e=!1){return this.getChildByLabel(i,e)},getChildByLabel(i,e=!1){const t=this.children;for(let s=0;s<t.length;s++){const r=t[s];if(r.label===i||i instanceof RegExp&&i.test(r.label))return r}if(e)for(let s=0;s<t.length;s++){const n=t[s].getChildByLabel(i,!0);if(n)return n}return null},getChildrenByLabel(i,e=!1,t=[]){const s=this.children;for(let r=0;r<s.length;r++){const n=s[r];(n.label===i||i instanceof RegExp&&i.test(n.label))&&t.push(n)}if(e)for(let r=0;r<s.length;r++)s[r].getChildrenByLabel(i,!0,t);return t}},He=Se.getPool(O),Ut=Se.getPool(De),uS=new O,dS={getFastGlobalBounds(i,e){e||(e=new De),e.clear(),this._getGlobalBoundsRecursive(!!i,e,this.parentRenderLayer),e.isValid||e.set(0,0,0,0);const t=this.renderGroup||this.parentRenderGroup;return e.applyMatrix(t.worldTransform),e},_getGlobalBoundsRecursive(i,e,t){let s=e;if(i&&this.parentRenderLayer&&this.parentRenderLayer!==t||this.localDisplayStatus!==7||!this.measurable)return;const r=!!this.effects.length;if((this.renderGroup||r)&&(s=Ut.get().clear()),this.boundsArea)e.addRect(this.boundsArea,this.worldTransform);else{if(this.renderPipeId){const o=this.bounds;s.addFrame(o.minX,o.minY,o.maxX,o.maxY,this.groupTransform)}const n=this.children;for(let o=0;o<n.length;o++)n[o]._getGlobalBoundsRecursive(i,s,t)}if(r){let n=!1;const o=this.renderGroup||this.parentRenderGroup;for(let a=0;a<this.effects.length;a++)this.effects[a].addBounds&&(n||(n=!0,s.applyMatrix(o.worldTransform)),this.effects[a].addBounds(s,!0));n&&s.applyMatrix(o.worldTransform.copyTo(uS).invert()),e.addBounds(s),Ut.return(s)}else this.renderGroup&&(e.addBounds(s,this.relativeGroupTransform),Ut.return(s))}};function pu(i,e,t){t.clear();let s,r;return i.parent?e?s=i.parent.worldTransform:(r=He.get().identity(),s=mu(i,r)):s=O.IDENTITY,am(i,t,s,e),r&&He.return(r),t.isValid||t.set(0,0,0,0),t}function am(i,e,t,s){if(!i.visible||!i.measurable)return;let r;s?r=i.worldTransform:(i.updateLocalTransform(),r=He.get(),r.appendFrom(i.localTransform,t));const n=e,o=!!i.effects.length;if(o&&(e=Ut.get().clear()),i.boundsArea)e.addRect(i.boundsArea,r);else{const a=i.bounds;a&&!a.isEmpty()&&(e.matrix=r,e.addBounds(a));for(let l=0;l<i.children.length;l++)am(i.children[l],e,r,s)}if(o){for(let a=0;a<i.effects.length;a++)i.effects[a].addBounds?.(e);n.addBounds(e,O.IDENTITY),Ut.return(e)}s||He.return(r)}function mu(i,e){const t=i.parent;return t&&(mu(t,e),t.updateLocalTransform(),e.append(t.localTransform)),e}function lm(i,e){if(i===16777215||!e)return e;if(e===16777215||!i)return i;const t=i>>16&255,s=i>>8&255,r=i&255,n=e>>16&255,o=e>>8&255,a=e&255,l=t*n/255|0,c=s*o/255|0,h=r*a/255|0;return(l<<16)+(c<<8)+h}const cm=16777215;function Fr(i,e){return i===cm?e:e===cm?i:lm(i,e)}function Ur(i){return((i&255)<<16)+(i&65280)+(i>>16&255)}const fS={getGlobalAlpha(i){if(i)return this.renderGroup?this.renderGroup.worldAlpha:this.parentRenderGroup?this.parentRenderGroup.worldAlpha*this.alpha:this.alpha;let e=this.alpha,t=this.parent;for(;t;)e*=t.alpha,t=t.parent;return e},getGlobalTransform(i=new O,e){if(e)return i.copyFrom(this.worldTransform);this.updateLocalTransform();const t=mu(this,He.get().identity());return i.appendFrom(this.localTransform,t),He.return(t),i},getGlobalTint(i){if(i)return this.renderGroup?Ur(this.renderGroup.worldColor):this.parentRenderGroup?Ur(Fr(this.localColor,this.parentRenderGroup.worldColor)):this.tint;let e=this.localColor,t=this.parent;for(;t;)e=Fr(e,t.localColor),t=t.parent;return Ur(e)}};function gu(i,e,t){return e.clear(),t||(t=O.IDENTITY),hm(i,e,t,i,!0),e.isValid||e.set(0,0,0,0),e}function hm(i,e,t,s,r){let n;if(r)n=He.get(),n=t.copyTo(n);else{if(!i.visible||!i.measurable)return;i.updateLocalTransform();const l=i.localTransform;n=He.get(),n.appendFrom(l,t)}const o=e,a=!!i.effects.length;if(a&&(e=Ut.get().clear()),i.boundsArea)e.addRect(i.boundsArea,n);else{i.renderPipeId&&(e.matrix=n,e.addBounds(i.bounds));const l=i.children;for(let c=0;c<l.length;c++)hm(l[c],e,n,s,!1)}if(a){for(let l=0;l<i.effects.length;l++)i.effects[l].addLocalBounds?.(e,s);o.addBounds(e,O.IDENTITY),Ut.return(e)}He.return(n)}function um(i,e){const t=i.children;for(let s=0;s<t.length;s++){const r=t[s],n=r.uid,o=(r._didViewChangeTick&65535)<<16|r._didContainerChangeTick&65535,a=e.index;(e.data[a]!==n||e.data[a+1]!==o)&&(e.data[e.index]=n,e.data[e.index+1]=o,e.didChange=!0),e.index=a+2,r.children.length&&um(r,e)}return e.didChange}const pS=new O,mS={_localBoundsCacheId:-1,_localBoundsCacheData:null,_setWidth(i,e){const t=Math.sign(this.scale.x)||1;e!==0?this.scale.x=i/e*t:this.scale.x=t},_setHeight(i,e){const t=Math.sign(this.scale.y)||1;e!==0?this.scale.y=i/e*t:this.scale.y=t},getLocalBounds(){this._localBoundsCacheData||(this._localBoundsCacheData={data:[],index:1,didChange:!1,localBounds:new De});const i=this._localBoundsCacheData;return i.index=1,i.didChange=!1,i.data[0]!==this._didViewChangeTick&&(i.didChange=!0,i.data[0]=this._didViewChangeTick),um(this,i),i.didChange&&gu(this,i.localBounds,pS),i.localBounds},getBounds(i,e){return pu(this,i,e||new De)}},gS={_onRender:null,set onRender(i){const e=this.renderGroup||this.parentRenderGroup;if(!i){this._onRender&&e?.removeOnRender(this),this._onRender=null;return}this._onRender||e?.addOnRender(this),this._onRender=i},get onRender(){return this._onRender}},_S={_zIndex:0,sortDirty:!1,sortableChildren:!1,get zIndex(){return this._zIndex},set zIndex(i){this._zIndex!==i&&(this._zIndex=i,this.depthOfChildModified())},depthOfChildModified(){this.parent&&(this.parent.sortableChildren=!0,this.parent.sortDirty=!0),this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0)},sortChildren(){this.sortDirty&&(this.sortDirty=!1,this.children.sort(xS))}};function xS(i,e){return i._zIndex-e._zIndex}const vS={getGlobalPosition(i=new X,e=!1){return this.parent?this.parent.toGlobal(this._position,i,e):(i.x=this._position.x,i.y=this._position.y),i},toGlobal(i,e,t=!1){const s=this.getGlobalTransform(He.get(),t);return e=s.apply(i,e),He.return(s),e},toLocal(i,e,t,s){e&&(i=e.toGlobal(i,t,s));const r=this.getGlobalTransform(He.get(),s);return t=r.applyInverse(i,t),He.return(r),t}};class dm{constructor(){this.uid=le("instructionSet"),this.instructions=[],this.instructionSize=0,this.renderables=[],this.gcTick=0}reset(){this.instructionSize=0}destroy(){this.instructions.length=0,this.renderables.length=0,this.renderPipes=null,this.gcTick=0}add(e){this.instructions[this.instructionSize++]=e}log(){this.instructions.length=this.instructionSize,console.table(this.instructions,["type","action"])}}let yS=0;class bS{constructor(e){this._poolKeyHash=Object.create(null),this._texturePool={},this.textureOptions=e||{},this.enableFullScreen=!1,this.textureStyle=new Ct(this.textureOptions)}createTexture(e,t,s){const r=new Ee({...this.textureOptions,width:e,height:t,resolution:1,antialias:s,autoGarbageCollect:!1});return new k({source:r,label:`texturePool_${yS++}`})}getOptimalTexture(e,t,s=1,r){let n=Math.ceil(e*s-1e-6),o=Math.ceil(t*s-1e-6);n=Mi(n),o=Mi(o);const a=(n<<17)+(o<<1)+(r?1:0);this._texturePool[a]||(this._texturePool[a]=[]);let l=this._texturePool[a].pop();return l||(l=this.createTexture(n,o,r)),l.source._resolution=s,l.source.width=n/s,l.source.height=o/s,l.source.pixelWidth=n,l.source.pixelHeight=o,l.frame.x=0,l.frame.y=0,l.frame.width=e,l.frame.height=t,l.updateUvs(),this._poolKeyHash[l.uid]=a,l}getSameSizeTexture(e,t=!1){const s=e.source;return this.getOptimalTexture(e.width,e.height,s._resolution,t)}returnTexture(e,t=!1){const s=this._poolKeyHash[e.uid];t&&(e.source.style=this.textureStyle),this._texturePool[s].push(e)}clear(e){if(e=e!==!1,e)for(const t in this._texturePool){const s=this._texturePool[t];if(s)for(let r=0;r<s.length;r++)s[r].destroy(!0)}this._texturePool={}}}const ye=new bS;Ui.register(ye);class _u{constructor(){this.renderPipeId="renderGroup",this.root=null,this.canBundle=!1,this.renderGroupParent=null,this.renderGroupChildren=[],this.worldTransform=new O,this.worldColorAlpha=4294967295,this.worldColor=16777215,this.worldAlpha=1,this.childrenToUpdate=Object.create(null),this.updateTick=0,this.gcTick=0,this.childrenRenderablesToUpdate={list:[],index:0},this.structureDidChange=!0,this.instructionSet=new dm,this._onRenderContainers=[],this.textureNeedsUpdate=!0,this.isCachedAsTexture=!1,this._matrixDirty=7}init(e){this.root=e,e._onRender&&this.addOnRender(e),e.didChange=!0;const t=e.children;for(let s=0;s<t.length;s++){const r=t[s];r._updateFlags=15,this.addChild(r)}}enableCacheAsTexture(e={}){this.textureOptions=e,this.isCachedAsTexture=!0,this.textureNeedsUpdate=!0}disableCacheAsTexture(){this.isCachedAsTexture=!1,this.texture&&(ye.returnTexture(this.texture,!0),this.texture=null)}updateCacheTexture(){this.textureNeedsUpdate=!0;const e=this._parentCacheAsTextureRenderGroup;e&&!e.textureNeedsUpdate&&e.updateCacheTexture()}reset(){this.renderGroupChildren.length=0;for(const e in this.childrenToUpdate){const t=this.childrenToUpdate[e];t.list.fill(null),t.index=0}this.childrenRenderablesToUpdate.index=0,this.childrenRenderablesToUpdate.list.fill(null),this.root=null,this.updateTick=0,this.structureDidChange=!0,this._onRenderContainers.length=0,this.renderGroupParent=null,this.disableCacheAsTexture()}get localTransform(){return this.root.localTransform}addRenderGroupChild(e){e.renderGroupParent&&e.renderGroupParent._removeRenderGroupChild(e),e.renderGroupParent=this,this.renderGroupChildren.push(e)}_removeRenderGroupChild(e){const t=this.renderGroupChildren.indexOf(e);t>-1&&this.renderGroupChildren.splice(t,1),e.renderGroupParent=null}addChild(e){if(this.structureDidChange=!0,e.parentRenderGroup=this,e.updateTick=-1,e.parent===this.root?e.relativeRenderGroupDepth=1:e.relativeRenderGroupDepth=e.parent.relativeRenderGroupDepth+1,e.didChange=!0,this.onChildUpdate(e),e.renderGroup){this.addRenderGroupChild(e.renderGroup);return}e._onRender&&this.addOnRender(e);const t=e.children;for(let s=0;s<t.length;s++)this.addChild(t[s])}removeChild(e){if(this.structureDidChange=!0,e._onRender&&(e.renderGroup||this.removeOnRender(e)),e.parentRenderGroup=null,e.renderGroup){this._removeRenderGroupChild(e.renderGroup);return}const t=e.children;for(let s=0;s<t.length;s++)this.removeChild(t[s])}removeChildren(e){for(let t=0;t<e.length;t++)this.removeChild(e[t])}onChildUpdate(e){let t=this.childrenToUpdate[e.relativeRenderGroupDepth];t||(t=this.childrenToUpdate[e.relativeRenderGroupDepth]={index:0,list:[]}),t.list[t.index++]=e}updateRenderable(e){e.globalDisplayStatus<7||(this.instructionSet.renderPipes[e.renderPipeId].updateRenderable(e),e.didViewUpdate=!1)}onChildViewUpdate(e){this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++]=e}get isRenderable(){return this.root.localDisplayStatus===7&&this.worldAlpha>0}addOnRender(e){this._onRenderContainers.push(e)}removeOnRender(e){this._onRenderContainers.splice(this._onRenderContainers.indexOf(e),1)}runOnRender(e){for(let t=0;t<this._onRenderContainers.length;t++)this._onRenderContainers[t]._onRender(e)}destroy(){this.disableCacheAsTexture(),this.renderGroupParent=null,this.root=null,this.childrenRenderablesToUpdate=null,this.childrenToUpdate=null,this.renderGroupChildren=null,this._onRenderContainers=null,this.instructionSet=null}getChildren(e=[]){const t=this.root.children;for(let s=0;s<t.length;s++)this._getChildren(t[s],e);return e}_getChildren(e,t=[]){if(t.push(e),e.renderGroup)return t;const s=e.children;for(let r=0;r<s.length;r++)this._getChildren(s[r],t);return t}invalidateMatrices(){this._matrixDirty=7}get inverseWorldTransform(){return(this._matrixDirty&1)===0?this._inverseWorldTransform:(this._matrixDirty&=-2,this._inverseWorldTransform||(this._inverseWorldTransform=new O),this._inverseWorldTransform.copyFrom(this.worldTransform).invert())}get textureOffsetInverseTransform(){return(this._matrixDirty&2)===0?this._textureOffsetInverseTransform:(this._matrixDirty&=-3,this._textureOffsetInverseTransform||(this._textureOffsetInverseTransform=new O),this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x,-this._textureBounds.y))}get inverseParentTextureTransform(){if((this._matrixDirty&4)===0)return this._inverseParentTextureTransform;this._matrixDirty&=-5;const e=this._parentCacheAsTextureRenderGroup;return e?(this._inverseParentTextureTransform||(this._inverseParentTextureTransform=new O),this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(e.inverseWorldTransform).translate(-e._textureBounds.x,-e._textureBounds.y)):this.worldTransform}get cacheToLocalTransform(){return this.isCachedAsTexture?this.textureOffsetInverseTransform:this._parentCacheAsTextureRenderGroup?this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform:null}}function TS(i,e,t={}){for(const s in e)!t[s]&&e[s]!==void 0&&(i[s]=e[s])}const xu=new Ue(null),Br=new Ue(null),vu=new Ue(null,1,1),Or=new Ue(null),Dr=1,yu=2,fs=4;class se extends Ze{constructor(e={}){super(),this.uid=le("renderable"),this._updateFlags=15,this.renderGroup=null,this.parentRenderGroup=null,this.parentRenderGroupIndex=0,this.didChange=!1,this.didViewUpdate=!1,this.relativeRenderGroupDepth=0,this.children=[],this.parent=null,this.includeInBuild=!0,this.measurable=!0,this.isSimple=!0,this.parentRenderLayer=null,this.updateTick=-1,this.localTransform=new O,this.relativeGroupTransform=new O,this.groupTransform=this.relativeGroupTransform,this.destroyed=!1,this._position=new Ue(this,0,0),this._scale=vu,this._pivot=Br,this._origin=Or,this._skew=xu,this._cx=1,this._sx=0,this._cy=0,this._sy=1,this._rotation=0,this.localColor=16777215,this.localAlpha=1,this.groupAlpha=1,this.groupColor=16777215,this.groupColorAlpha=4294967295,this.localBlendMode="inherit",this.groupBlendMode="normal",this.localDisplayStatus=7,this.globalDisplayStatus=7,this._didContainerChangeTick=0,this._didViewChangeTick=0,this._didLocalTransformChangeId=-1,this.effects=[],TS(this,e,{children:!0,parent:!0,effects:!0}),e.children?.forEach(t=>this.addChild(t)),e.parent?.addChild(this)}static mixin(e){L("8.8.0","Container.mixin is deprecated, please use extensions.mixin instead."),V.mixin(se,e)}set _didChangeId(e){this._didViewChangeTick=e>>12&4095,this._didContainerChangeTick=e&4095}get _didChangeId(){return this._didContainerChangeTick&4095|(this._didViewChangeTick&4095)<<12}addChild(...e){if(this.allowChildren||L(J,"addChild: Only Containers will be allowed to add children in v8.0.0"),e.length>1){for(let r=0;r<e.length;r++)this.addChild(e[r]);return e[0]}const t=e[0],s=this.renderGroup||this.parentRenderGroup;return t.parent===this?(this.children.splice(this.children.indexOf(t),1),this.children.push(t),s&&(s.structureDidChange=!0),t):(t.parent&&t.parent.removeChild(t),this.children.push(t),this.sortableChildren&&(this.sortDirty=!0),t.parent=this,t.didChange=!0,t._updateFlags=15,s&&s.addChild(t),this.emit("childAdded",t,this,this.children.length-1),t.emit("added",this),this._didViewChangeTick++,t._zIndex!==0&&t.depthOfChildModified(),t)}removeChild(...e){if(e.length>1){for(let r=0;r<e.length;r++)this.removeChild(e[r]);return e[0]}const t=e[0],s=this.children.indexOf(t);return s>-1&&(this._didViewChangeTick++,this.children.splice(s,1),this.renderGroup?this.renderGroup.removeChild(t):this.parentRenderGroup&&this.parentRenderGroup.removeChild(t),t.parentRenderLayer&&t.parentRenderLayer.detach(t),t.parent=null,this.emit("childRemoved",t,this,s),t.emit("removed",this)),t}_onUpdate(e){e&&e===this._skew&&this._updateSkew(),this._didContainerChangeTick++,!this.didChange&&(this.didChange=!0,this.parentRenderGroup&&this.parentRenderGroup.onChildUpdate(this))}set isRenderGroup(e){!!this.renderGroup!==e&&(e?this.enableRenderGroup():this.disableRenderGroup())}get isRenderGroup(){return!!this.renderGroup}enableRenderGroup(){if(this.renderGroup)return;const e=this.parentRenderGroup;e?.removeChild(this),this.renderGroup=Se.get(_u,this),this.groupTransform=O.IDENTITY,e?.addChild(this),this._updateIsSimple()}disableRenderGroup(){if(!this.renderGroup)return;const e=this.parentRenderGroup;e?.removeChild(this),Se.return(this.renderGroup),this.renderGroup=null,this.groupTransform=this.relativeGroupTransform,e?.addChild(this),this._updateIsSimple()}_updateIsSimple(){this.isSimple=!this.renderGroup&&this.effects.length===0}get worldTransform(){return this._worldTransform||(this._worldTransform=new O),this.renderGroup?this._worldTransform.copyFrom(this.renderGroup.worldTransform):this.parentRenderGroup&&this._worldTransform.appendFrom(this.relativeGroupTransform,this.parentRenderGroup.worldTransform),this._worldTransform}get x(){return this._position.x}set x(e){this._position.x=e}get y(){return this._position.y}set y(e){this._position.y=e}get position(){return this._position}set position(e){this._position.copyFrom(e)}get rotation(){return this._rotation}set rotation(e){this._rotation!==e&&(this._rotation=e,this._onUpdate(this._skew))}get angle(){return this.rotation*Lw}set angle(e){this.rotation=e*Nw}get pivot(){return this._pivot===Br&&(this._pivot=new Ue(this,0,0)),this._pivot}set pivot(e){this._pivot===Br&&(this._pivot=new Ue(this,0,0),this._origin!==Or&&H("Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.")),typeof e=="number"?this._pivot.set(e):this._pivot.copyFrom(e)}get skew(){return this._skew===xu&&(this._skew=new Ue(this,0,0)),this._skew}set skew(e){this._skew===xu&&(this._skew=new Ue(this,0,0)),this._skew.copyFrom(e)}get scale(){return this._scale===vu&&(this._scale=new Ue(this,1,1)),this._scale}set scale(e){this._scale===vu&&(this._scale=new Ue(this,0,0)),typeof e=="string"&&(e=parseFloat(e)),typeof e=="number"?this._scale.set(e):this._scale.copyFrom(e)}get origin(){return this._origin===Or&&(this._origin=new Ue(this,0,0)),this._origin}set origin(e){this._origin===Or&&(this._origin=new Ue(this,0,0),this._pivot!==Br&&H("Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.")),typeof e=="number"?this._origin.set(e):this._origin.copyFrom(e)}get width(){return Math.abs(this.scale.x*this.getLocalBounds().width)}set width(e){const t=this.getLocalBounds().width;this._setWidth(e,t)}get height(){return Math.abs(this.scale.y*this.getLocalBounds().height)}set height(e){const t=this.getLocalBounds().height;this._setHeight(e,t)}getSize(e){e||(e={});const t=this.getLocalBounds();return e.width=Math.abs(this.scale.x*t.width),e.height=Math.abs(this.scale.y*t.height),e}setSize(e,t){const s=this.getLocalBounds();typeof e=="object"?(t=e.height??e.width,e=e.width):t??(t=e),e!==void 0&&this._setWidth(e,s.width),t!==void 0&&this._setHeight(t,s.height)}_updateSkew(){const e=this._rotation,t=this._skew;this._cx=Math.cos(e+t._y),this._sx=Math.sin(e+t._y),this._cy=-Math.sin(e-t._x),this._sy=Math.cos(e-t._x)}updateTransform(e){return this.position.set(typeof e.x=="number"?e.x:this.position.x,typeof e.y=="number"?e.y:this.position.y),this.scale.set(typeof e.scaleX=="number"?e.scaleX||1:this.scale.x,typeof e.scaleY=="number"?e.scaleY||1:this.scale.y),this.rotation=typeof e.rotation=="number"?e.rotation:this.rotation,this.skew.set(typeof e.skewX=="number"?e.skewX:this.skew.x,typeof e.skewY=="number"?e.skewY:this.skew.y),this.pivot.set(typeof e.pivotX=="number"?e.pivotX:this.pivot.x,typeof e.pivotY=="number"?e.pivotY:this.pivot.y),this.origin.set(typeof e.originX=="number"?e.originX:this.origin.x,typeof e.originY=="number"?e.originY:this.origin.y),this}setFromMatrix(e){e.decompose(this)}updateLocalTransform(){const e=this._didContainerChangeTick;if(this._didLocalTransformChangeId===e)return;this._didLocalTransformChangeId=e;const t=this.localTransform,s=this._scale,r=this._pivot,n=this._origin,o=this._position,a=s._x,l=s._y,c=r._x,h=r._y,u=-n._x,d=-n._y;t.a=this._cx*a,t.b=this._sx*a,t.c=this._cy*l,t.d=this._sy*l,t.tx=o._x-(c*t.a+h*t.c)+(u*t.a+d*t.c)-u,t.ty=o._y-(c*t.b+h*t.d)+(u*t.b+d*t.d)-d}set alpha(e){e!==this.localAlpha&&(this.localAlpha=e,this._updateFlags|=Dr,this._onUpdate())}get alpha(){return this.localAlpha}set tint(e){const s=ue.shared.setValue(e??16777215).toBgrNumber();s!==this.localColor&&(this.localColor=s,this._updateFlags|=Dr,this._onUpdate())}get tint(){return Ur(this.localColor)}set blendMode(e){this.localBlendMode!==e&&(this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._updateFlags|=yu,this.localBlendMode=e,this._onUpdate())}get blendMode(){return this.localBlendMode}get visible(){return!!(this.localDisplayStatus&2)}set visible(e){const t=e?2:0;(this.localDisplayStatus&2)!==t&&(this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._updateFlags|=fs,this.localDisplayStatus^=2,this._onUpdate())}get culled(){return!(this.localDisplayStatus&4)}set culled(e){const t=e?0:4;(this.localDisplayStatus&4)!==t&&(this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._updateFlags|=fs,this.localDisplayStatus^=4,this._onUpdate())}get renderable(){return!!(this.localDisplayStatus&1)}set renderable(e){const t=e?1:0;(this.localDisplayStatus&1)!==t&&(this._updateFlags|=fs,this.localDisplayStatus^=1,this.parentRenderGroup&&(this.parentRenderGroup.structureDidChange=!0),this._onUpdate())}get isRenderable(){return this.localDisplayStatus===7&&this.groupAlpha>0}destroy(e=!1){if(this.destroyed)return;this.destroyed=!0;let t;if(this.children.length&&(t=this.removeChildren(0,this.children.length)),this.removeFromParent(),this.parent=null,this._maskEffect=null,this._filterEffect=null,this.effects=null,this._position=null,this._scale=null,this._pivot=null,this._origin=null,this._skew=null,this.emit("destroyed",this),this.removeAllListeners(),(typeof e=="boolean"?e:e?.children)&&t)for(let r=0;r<t.length;++r)t[r].destroy(e);this.renderGroup?.destroy(),this.renderGroup=null}}V.mixin(se,oS,dS,vS,gS,mS,cS,hS,_S,iS,nS,fS,aS);class bu extends se{constructor(e){super(e),this.canBundle=!0,this.allowChildren=!1,this._roundPixels=0,this._lastUsed=-1,this._gpuData=Object.create(null),this.autoGarbageCollect=!0,this._gcLastUsed=-1,this._bounds=new De(0,1,0,0),this._boundsDirty=!0,this.autoGarbageCollect=e.autoGarbageCollect??!0}get bounds(){return this._boundsDirty?(this.updateBounds(),this._boundsDirty=!1,this._bounds):this._bounds}get roundPixels(){return!!this._roundPixels}set roundPixels(e){this._roundPixels=e?1:0}containsPoint(e){const t=this.bounds,{x:s,y:r}=e;return s>=t.minX&&s<=t.maxX&&r>=t.minY&&r<=t.maxY}onViewUpdate(){if(this._didViewChangeTick++,this._boundsDirty=!0,this.didViewUpdate)return;this.didViewUpdate=!0;const e=this.renderGroup||this.parentRenderGroup;e&&e.onChildViewUpdate(this)}unload(){this.emit("unload",this);for(const e in this._gpuData)this._gpuData[e]?.destroy();this._gpuData=Object.create(null),this.onViewUpdate()}destroy(e){this.unload(),super.destroy(e),this._bounds=null}collectRenderablesSimple(e,t,s){const{renderPipes:r}=t;r.blendMode.pushBlendMode(this,this.groupBlendMode,e),r[this.renderPipeId].addRenderable(this,e),this.didViewUpdate=!1;const o=this.children,a=o.length;for(let l=0;l<a;l++)o[l].collectRenderables(e,t,s);r.blendMode.popBlendMode(e)}}class Be extends bu{constructor(e=k.EMPTY){e instanceof k&&(e={texture:e});const{texture:t=k.EMPTY,anchor:s,roundPixels:r,width:n,height:o,...a}=e;super({label:"Sprite",...a}),this.renderPipeId="sprite",this.batched=!0,this._visualBounds={minX:0,maxX:1,minY:0,maxY:0},this._anchor=new Ue({_onUpdate:()=>{this.onViewUpdate()}}),s?this.anchor=s:t.defaultAnchor&&(this.anchor=t.defaultAnchor),this.texture=t,this.allowChildren=!1,this.roundPixels=r??!1,n!==void 0&&(this.width=n),o!==void 0&&(this.height=o)}static from(e,t=!1){return e instanceof k?new Be(e):new Be(k.from(e,t))}set texture(e){e||(e=k.EMPTY);const t=this._texture;t!==e&&(t&&t.dynamic&&t.off("update",this.onViewUpdate,this),e.dynamic&&e.on("update",this.onViewUpdate,this),this._texture=e,this._width&&this._setWidth(this._width,this._texture.orig.width),this._height&&this._setHeight(this._height,this._texture.orig.height),this.onViewUpdate())}get texture(){return this._texture}get visualBounds(){return Yp(this._visualBounds,this._anchor,this._texture),this._visualBounds}get sourceBounds(){return L("8.6.1","Sprite.sourceBounds is deprecated, use visualBounds instead."),this.visualBounds}updateBounds(){const e=this._anchor,t=this._texture,s=this._bounds,{width:r,height:n}=t.orig;s.minX=-e._x*r,s.maxX=s.minX+r,s.minY=-e._y*n,s.maxY=s.minY+n}destroy(e=!1){if(super.destroy(e),typeof e=="boolean"?e:e?.texture){const s=typeof e=="boolean"?e:e?.textureSource;this._texture.destroy(s)}this._texture=null,this._visualBounds=null,this._bounds=null,this._anchor=null}get anchor(){return this._anchor}set anchor(e){typeof e=="number"?this._anchor.set(e):this._anchor.copyFrom(e)}get width(){return Math.abs(this.scale.x)*this._texture.orig.width}set width(e){this._setWidth(e,this._texture.orig.width),this._width=e}get height(){return Math.abs(this.scale.y)*this._texture.orig.height}set height(e){this._setHeight(e,this._texture.orig.height),this._height=e}getSize(e){return e||(e={}),e.width=Math.abs(this.scale.x)*this._texture.orig.width,e.height=Math.abs(this.scale.y)*this._texture.orig.height,e}setSize(e,t){typeof e=="object"?(t=e.height??e.width,e=e.width):t??(t=e),e!==void 0&&this._setWidth(e,this._texture.orig.width),t!==void 0&&this._setHeight(t,this._texture.orig.height)}}const wS=new De;function fm(i,e,t){const s=wS;i.measurable=!0,pu(i,t,s),e.addBoundsMask(s),i.measurable=!1}function pm(i,e,t){const s=Ut.get();i.measurable=!0;const r=He.get().identity(),n=mm(i,t,r);gu(i,s,n),i.measurable=!1,e.addBoundsMask(s),He.return(r),Ut.return(s)}function mm(i,e,t){return i?(i!==e&&(mm(i.parent,e,t),i.updateLocalTransform(),t.append(i.localTransform)),t):(H("Mask bounds, renderable is not inside the root container"),t)}class gm{constructor(e){this.priority=0,this.inverse=!1,this.pipe="alphaMask",e?.mask&&this.init(e.mask)}init(e){this.mask=e,this.renderMaskToTexture=!(e instanceof Be),this.mask.renderable=this.renderMaskToTexture,this.mask.includeInBuild=!this.renderMaskToTexture,this.mask.measurable=!1}reset(){this.mask!==null&&(this.mask.measurable=!0,this.mask=null)}addBounds(e,t){this.inverse||fm(this.mask,e,t)}addLocalBounds(e,t){pm(this.mask,e,t)}containsPoint(e,t){const s=this.mask;return t(s,e)}destroy(){this.reset()}static test(e){return e instanceof Be}}gm.extension=b.MaskEffect;class _m{constructor(e){this.priority=0,this.pipe="colorMask",e?.mask&&this.init(e.mask)}init(e){this.mask=e}destroy(){}static test(e){return typeof e=="number"}}_m.extension=b.MaskEffect;class xm{constructor(e){this.priority=0,this.pipe="stencilMask",e?.mask&&this.init(e.mask)}init(e){this.mask=e,this.mask.includeInBuild=!1,this.mask.measurable=!1}reset(){this.mask!==null&&(this.mask.measurable=!0,this.mask.includeInBuild=!0,this.mask=null)}addBounds(e,t){fm(this.mask,e,t)}addLocalBounds(e,t){pm(this.mask,e,t)}containsPoint(e,t){const s=this.mask;return t(s,e)}destroy(){this.reset()}static test(e){return e instanceof se}}xm.extension=b.MaskEffect;let vm={createCanvas:(i,e)=>{const t=document.createElement("canvas");return t.width=i,t.height=e,t},createImage:()=>new Image,getCanvasRenderingContext2D:()=>CanvasRenderingContext2D,getWebGLRenderingContext:()=>WebGLRenderingContext,getNavigator:()=>navigator,getBaseUrl:()=>document.baseURI??window.location.href,getFontFaceSet:()=>document.fonts,fetch:(i,e)=>fetch(i,e),parseXML:i=>new DOMParser().parseFromString(i,"text/xml")};const Y={get(){return vm},set(i){vm=i}};class Bt extends Ee{constructor(e){e.resource||(e.resource=Y.get().createCanvas()),e.width||(e.width=e.resource.width,e.autoDensity||(e.width/=e.resolution)),e.height||(e.height=e.resource.height,e.autoDensity||(e.height/=e.resolution)),super(e),this.uploadMethodId="image",this.autoDensity=e.autoDensity,this.resizeCanvas(),this.transparent=!!e.transparent}resizeCanvas(){this.autoDensity&&"style"in this.resource&&(this.resource.style.width=`${this.width}px`,this.resource.style.height=`${this.height}px`),(this.resource.width!==this.pixelWidth||this.resource.height!==this.pixelHeight)&&(this.resource.width=this.pixelWidth,this.resource.height=this.pixelHeight)}resize(e=this.width,t=this.height,s=this._resolution){const r=super.resize(e,t,s);return r&&this.resizeCanvas(),r}static test(e){return globalThis.HTMLCanvasElement&&e instanceof HTMLCanvasElement||globalThis.OffscreenCanvas&&e instanceof OffscreenCanvas}get context2D(){return this._context2D||(this._context2D=this.resource.getContext("2d"))}}Bt.extension=b.TextureSource;class Et extends Ee{constructor(e){super(e),this.uploadMethodId="image",this.autoGarbageCollect=!0}static test(e){return globalThis.HTMLImageElement&&e instanceof HTMLImageElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap||globalThis.VideoFrame&&e instanceof VideoFrame}}Et.extension=b.TextureSource;var Bi=(i=>(i[i.INTERACTION=50]="INTERACTION",i[i.HIGH=25]="HIGH",i[i.NORMAL=0]="NORMAL",i[i.LOW=-25]="LOW",i[i.UTILITY=-50]="UTILITY",i))(Bi||{});class Tu{constructor(e,t=null,s=0,r=!1){this.next=null,this.previous=null,this._destroyed=!1,this._fn=e,this._context=t,this.priority=s,this._once=r}match(e,t=null){return this._fn===e&&this._context===t}emit(e){this._fn&&(this._context?this._fn.call(this._context,e):this._fn(e));const t=this.next;return this._once&&this.destroy(!0),this._destroyed&&(this.next=null),t}connect(e){this.previous=e,e.next&&(e.next.previous=this),this.next=e.next,e.next=this}destroy(e=!1){this._destroyed=!0,this._fn=null,this._context=null,this.previous&&(this.previous.next=this.next),this.next&&(this.next.previous=this.previous);const t=this.next;return this.next=e?null:t,this.previous=null,t}}const ym=class rt{constructor(){this.autoStart=!1,this.deltaTime=1,this.lastTime=-1,this.speed=1,this.started=!1,this._requestId=null,this._maxElapsedMS=100,this._minElapsedMS=0,this._protected=!1,this._lastFrame=-1,this._head=new Tu(null,null,1/0),this.deltaMS=1/rt.targetFPMS,this.elapsedMS=1/rt.targetFPMS,this._tick=e=>{this._requestId=null,this.started&&(this.update(e),this.started&&this._requestId===null&&this._head.next&&(this._requestId=requestAnimationFrame(this._tick)))}}_requestIfNeeded(){this._requestId===null&&this._head.next&&(this.lastTime=performance.now(),this._lastFrame=this.lastTime,this._requestId=requestAnimationFrame(this._tick))}_cancelIfNeeded(){this._requestId!==null&&(cancelAnimationFrame(this._requestId),this._requestId=null)}_startIfPossible(){this.started?this._requestIfNeeded():this.autoStart&&this.start()}add(e,t,s=Bi.NORMAL){return this._addListener(new Tu(e,t,s))}addOnce(e,t,s=Bi.NORMAL){return this._addListener(new Tu(e,t,s,!0))}_addListener(e){let t=this._head.next,s=this._head;if(!t)e.connect(s);else{for(;t;){if(e.priority>t.priority){e.connect(s);break}s=t,t=t.next}e.previous||e.connect(s)}return this._startIfPossible(),this}remove(e,t){let s=this._head.next;for(;s;)s.match(e,t)?s=s.destroy():s=s.next;return this._head.next||this._cancelIfNeeded(),this}get count(){if(!this._head)return 0;let e=0,t=this._head;for(;t=t.next;)e++;return e}start(){this.started||(this.started=!0,this._requestIfNeeded())}stop(){this.started&&(this.started=!1,this._cancelIfNeeded())}destroy(){if(!this._protected){this.stop();let e=this._head.next;for(;e;)e=e.destroy(!0);this._head.destroy(),this._head=null}}update(e=performance.now()){let t;if(e>this.lastTime){if(t=this.elapsedMS=e-this.lastTime,t>this._maxElapsedMS&&(t=this._maxElapsedMS),t*=this.speed,this._minElapsedMS){const n=e-this._lastFrame|0;if(n<this._minElapsedMS)return;this._lastFrame=e-n%this._minElapsedMS}this.deltaMS=t,this.deltaTime=this.deltaMS*rt.targetFPMS;const s=this._head;let r=s.next;for(;r;)r=r.emit(this);s.next||this._cancelIfNeeded()}else this.deltaTime=this.deltaMS=this.elapsedMS=0;this.lastTime=e}get FPS(){return 1e3/this.elapsedMS}get minFPS(){return 1e3/this._maxElapsedMS}set minFPS(e){const t=Math.min(this.maxFPS,e),s=Math.min(Math.max(0,t)/1e3,rt.targetFPMS);this._maxElapsedMS=1/s}get maxFPS(){return this._minElapsedMS?Math.round(1e3/this._minElapsedMS):0}set maxFPS(e){if(e===0)this._minElapsedMS=0;else{const t=Math.max(this.minFPS,e);this._minElapsedMS=1/(t/1e3)}}static get shared(){if(!rt._shared){const e=rt._shared=new rt;e.autoStart=!0,e._protected=!0}return rt._shared}static get system(){if(!rt._system){const e=rt._system=new rt;e.autoStart=!0,e._protected=!0}return rt._system}};ym.targetFPMS=.06;let Je=ym,wu;async function bm(){return wu??(wu=(async()=>{const e=Y.get().createCanvas(1,1).getContext("webgl");if(!e)return"premultiply-alpha-on-upload";const t=await new Promise(o=>{const a=document.createElement("video");a.onloadeddata=()=>o(a),a.onerror=()=>o(null),a.autoplay=!1,a.crossOrigin="anonymous",a.preload="auto",a.src="data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=",a.load()});if(!t)return"premultiply-alpha-on-upload";const s=e.createTexture();e.bindTexture(e.TEXTURE_2D,s);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,s,0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL,e.NONE),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,t);const n=new Uint8Array(4);return e.readPixels(0,0,1,1,e.RGBA,e.UNSIGNED_BYTE,n),e.deleteFramebuffer(r),e.deleteTexture(s),e.getExtension("WEBGL_lose_context")?.loseContext(),n[0]<=n[3]?"premultiplied-alpha":"premultiply-alpha-on-upload"})()),wu}const Gr=class Kx extends Ee{constructor(e){super(e),this.isReady=!1,this.uploadMethodId="video",e={...Kx.defaultOptions,...e},this._autoUpdate=!0,this._isConnectedToTicker=!1,this._updateFPS=e.updateFPS||0,this._msToNextUpdate=0,this.autoPlay=e.autoPlay!==!1,this.alphaMode=e.alphaMode??"premultiply-alpha-on-upload",this._videoFrameRequestCallback=this._videoFrameRequestCallback.bind(this),this._videoFrameRequestCallbackHandle=null,this._load=null,this._resolve=null,this._reject=null,this._onCanPlay=this._onCanPlay.bind(this),this._onCanPlayThrough=this._onCanPlayThrough.bind(this),this._onError=this._onError.bind(this),this._onPlayStart=this._onPlayStart.bind(this),this._onPlayStop=this._onPlayStop.bind(this),this._onSeeked=this._onSeeked.bind(this),e.autoLoad!==!1&&this.load()}updateFrame(){if(!this.destroyed){if(this._updateFPS){const e=Je.shared.elapsedMS*this.resource.playbackRate;this._msToNextUpdate=Math.floor(this._msToNextUpdate-e)}(!this._updateFPS||this._msToNextUpdate<=0)&&(this._msToNextUpdate=this._updateFPS?Math.floor(1e3/this._updateFPS):0),this.isValid&&this.update()}}_videoFrameRequestCallback(){this.updateFrame(),this.destroyed?this._videoFrameRequestCallbackHandle=null:this._videoFrameRequestCallbackHandle=this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback)}get isValid(){return!!this.resource.videoWidth&&!!this.resource.videoHeight}async load(){if(this._load)return this._load;const e=this.resource,t=this.options;return(e.readyState===e.HAVE_ENOUGH_DATA||e.readyState===e.HAVE_FUTURE_DATA)&&e.width&&e.height&&(e.complete=!0),e.addEventListener("play",this._onPlayStart),e.addEventListener("pause",this._onPlayStop),e.addEventListener("seeked",this._onSeeked),this._isSourceReady()?this._mediaReady():(t.preload||e.addEventListener("canplay",this._onCanPlay),e.addEventListener("canplaythrough",this._onCanPlayThrough),e.addEventListener("error",this._onError,!0)),this.alphaMode=await bm(),this._load=new Promise((s,r)=>{this.isValid?s(this):(this._resolve=s,this._reject=r,t.preloadTimeoutMs!==void 0&&(this._preloadTimeout=setTimeout(()=>{this._onError(new ErrorEvent(`Preload exceeded timeout of ${t.preloadTimeoutMs}ms`))})),e.load())}),this._load}_onError(e){this.resource.removeEventListener("error",this._onError,!0),this.emit("error",e),this._reject&&(this._reject(e),this._reject=null,this._resolve=null)}_isSourcePlaying(){const e=this.resource;return!e.paused&&!e.ended}_isSourceReady(){return this.resource.readyState>2}_onPlayStart(){this.isValid||this._mediaReady(),this._configureAutoUpdate()}_onPlayStop(){this._configureAutoUpdate()}_onSeeked(){this._autoUpdate&&!this._isSourcePlaying()&&(this._msToNextUpdate=0,this.updateFrame(),this._msToNextUpdate=0)}_onCanPlay(){this.resource.removeEventListener("canplay",this._onCanPlay),this._mediaReady()}_onCanPlayThrough(){this.resource.removeEventListener("canplaythrough",this._onCanPlay),this._preloadTimeout&&(clearTimeout(this._preloadTimeout),this._preloadTimeout=void 0),this._mediaReady()}_mediaReady(){const e=this.resource;this.isValid&&(this.isReady=!0,this.resize(e.videoWidth,e.videoHeight)),this._msToNextUpdate=0,this.updateFrame(),this._msToNextUpdate=0,this._resolve&&(this._resolve(this),this._resolve=null,this._reject=null),this._isSourcePlaying()?this._onPlayStart():this.autoPlay&&this.resource.play()}destroy(){this._configureAutoUpdate();const e=this.resource;e&&(e.removeEventListener("play",this._onPlayStart),e.removeEventListener("pause",this._onPlayStop),e.removeEventListener("seeked",this._onSeeked),e.removeEventListener("canplay",this._onCanPlay),e.removeEventListener("canplaythrough",this._onCanPlayThrough),e.removeEventListener("error",this._onError,!0),e.pause(),e.src="",e.load()),super.destroy()}get autoUpdate(){return this._autoUpdate}set autoUpdate(e){e!==this._autoUpdate&&(this._autoUpdate=e,this._configureAutoUpdate())}get updateFPS(){return this._updateFPS}set updateFPS(e){e!==this._updateFPS&&(this._updateFPS=e,this._configureAutoUpdate())}_configureAutoUpdate(){this._autoUpdate&&this._isSourcePlaying()?!this._updateFPS&&this.resource.requestVideoFrameCallback?(this._isConnectedToTicker&&(Je.shared.remove(this.updateFrame,this),this._isConnectedToTicker=!1,this._msToNextUpdate=0),this._videoFrameRequestCallbackHandle===null&&(this._videoFrameRequestCallbackHandle=this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))):(this._videoFrameRequestCallbackHandle!==null&&(this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),this._videoFrameRequestCallbackHandle=null),this._isConnectedToTicker||(Je.shared.add(this.updateFrame,this),this._isConnectedToTicker=!0,this._msToNextUpdate=0)):(this._videoFrameRequestCallbackHandle!==null&&(this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle),this._videoFrameRequestCallbackHandle=null),this._isConnectedToTicker&&(Je.shared.remove(this.updateFrame,this),this._isConnectedToTicker=!1,this._msToNextUpdate=0))}static test(e){return globalThis.HTMLVideoElement&&e instanceof HTMLVideoElement}};Gr.extension=b.TextureSource,Gr.defaultOptions={...Ee.defaultOptions,autoLoad:!0,autoPlay:!0,updateFPS:0,crossorigin:!0,loop:!1,muted:!0,playsinline:!0,preload:!1},Gr.MIME_TYPES={ogv:"video/ogg",mov:"video/quicktime",m4v:"video/mp4"};let ps=Gr;const ft=(i,e,t=!1)=>(Array.isArray(i)||(i=[i]),e?i.map(s=>typeof s=="string"||t?e(s):s):i);class SS{constructor(){this._parsers=[],this._cache=new Map,this._cacheMap=new Map}reset(){this._cacheMap.clear(),this._cache.clear()}has(e){return this._cache.has(e)}get(e){const t=this._cache.get(e);return t||H(`[Assets] Asset id ${e} was not found in the Cache`),t}set(e,t){const s=ft(e);let r;for(let l=0;l<this.parsers.length;l++){const c=this.parsers[l];if(c.test(t)){r=c.getCacheableAssets(s,t);break}}const n=new Map(Object.entries(r||{}));r||s.forEach(l=>{n.set(l,t)});const o=[...n.keys()],a={cacheKeys:o,keys:s};s.forEach(l=>{this._cacheMap.set(l,a)}),o.forEach(l=>{const c=r?r[l]:t;this._cache.has(l)&&this._cache.get(l)!==c&&H("[Cache] already has key:",l),this._cache.set(l,n.get(l))})}remove(e){if(!this._cacheMap.has(e)){H(`[Assets] Asset id ${e} was not found in the Cache`);return}const t=this._cacheMap.get(e);t.cacheKeys.forEach(r=>{this._cache.delete(r)}),t.keys.forEach(r=>{this._cacheMap.delete(r)})}get parsers(){return this._parsers}}const ae=new SS,Su=[];V.handleByList(b.TextureSource,Su);function Tm(i={}){const e=i&&i.resource,t=e?i.resource:i,s=e?i:{resource:i};for(let r=0;r<Su.length;r++){const n=Su[r];if(n.test(t))return new n(s)}throw new Error(`Could not find a source type for resource: ${s.resource}`)}function CS(i={},e=!1){const t=i&&i.resource,s=t?i.resource:i,r=t?i:{resource:i};if(!e&&ae.has(s))return ae.get(s);const n=new k({source:Tm(r)});return n.on("destroy",()=>{ae.has(s)&&ae.remove(s)}),e||ae.set(s,n),n}function AS(i,e=!1){return typeof i=="string"?ae.get(i):i instanceof Ee?new k({source:i}):CS(i,e)}k.from=AS,Ee.from=Tm,V.add(gm,_m,xm,ps,Et,Bt,ou);var jt=(i=>(i[i.Low=0]="Low",i[i.Normal=1]="Normal",i[i.High=2]="High",i))(jt||{});function pt(i){if(typeof i!="string")throw new TypeError(`Path must be a string. Received ${JSON.stringify(i)}`)}function ms(i){return i.split("?")[0].split("#")[0]}function ES(i){return i.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function IS(i,e,t){return i.replace(new RegExp(ES(e),"g"),t)}function PS(i,e){let t="",s=0,r=-1,n=0,o=-1;for(let a=0;a<=i.length;++a){if(a<i.length)o=i.charCodeAt(a);else{if(o===47)break;o=47}if(o===47){if(!(r===a-1||n===1))if(r!==a-1&&n===2){if(t.length<2||s!==2||t.charCodeAt(t.length-1)!==46||t.charCodeAt(t.length-2)!==46){if(t.length>2){const l=t.lastIndexOf("/");if(l!==t.length-1){l===-1?(t="",s=0):(t=t.slice(0,l),s=t.length-1-t.lastIndexOf("/")),r=a,n=0;continue}}else if(t.length===2||t.length===1){t="",s=0,r=a,n=0;continue}}}else t.length>0?t+=`/${i.slice(r+1,a)}`:t=i.slice(r+1,a),s=a-r-1;r=a,n=0}else o===46&&n!==-1?++n:n=-1}return t}const Qe={toPosix(i){return IS(i,"\\","/")},isUrl(i){return/^https?:/.test(this.toPosix(i))},isDataUrl(i){return/^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(i)},isBlobUrl(i){return i.startsWith("blob:")},hasProtocol(i){return/^[^/:]+:/.test(this.toPosix(i))},getProtocol(i){pt(i),i=this.toPosix(i);const e=/^file:\/\/\//.exec(i);if(e)return e[0];const t=/^[^/:]+:\/{0,2}/.exec(i);return t?t[0]:""},toAbsolute(i,e,t){if(pt(i),this.isDataUrl(i)||this.isBlobUrl(i))return i;const s=ms(this.toPosix(e??Y.get().getBaseUrl())),r=ms(this.toPosix(t??this.rootname(s)));return i=this.toPosix(i),i.startsWith("/")?Qe.join(r,i.slice(1)):this.isAbsolute(i)?i:this.join(s,i)},normalize(i){if(pt(i),i.length===0)return".";if(this.isDataUrl(i)||this.isBlobUrl(i))return i;i=this.toPosix(i);let e="";const t=i.startsWith("/");this.hasProtocol(i)&&(e=this.rootname(i),i=i.slice(e.length));const s=i.endsWith("/");return i=PS(i),i.length>0&&s&&(i+="/"),t?`/${i}`:e+i},isAbsolute(i){return pt(i),i=this.toPosix(i),this.hasProtocol(i)?!0:i.startsWith("/")},join(...i){if(i.length===0)return".";let e;for(let t=0;t<i.length;++t){const s=i[t];if(pt(s),s.length>0)if(e===void 0)e=s;else{const r=i[t-1]??"";this.joinExtensions.includes(this.extname(r).toLowerCase())?e+=`/../${s}`:e+=`/${s}`}}return e===void 0?".":this.normalize(e)},dirname(i){if(pt(i),i.length===0)return".";i=this.toPosix(i);let e=i.charCodeAt(0);const t=e===47;let s=-1,r=!0;const n=this.getProtocol(i),o=i;i=i.slice(n.length);for(let a=i.length-1;a>=1;--a)if(e=i.charCodeAt(a),e===47){if(!r){s=a;break}}else r=!1;return s===-1?t?"/":this.isUrl(o)?n+i:n:t&&s===1?"//":n+i.slice(0,s)},rootname(i){pt(i),i=this.toPosix(i);let e="";if(i.startsWith("/")?e="/":e=this.getProtocol(i),this.isUrl(i)){const t=i.indexOf("/",e.length);t!==-1?e=i.slice(0,t):e=i,e.endsWith("/")||(e+="/")}return e},basename(i,e){pt(i),e&&pt(e),i=ms(this.toPosix(i));let t=0,s=-1,r=!0,n;if(e!==void 0&&e.length>0&&e.length<=i.length){if(e.length===i.length&&e===i)return"";let o=e.length-1,a=-1;for(n=i.length-1;n>=0;--n){const l=i.charCodeAt(n);if(l===47){if(!r){t=n+1;break}}else a===-1&&(r=!1,a=n+1),o>=0&&(l===e.charCodeAt(o)?--o===-1&&(s=n):(o=-1,s=a))}return t===s?s=a:s===-1&&(s=i.length),i.slice(t,s)}for(n=i.length-1;n>=0;--n)if(i.charCodeAt(n)===47){if(!r){t=n+1;break}}else s===-1&&(r=!1,s=n+1);return s===-1?"":i.slice(t,s)},extname(i){pt(i),i=ms(this.toPosix(i));let e=-1,t=0,s=-1,r=!0,n=0;for(let o=i.length-1;o>=0;--o){const a=i.charCodeAt(o);if(a===47){if(!r){t=o+1;break}continue}s===-1&&(r=!1,s=o+1),a===46?e===-1?e=o:n!==1&&(n=1):e!==-1&&(n=-1)}return e===-1||s===-1||n===0||n===1&&e===s-1&&e===t+1?"":i.slice(e,s)},parse(i){pt(i);const e={root:"",dir:"",base:"",ext:"",name:""};if(i.length===0)return e;i=ms(this.toPosix(i));let t=i.charCodeAt(0);const s=this.isAbsolute(i);let r;e.root=this.rootname(i),s||this.hasProtocol(i)?r=1:r=0;let n=-1,o=0,a=-1,l=!0,c=i.length-1,h=0;for(;c>=r;--c){if(t=i.charCodeAt(c),t===47){if(!l){o=c+1;break}continue}a===-1&&(l=!1,a=c+1),t===46?n===-1?n=c:h!==1&&(h=1):n!==-1&&(h=-1)}return n===-1||a===-1||h===0||h===1&&n===a-1&&n===o+1?a!==-1&&(o===0&&s?e.base=e.name=i.slice(1,a):e.base=e.name=i.slice(o,a)):(o===0&&s?(e.name=i.slice(1,n),e.base=i.slice(1,a)):(e.name=i.slice(o,n),e.base=i.slice(o,a)),e.ext=i.slice(n,a)),e.dir=this.dirname(i),e},sep:"/",delimiter:":",joinExtensions:[".html"]};function wm(i,e,t,s,r){const n=e[t];for(let o=0;o<n.length;o++){const a=n[o];t<e.length-1?wm(i.replace(s[t],a),e,t+1,s,r):r.push(i.replace(s[t],a))}}function RS(i){const e=/\{(.*?)\}/g,t=i.match(e),s=[];if(t){const r=[];t.forEach(n=>{const o=n.substring(1,n.length-1).split(",");r.push(o)}),wm(i,r,0,t,s)}else s.push(i);return s}const zr=i=>!Array.isArray(i);class Oi{constructor(){this._defaultBundleIdentifierOptions={connector:"-",createBundleAssetId:(e,t)=>`${e}${this._bundleIdConnector}${t}`,extractAssetIdFromBundle:(e,t)=>t.replace(`${e}${this._bundleIdConnector}`,"")},this._bundleIdConnector=this._defaultBundleIdentifierOptions.connector,this._createBundleAssetId=this._defaultBundleIdentifierOptions.createBundleAssetId,this._extractAssetIdFromBundle=this._defaultBundleIdentifierOptions.extractAssetIdFromBundle,this._assetMap={},this._preferredOrder=[],this._parsers=[],this._resolverHash={},this._bundles={}}setBundleIdentifier(e){if(this._bundleIdConnector=e.connector??this._bundleIdConnector,this._createBundleAssetId=e.createBundleAssetId??this._createBundleAssetId,this._extractAssetIdFromBundle=e.extractAssetIdFromBundle??this._extractAssetIdFromBundle,this._extractAssetIdFromBundle("foo",this._createBundleAssetId("foo","bar"))!=="bar")throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")}prefer(...e){e.forEach(t=>{this._preferredOrder.push(t),t.priority||(t.priority=Object.keys(t.params))}),this._resolverHash={}}set basePath(e){this._basePath=e}get basePath(){return this._basePath}set rootPath(e){this._rootPath=e}get rootPath(){return this._rootPath}get parsers(){return this._parsers}reset(){this.setBundleIdentifier(this._defaultBundleIdentifierOptions),this._assetMap={},this._preferredOrder=[],this._resolverHash={},this._rootPath=null,this._basePath=null,this._manifest=null,this._bundles={},this._defaultSearchParams=null}setDefaultSearchParams(e){if(typeof e=="string")this._defaultSearchParams=e;else{const t=e;this._defaultSearchParams=Object.keys(t).map(s=>`${encodeURIComponent(s)}=${encodeURIComponent(t[s])}`).join("&")}}getAlias(e){const{alias:t,src:s}=e;return ft(t||s,n=>typeof n=="string"?n:Array.isArray(n)?n.map(o=>o?.src??o):n?.src?n.src:n,!0)}addManifest(e){this._manifest&&H("[Resolver] Manifest already exists, this will be overwritten"),this._manifest=e,e.bundles.forEach(t=>{this.addBundle(t.name,t.assets)})}addBundle(e,t){const s=[];let r=t;Array.isArray(t)||(r=Object.entries(t).map(([n,o])=>typeof o=="string"||Array.isArray(o)?{alias:n,src:o}:{alias:n,...o})),r.forEach(n=>{const o=n.src,a=n.alias;let l;if(typeof a=="string"){const c=this._createBundleAssetId(e,a);s.push(c),l=[a,c]}else{const c=a.map(h=>this._createBundleAssetId(e,h));s.push(...c),l=[...a,...c]}this.add({...n,alias:l,src:o})}),this._bundles[e]=s}add(e){const t=[];Array.isArray(e)?t.push(...e):t.push(e);let s;s=n=>{this.hasKey(n)&&H(`[Resolver] already has key: ${n} overwriting`)},ft(t).forEach(n=>{const{src:o}=n;let{data:a,format:l,loadParser:c,parser:h}=n;const u=ft(o).map(g=>typeof g=="string"?RS(g):Array.isArray(g)?g:[g]),d=this.getAlias(n);Array.isArray(d)?d.forEach(s):s(d);const f=[],m=g=>({...this._parsers.find(_=>_.test(g))?.parse(g),src:g});u.forEach(g=>{g.forEach(p=>{let _={};if(typeof p!="object"?_=m(p):(a=p.data??a,l=p.format??l,(p.loadParser||p.parser)&&(c=p.loadParser??c,h=p.parser??h),_={...m(p.src),...p}),!d)throw new Error(`[Resolver] alias is undefined for this asset: ${_.src}`);_=this._buildResolvedAsset(_,{aliases:d,data:a,format:l,loadParser:c,parser:h,progressSize:n.progressSize}),f.push(_)})}),d.forEach(g=>{this._assetMap[g]=f})})}resolveBundle(e){const t=zr(e);e=ft(e);const s={};return e.forEach(r=>{const n=this._bundles[r];if(n){const o=this.resolve(n),a={};for(const l in o){const c=o[l];a[this._extractAssetIdFromBundle(r,l)]=c}s[r]=a}}),t?s[e[0]]:s}resolveUrl(e){const t=this.resolve(e);if(typeof e!="string"){const s={};for(const r in t)s[r]=t[r].src;return s}return t.src}resolve(e){const t=zr(e);e=ft(e);const s={};return e.forEach(r=>{if(!this._resolverHash[r])if(this._assetMap[r]){let n=this._assetMap[r];const o=this._getPreferredOrder(n);o?.priority.forEach(a=>{o.params[a].forEach(l=>{const c=n.filter(h=>h[a]?h[a]===l:!1);c.length&&(n=c)})}),this._resolverHash[r]=n[0]}else this._resolverHash[r]=this._buildResolvedAsset({alias:[r],src:r},{});s[r]=this._resolverHash[r]}),t?s[e[0]]:s}hasKey(e){return!!this._assetMap[e]}hasBundle(e){return!!this._bundles[e]}_getPreferredOrder(e){for(let t=0;t<e.length;t++){const s=e[t],r=this._preferredOrder.find(n=>n.params.format.includes(s.format));if(r)return r}return this._preferredOrder[0]}_appendDefaultSearchParams(e){if(!this._defaultSearchParams)return e;const t=/\?/.test(e)?"&":"?";return`${e}${t}${this._defaultSearchParams}`}_buildResolvedAsset(e,t){const{aliases:s,data:r,loadParser:n,parser:o,format:a,progressSize:l}=t;return(this._basePath||this._rootPath)&&(e.src=Qe.toAbsolute(e.src,this._basePath,this._rootPath)),e.alias=s??e.alias??[e.src],e.src=this._appendDefaultSearchParams(e.src),e.data={...r||{},...e.data},e.loadParser=n??e.loadParser,e.parser=o??e.parser,e.format=a??e.format??kS(e.src),l!==void 0&&(e.progressSize=l),e}}Oi.RETINA_PREFIX=/@([0-9\.]+)x/;function kS(i){return i.split(".").pop().split("?").shift().split("#").shift()}const Cu=(i,e)=>{const t=e.split("?")[1];return t&&(i+=`?${t}`),i},Sm=class Ks{constructor(e,t){this.linkedSheets=[];let s=e;e?.source instanceof Ee&&(s={texture:e,data:t});const{texture:r,data:n,cachePrefix:o=""}=s;this.cachePrefix=o,this._texture=r instanceof k?r:null,this.textureSource=r.source,this.textures={},this.animations={},this.data=n;const a=parseFloat(n.meta.scale);a?(this.resolution=a,r.source.resolution=this.resolution):this.resolution=r.source._resolution,this._frames=this.data.frames,this._frameKeys=Object.keys(this._frames),this._batchIndex=0,this._callback=null}parse(){return new Promise(e=>{this._callback=e,this._batchIndex=0,this._frameKeys.length<=Ks.BATCH_SIZE?(this._processFrames(0),this._processAnimations(),this._parseComplete()):this._nextBatch()})}_processFrames(e){let t=e;const s=Ks.BATCH_SIZE;for(;t-e<s&&t<this._frameKeys.length;){const r=this._frameKeys[t],n=this._frames[r],o=n.frame;if(o){let a=null,l=null;const c=n.trimmed!==!1&&n.sourceSize?n.sourceSize:n.frame,h=new W(0,0,Math.floor(c.w)/this.resolution,Math.floor(c.h)/this.resolution);n.rotated?a=new W(Math.floor(o.x)/this.resolution,Math.floor(o.y)/this.resolution,Math.floor(o.h)/this.resolution,Math.floor(o.w)/this.resolution):a=new W(Math.floor(o.x)/this.resolution,Math.floor(o.y)/this.resolution,Math.floor(o.w)/this.resolution,Math.floor(o.h)/this.resolution),n.trimmed!==!1&&n.spriteSourceSize&&(l=new W(Math.floor(n.spriteSourceSize.x)/this.resolution,Math.floor(n.spriteSourceSize.y)/this.resolution,Math.floor(o.w)/this.resolution,Math.floor(o.h)/this.resolution)),this.textures[r]=new k({source:this.textureSource,frame:a,orig:h,trim:l,rotate:n.rotated?2:0,defaultAnchor:n.anchor,defaultBorders:n.borders,label:r.toString()})}t++}}_processAnimations(){const e=this.data.animations||{};for(const t in e){this.animations[t]=[];for(let s=0;s<e[t].length;s++){const r=e[t][s];this.animations[t].push(this.textures[r])}}}_parseComplete(){const e=this._callback;this._callback=null,this._batchIndex=0,e.call(this,this.textures)}_nextBatch(){this._processFrames(this._batchIndex*Ks.BATCH_SIZE),this._batchIndex++,setTimeout(()=>{this._batchIndex*Ks.BATCH_SIZE<this._frameKeys.length?this._nextBatch():(this._processAnimations(),this._parseComplete())},0)}destroy(e=!1){for(const t in this.textures)this.textures[t].destroy();this._frames=null,this._frameKeys=null,this.data=null,this.textures=null,e&&(this._texture?.destroy(),this.textureSource.destroy()),this._texture=null,this.textureSource=null,this.linkedSheets=[]}};Sm.BATCH_SIZE=1e3;let Cm=Sm;const MS=["jpg","png","jpeg","avif","webp","basis","etc2","bc7","bc6h","bc5","bc4","bc3","bc2","bc1","eac","astc"];function Am(i,e,t){const s={};if(i.forEach(r=>{s[r]=e}),Object.keys(e.textures).forEach(r=>{s[`${e.cachePrefix}${r}`]=e.textures[r]}),!t){const r=Qe.dirname(i[0]);e.linkedSheets.forEach((n,o)=>{const a=Am([`${r}/${e.data.meta.related_multi_packs[o]}`],n,!0);Object.assign(s,a)})}return s}const FS={extension:b.Asset,cache:{test:i=>i instanceof Cm,getCacheableAssets:(i,e)=>Am(i,e,!1)},resolver:{extension:{type:b.ResolveParser,name:"resolveSpritesheet"},test:i=>{const t=i.split("?")[0].split("."),s=t.pop(),r=t.pop();return s==="json"&&MS.includes(r)},parse:i=>{const e=i.split(".");return{resolution:parseFloat(Oi.RETINA_PREFIX.exec(i)?.[1]??"1"),format:e[e.length-2],src:i}}},loader:{name:"spritesheetLoader",id:"spritesheet",extension:{type:b.LoadParser,priority:jt.Normal,name:"spritesheetLoader"},async testParse(i,e){return Qe.extname(e.src).toLowerCase()===".json"&&!!i.frames},async parse(i,e,t){const{texture:s,imageFilename:r,textureOptions:n,cachePrefix:o}=e?.data??{};let a=Qe.dirname(e.src);a&&a.lastIndexOf("/")!==a.length-1&&(a+="/");let l;if(s instanceof k)l=s;else{const u=Cu(a+(r??i.meta.image),e.src);l=(await t.load([{src:u,data:n}]))[u]}const c=new Cm({texture:l.source,data:i,cachePrefix:o});await c.parse();const h=i?.meta?.related_multi_packs;if(Array.isArray(h)){const u=[];for(const f of h){if(typeof f!="string")continue;let m=a+f;e.data?.ignoreMultiPack||(m=Cu(m,e.src),u.push(t.load({src:m,data:{textureOptions:n,ignoreMultiPack:!0}})))}const d=await Promise.all(u);c.linkedSheets=d,d.forEach(f=>{f.linkedSheets=[c].concat(c.linkedSheets.filter(m=>m!==f))})}return c},async unload(i,e,t){await t.unload(i.textureSource._sourceOrigin),i.destroy(!1)}}};V.add(FS);class Em{constructor(e){this._lastTransform="",this._observer=null,this._tickerAttached=!1,this.updateTranslation=()=>{if(!this._canvas)return;const t=this._canvas.getBoundingClientRect(),s=this._canvas.width,r=this._canvas.height,n=t.width/s*this._renderer.resolution,o=t.height/r*this._renderer.resolution,a=t.left,l=t.top,c=`translate(${a}px, ${l}px) scale(${n}, ${o})`;c!==this._lastTransform&&(this._domElement.style.transform=c,this._lastTransform=c)},this._domElement=e.domElement,this._renderer=e.renderer,!(globalThis.OffscreenCanvas&&this._renderer.canvas instanceof OffscreenCanvas)&&(this._canvas=this._renderer.canvas,this._attachObserver())}get canvas(){return this._canvas}ensureAttached(){!this._domElement.parentNode&&this._canvas.parentNode&&(this._canvas.parentNode.appendChild(this._domElement),this.updateTranslation())}_attachObserver(){"ResizeObserver"in globalThis?(this._observer&&(this._observer.disconnect(),this._observer=null),this._observer=new ResizeObserver(e=>{for(const t of e){if(t.target!==this._canvas)continue;const s=this.canvas.width,r=this.canvas.height,n=t.contentRect.width/s*this._renderer.resolution,o=t.contentRect.height/r*this._renderer.resolution;(this._lastScaleX!==n||this._lastScaleY!==o)&&(this.updateTranslation(),this._lastScaleX=n,this._lastScaleY=o)}}),this._observer.observe(this._canvas)):this._tickerAttached||Je.shared.add(this.updateTranslation,this,Bi.HIGH)}destroy(){this._observer?(this._observer.disconnect(),this._observer=null):this._tickerAttached&&Je.shared.remove(this.updateTranslation),this._domElement=null,this._renderer=null,this._canvas=null,this._tickerAttached=!1,this._lastTransform="",this._lastScaleX=null,this._lastScaleY=null}}class gs{constructor(e){this.bubbles=!0,this.cancelBubble=!0,this.cancelable=!1,this.composed=!1,this.defaultPrevented=!1,this.eventPhase=gs.prototype.NONE,this.propagationStopped=!1,this.propagationImmediatelyStopped=!1,this.layer=new X,this.page=new X,this.NONE=0,this.CAPTURING_PHASE=1,this.AT_TARGET=2,this.BUBBLING_PHASE=3,this.manager=e}get layerX(){return this.layer.x}get layerY(){return this.layer.y}get pageX(){return this.page.x}get pageY(){return this.page.y}get data(){return this}composedPath(){return this.manager&&(!this.path||this.path[this.path.length-1]!==this.target)&&(this.path=this.target?this.manager.propagationPath(this.target):[]),this.path}initEvent(e,t,s){throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")}initUIEvent(e,t,s,r,n){throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")}preventDefault(){this.nativeEvent instanceof Event&&this.nativeEvent.cancelable&&this.nativeEvent.preventDefault(),this.defaultPrevented=!0}stopImmediatePropagation(){this.propagationImmediatelyStopped=!0}stopPropagation(){this.propagationStopped=!0}}var Au=/iPhone/i,Im=/iPod/i,Pm=/iPad/i,Rm=/\biOS-universal(?:.+)Mac\b/i,Eu=/\bAndroid(?:.+)Mobile\b/i,km=/Android/i,Di=/(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,Lr=/Silk/i,Ot=/Windows Phone/i,Mm=/\bWindows(?:.+)ARM\b/i,Fm=/BlackBerry/i,Um=/BB10/i,Bm=/Opera Mini/i,Om=/\b(CriOS|Chrome)(?:.+)Mobile/i,Dm=/Mobile(?:.+)Firefox\b/i,Gm=function(i){return typeof i<"u"&&i.platform==="MacIntel"&&typeof i.maxTouchPoints=="number"&&i.maxTouchPoints>1&&typeof MSStream>"u"};function US(i){return function(e){return e.test(i)}}function zm(i){var e={userAgent:"",platform:"",maxTouchPoints:0};!i&&typeof navigator<"u"?e={userAgent:navigator.userAgent,platform:navigator.platform,maxTouchPoints:navigator.maxTouchPoints||0}:typeof i=="string"?e.userAgent=i:i&&i.userAgent&&(e={userAgent:i.userAgent,platform:i.platform,maxTouchPoints:i.maxTouchPoints||0});var t=e.userAgent,s=t.split("[FBAN");typeof s[1]<"u"&&(t=s[0]),s=t.split("Twitter"),typeof s[1]<"u"&&(t=s[0]);var r=US(t),n={apple:{phone:r(Au)&&!r(Ot),ipod:r(Im),tablet:!r(Au)&&(r(Pm)||Gm(e))&&!r(Ot),universal:r(Rm),device:(r(Au)||r(Im)||r(Pm)||r(Rm)||Gm(e))&&!r(Ot)},amazon:{phone:r(Di),tablet:!r(Di)&&r(Lr),device:r(Di)||r(Lr)},android:{phone:!r(Ot)&&r(Di)||!r(Ot)&&r(Eu),tablet:!r(Ot)&&!r(Di)&&!r(Eu)&&(r(Lr)||r(km)),device:!r(Ot)&&(r(Di)||r(Lr)||r(Eu)||r(km))||r(/\bokhttp\b/i)},windows:{phone:r(Ot),tablet:r(Mm),device:r(Ot)||r(Mm)},other:{blackberry:r(Fm),blackberry10:r(Um),opera:r(Bm),firefox:r(Dm),chrome:r(Om),device:r(Fm)||r(Um)||r(Bm)||r(Dm)||r(Om)},any:!1,phone:!1,tablet:!1};return n.any=n.apple.device||n.android.device||n.windows.device||n.other.device,n.phone=n.apple.phone||n.android.phone||n.windows.phone,n.tablet=n.apple.tablet||n.android.tablet||n.windows.tablet,n}const BS=(zm.default??zm)(globalThis.navigator),OS=9,Lm=100,DS=0,GS=0,Nm=2,Hm=1,zS=-1e3,LS=-1e3,NS=2,Iu=class jx{constructor(e,t=BS){this._mobileInfo=t,this.debug=!1,this._activateOnTab=!0,this._deactivateOnMouseMove=!0,this._isActive=!1,this._isMobileAccessibility=!1,this._div=null,this._pools={},this._renderId=0,this._children=[],this._androidUpdateCount=0,this._androidUpdateFrequency=500,this._isRunningTests=!1,this._boundOnKeyDown=this._onKeyDown.bind(this),this._boundOnMouseMove=this._onMouseMove.bind(this),this._hookDiv=null,(t.tablet||t.phone)&&this._createTouchHook(),this._renderer=e}get isActive(){return this._isActive}get isMobileAccessibility(){return this._isMobileAccessibility}get hookDiv(){return this._hookDiv}get div(){return this._div}_createTouchHook(){const e=document.createElement("button");e.style.width=`${Hm}px`,e.style.height=`${Hm}px`,e.style.position="absolute",e.style.top=`${zS}px`,e.style.left=`${LS}px`,e.style.zIndex=NS.toString(),e.style.backgroundColor="#FF0000",e.title="select to enable accessibility for this content",e.addEventListener("focus",()=>{this._isMobileAccessibility=!0,this._activate(),this._destroyTouchHook()}),document.body.appendChild(e),this._hookDiv=e}_destroyTouchHook(){this._hookDiv&&(document.body.removeChild(this._hookDiv),this._hookDiv=null)}_activate(){if(this._isActive)return;this._isActive=!0,this._div||(this._div=document.createElement("div"),this._div.style.position="absolute",this._div.style.top=`${DS}px`,this._div.style.left=`${GS}px`,this._div.style.pointerEvents="none",this._div.style.zIndex=Nm.toString(),this._canvasObserver=new Em({domElement:this._div,renderer:this._renderer})),this._activateOnTab&&globalThis.addEventListener("keydown",this._boundOnKeyDown,!1),this._deactivateOnMouseMove&&globalThis.document.addEventListener("mousemove",this._boundOnMouseMove,!0);const e=this._renderer.view.canvas;if(e.parentNode)this._canvasObserver.ensureAttached(),this._initAccessibilitySetup();else{const t=new MutationObserver(()=>{e.parentNode&&(t.disconnect(),this._canvasObserver.ensureAttached(),this._initAccessibilitySetup())});t.observe(document.body,{childList:!0,subtree:!0})}}_initAccessibilitySetup(){this._renderer.runners.postrender.add(this),this._renderer.lastObjectRendered&&this._updateAccessibleObjects(this._renderer.lastObjectRendered)}_deactivate(){if(!(!this._isActive||this._isMobileAccessibility)){this._isActive=!1,globalThis.document.removeEventListener("mousemove",this._boundOnMouseMove,!0),this._activateOnTab&&globalThis.addEventListener("keydown",this._boundOnKeyDown,!1),this._renderer.runners.postrender.remove(this);for(const e of this._children)e._accessibleDiv?.parentNode&&(e._accessibleDiv.parentNode.removeChild(e._accessibleDiv),e._accessibleDiv=null),e._accessibleActive=!1;for(const e in this._pools)this._pools[e].forEach(s=>{s.parentNode&&s.parentNode.removeChild(s)}),delete this._pools[e];this._div?.parentNode&&this._div.parentNode.removeChild(this._div),this._pools={},this._children=[]}}_updateAccessibleObjects(e){if(!e.visible||!e.accessibleChildren)return;e.accessible&&(e._accessibleActive||this._addChild(e),e._renderId=this._renderId);const t=e.children;if(t)for(let s=0;s<t.length;s++)this._updateAccessibleObjects(t[s])}init(e){const s={accessibilityOptions:{...jx.defaultOptions,...e?.accessibilityOptions||{}}};this.debug=s.accessibilityOptions.debug,this._activateOnTab=s.accessibilityOptions.activateOnTab,this._deactivateOnMouseMove=s.accessibilityOptions.deactivateOnMouseMove,s.accessibilityOptions.enabledByDefault&&this._activate(),this._renderer.runners.postrender.remove(this)}postrender(){const e=performance.now();if(this._mobileInfo.android.device&&e<this._androidUpdateCount||(this._androidUpdateCount=e+this._androidUpdateFrequency,(!this._renderer.renderingToScreen||!this._renderer.view.canvas)&&!this._isRunningTests))return;const t=new Set;if(this._renderer.lastObjectRendered){this._updateAccessibleObjects(this._renderer.lastObjectRendered);for(const s of this._children)s._renderId===this._renderId&&t.add(this._children.indexOf(s))}for(let s=this._children.length-1;s>=0;s--){const r=this._children[s];t.has(s)||(r._accessibleDiv&&r._accessibleDiv.parentNode&&(r._accessibleDiv.parentNode.removeChild(r._accessibleDiv),this._getPool(r.accessibleType).push(r._accessibleDiv),r._accessibleDiv=null),r._accessibleActive=!1,om(this._children,s,1))}this._renderer.renderingToScreen&&this._canvasObserver.ensureAttached();for(let s=0;s<this._children.length;s++){const r=this._children[s];if(!r._accessibleActive||!r._accessibleDiv)continue;const n=r._accessibleDiv,o=r.hitArea||r.getBounds().rectangle;if(r.hitArea){const a=r.worldTransform;n.style.left=`${a.tx+o.x*a.a}px`,n.style.top=`${a.ty+o.y*a.d}px`,n.style.width=`${o.width*a.a}px`,n.style.height=`${o.height*a.d}px`}else this._capHitArea(o),n.style.left=`${o.x}px`,n.style.top=`${o.y}px`,n.style.width=`${o.width}px`,n.style.height=`${o.height}px`}this._renderId++}_updateDebugHTML(e){e.innerHTML=`type: ${e.type}</br> title : ${e.title}</br> tabIndex: ${e.tabIndex}`}_capHitArea(e){e.x<0&&(e.width+=e.x,e.x=0),e.y<0&&(e.height+=e.y,e.y=0);const{width:t,height:s}=this._renderer;e.x+e.width>t&&(e.width=t-e.x),e.y+e.height>s&&(e.height=s-e.y)}_addChild(e){let s=this._getPool(e.accessibleType).pop();s?(s.innerHTML="",s.removeAttribute("title"),s.removeAttribute("aria-label"),s.tabIndex=0):(e.accessibleType==="button"?s=document.createElement("button"):(s=document.createElement(e.accessibleType),s.style.cssText=`
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `,e.accessibleText&&(s.innerText=e.accessibleText)),s.style.width=`${Lm}px`,s.style.height=`${Lm}px`,s.style.backgroundColor=this.debug?"rgba(255,255,255,0.5)":"transparent",s.style.position="absolute",s.style.zIndex=Nm.toString(),s.style.borderStyle="none",navigator.userAgent.toLowerCase().includes("chrome")?s.setAttribute("aria-live","off"):s.setAttribute("aria-live","polite"),navigator.userAgent.match(/rv:.*Gecko\//)?s.setAttribute("aria-relevant","additions"):s.setAttribute("aria-relevant","text"),s.addEventListener("click",this._onClick.bind(this)),s.addEventListener("focus",this._onFocus.bind(this)),s.addEventListener("focusout",this._onFocusOut.bind(this))),s.style.pointerEvents=e.accessiblePointerEvents,s.type=e.accessibleType,e.accessibleTitle&&e.accessibleTitle!==null?s.title=e.accessibleTitle:(!e.accessibleHint||e.accessibleHint===null)&&(s.title=`container ${e.tabIndex}`),e.accessibleHint&&e.accessibleHint!==null&&s.setAttribute("aria-label",e.accessibleHint),e.interactive?s.tabIndex=e.tabIndex:s.tabIndex=0,this.debug&&this._updateDebugHTML(s),e._accessibleActive=!0,e._accessibleDiv=s,s.container=e,this._children.push(e),this._div.appendChild(e._accessibleDiv)}_dispatchEvent(e,t){const{container:s}=e.target,r=this._renderer.events.rootBoundary,n=Object.assign(new gs(r),{target:s});r.rootTarget=this._renderer.lastObjectRendered,t.forEach(o=>r.dispatchEvent(n,o))}_onClick(e){this._dispatchEvent(e,["click","pointertap","tap"])}_onFocus(e){e.target.getAttribute("aria-live")||e.target.setAttribute("aria-live","assertive"),this._dispatchEvent(e,["mouseover"])}_onFocusOut(e){e.target.getAttribute("aria-live")||e.target.setAttribute("aria-live","polite"),this._dispatchEvent(e,["mouseout"])}_onKeyDown(e){e.keyCode!==OS||!this._activateOnTab||this._activate()}_onMouseMove(e){e.movementX===0&&e.movementY===0||this._deactivate()}destroy(){this._deactivate(),this._destroyTouchHook(),this._canvasObserver?.destroy(),this._canvasObserver=null,this._div=null,this._pools=null,this._children=null,this._renderer=null,this._hookDiv=null,globalThis.removeEventListener("keydown",this._boundOnKeyDown),this._boundOnKeyDown=null,globalThis.document.removeEventListener("mousemove",this._boundOnMouseMove,!0),this._boundOnMouseMove=null}setAccessibilityEnabled(e){e?this._activate():this._deactivate()}_getPool(e){return this._pools[e]||(this._pools[e]=[]),this._pools[e]}};Iu.extension={type:[b.WebGLSystem,b.WebGPUSystem],name:"accessibility"},Iu.defaultOptions={enabledByDefault:!1,debug:!1,activateOnTab:!0,deactivateOnMouseMove:!0};let HS=Iu;const WS={accessible:!1,accessibleTitle:null,accessibleHint:null,tabIndex:0,accessibleType:"button",accessibleText:null,accessiblePointerEvents:"auto",accessibleChildren:!0,_accessibleActive:!1,_accessibleDiv:null,_renderId:-1},Pu=Object.create(null),Wm=Object.create(null);function _s(i,e){let t=Wm[i];return t===void 0&&(Pu[e]===void 0&&(Pu[e]=1),Wm[i]=t=Pu[e]++),t}let Nr;function Vm(){return(!Nr||Nr?.isContextLost())&&(Nr=Y.get().createCanvas().getContext("webgl",{})),Nr}let Hr;function VS(){if(!Hr){Hr="mediump";const i=Vm();i&&i.getShaderPrecisionFormat&&(Hr=i.getShaderPrecisionFormat(i.FRAGMENT_SHADER,i.HIGH_FLOAT).precision?"highp":"mediump")}return Hr}function $S(i,e,t){return e?i:t?(i=i.replace("out vec4 finalColor;",""),`

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${i}
        `):`

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${i}
        `}function XS(i,e,t){const s=t?e.maxSupportedFragmentPrecision:e.maxSupportedVertexPrecision;if(i.substring(0,9)!=="precision"){let r=t?e.requestedFragmentPrecision:e.requestedVertexPrecision;return r==="highp"&&s!=="highp"&&(r="mediump"),`precision ${r} float;
${i}`}else if(s!=="highp"&&i.substring(0,15)==="precision highp")return i.replace("precision highp","precision mediump");return i}function YS(i,e){return e?`#version 300 es
${i}`:i}const qS={},KS={};function jS(i,{name:e="pixi-program"},t=!0){e=e.replace(/\s+/g,"-"),e+=t?"-fragment":"-vertex";const s=t?qS:KS;return s[e]?(s[e]++,e+=`-${s[e]}`):s[e]=1,i.indexOf("#define SHADER_NAME")!==-1?i:`${`#define SHADER_NAME ${e}`}
${i}`}function ZS(i,e){return e?i.replace("#version 300 es",""):i}const Ru={stripVersion:ZS,ensurePrecision:XS,addProgramDefines:$S,setProgramName:jS,insertVersion:YS},xs=Object.create(null),$m=class af{constructor(e){e={...af.defaultOptions,...e};const t=e.fragment.indexOf("#version 300 es")!==-1,s={stripVersion:t,ensurePrecision:{requestedFragmentPrecision:e.preferredFragmentPrecision,requestedVertexPrecision:e.preferredVertexPrecision,maxSupportedVertexPrecision:"highp",maxSupportedFragmentPrecision:VS()},setProgramName:{name:e.name},addProgramDefines:t,insertVersion:t};let r=e.fragment,n=e.vertex;Object.keys(Ru).forEach(o=>{const a=s[o];r=Ru[o](r,a,!0),n=Ru[o](n,a,!1)}),this.fragment=r,this.vertex=n,this.transformFeedbackVaryings=e.transformFeedbackVaryings,this._key=_s(`${this.vertex}:${this.fragment}`,"gl-program")}destroy(){this.fragment=null,this.vertex=null,this._attributeData=null,this._uniformData=null,this._uniformBlockData=null,this.transformFeedbackVaryings=null,xs[this._cacheKey]=null}static from(e){const t=`${e.vertex}:${e.fragment}`;return xs[t]||(xs[t]=new af(e),xs[t]._cacheKey=t),xs[t]}};$m.defaultOptions={preferredVertexPrecision:"highp",preferredFragmentPrecision:"mediump"};let It=$m;const Xm={uint8x2:{size:2,stride:2,normalised:!1},uint8x4:{size:4,stride:4,normalised:!1},sint8x2:{size:2,stride:2,normalised:!1},sint8x4:{size:4,stride:4,normalised:!1},unorm8x2:{size:2,stride:2,normalised:!0},unorm8x4:{size:4,stride:4,normalised:!0},snorm8x2:{size:2,stride:2,normalised:!0},snorm8x4:{size:4,stride:4,normalised:!0},uint16x2:{size:2,stride:4,normalised:!1},uint16x4:{size:4,stride:8,normalised:!1},sint16x2:{size:2,stride:4,normalised:!1},sint16x4:{size:4,stride:8,normalised:!1},unorm16x2:{size:2,stride:4,normalised:!0},unorm16x4:{size:4,stride:8,normalised:!0},snorm16x2:{size:2,stride:4,normalised:!0},snorm16x4:{size:4,stride:8,normalised:!0},float16x2:{size:2,stride:4,normalised:!1},float16x4:{size:4,stride:8,normalised:!1},float32:{size:1,stride:4,normalised:!1},float32x2:{size:2,stride:8,normalised:!1},float32x3:{size:3,stride:12,normalised:!1},float32x4:{size:4,stride:16,normalised:!1},uint32:{size:1,stride:4,normalised:!1},uint32x2:{size:2,stride:8,normalised:!1},uint32x3:{size:3,stride:12,normalised:!1},uint32x4:{size:4,stride:16,normalised:!1},sint32:{size:1,stride:4,normalised:!1},sint32x2:{size:2,stride:8,normalised:!1},sint32x3:{size:3,stride:12,normalised:!1},sint32x4:{size:4,stride:16,normalised:!1}};function Zt(i){return Xm[i]??Xm.float32}const JS={f32:"float32","vec2<f32>":"float32x2","vec3<f32>":"float32x3","vec4<f32>":"float32x4",vec2f:"float32x2",vec3f:"float32x3",vec4f:"float32x4",i32:"sint32","vec2<i32>":"sint32x2","vec3<i32>":"sint32x3","vec4<i32>":"sint32x4",u32:"uint32","vec2<u32>":"uint32x2","vec3<u32>":"uint32x3","vec4<u32>":"uint32x4",bool:"uint32","vec2<bool>":"uint32x2","vec3<bool>":"uint32x3","vec4<bool>":"uint32x4"};function QS({source:i,entryPoint:e}){const t={},s=i.indexOf(`fn ${e}`);if(s!==-1){const r=i.indexOf("->",s);if(r!==-1){const n=i.substring(s,r),o=/@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;let a;for(;(a=o.exec(n))!==null;){const l=JS[a[3]]??"float32";t[a[2]]={location:parseInt(a[1],10),format:l,stride:Zt(l).stride,offset:0,instance:!1,start:0}}}}return t}function ku(i){const e=/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,t=/@group\((\d+)\)/,s=/@binding\((\d+)\)/,r=/var(<[^>]+>)? (\w+)/,n=/:\s*(\w+)/,o=/struct\s+(\w+)\s*{([^}]+)}/g,a=/(\w+)\s*:\s*([\w\<\>]+)/g,l=/struct\s+(\w+)/,c=i.match(e)?.map(u=>({group:parseInt(u.match(t)[1],10),binding:parseInt(u.match(s)[1],10),name:u.match(r)[2],isUniform:u.match(r)[1]==="<uniform>",type:u.match(n)[1]}));if(!c)return{groups:[],structs:[]};const h=i.match(o)?.map(u=>{const d=u.match(l)[1],f=u.match(a).reduce((m,g)=>{const[p,_]=g.split(":");return m[p.trim()]=_.trim(),m},{});return f?{name:d,members:f}:null}).filter(({name:u})=>c.some(d=>d.type===u))??[];return{groups:c,structs:h}}var vs=(i=>(i[i.VERTEX=1]="VERTEX",i[i.FRAGMENT=2]="FRAGMENT",i[i.COMPUTE=4]="COMPUTE",i))(vs||{});function eC({groups:i}){const e=[];for(let t=0;t<i.length;t++){const s=i[t];e[s.group]||(e[s.group]=[]),s.isUniform?e[s.group].push({binding:s.binding,visibility:vs.VERTEX|vs.FRAGMENT,buffer:{type:"uniform"}}):s.type==="sampler"?e[s.group].push({binding:s.binding,visibility:vs.FRAGMENT,sampler:{type:"filtering"}}):s.type==="texture_2d"&&e[s.group].push({binding:s.binding,visibility:vs.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d",multisampled:!1}})}return e}function tC({groups:i}){const e=[];for(let t=0;t<i.length;t++){const s=i[t];e[s.group]||(e[s.group]={}),e[s.group][s.name]=s.binding}return e}function iC(i,e){const t=new Set,s=new Set,r=[...i.structs,...e.structs].filter(o=>t.has(o.name)?!1:(t.add(o.name),!0)),n=[...i.groups,...e.groups].filter(o=>{const a=`${o.name}-${o.binding}`;return s.has(a)?!1:(s.add(a),!0)});return{structs:r,groups:n}}const ys=Object.create(null);class Dt{constructor(e){this._layoutKey=0,this._attributeLocationsKey=0;const{fragment:t,vertex:s,layout:r,gpuLayout:n,name:o}=e;if(this.name=o,this.fragment=t,this.vertex=s,t.source===s.source){const a=ku(t.source);this.structsAndGroups=a}else{const a=ku(s.source),l=ku(t.source);this.structsAndGroups=iC(a,l)}this.layout=r??tC(this.structsAndGroups),this.gpuLayout=n??eC(this.structsAndGroups),this.autoAssignGlobalUniforms=this.layout[0]?.globalUniforms!==void 0,this.autoAssignLocalUniforms=this.layout[1]?.localUniforms!==void 0,this._generateProgramKey()}_generateProgramKey(){const{vertex:e,fragment:t}=this,s=e.source+t.source+e.entryPoint+t.entryPoint;this._layoutKey=_s(s,"program")}get attributeData(){return this._attributeData??(this._attributeData=QS(this.vertex)),this._attributeData}destroy(){this.gpuLayout=null,this.layout=null,this.structsAndGroups=null,this.fragment=null,this.vertex=null,ys[this._cacheKey]=null}static from(e){const t=`${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;return ys[t]||(ys[t]=new Dt(e),ys[t]._cacheKey=t),ys[t]}}const Ym=["f32","i32","vec2<f32>","vec3<f32>","vec4<f32>","mat2x2<f32>","mat3x3<f32>","mat4x4<f32>","mat3x2<f32>","mat4x2<f32>","mat2x3<f32>","mat4x3<f32>","mat2x4<f32>","mat3x4<f32>","vec2<i32>","vec3<i32>","vec4<i32>"],sC=Ym.reduce((i,e)=>(i[e]=!0,i),{});function rC(i,e){switch(i){case"f32":return 0;case"vec2<f32>":return new Float32Array(2*e);case"vec3<f32>":return new Float32Array(3*e);case"vec4<f32>":return new Float32Array(4*e);case"mat2x2<f32>":return new Float32Array([1,0,0,1]);case"mat3x3<f32>":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4x4<f32>":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}const qm=class Zx{constructor(e,t){this._touched=0,this.uid=le("uniform"),this._resourceType="uniformGroup",this._resourceId=le("resource"),this.isUniformGroup=!0,this._dirtyId=0,this.destroyed=!1,t={...Zx.defaultOptions,...t},this.uniformStructures=e;const s={};for(const r in e){const n=e[r];if(n.name=r,n.size=n.size??1,!sC[n.type]){const o=n.type.match(/^array<(\w+(?:<\w+>)?),\s*(\d+)>$/);if(o){const[,a,l]=o;throw new Error(`Uniform type ${n.type} is not supported. Use type: '${a}', size: ${l} instead.`)}throw new Error(`Uniform type ${n.type} is not supported. Supported uniform types are: ${Ym.join(", ")}`)}n.value??(n.value=rC(n.type,n.size)),s[r]=n.value}this.uniforms=s,this._dirtyId=1,this.ubo=t.ubo,this.isStatic=t.isStatic,this._signature=_s(Object.keys(s).map(r=>`${r}-${e[r].type}`).join("-"),"uniform-group")}update(){this._dirtyId++}};qm.defaultOptions={ubo:!1,isStatic:!1};let We=qm;class Gt{constructor(e){this.resources=Object.create(null),this._dirty=!0;let t=0;for(const s in e){const r=e[s];this.setResource(r,t++)}this._updateKey()}_updateKey(){if(!this._dirty)return;this._dirty=!1;const e=[];let t=0;for(const s in this.resources)e[t++]=this.resources[s]._resourceId;this._key=e.join("|")}setResource(e,t){const s=this.resources[t];e!==s&&(s&&e.off?.("change",this.onResourceChange,this),e.on?.("change",this.onResourceChange,this),this.resources[t]=e,this._dirty=!0)}getResource(e){return this.resources[e]}_touch(e,t){const s=this.resources;for(const r in s)s[r]._gcLastUsed=e,s[r]._touched=t}destroy(){const e=this.resources;for(const t in e)e[t]?.off?.("change",this.onResourceChange,this);this.resources=null}onResourceChange(e){if(this._dirty=!0,e.destroyed){const t=this.resources;for(const s in t)t[s]===e&&(t[s]=null)}else this._updateKey()}}var et=(i=>(i[i.WEBGL=1]="WEBGL",i[i.WEBGPU=2]="WEBGPU",i[i.BOTH=3]="BOTH",i))(et||{});class lt extends Ze{constructor(e){super(),this.uid=le("shader"),this._uniformBindMap=Object.create(null),this._ownedBindGroups=[],this._destroyed=!1;let{gpuProgram:t,glProgram:s,groups:r,resources:n,compatibleRenderers:o,groupMap:a}=e;this.gpuProgram=t,this.glProgram=s,o===void 0&&(o=0,t&&(o|=et.WEBGPU),s&&(o|=et.WEBGL)),this.compatibleRenderers=o;const l={};if(!n&&!r&&(n={}),n&&r)throw new Error("[Shader] Cannot have both resources and groups");if(!t&&r&&!a)throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");if(!t&&r&&a)for(const c in a)for(const h in a[c]){const u=a[c][h];l[u]={group:c,binding:h,name:u}}else if(t&&r&&!a){const c=t.structsAndGroups.groups;a={},c.forEach(h=>{a[h.group]=a[h.group]||{},a[h.group][h.binding]=h.name,l[h.name]=h})}else if(n){r={},a={},t&&t.structsAndGroups.groups.forEach(u=>{a[u.group]=a[u.group]||{},a[u.group][u.binding]=u.name,l[u.name]=u});let c=0;for(const h in n)l[h]||(r[99]||(r[99]=new Gt,this._ownedBindGroups.push(r[99])),l[h]={group:99,binding:c,name:h},a[99]=a[99]||{},a[99][c]=h,c++);for(const h in n){const u=h;let d=n[h];!d.source&&!d._resourceType&&(d=new We(d));const f=l[u];f&&(r[f.group]||(r[f.group]=new Gt,this._ownedBindGroups.push(r[f.group])),r[f.group].setResource(d,f.binding))}}this.groups=r,this._uniformBindMap=a,this.resources=this._buildResourceAccessor(r,l)}addResource(e,t,s){var r,n;(r=this._uniformBindMap)[t]||(r[t]={}),(n=this._uniformBindMap[t])[s]||(n[s]=e),this.groups[t]||(this.groups[t]=new Gt,this._ownedBindGroups.push(this.groups[t]))}_buildResourceAccessor(e,t){const s={};for(const r in t){const n=t[r];Object.defineProperty(s,n.name,{get(){return e[n.group].getResource(n.binding)},set(o){e[n.group].setResource(o,n.binding)}})}return s}destroy(e=!1){this._destroyed||(this._destroyed=!0,this.emit("destroy",this),e&&(this.gpuProgram?.destroy(),this.glProgram?.destroy()),this.gpuProgram=null,this.glProgram=null,this.removeAllListeners(),this._uniformBindMap=null,this._ownedBindGroups.forEach(t=>{t.destroy()}),this._ownedBindGroups=null,this.resources=null,this.groups=null)}static from(e){const{gpu:t,gl:s,...r}=e;let n,o;return t&&(n=Dt.from(t)),s&&(o=It.from(s)),new lt({gpuProgram:n,glProgram:o,...r})}}const nC={normal:0,add:1,multiply:2,screen:3,overlay:4,erase:5,"normal-npm":6,"add-npm":7,"screen-npm":8,min:9,max:10},Mu=0,Fu=1,Uu=2,Bu=3,Ou=4,Du=5,Gu=class Jx{constructor(){this.data=0,this.blendMode="normal",this.polygonOffset=0,this.blend=!0,this.depthMask=!0}get blend(){return!!(this.data&1<<Mu)}set blend(e){!!(this.data&1<<Mu)!==e&&(this.data^=1<<Mu)}get offsets(){return!!(this.data&1<<Fu)}set offsets(e){!!(this.data&1<<Fu)!==e&&(this.data^=1<<Fu)}set cullMode(e){if(e==="none"){this.culling=!1;return}this.culling=!0,this.clockwiseFrontFace=e==="front"}get cullMode(){return this.culling?this.clockwiseFrontFace?"front":"back":"none"}get culling(){return!!(this.data&1<<Uu)}set culling(e){!!(this.data&1<<Uu)!==e&&(this.data^=1<<Uu)}get depthTest(){return!!(this.data&1<<Bu)}set depthTest(e){!!(this.data&1<<Bu)!==e&&(this.data^=1<<Bu)}get depthMask(){return!!(this.data&1<<Du)}set depthMask(e){!!(this.data&1<<Du)!==e&&(this.data^=1<<Du)}get clockwiseFrontFace(){return!!(this.data&1<<Ou)}set clockwiseFrontFace(e){!!(this.data&1<<Ou)!==e&&(this.data^=1<<Ou)}get blendMode(){return this._blendMode}set blendMode(e){this.blend=e!=="none",this._blendMode=e,this._blendModeId=nC[e]||0}get polygonOffset(){return this._polygonOffset}set polygonOffset(e){this.offsets=!!e,this._polygonOffset=e}toString(){return`[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`}static for2d(){const e=new Jx;return e.depthTest=!1,e.blend=!0,e}};Gu.default2d=Gu.for2d();let mt=Gu;const Km=class lf extends lt{constructor(e){e={...lf.defaultOptions,...e},super(e),this.enabled=!0,this._state=mt.for2d(),this.blendMode=e.blendMode,this.padding=e.padding,typeof e.antialias=="boolean"?this.antialias=e.antialias?"on":"off":this.antialias=e.antialias,this.resolution=e.resolution,this.blendRequired=e.blendRequired,this.clipToViewport=e.clipToViewport,this.addResource("uTexture",0,1),e.blendRequired&&this.addResource("uBackTexture",0,3)}apply(e,t,s,r){e.applyFilter(this,t,s,r)}get blendMode(){return this._state.blendMode}set blendMode(e){this._state.blendMode=e}static from(e){const{gpu:t,gl:s,...r}=e;let n,o;return t&&(n=Dt.from(t)),s&&(o=It.from(s)),new lf({gpuProgram:n,glProgram:o,...r})}};Km.defaultOptions={blendMode:"normal",resolution:1,padding:0,antialias:"off",blendRequired:!1,clipToViewport:!0};let Gi=Km;const zu=[];V.handleByNamedList(b.Environment,zu);async function oC(i){if(!i)for(let e=0;e<zu.length;e++){const t=zu[e];if(t.value.test()){await t.value.load();return}}}let bs;function jm(){if(typeof bs=="boolean")return bs;try{bs=new Function("param1","param2","param3","return param1[param2] === param3;")({a:"b"},"a","b")===!0}catch{bs=!1}return bs}function Zm(i,e,t=2){const s=e&&e.length,r=s?e[0]*t:i.length;let n=Jm(i,0,r,t,!0);const o=[];if(!n||n.next===n.prev)return o;let a,l,c;if(s&&(n=uC(i,e,n,t)),i.length>80*t){a=i[0],l=i[1];let h=a,u=l;for(let d=t;d<r;d+=t){const f=i[d],m=i[d+1];f<a&&(a=f),m<l&&(l=m),f>h&&(h=f),m>u&&(u=m)}c=Math.max(h-a,u-l),c=c!==0?32767/c:0}return Ts(n,o,t,a,l,c,0),o}function Jm(i,e,t,s,r){let n;if(r===TC(i,e,t,s)>0)for(let o=e;o<t;o+=s)n=ig(o/s|0,i[o],i[o+1],n);else for(let o=t-s;o>=e;o-=s)n=ig(o/s|0,i[o],i[o+1],n);return n&&zi(n,n.next)&&(Cs(n),n=n.next),n}function di(i,e){if(!i)return i;e||(e=i);let t=i,s;do if(s=!1,!t.steiner&&(zi(t,t.next)||ge(t.prev,t,t.next)===0)){if(Cs(t),t=e=t.prev,t===t.next)break;s=!0}else t=t.next;while(s||t!==e);return e}function Ts(i,e,t,s,r,n,o){if(!i)return;!o&&n&&gC(i,s,r,n);let a=i;for(;i.prev!==i.next;){const l=i.prev,c=i.next;if(n?lC(i,s,r,n):aC(i)){e.push(l.i,i.i,c.i),Cs(i),i=c.next,a=c.next;continue}if(i=c,i===a){o?o===1?(i=cC(di(i),e),Ts(i,e,t,s,r,n,2)):o===2&&hC(i,e,t,s,r,n):Ts(di(i),e,t,s,r,n,1);break}}}function aC(i){const e=i.prev,t=i,s=i.next;if(ge(e,t,s)>=0)return!1;const r=e.x,n=t.x,o=s.x,a=e.y,l=t.y,c=s.y,h=Math.min(r,n,o),u=Math.min(a,l,c),d=Math.max(r,n,o),f=Math.max(a,l,c);let m=s.next;for(;m!==e;){if(m.x>=h&&m.x<=d&&m.y>=u&&m.y<=f&&ws(r,a,n,l,o,c,m.x,m.y)&&ge(m.prev,m,m.next)>=0)return!1;m=m.next}return!0}function lC(i,e,t,s){const r=i.prev,n=i,o=i.next;if(ge(r,n,o)>=0)return!1;const a=r.x,l=n.x,c=o.x,h=r.y,u=n.y,d=o.y,f=Math.min(a,l,c),m=Math.min(h,u,d),g=Math.max(a,l,c),p=Math.max(h,u,d),_=Lu(f,m,e,t,s),x=Lu(g,p,e,t,s);let v=i.prevZ,y=i.nextZ;for(;v&&v.z>=_&&y&&y.z<=x;){if(v.x>=f&&v.x<=g&&v.y>=m&&v.y<=p&&v!==r&&v!==o&&ws(a,h,l,u,c,d,v.x,v.y)&&ge(v.prev,v,v.next)>=0||(v=v.prevZ,y.x>=f&&y.x<=g&&y.y>=m&&y.y<=p&&y!==r&&y!==o&&ws(a,h,l,u,c,d,y.x,y.y)&&ge(y.prev,y,y.next)>=0))return!1;y=y.nextZ}for(;v&&v.z>=_;){if(v.x>=f&&v.x<=g&&v.y>=m&&v.y<=p&&v!==r&&v!==o&&ws(a,h,l,u,c,d,v.x,v.y)&&ge(v.prev,v,v.next)>=0)return!1;v=v.prevZ}for(;y&&y.z<=x;){if(y.x>=f&&y.x<=g&&y.y>=m&&y.y<=p&&y!==r&&y!==o&&ws(a,h,l,u,c,d,y.x,y.y)&&ge(y.prev,y,y.next)>=0)return!1;y=y.nextZ}return!0}function cC(i,e){let t=i;do{const s=t.prev,r=t.next.next;!zi(s,r)&&eg(s,t,t.next,r)&&Ss(s,r)&&Ss(r,s)&&(e.push(s.i,t.i,r.i),Cs(t),Cs(t.next),t=i=r),t=t.next}while(t!==i);return di(t)}function hC(i,e,t,s,r,n){let o=i;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&vC(o,a)){let l=tg(o,a);o=di(o,o.next),l=di(l,l.next),Ts(o,e,t,s,r,n,0),Ts(l,e,t,s,r,n,0);return}a=a.next}o=o.next}while(o!==i)}function uC(i,e,t,s){const r=[];for(let n=0,o=e.length;n<o;n++){const a=e[n]*s,l=n<o-1?e[n+1]*s:i.length,c=Jm(i,a,l,s,!1);c===c.next&&(c.steiner=!0),r.push(xC(c))}r.sort(dC);for(let n=0;n<r.length;n++)t=fC(r[n],t);return t}function dC(i,e){let t=i.x-e.x;if(t===0&&(t=i.y-e.y,t===0)){const s=(i.next.y-i.y)/(i.next.x-i.x),r=(e.next.y-e.y)/(e.next.x-e.x);t=s-r}return t}function fC(i,e){const t=pC(i,e);if(!t)return e;const s=tg(t,i);return di(s,s.next),di(t,t.next)}function pC(i,e){let t=e;const s=i.x,r=i.y;let n=-1/0,o;if(zi(i,t))return t;do{if(zi(i,t.next))return t.next;if(r<=t.y&&r>=t.next.y&&t.next.y!==t.y){const u=t.x+(r-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(u<=s&&u>n&&(n=u,o=t.x<t.next.x?t:t.next,u===s))return o}t=t.next}while(t!==e);if(!o)return null;const a=o,l=o.x,c=o.y;let h=1/0;t=o;do{if(s>=t.x&&t.x>=l&&s!==t.x&&Qm(r<c?s:n,r,l,c,r<c?n:s,r,t.x,t.y)){const u=Math.abs(r-t.y)/(s-t.x);Ss(t,i)&&(u<h||u===h&&(t.x>o.x||t.x===o.x&&mC(o,t)))&&(o=t,h=u)}t=t.next}while(t!==a);return o}function mC(i,e){return ge(i.prev,i,e.prev)<0&&ge(e.next,i,i.next)<0}function gC(i,e,t,s){let r=i;do r.z===0&&(r.z=Lu(r.x,r.y,e,t,s)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==i);r.prevZ.nextZ=null,r.prevZ=null,_C(r)}function _C(i){let e,t=1;do{let s=i,r;i=null;let n=null;for(e=0;s;){e++;let o=s,a=0;for(let c=0;c<t&&(a++,o=o.nextZ,!!o);c++);let l=t;for(;a>0||l>0&&o;)a!==0&&(l===0||!o||s.z<=o.z)?(r=s,s=s.nextZ,a--):(r=o,o=o.nextZ,l--),n?n.nextZ=r:i=r,r.prevZ=n,n=r;s=o}n.nextZ=null,t*=2}while(e>1);return i}function Lu(i,e,t,s,r){return i=(i-t)*r|0,e=(e-s)*r|0,i=(i|i<<8)&16711935,i=(i|i<<4)&252645135,i=(i|i<<2)&858993459,i=(i|i<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,i|e<<1}function xC(i){let e=i,t=i;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==i);return t}function Qm(i,e,t,s,r,n,o,a){return(r-o)*(e-a)>=(i-o)*(n-a)&&(i-o)*(s-a)>=(t-o)*(e-a)&&(t-o)*(n-a)>=(r-o)*(s-a)}function ws(i,e,t,s,r,n,o,a){return!(i===o&&e===a)&&Qm(i,e,t,s,r,n,o,a)}function vC(i,e){return i.next.i!==e.i&&i.prev.i!==e.i&&!yC(i,e)&&(Ss(i,e)&&Ss(e,i)&&bC(i,e)&&(ge(i.prev,i,e.prev)||ge(i,e.prev,e))||zi(i,e)&&ge(i.prev,i,i.next)>0&&ge(e.prev,e,e.next)>0)}function ge(i,e,t){return(e.y-i.y)*(t.x-e.x)-(e.x-i.x)*(t.y-e.y)}function zi(i,e){return i.x===e.x&&i.y===e.y}function eg(i,e,t,s){const r=Vr(ge(i,e,t)),n=Vr(ge(i,e,s)),o=Vr(ge(t,s,i)),a=Vr(ge(t,s,e));return!!(r!==n&&o!==a||r===0&&Wr(i,t,e)||n===0&&Wr(i,s,e)||o===0&&Wr(t,i,s)||a===0&&Wr(t,e,s))}function Wr(i,e,t){return e.x<=Math.max(i.x,t.x)&&e.x>=Math.min(i.x,t.x)&&e.y<=Math.max(i.y,t.y)&&e.y>=Math.min(i.y,t.y)}function Vr(i){return i>0?1:i<0?-1:0}function yC(i,e){let t=i;do{if(t.i!==i.i&&t.next.i!==i.i&&t.i!==e.i&&t.next.i!==e.i&&eg(t,t.next,i,e))return!0;t=t.next}while(t!==i);return!1}function Ss(i,e){return ge(i.prev,i,i.next)<0?ge(i,e,i.next)>=0&&ge(i,i.prev,e)>=0:ge(i,e,i.prev)<0||ge(i,i.next,e)<0}function bC(i,e){let t=i,s=!1;const r=(i.x+e.x)/2,n=(i.y+e.y)/2;do t.y>n!=t.next.y>n&&t.next.y!==t.y&&r<(t.next.x-t.x)*(n-t.y)/(t.next.y-t.y)+t.x&&(s=!s),t=t.next;while(t!==i);return s}function tg(i,e){const t=Nu(i.i,i.x,i.y),s=Nu(e.i,e.x,e.y),r=i.next,n=e.prev;return i.next=e,e.prev=i,t.next=r,r.prev=t,s.next=t,t.prev=s,n.next=s,s.prev=n,s}function ig(i,e,t,s){const r=Nu(i,e,t);return s?(r.next=s.next,r.prev=s,s.next.prev=r,s.next=r):(r.prev=r,r.next=r),r}function Cs(i){i.next.prev=i.prev,i.prev.next=i.next,i.prevZ&&(i.prevZ.nextZ=i.nextZ),i.nextZ&&(i.nextZ.prevZ=i.prevZ)}function Nu(i,e,t){return{i,x:e,y:t,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}function TC(i,e,t,s){let r=0;for(let n=e,o=t-s;n<t;n+=s)r+=(i[o]-i[n])*(i[n+1]+i[o+1]),o=n;return r}const wC=Zm.default||Zm;var tt=(i=>(i[i.NONE=0]="NONE",i[i.COLOR=16384]="COLOR",i[i.STENCIL=1024]="STENCIL",i[i.DEPTH=256]="DEPTH",i[i.COLOR_DEPTH=16640]="COLOR_DEPTH",i[i.COLOR_STENCIL=17408]="COLOR_STENCIL",i[i.DEPTH_STENCIL=1280]="DEPTH_STENCIL",i[i.ALL=17664]="ALL",i))(tt||{});class sg{constructor(e){this.items=[],this._name=e}emit(e,t,s,r,n,o,a,l){const{name:c,items:h}=this;for(let u=0,d=h.length;u<d;u++)h[u][c](e,t,s,r,n,o,a,l);return this}add(e){return e[this._name]&&(this.remove(e),this.items.push(e)),this}remove(e){const t=this.items.indexOf(e);return t!==-1&&this.items.splice(t,1),this}contains(e){return this.items.indexOf(e)!==-1}removeAll(){return this.items.length=0,this}destroy(){this.removeAll(),this.items=null,this._name=null}get empty(){return this.items.length===0}get name(){return this._name}}const SC=["init","destroy","contextChange","resolutionChange","resetState","renderEnd","renderStart","render","update","postrender","prerender"],rg=class Qx extends Ze{constructor(e){super(),this.tick=0,this.uid=le("renderer"),this.runners=Object.create(null),this.renderPipes=Object.create(null),this._initOptions={},this._systemsHash=Object.create(null),this.type=e.type,this.name=e.name,this.config=e;const t=[...SC,...this.config.runners??[]];this._addRunners(...t),this._unsafeEvalCheck()}async init(e={}){const t=e.skipExtensionImports===!0?!0:e.manageImports===!1;await oC(t),this._addSystems(this.config.systems),this._addPipes(this.config.renderPipes,this.config.renderPipeAdaptors);for(const s in this._systemsHash)e={...this._systemsHash[s].constructor.defaultOptions,...e};e={...Qx.defaultOptions,...e},this._roundPixels=e.roundPixels?1:0;for(let s=0;s<this.runners.init.items.length;s++)await this.runners.init.items[s].init(e);this._initOptions=e}render(e,t){this.tick++;let s=e;if(s instanceof se&&(s={container:s},t&&(L(J,"passing a second argument is deprecated, please use render options instead"),s.target=t.renderTexture)),s.target||(s.target=this.view.renderTarget),s.target===this.view.renderTarget&&(this._lastObjectRendered=s.container,s.clearColor??(s.clearColor=this.background.colorRgba),s.clear??(s.clear=this.background.clearBeforeRender)),s.clearColor){const r=Array.isArray(s.clearColor)&&s.clearColor.length===4;s.clearColor=r?s.clearColor:ue.shared.setValue(s.clearColor).toArray()}s.transform||(s.container.updateLocalTransform(),s.transform=s.container.localTransform),s.container.visible&&(s.container.enableRenderGroup(),this.runners.prerender.emit(s),this.runners.renderStart.emit(s),this.runners.render.emit(s),this.runners.renderEnd.emit(s),this.runners.postrender.emit(s))}resize(e,t,s){const r=this.view.resolution;this.view.resize(e,t,s),this.emit("resize",this.view.screen.width,this.view.screen.height,this.view.resolution),s!==void 0&&s!==r&&this.runners.resolutionChange.emit(s)}clear(e={}){const t=this;e.target||(e.target=t.renderTarget.renderTarget),e.clearColor||(e.clearColor=this.background.colorRgba),e.clear??(e.clear=tt.ALL);const{clear:s,clearColor:r,target:n}=e;ue.shared.setValue(r??this.background.colorRgba),t.renderTarget.clear(n,s,ue.shared.toArray())}get resolution(){return this.view.resolution}set resolution(e){this.view.resolution=e,this.runners.resolutionChange.emit(e)}get width(){return this.view.texture.frame.width}get height(){return this.view.texture.frame.height}get canvas(){return this.view.canvas}get lastObjectRendered(){return this._lastObjectRendered}get renderingToScreen(){return this.renderTarget.renderingToScreen}get screen(){return this.view.screen}_addRunners(...e){e.forEach(t=>{this.runners[t]=new sg(t)})}_addSystems(e){let t;for(t in e){const s=e[t];this._addSystem(s.value,s.name)}}_addSystem(e,t){const s=new e(this);if(this[t])throw new Error(`Whoops! The name "${t}" is already in use`);this[t]=s,this._systemsHash[t]=s;for(const r in this.runners)this.runners[r].add(s);return this}_addPipes(e,t){const s=t.reduce((r,n)=>(r[n.name]=n.value,r),{});e.forEach(r=>{const n=r.value,o=r.name,a=s[o];this.renderPipes[o]=new n(this,a?new a:null),this.runners.destroy.add(this.renderPipes[o])})}destroy(e=!1){this.runners.destroy.items.reverse(),this.runners.destroy.emit(e),(e===!0||typeof e=="object"&&e.releaseGlobalResources)&&Ui.release(),Object.values(this.runners).forEach(t=>{t.destroy()}),this._systemsHash=null,this.renderPipes=null}generateTexture(e){return this.textureGenerator.generateTexture(e)}get roundPixels(){return!!this._roundPixels}_unsafeEvalCheck(){if(!jm())throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")}resetState(){this.runners.resetState.emit()}};rg.defaultOptions={resolution:1,failIfMajorPerformanceCaveat:!1,roundPixels:!1};let $r=rg,Xr;function CC(i){return Xr!==void 0||(Xr=(()=>{const e={stencil:!0,failIfMajorPerformanceCaveat:i??$r.defaultOptions.failIfMajorPerformanceCaveat};try{if(!Y.get().getWebGLRenderingContext())return!1;let s=Y.get().createCanvas().getContext("webgl",e);const r=!!s?.getContextAttributes()?.stencil;if(s){const n=s.getExtension("WEBGL_lose_context");n&&n.loseContext()}return s=null,r}catch{return!1}})()),Xr}let Yr;async function AC(i={}){return Yr!==void 0||(Yr=await(async()=>{const e=Y.get().getNavigator().gpu;if(!e)return!1;try{return await(await e.requestAdapter(i)).requestDevice(),!0}catch{return!1}})()),Yr}const ng=["webgl","webgpu","canvas"];async function EC(i){let e=[];i.preference?(e.push(i.preference),ng.forEach(n=>{n!==i.preference&&e.push(n)})):e=ng.slice();let t,s={};for(let n=0;n<e.length;n++){const o=e[n];if(o==="webgpu"&&await AC()){const{WebGPURenderer:a}=await Promise.resolve().then(()=>AP);t=a,s={...i,...i.webgpu};break}else if(o==="webgl"&&CC(i.failIfMajorPerformanceCaveat??$r.defaultOptions.failIfMajorPerformanceCaveat)){const{WebGLRenderer:a}=await Promise.resolve().then(()=>nP);t=a,s={...i,...i.webgl};break}else if(o==="canvas")throw s={...i},new Error("CanvasRenderer is not yet implemented")}if(delete s.webgpu,delete s.webgl,!t)throw new Error("No available renderer for the current environment");const r=new t;return await r.init(s),r}const qr="8.15.0";class og{static init(){globalThis.__PIXI_APP_INIT__?.(this,qr)}static destroy(){}}og.extension=b.Application;class ag{constructor(e){this._renderer=e}init(){globalThis.__PIXI_RENDERER_INIT__?.(this._renderer,qr)}destroy(){this._renderer=null}}ag.extension={type:[b.WebGLSystem,b.WebGPUSystem],name:"initHook",priority:-10};const lg=class cf{constructor(...e){this.stage=new se,e[0]!==void 0&&L(J,"Application constructor options are deprecated, please use Application.init() instead.")}async init(e){e={...e},this.stage||(this.stage=new se),this.renderer=await EC(e),cf._plugins.forEach(t=>{t.init.call(this,e)})}render(){this.renderer.render({container:this.stage})}get canvas(){return this.renderer.canvas}get view(){return L(J,"Application.view is deprecated, please use Application.canvas instead."),this.renderer.canvas}get screen(){return this.renderer.screen}destroy(e=!1,t=!1){const s=cf._plugins.slice(0);s.reverse(),s.forEach(r=>{r.destroy.call(this)}),this.stage.destroy(t),this.stage=null,this.renderer.destroy(e),this.renderer=null}};lg._plugins=[];let Hu=lg;V.handleByList(b.Application,Hu._plugins),V.add(og);class cg{static init(e){Object.defineProperty(this,"resizeTo",{configurable:!0,set(t){globalThis.removeEventListener("resize",this.queueResize),this._resizeTo=t,t&&(globalThis.addEventListener("resize",this.queueResize),this.resize())},get(){return this._resizeTo}}),this.queueResize=()=>{this._resizeTo&&(this._cancelResize(),this._resizeId=requestAnimationFrame(()=>this.resize()))},this._cancelResize=()=>{this._resizeId&&(cancelAnimationFrame(this._resizeId),this._resizeId=null)},this.resize=()=>{if(!this._resizeTo)return;this._cancelResize();let t,s;if(this._resizeTo===globalThis.window)t=globalThis.innerWidth,s=globalThis.innerHeight;else{const{clientWidth:r,clientHeight:n}=this._resizeTo;t=r,s=n}this.renderer.resize(t,s),this.render()},this._resizeId=null,this._resizeTo=null,this.resizeTo=e.resizeTo||null}static destroy(){globalThis.removeEventListener("resize",this.queueResize),this._cancelResize(),this._cancelResize=null,this.queueResize=null,this.resizeTo=null,this.resize=null}}cg.extension=b.Application;class hg{static init(e){e=Object.assign({autoStart:!0,sharedTicker:!1},e),Object.defineProperty(this,"ticker",{configurable:!0,set(t){this._ticker&&this._ticker.remove(this.render,this),this._ticker=t,t&&t.add(this.render,this,Bi.LOW)},get(){return this._ticker}}),this.stop=()=>{this._ticker.stop()},this.start=()=>{this._ticker.start()},this._ticker=null,this.ticker=e.sharedTicker?Je.shared:new Je,e.autoStart&&this.start()}static destroy(){if(this._ticker){const e=this._ticker;this.ticker=null,e.destroy()}}}hg.extension=b.Application;class ug extends Ze{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.applyFillAsTint=!0,this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return L(J,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return L(J,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return L(J,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return L(J,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return L(J,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(e=!1){this.emit("destroy",this),this.removeAllListeners();for(const t in this.chars)this.chars[t].texture?.destroy();this.chars=null,e&&(this.pages.forEach(t=>t.texture.destroy(!0)),this.pages=null)}}class IC{constructor(e=0,t=0,s=!1){this.first=null,this.items=Object.create(null),this.last=null,this.max=e,this.resetTtl=s,this.size=0,this.ttl=t}clear(){return this.first=null,this.items=Object.create(null),this.last=null,this.size=0,this}delete(e){if(this.has(e)){const t=this.items[e];delete this.items[e],this.size--,t.prev!==null&&(t.prev.next=t.next),t.next!==null&&(t.next.prev=t.prev),this.first===t&&(this.first=t.next),this.last===t&&(this.last=t.prev)}return this}entries(e=this.keys()){const t=new Array(e.length);for(let s=0;s<e.length;s++){const r=e[s];t[s]=[r,this.get(r)]}return t}evict(e=!1){if(e||this.size>0){const t=this.first;delete this.items[t.key],--this.size===0?(this.first=null,this.last=null):(this.first=t.next,this.first.prev=null)}return this}expiresAt(e){let t;return this.has(e)&&(t=this.items[e].expiry),t}get(e){const t=this.items[e];if(t!==void 0){if(this.ttl>0&&t.expiry<=Date.now()){this.delete(e);return}return this.moveToEnd(t),t.value}}has(e){return e in this.items}moveToEnd(e){this.last!==e&&(e.prev!==null&&(e.prev.next=e.next),e.next!==null&&(e.next.prev=e.prev),this.first===e&&(this.first=e.next),e.prev=this.last,e.next=null,this.last!==null&&(this.last.next=e),this.last=e,this.first===null&&(this.first=e))}keys(){const e=new Array(this.size);let t=this.first,s=0;for(;t!==null;)e[s++]=t.key,t=t.next;return e}setWithEvicted(e,t,s=this.resetTtl){let r=null;if(this.has(e))this.set(e,t,!0,s);else{this.max>0&&this.size===this.max&&(r={...this.first},this.evict(!0));let n=this.items[e]={expiry:this.ttl>0?Date.now()+this.ttl:this.ttl,key:e,prev:this.last,next:null,value:t};++this.size===1?this.first=n:this.last.next=n,this.last=n}return r}set(e,t,s=!1,r=this.resetTtl){let n=this.items[e];return s||n!==void 0?(n.value=t,s===!1&&r&&(n.expiry=this.ttl>0?Date.now()+this.ttl:this.ttl),this.moveToEnd(n)):(this.max>0&&this.size===this.max&&this.evict(!0),n=this.items[e]={expiry:this.ttl>0?Date.now()+this.ttl:this.ttl,key:e,prev:this.last,next:null,value:t},++this.size===1?this.first=n:this.last.next=n,this.last=n),this}values(e=this.keys()){const t=new Array(e.length);for(let s=0;s<e.length;s++)t[s]=this.get(e[s]);return t}}function dg(i=1e3,e=0,t=!1){if(isNaN(i)||i<0)throw new TypeError("Invalid max value");if(isNaN(e)||e<0)throw new TypeError("Invalid ttl value");if(typeof t!="boolean")throw new TypeError("Invalid resetTtl value");return new IC(i,e,t)}const PC=["serif","sans-serif","monospace","cursive","fantasy","system-ui"];function Kr(i){const e=typeof i.fontSize=="number"?`${i.fontSize}px`:i.fontSize;let t=i.fontFamily;Array.isArray(i.fontFamily)||(t=i.fontFamily.split(","));for(let s=t.length-1;s>=0;s--){let r=t[s].trim();!/([\"\'])[^\'\"]+\1/.test(r)&&!PC.includes(r)&&(r=`"${r}"`),t[s]=r}return`${i.fontStyle} ${i.fontVariant} ${i.fontWeight} ${e} ${t.join(",")}`}const Wu={willReadFrequently:!0},gt=class z{static get experimentalLetterSpacingSupported(){let e=z._experimentalLetterSpacingSupported;if(e===void 0){const t=Y.get().getCanvasRenderingContext2D().prototype;e=z._experimentalLetterSpacingSupported="letterSpacing"in t||"textLetterSpacing"in t}return e}constructor(e,t,s,r,n,o,a,l,c){this.text=e,this.style=t,this.width=s,this.height=r,this.lines=n,this.lineWidths=o,this.lineHeight=a,this.maxLineWidth=l,this.fontProperties=c}static measureText(e=" ",t,s=z._canvas,r=t.wordWrap){const n=`${e}-${t.styleKey}-wordWrap-${r}`;if(z._measurementCache.has(n))return z._measurementCache.get(n);const o=Kr(t),a=z.measureFont(o);a.fontSize===0&&(a.fontSize=t.fontSize,a.ascent=t.fontSize);const l=z.__context;l.font=o;const h=(r?z._wordWrap(e,t,s):e).split(/(?:\r\n|\r|\n)/),u=new Array(h.length);let d=0;for(let x=0;x<h.length;x++){const v=z._measureText(h[x],t.letterSpacing,l);u[x]=v,d=Math.max(d,v)}const f=t._stroke?.width||0;let m=d+f;t.dropShadow&&(m+=t.dropShadow.distance);const g=t.lineHeight||a.fontSize;let p=Math.max(g,a.fontSize+f)+(h.length-1)*(g+t.leading);t.dropShadow&&(p+=t.dropShadow.distance);const _=new z(e,t,m,p,h,u,g+t.leading,d,a);return z._measurementCache.set(n,_),_}static _measureText(e,t,s){let r=!1;z.experimentalLetterSpacingSupported&&(z.experimentalLetterSpacing?(s.letterSpacing=`${t}px`,s.textLetterSpacing=`${t}px`,r=!0):(s.letterSpacing="0px",s.textLetterSpacing="0px"));const n=s.measureText(e);let o=n.width;const a=-n.actualBoundingBoxLeft;let c=n.actualBoundingBoxRight-a;if(o>0)if(r)o-=t,c-=t;else{const h=(z.graphemeSegmenter(e).length-1)*t;o+=h,c+=h}return Math.max(o,c)}static _wordWrap(e,t,s=z._canvas){const r=s.getContext("2d",Wu);let n=0,o="",a="";const l=Object.create(null),{letterSpacing:c,whiteSpace:h}=t,u=z._collapseSpaces(h),d=z._collapseNewlines(h);let f=!u;const m=t.wordWrapWidth+c,g=z._tokenize(e);for(let p=0;p<g.length;p++){let _=g[p];if(z._isNewline(_)){if(!d){a+=z._addLine(o),f=!u,o="",n=0;continue}_=" "}if(u){const v=z.isBreakingSpace(_),y=z.isBreakingSpace(o[o.length-1]);if(v&&y)continue}const x=z._getFromCache(_,c,l,r);if(x>m)if(o!==""&&(a+=z._addLine(o),o="",n=0),z.canBreakWords(_,t.breakWords)){const v=z.wordWrapSplit(_);for(let y=0;y<v.length;y++){let T=v[y],S=T,w=1;for(;v[y+w];){const P=v[y+w];if(!z.canBreakChars(S,P,_,y,t.breakWords))T+=P;else break;S=P,w++}y+=w-1;const E=z._getFromCache(T,c,l,r);E+n>m&&(a+=z._addLine(o),f=!1,o="",n=0),o+=T,n+=E}}else{o.length>0&&(a+=z._addLine(o),o="",n=0);const v=p===g.length-1;a+=z._addLine(_,!v),f=!1,o="",n=0}else x+n>m&&(f=!1,a+=z._addLine(o),o="",n=0),(o.length>0||!z.isBreakingSpace(_)||f)&&(o+=_,n+=x)}return a+=z._addLine(o,!1),a}static _addLine(e,t=!0){return e=z._trimRight(e),e=t?`${e}
`:e,e}static _getFromCache(e,t,s,r){let n=s[e];return typeof n!="number"&&(n=z._measureText(e,t,r)+t,s[e]=n),n}static _collapseSpaces(e){return e==="normal"||e==="pre-line"}static _collapseNewlines(e){return e==="normal"}static _trimRight(e){if(typeof e!="string")return"";for(let t=e.length-1;t>=0;t--){const s=e[t];if(!z.isBreakingSpace(s))break;e=e.slice(0,-1)}return e}static _isNewline(e){return typeof e!="string"?!1:z._newlines.includes(e.charCodeAt(0))}static isBreakingSpace(e,t){return typeof e!="string"?!1:z._breakingSpaces.includes(e.charCodeAt(0))}static _tokenize(e){const t=[];let s="";if(typeof e!="string")return t;for(let r=0;r<e.length;r++){const n=e[r],o=e[r+1];if(z.isBreakingSpace(n,o)||z._isNewline(n)){s!==""&&(t.push(s),s=""),n==="\r"&&o===`
`?(t.push(`\r
`),r++):t.push(n);continue}s+=n}return s!==""&&t.push(s),t}static canBreakWords(e,t){return t}static canBreakChars(e,t,s,r,n){return!0}static wordWrapSplit(e){return z.graphemeSegmenter(e)}static measureFont(e){if(z._fonts[e])return z._fonts[e];const t=z._context;t.font=e;const s=t.measureText(z.METRICS_STRING+z.BASELINE_SYMBOL),r={ascent:s.actualBoundingBoxAscent,descent:s.actualBoundingBoxDescent,fontSize:s.actualBoundingBoxAscent+s.actualBoundingBoxDescent};return z._fonts[e]=r,r}static clearMetrics(e=""){e?delete z._fonts[e]:z._fonts={}}static get _canvas(){if(!z.__canvas){let e;try{const t=new OffscreenCanvas(0,0);if(t.getContext("2d",Wu)?.measureText)return z.__canvas=t,t;e=Y.get().createCanvas()}catch{e=Y.get().createCanvas()}e.width=e.height=10,z.__canvas=e}return z.__canvas}static get _context(){return z.__context||(z.__context=z._canvas.getContext("2d",Wu)),z.__context}};gt.METRICS_STRING="|q",gt.BASELINE_SYMBOL="M",gt.BASELINE_MULTIPLIER=1.4,gt.HEIGHT_MULTIPLIER=2,gt.graphemeSegmenter=(()=>{if(typeof Intl?.Segmenter=="function"){const i=new Intl.Segmenter;return e=>{const t=i.segment(e),s=[];let r=0;for(const n of t)s[r++]=n.segment;return s}}return i=>[...i]})(),gt.experimentalLetterSpacing=!1,gt._fonts={},gt._newlines=[10,13],gt._breakingSpaces=[9,32,8192,8193,8194,8195,8196,8197,8198,8200,8201,8202,8287,12288],gt._measurementCache=dg(1e3);let Xe=gt;const fg=[{offset:0,color:"white"},{offset:1,color:"black"}],Vu=class hf{constructor(...e){this.uid=le("fillGradient"),this._tick=0,this.type="linear",this.colorStops=[];let t=RC(e);t={...t.type==="radial"?hf.defaultRadialOptions:hf.defaultLinearOptions,...Np(t)},this._textureSize=t.textureSize,this._wrapMode=t.wrapMode,t.type==="radial"?(this.center=t.center,this.outerCenter=t.outerCenter??this.center,this.innerRadius=t.innerRadius,this.outerRadius=t.outerRadius,this.scale=t.scale,this.rotation=t.rotation):(this.start=t.start,this.end=t.end),this.textureSpace=t.textureSpace,this.type=t.type,t.colorStops.forEach(r=>{this.addColorStop(r.offset,r.color)})}addColorStop(e,t){return this.colorStops.push({offset:e,color:ue.shared.setValue(t).toHexa()}),this}buildLinearGradient(){if(this.texture)return;let{x:e,y:t}=this.start,{x:s,y:r}=this.end,n=s-e,o=r-t;const a=n<0||o<0;if(this._wrapMode==="clamp-to-edge"){if(n<0){const p=e;e=s,s=p,n*=-1}if(o<0){const p=t;t=r,r=p,o*=-1}}const l=this.colorStops.length?this.colorStops:fg,c=this._textureSize,{canvas:h,context:u}=mg(c,1),d=a?u.createLinearGradient(this._textureSize,0,0,0):u.createLinearGradient(0,0,this._textureSize,0);pg(d,l),u.fillStyle=d,u.fillRect(0,0,c,1),this.texture=new k({source:new Et({resource:h,addressMode:this._wrapMode})});const f=Math.sqrt(n*n+o*o),m=Math.atan2(o,n),g=new O;g.scale(f/c,1),g.rotate(m),g.translate(e,t),this.textureSpace==="local"&&g.scale(c,c),this.transform=g}buildGradient(){this.texture||this._tick++,this.type==="linear"?this.buildLinearGradient():this.buildRadialGradient()}buildRadialGradient(){if(this.texture)return;const e=this.colorStops.length?this.colorStops:fg,t=this._textureSize,{canvas:s,context:r}=mg(t,t),{x:n,y:o}=this.center,{x:a,y:l}=this.outerCenter,c=this.innerRadius,h=this.outerRadius,u=a-h,d=l-h,f=t/(h*2),m=(n-u)*f,g=(o-d)*f,p=r.createRadialGradient(m,g,c*f,(a-u)*f,(l-d)*f,h*f);pg(p,e),r.fillStyle=e[e.length-1].color,r.fillRect(0,0,t,t),r.fillStyle=p,r.translate(m,g),r.rotate(this.rotation),r.scale(1,this.scale),r.translate(-m,-g),r.fillRect(0,0,t,t),this.texture=new k({source:new Et({resource:s,addressMode:this._wrapMode})});const _=new O;_.scale(1/f,1/f),_.translate(u,d),this.textureSpace==="local"&&_.scale(t,t),this.transform=_}destroy(){this.texture?.destroy(!0),this.texture=null,this.transform=null,this.colorStops=[],this.start=null,this.end=null,this.center=null,this.outerCenter=null}get styleKey(){return`fill-gradient-${this.uid}-${this._tick}`}};Vu.defaultLinearOptions={start:{x:0,y:0},end:{x:0,y:1},colorStops:[],textureSpace:"local",type:"linear",textureSize:256,wrapMode:"clamp-to-edge"},Vu.defaultRadialOptions={center:{x:.5,y:.5},innerRadius:0,outerRadius:.5,colorStops:[],scale:1,textureSpace:"local",type:"radial",textureSize:256,wrapMode:"clamp-to-edge"};let ct=Vu;function pg(i,e){for(let t=0;t<e.length;t++){const s=e[t];i.addColorStop(s.offset,s.color)}}function mg(i,e){const t=Y.get().createCanvas(i,e),s=t.getContext("2d");return{canvas:t,context:s}}function RC(i){let e=i[0]??{};return(typeof e=="number"||i[1])&&(L("8.5.2","use options object instead"),e={type:"linear",start:{x:i[0],y:i[1]},end:{x:i[2],y:i[3]},textureSpace:i[4],textureSize:i[5]??ct.defaultLinearOptions.textureSize}),e}const gg={repeat:{addressModeU:"repeat",addressModeV:"repeat"},"repeat-x":{addressModeU:"repeat",addressModeV:"clamp-to-edge"},"repeat-y":{addressModeU:"clamp-to-edge",addressModeV:"repeat"},"no-repeat":{addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge"}};class jr{constructor(e,t){this.uid=le("fillPattern"),this._tick=0,this.transform=new O,this.texture=e,this.transform.scale(1/e.frame.width,1/e.frame.height),t&&(e.source.style.addressModeU=gg[t].addressModeU,e.source.style.addressModeV=gg[t].addressModeV)}setTransform(e){const t=this.texture;this.transform.copyFrom(e),this.transform.invert(),this.transform.scale(1/t.frame.width,1/t.frame.height),this._tick++}get texture(){return this._texture}set texture(e){this._texture!==e&&(this._texture=e,this._tick++)}get styleKey(){return`fill-pattern-${this.uid}-${this._tick}`}destroy(){this.texture.destroy(!0),this.texture=null}}var $u,_g;function kC(){if(_g)return $u;_g=1,$u=t;var i={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},e=/([astvzqmhlc])([^astvzqmhlc]*)/ig;function t(n){var o=[];return n.replace(e,function(a,l,c){var h=l.toLowerCase();for(c=r(c),h=="m"&&c.length>2&&(o.push([l].concat(c.splice(0,2))),h="l",l=l=="m"?"l":"L");;){if(c.length==i[h])return c.unshift(l),o.push(c);if(c.length<i[h])throw new Error("malformed path data");o.push([l].concat(c.splice(0,i[h])))}}),o}var s=/-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;function r(n){var o=n.match(s);return o?o.map(Number):[]}return $u}var MC=kC();const FC=tu(MC);function UC(i,e){const t=FC(i),s=[];let r=null,n=0,o=0;for(let a=0;a<t.length;a++){const l=t[a],c=l[0],h=l;switch(c){case"M":n=h[1],o=h[2],e.moveTo(n,o);break;case"m":n+=h[1],o+=h[2],e.moveTo(n,o);break;case"H":n=h[1],e.lineTo(n,o);break;case"h":n+=h[1],e.lineTo(n,o);break;case"V":o=h[1],e.lineTo(n,o);break;case"v":o+=h[1],e.lineTo(n,o);break;case"L":n=h[1],o=h[2],e.lineTo(n,o);break;case"l":n+=h[1],o+=h[2],e.lineTo(n,o);break;case"C":n=h[5],o=h[6],e.bezierCurveTo(h[1],h[2],h[3],h[4],n,o);break;case"c":e.bezierCurveTo(n+h[1],o+h[2],n+h[3],o+h[4],n+h[5],o+h[6]),n+=h[5],o+=h[6];break;case"S":n=h[3],o=h[4],e.bezierCurveToShort(h[1],h[2],n,o);break;case"s":e.bezierCurveToShort(n+h[1],o+h[2],n+h[3],o+h[4]),n+=h[3],o+=h[4];break;case"Q":n=h[3],o=h[4],e.quadraticCurveTo(h[1],h[2],n,o);break;case"q":e.quadraticCurveTo(n+h[1],o+h[2],n+h[3],o+h[4]),n+=h[3],o+=h[4];break;case"T":n=h[1],o=h[2],e.quadraticCurveToShort(n,o);break;case"t":n+=h[1],o+=h[2],e.quadraticCurveToShort(n,o);break;case"A":n=h[6],o=h[7],e.arcToSvg(h[1],h[2],h[3],h[4],h[5],n,o);break;case"a":n+=h[6],o+=h[7],e.arcToSvg(h[1],h[2],h[3],h[4],h[5],n,o);break;case"Z":case"z":e.closePath(),s.length>0&&(r=s.pop(),r?(n=r.startX,o=r.startY):(n=0,o=0)),r=null;break;default:H(`Unknown SVG path command: ${c}`)}c!=="Z"&&c!=="z"&&r===null&&(r={startX:n,startY:o},s.push(r))}return e}class Zr{constructor(e=0,t=0,s=0){this.type="circle",this.x=e,this.y=t,this.radius=s}clone(){return new Zr(this.x,this.y,this.radius)}contains(e,t){if(this.radius<=0)return!1;const s=this.radius*this.radius;let r=this.x-e,n=this.y-t;return r*=r,n*=n,r+n<=s}strokeContains(e,t,s,r=.5){if(this.radius===0)return!1;const n=this.x-e,o=this.y-t,a=this.radius,l=(1-r)*s,c=Math.sqrt(n*n+o*o);return c<=a+l&&c>a-(s-l)}getBounds(e){return e||(e=new W),e.x=this.x-this.radius,e.y=this.y-this.radius,e.width=this.radius*2,e.height=this.radius*2,e}copyFrom(e){return this.x=e.x,this.y=e.y,this.radius=e.radius,this}copyTo(e){return e.copyFrom(this),e}toString(){return`[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`}}class Xu{constructor(e=0,t=0,s=0,r=0){this.type="ellipse",this.x=e,this.y=t,this.halfWidth=s,this.halfHeight=r}clone(){return new Xu(this.x,this.y,this.halfWidth,this.halfHeight)}contains(e,t){if(this.halfWidth<=0||this.halfHeight<=0)return!1;let s=(e-this.x)/this.halfWidth,r=(t-this.y)/this.halfHeight;return s*=s,r*=r,s+r<=1}strokeContains(e,t,s,r=.5){const{halfWidth:n,halfHeight:o}=this;if(n<=0||o<=0)return!1;const a=s*(1-r),l=s-a,c=n-l,h=o-l,u=n+a,d=o+a,f=e-this.x,m=t-this.y,g=f*f/(c*c)+m*m/(h*h),p=f*f/(u*u)+m*m/(d*d);return g>1&&p<=1}getBounds(e){return e||(e=new W),e.x=this.x-this.halfWidth,e.y=this.y-this.halfHeight,e.width=this.halfWidth*2,e.height=this.halfHeight*2,e}copyFrom(e){return this.x=e.x,this.y=e.y,this.halfWidth=e.halfWidth,this.halfHeight=e.halfHeight,this}copyTo(e){return e.copyFrom(this),e}toString(){return`[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`}}function BC(i,e,t,s,r,n){const o=i-t,a=e-s,l=r-t,c=n-s,h=o*l+a*c,u=l*l+c*c;let d=-1;u!==0&&(d=h/u);let f,m;d<0?(f=t,m=s):d>1?(f=r,m=n):(f=t+d*l,m=s+d*c);const g=i-f,p=e-m;return g*g+p*p}let OC,DC;class As{constructor(...e){this.type="polygon";let t=Array.isArray(e[0])?e[0]:e;if(typeof t[0]!="number"){const s=[];for(let r=0,n=t.length;r<n;r++)s.push(t[r].x,t[r].y);t=s}this.points=t,this.closePath=!0}isClockwise(){let e=0;const t=this.points,s=t.length;for(let r=0;r<s;r+=2){const n=t[r],o=t[r+1],a=t[(r+2)%s],l=t[(r+3)%s];e+=(a-n)*(l+o)}return e<0}containsPolygon(e){const t=this.getBounds(OC),s=e.getBounds(DC);if(!t.containsRect(s))return!1;const r=e.points;for(let n=0;n<r.length;n+=2){const o=r[n],a=r[n+1];if(!this.contains(o,a))return!1}return!0}clone(){const e=this.points.slice(),t=new As(e);return t.closePath=this.closePath,t}contains(e,t){let s=!1;const r=this.points.length/2;for(let n=0,o=r-1;n<r;o=n++){const a=this.points[n*2],l=this.points[n*2+1],c=this.points[o*2],h=this.points[o*2+1];l>t!=h>t&&e<(c-a)*((t-l)/(h-l))+a&&(s=!s)}return s}strokeContains(e,t,s,r=.5){const n=s*s,o=n*(1-r),a=n-o,{points:l}=this,c=l.length-(this.closePath?0:2);for(let h=0;h<c;h+=2){const u=l[h],d=l[h+1],f=l[(h+2)%l.length],m=l[(h+3)%l.length],g=BC(e,t,u,d,f,m),p=Math.sign((f-u)*(t-d)-(m-d)*(e-u));if(g<=(p<0?a:o))return!0}return!1}getBounds(e){e||(e=new W);const t=this.points;let s=1/0,r=-1/0,n=1/0,o=-1/0;for(let a=0,l=t.length;a<l;a+=2){const c=t[a],h=t[a+1];s=c<s?c:s,r=c>r?c:r,n=h<n?h:n,o=h>o?h:o}return e.x=s,e.width=r-s,e.y=n,e.height=o-n,e}copyFrom(e){return this.points=e.points.slice(),this.closePath=e.closePath,this}copyTo(e){return e.copyFrom(this),e}toString(){return`[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((e,t)=>`${e}, ${t}`,"")}]`}get lastX(){return this.points[this.points.length-2]}get lastY(){return this.points[this.points.length-1]}get x(){return L("8.11.0","Polygon.lastX is deprecated, please use Polygon.lastX instead."),this.points[this.points.length-2]}get y(){return L("8.11.0","Polygon.y is deprecated, please use Polygon.lastY instead."),this.points[this.points.length-1]}get startX(){return this.points[0]}get startY(){return this.points[1]}}const Jr=(i,e,t,s,r,n,o)=>{const a=i-t,l=e-s,c=Math.sqrt(a*a+l*l);return c>=r-n&&c<=r+o};class Yu{constructor(e=0,t=0,s=0,r=0,n=20){this.type="roundedRectangle",this.x=e,this.y=t,this.width=s,this.height=r,this.radius=n}getBounds(e){return e||(e=new W),e.x=this.x,e.y=this.y,e.width=this.width,e.height=this.height,e}clone(){return new Yu(this.x,this.y,this.width,this.height,this.radius)}copyFrom(e){return this.x=e.x,this.y=e.y,this.width=e.width,this.height=e.height,this}copyTo(e){return e.copyFrom(this),e}contains(e,t){if(this.width<=0||this.height<=0)return!1;if(e>=this.x&&e<=this.x+this.width&&t>=this.y&&t<=this.y+this.height){const s=Math.max(0,Math.min(this.radius,Math.min(this.width,this.height)/2));if(t>=this.y+s&&t<=this.y+this.height-s||e>=this.x+s&&e<=this.x+this.width-s)return!0;let r=e-(this.x+s),n=t-(this.y+s);const o=s*s;if(r*r+n*n<=o||(r=e-(this.x+this.width-s),r*r+n*n<=o)||(n=t-(this.y+this.height-s),r*r+n*n<=o)||(r=e-(this.x+s),r*r+n*n<=o))return!0}return!1}strokeContains(e,t,s,r=.5){const{x:n,y:o,width:a,height:l,radius:c}=this,h=s*(1-r),u=s-h,d=n+c,f=o+c,m=a-c*2,g=l-c*2,p=n+a,_=o+l;return(e>=n-h&&e<=n+u||e>=p-u&&e<=p+h)&&t>=f&&t<=f+g||(t>=o-h&&t<=o+u||t>=_-u&&t<=_+h)&&e>=d&&e<=d+m?!0:e<d&&t<f&&Jr(e,t,d,f,c,u,h)||e>p-c&&t<f&&Jr(e,t,p-c,f,c,u,h)||e>p-c&&t>_-c&&Jr(e,t,p-c,_-c,c,u,h)||e<d&&t>_-c&&Jr(e,t,d,_-c,c,u,h)}toString(){return`[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`}}const xg={};function qu(i,e,t){let s=2166136261;for(let r=0;r<e;r++)s^=i[r].uid,s=Math.imul(s,16777619),s>>>=0;return xg[s]||GC(i,e,s,t)}function GC(i,e,t,s){const r={};let n=0;for(let a=0;a<s;a++){const l=a<e?i[a]:k.EMPTY.source;r[n++]=l.source,r[n++]=l.style}const o=new Gt(r);return xg[t]=o,o}class Li{constructor(e){typeof e=="number"?this.rawBinaryData=new ArrayBuffer(e):e instanceof Uint8Array?this.rawBinaryData=e.buffer:this.rawBinaryData=e,this.uint32View=new Uint32Array(this.rawBinaryData),this.float32View=new Float32Array(this.rawBinaryData),this.size=this.rawBinaryData.byteLength}get int8View(){return this._int8View||(this._int8View=new Int8Array(this.rawBinaryData)),this._int8View}get uint8View(){return this._uint8View||(this._uint8View=new Uint8Array(this.rawBinaryData)),this._uint8View}get int16View(){return this._int16View||(this._int16View=new Int16Array(this.rawBinaryData)),this._int16View}get int32View(){return this._int32View||(this._int32View=new Int32Array(this.rawBinaryData)),this._int32View}get float64View(){return this._float64Array||(this._float64Array=new Float64Array(this.rawBinaryData)),this._float64Array}get bigUint64View(){return this._bigUint64Array||(this._bigUint64Array=new BigUint64Array(this.rawBinaryData)),this._bigUint64Array}view(e){return this[`${e}View`]}destroy(){this.rawBinaryData=null,this.uint32View=null,this.float32View=null,this.uint16View=null,this._int8View=null,this._uint8View=null,this._int16View=null,this._int32View=null,this._float64Array=null,this._bigUint64Array=null}static sizeOf(e){switch(e){case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;default:throw new Error(`${e} isn't a valid view type`)}}}function Ku(i,e){const t=i.byteLength/8|0,s=new Float64Array(i,0,t);new Float64Array(e,0,t).set(s);const n=i.byteLength-t*8;if(n>0){const o=new Uint8Array(i,t*8,n);new Uint8Array(e,t*8,n).set(o)}}const zC={normal:"normal-npm",add:"add-npm",screen:"screen-npm"};var be=(i=>(i[i.DISABLED=0]="DISABLED",i[i.RENDERING_MASK_ADD=1]="RENDERING_MASK_ADD",i[i.MASK_ACTIVE=2]="MASK_ACTIVE",i[i.INVERSE_MASK_ACTIVE=3]="INVERSE_MASK_ACTIVE",i[i.RENDERING_MASK_REMOVE=4]="RENDERING_MASK_REMOVE",i[i.NONE=5]="NONE",i))(be||{});function Es(i,e){return e.alphaMode==="no-premultiply-alpha"&&zC[i]||i}const LC=["precision mediump float;","void main(void){","float test = 0.1;","%forloop%","gl_FragColor = vec4(0.0);","}"].join(`
`);function NC(i){let e="";for(let t=0;t<i;++t)t>0&&(e+=`
else `),t<i-1&&(e+=`if(test == ${t}.0){}`);return e}function vg(i,e){if(i===0)throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");const t=e.createShader(e.FRAGMENT_SHADER);try{for(;;){const s=LC.replace(/%forloop%/gi,NC(i));if(e.shaderSource(t,s),e.compileShader(t),!e.getShaderParameter(t,e.COMPILE_STATUS))i=i/2|0;else break}}finally{e.deleteShader(t)}return i}let Ni=null;function HC(){if(Ni)return Ni;const i=Vm();return Ni=i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS),Ni=vg(Ni,i),i.getExtension("WEBGL_lose_context")?.loseContext(),Ni}class WC{constructor(){this.ids=Object.create(null),this.textures=[],this.count=0}clear(){for(let e=0;e<this.count;e++){const t=this.textures[e];this.textures[e]=null,this.ids[t.uid]=null}this.count=0}}class VC{constructor(){this.renderPipeId="batch",this.action="startBatch",this.start=0,this.size=0,this.textures=new WC,this.blendMode="normal",this.topology="triangle-strip",this.canBundle=!0}destroy(){this.textures=null,this.gpuBindGroup=null,this.bindGroup=null,this.batcher=null}}const Is=[];let Qr=0;Ui.register({clear:()=>{if(Is.length>0)for(const i of Is)i&&i.destroy();Is.length=0,Qr=0}});function yg(){return Qr>0?Is[--Qr]:new VC}function bg(i){Is[Qr++]=i}let Ps=0;const Tg=class ev{constructor(e){this.uid=le("batcher"),this.dirty=!0,this.batchIndex=0,this.batches=[],this._elements=[],e={...ev.defaultOptions,...e},e.maxTextures||(L("v8.8.0","maxTextures is a required option for Batcher now, please pass it in the options"),e.maxTextures=HC());const{maxTextures:t,attributesInitialSize:s,indicesInitialSize:r}=e;this.attributeBuffer=new Li(s*4),this.indexBuffer=new Uint16Array(r),this.maxTextures=t}begin(){this.elementSize=0,this.elementStart=0,this.indexSize=0,this.attributeSize=0;for(let e=0;e<this.batchIndex;e++)bg(this.batches[e]);this.batchIndex=0,this._batchIndexStart=0,this._batchIndexSize=0,this.dirty=!0}add(e){this._elements[this.elementSize++]=e,e._indexStart=this.indexSize,e._attributeStart=this.attributeSize,e._batcher=this,this.indexSize+=e.indexSize,this.attributeSize+=e.attributeSize*this.vertexSize}checkAndUpdateTexture(e,t){const s=e._batch.textures.ids[t._source.uid];return!s&&s!==0?!1:(e._textureId=s,e.texture=t,!0)}updateElement(e){this.dirty=!0;const t=this.attributeBuffer;e.packAsQuad?this.packQuadAttributes(e,t.float32View,t.uint32View,e._attributeStart,e._textureId):this.packAttributes(e,t.float32View,t.uint32View,e._attributeStart,e._textureId)}break(e){const t=this._elements;if(!t[this.elementStart])return;let s=yg(),r=s.textures;r.clear();const n=t[this.elementStart];let o=Es(n.blendMode,n.texture._source),a=n.topology;this.attributeSize*4>this.attributeBuffer.size&&this._resizeAttributeBuffer(this.attributeSize*4),this.indexSize>this.indexBuffer.length&&this._resizeIndexBuffer(this.indexSize);const l=this.attributeBuffer.float32View,c=this.attributeBuffer.uint32View,h=this.indexBuffer;let u=this._batchIndexSize,d=this._batchIndexStart,f="startBatch";const m=this.maxTextures;for(let g=this.elementStart;g<this.elementSize;++g){const p=t[g];t[g]=null;const x=p.texture._source,v=Es(p.blendMode,x),y=o!==v||a!==p.topology;if(x._batchTick===Ps&&!y){p._textureId=x._textureBindLocation,u+=p.indexSize,p.packAsQuad?(this.packQuadAttributes(p,l,c,p._attributeStart,p._textureId),this.packQuadIndex(h,p._indexStart,p._attributeStart/this.vertexSize)):(this.packAttributes(p,l,c,p._attributeStart,p._textureId),this.packIndex(p,h,p._indexStart,p._attributeStart/this.vertexSize)),p._batch=s;continue}x._batchTick=Ps,(r.count>=m||y)&&(this._finishBatch(s,d,u-d,r,o,a,e,f),f="renderBatch",d=u,o=v,a=p.topology,s=yg(),r=s.textures,r.clear(),++Ps),p._textureId=x._textureBindLocation=r.count,r.ids[x.uid]=r.count,r.textures[r.count++]=x,p._batch=s,u+=p.indexSize,p.packAsQuad?(this.packQuadAttributes(p,l,c,p._attributeStart,p._textureId),this.packQuadIndex(h,p._indexStart,p._attributeStart/this.vertexSize)):(this.packAttributes(p,l,c,p._attributeStart,p._textureId),this.packIndex(p,h,p._indexStart,p._attributeStart/this.vertexSize))}r.count>0&&(this._finishBatch(s,d,u-d,r,o,a,e,f),d=u,++Ps),this.elementStart=this.elementSize,this._batchIndexStart=d,this._batchIndexSize=u}_finishBatch(e,t,s,r,n,o,a,l){e.gpuBindGroup=null,e.bindGroup=null,e.action=l,e.batcher=this,e.textures=r,e.blendMode=n,e.topology=o,e.start=t,e.size=s,++Ps,this.batches[this.batchIndex++]=e,a.add(e)}finish(e){this.break(e)}ensureAttributeBuffer(e){e*4<=this.attributeBuffer.size||this._resizeAttributeBuffer(e*4)}ensureIndexBuffer(e){e<=this.indexBuffer.length||this._resizeIndexBuffer(e)}_resizeAttributeBuffer(e){const t=Math.max(e,this.attributeBuffer.size*2),s=new Li(t);Ku(this.attributeBuffer.rawBinaryData,s.rawBinaryData),this.attributeBuffer=s}_resizeIndexBuffer(e){const t=this.indexBuffer;let s=Math.max(e,t.length*1.5);s+=s%2;const r=s>65535?new Uint32Array(s):new Uint16Array(s);if(r.BYTES_PER_ELEMENT!==t.BYTES_PER_ELEMENT)for(let n=0;n<t.length;n++)r[n]=t[n];else Ku(t.buffer,r.buffer);this.indexBuffer=r}packQuadIndex(e,t,s){e[t]=s+0,e[t+1]=s+1,e[t+2]=s+2,e[t+3]=s+0,e[t+4]=s+2,e[t+5]=s+3}packIndex(e,t,s,r){const n=e.indices,o=e.indexSize,a=e.indexOffset,l=e.attributeOffset;for(let c=0;c<o;c++)t[s++]=r+n[c+a]-l}destroy(e={}){if(this.batches!==null){for(let t=0;t<this.batchIndex;t++)bg(this.batches[t]);this.batches=null,this.geometry.destroy(!0),this.geometry=null,e.shader&&(this.shader?.destroy(),this.shader=null);for(let t=0;t<this._elements.length;t++)this._elements[t]&&(this._elements[t]._batch=null);this._elements=null,this.indexBuffer=null,this.attributeBuffer.destroy(),this.attributeBuffer=null}}};Tg.defaultOptions={maxTextures:null,attributesInitialSize:4,indicesInitialSize:6};let $C=Tg;var K=(i=>(i[i.MAP_READ=1]="MAP_READ",i[i.MAP_WRITE=2]="MAP_WRITE",i[i.COPY_SRC=4]="COPY_SRC",i[i.COPY_DST=8]="COPY_DST",i[i.INDEX=16]="INDEX",i[i.VERTEX=32]="VERTEX",i[i.UNIFORM=64]="UNIFORM",i[i.STORAGE=128]="STORAGE",i[i.INDIRECT=256]="INDIRECT",i[i.QUERY_RESOLVE=512]="QUERY_RESOLVE",i[i.STATIC=1024]="STATIC",i))(K||{});class it extends Ze{constructor(e){let{data:t,size:s}=e;const{usage:r,label:n,shrinkToFit:o}=e;super(),this._gpuData=Object.create(null),this._gcLastUsed=-1,this.autoGarbageCollect=!0,this.uid=le("buffer"),this._resourceType="buffer",this._resourceId=le("resource"),this._touched=0,this._updateID=1,this._dataInt32=null,this.shrinkToFit=!0,this.destroyed=!1,t instanceof Array&&(t=new Float32Array(t)),this._data=t,s??(s=t?.byteLength);const a=!!t;this.descriptor={size:s,usage:r,mappedAtCreation:a,label:n},this.shrinkToFit=o??!0}get data(){return this._data}set data(e){this.setDataWithSize(e,e.length,!0)}get dataInt32(){return this._dataInt32||(this._dataInt32=new Int32Array(this.data.buffer)),this._dataInt32}get static(){return!!(this.descriptor.usage&K.STATIC)}set static(e){e?this.descriptor.usage|=K.STATIC:this.descriptor.usage&=~K.STATIC}setDataWithSize(e,t,s){if(this._updateID++,this._updateSize=t*e.BYTES_PER_ELEMENT,this._data===e){s&&this.emit("update",this);return}const r=this._data;if(this._data=e,this._dataInt32=null,!r||r.length!==e.length){!this.shrinkToFit&&r&&e.byteLength<r.byteLength?s&&this.emit("update",this):(this.descriptor.size=e.byteLength,this._resourceId=le("resource"),this.emit("change",this));return}s&&this.emit("update",this)}update(e){this._updateSize=e??this._updateSize,this._updateID++,this.emit("update",this)}unload(){this.emit("unload",this);for(const e in this._gpuData)this._gpuData[e]?.destroy();this._gpuData=Object.create(null)}destroy(){this.destroyed=!0,this.unload(),this.emit("destroy",this),this.emit("change",this),this._data=null,this.descriptor=null,this.removeAllListeners()}}function wg(i,e){if(!(i instanceof it)){let t=e?K.INDEX:K.VERTEX;i instanceof Array&&(e?(i=new Uint32Array(i),t=K.INDEX|K.COPY_DST):(i=new Float32Array(i),t=K.VERTEX|K.COPY_DST)),i=new it({data:i,label:e?"index-mesh-buffer":"vertex-mesh-buffer",usage:t})}return i}function XC(i,e,t){const s=i.getAttribute(e);if(!s)return t.minX=0,t.minY=0,t.maxX=0,t.maxY=0,t;const r=s.buffer.data;let n=1/0,o=1/0,a=-1/0,l=-1/0;const c=r.BYTES_PER_ELEMENT,h=(s.offset||0)/c,u=(s.stride||8)/c;for(let d=h;d<r.length;d+=u){const f=r[d],m=r[d+1];f>a&&(a=f),m>l&&(l=m),f<n&&(n=f),m<o&&(o=m)}return t.minX=n,t.minY=o,t.maxX=a,t.maxY=l,t}function YC(i){return(i instanceof it||Array.isArray(i)||i.BYTES_PER_ELEMENT)&&(i={buffer:i}),i.buffer=wg(i.buffer,!1),i}class Rs extends Ze{constructor(e={}){super(),this._gpuData=Object.create(null),this.autoGarbageCollect=!0,this._gcLastUsed=-1,this.uid=le("geometry"),this._layoutKey=0,this.instanceCount=1,this._bounds=new De,this._boundsDirty=!0;const{attributes:t,indexBuffer:s,topology:r}=e;if(this.buffers=[],this.attributes={},t)for(const n in t)this.addAttribute(n,t[n]);this.instanceCount=e.instanceCount??1,s&&this.addIndex(s),this.topology=r||"triangle-list"}onBufferUpdate(){this._boundsDirty=!0,this.emit("update",this)}getAttribute(e){return this.attributes[e]}getIndex(){return this.indexBuffer}getBuffer(e){return this.getAttribute(e).buffer}getSize(){for(const e in this.attributes){const t=this.attributes[e];return t.buffer.data.length/(t.stride/4||t.size)}return 0}addAttribute(e,t){const s=YC(t);this.buffers.indexOf(s.buffer)===-1&&(this.buffers.push(s.buffer),s.buffer.on("update",this.onBufferUpdate,this),s.buffer.on("change",this.onBufferUpdate,this)),this.attributes[e]=s}addIndex(e){this.indexBuffer=wg(e,!0),this.buffers.push(this.indexBuffer)}get bounds(){return this._boundsDirty?(this._boundsDirty=!1,XC(this,"aPosition",this._bounds)):this._bounds}unload(){this.emit("unload",this);for(const e in this._gpuData)this._gpuData[e]?.destroy();this._gpuData=Object.create(null)}destroy(e=!1){this.emit("destroy",this),this.removeAllListeners(),e&&this.buffers.forEach(t=>t.destroy()),this.unload(),this.indexBuffer?.destroy(),this.attributes=null,this.buffers=null,this.indexBuffer=null,this._bounds=null}}const qC=new Float32Array(1),KC=new Uint32Array(1);class jC extends Rs{constructor(){const t=new it({data:qC,label:"attribute-batch-buffer",usage:K.VERTEX|K.COPY_DST,shrinkToFit:!1}),s=new it({data:KC,label:"index-batch-buffer",usage:K.INDEX|K.COPY_DST,shrinkToFit:!1}),r=24;super({attributes:{aPosition:{buffer:t,format:"float32x2",stride:r,offset:0},aUV:{buffer:t,format:"float32x2",stride:r,offset:8},aColor:{buffer:t,format:"unorm8x4",stride:r,offset:16},aTextureIdAndRound:{buffer:t,format:"uint16x2",stride:r,offset:20}},indexBuffer:s})}}function Sg(i,e,t){if(i)for(const s in i){const r=s.toLocaleLowerCase(),n=e[r];if(n){let o=i[s];s==="header"&&(o=o.replace(/@in\s+[^;]+;\s*/g,"").replace(/@out\s+[^;]+;\s*/g,"")),t&&n.push(`//----${t}----//`),n.push(o)}else H(`${s} placement hook does not exist in shader`)}}const ZC=/\{\{(.*?)\}\}/g;function Cg(i){const e={};return(i.match(ZC)?.map(s=>s.replace(/[{()}]/g,""))??[]).forEach(s=>{e[s]=[]}),e}function Ag(i,e){let t;const s=/@in\s+([^;]+);/g;for(;(t=s.exec(i))!==null;)e.push(t[1])}function Eg(i,e,t=!1){const s=[];Ag(e,s),i.forEach(a=>{a.header&&Ag(a.header,s)});const r=s;t&&r.sort();const n=r.map((a,l)=>`       @location(${l}) ${a},`).join(`
`);let o=e.replace(/@in\s+[^;]+;\s*/g,"");return o=o.replace("{{in}}",`
${n}
`),o}function Ig(i,e){let t;const s=/@out\s+([^;]+);/g;for(;(t=s.exec(i))!==null;)e.push(t[1])}function JC(i){const t=/\b(\w+)\s*:/g.exec(i);return t?t[1]:""}function QC(i){const e=/@.*?\s+/g;return i.replace(e,"")}function eA(i,e){const t=[];Ig(e,t),i.forEach(l=>{l.header&&Ig(l.header,t)});let s=0;const r=t.sort().map(l=>l.indexOf("builtin")>-1?l:`@location(${s++}) ${l}`).join(`,
`),n=t.sort().map(l=>`       var ${QC(l)};`).join(`
`),o=`return VSOutput(
            ${t.sort().map(l=>` ${JC(l)}`).join(`,
`)});`;let a=e.replace(/@out\s+[^;]+;\s*/g,"");return a=a.replace("{{struct}}",`
${r}
`),a=a.replace("{{start}}",`
${n}
`),a=a.replace("{{return}}",`
${o}
`),a}function Pg(i,e){let t=i;for(const s in e){const r=e[s];r.join(`
`).length?t=t.replace(`{{${s}}}`,`//-----${s} START-----//
${r.join(`
`)}
//----${s} FINISH----//`):t=t.replace(`{{${s}}}`,"")}return t}const Jt=Object.create(null),ju=new Map;let tA=0;function iA({template:i,bits:e}){const t=Rg(i,e);if(Jt[t])return Jt[t];const{vertex:s,fragment:r}=rA(i,e);return Jt[t]=kg(s,r,e),Jt[t]}function sA({template:i,bits:e}){const t=Rg(i,e);return Jt[t]||(Jt[t]=kg(i.vertex,i.fragment,e)),Jt[t]}function rA(i,e){const t=e.map(o=>o.vertex).filter(o=>!!o),s=e.map(o=>o.fragment).filter(o=>!!o);let r=Eg(t,i.vertex,!0);r=eA(t,r);const n=Eg(s,i.fragment,!0);return{vertex:r,fragment:n}}function Rg(i,e){return e.map(t=>(ju.has(t)||ju.set(t,tA++),ju.get(t))).sort((t,s)=>t-s).join("-")+i.vertex+i.fragment}function kg(i,e,t){const s=Cg(i),r=Cg(e);return t.forEach(n=>{Sg(n.vertex,s,n.name),Sg(n.fragment,r,n.name)}),{vertex:Pg(i,s),fragment:Pg(e,r)}}const nA=`
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}

        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);

        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`,oA=`
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;

    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {

        {{start}}

        var outColor:vec4<f32>;

        {{main}}

        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`,aA=`
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;

        {{start}}

        vColor = vec4(1.);

        {{main}}

        vUV = uv;

        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`,lA=`

    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {

        {{start}}

        vec4 outColor;

        {{main}}

        finalColor = outColor * vColor;

        {{end}}
    }
`,cA={name:"global-uniforms-bit",vertex:{header:`
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `}},hA={name:"global-uniforms-bit",vertex:{header:`
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `}};function ks({bits:i,name:e}){const t=iA({template:{fragment:oA,vertex:nA},bits:[cA,...i]});return Dt.from({name:e,vertex:{source:t.vertex,entryPoint:"main"},fragment:{source:t.fragment,entryPoint:"main"}})}function Ms({bits:i,name:e}){return new It({name:e,...sA({template:{vertex:aA,fragment:lA},bits:[hA,...i]})})}const Zu={name:"color-bit",vertex:{header:`
            @in aColor: vec4<f32>;
        `,main:`
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `}},Ju={name:"color-bit",vertex:{header:`
            in vec4 aColor;
        `,main:`
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `}},Qu={};function uA(i){const e=[];if(i===1)e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"),e.push("@group(1) @binding(1) var textureSampler1: sampler;");else{let t=0;for(let s=0;s<i;s++)e.push(`@group(1) @binding(${t++}) var textureSource${s+1}: texture_2d<f32>;`),e.push(`@group(1) @binding(${t++}) var textureSampler${s+1}: sampler;`)}return e.join(`
`)}function dA(i){const e=[];if(i===1)e.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");else{e.push("switch vTextureId {");for(let t=0;t<i;t++)t===i-1?e.push("  default:{"):e.push(`  case ${t}:{`),e.push(`      outColor = textureSampleGrad(textureSource${t+1}, textureSampler${t+1}, vUV, uvDx, uvDy);`),e.push("      break;}");e.push("}")}return e.join(`
`)}function ed(i){return Qu[i]||(Qu[i]={name:"texture-batch-bit",vertex:{header:`
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `},fragment:{header:`
                @in @interpolate(flat) vTextureId: u32;

                ${uA(i)}
            `,main:`
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${dA(i)}
            `}}),Qu[i]}const td={};function fA(i){const e=[];for(let t=0;t<i;t++)t>0&&e.push("else"),t<i-1&&e.push(`if(vTextureId < ${t}.5)`),e.push("{"),e.push(`	outColor = texture(uTextures[${t}], vUV);`),e.push("}");return e.join(`
`)}function id(i){return td[i]||(td[i]={name:"texture-batch-bit",vertex:{header:`
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,main:`
                vTextureId = aTextureIdAndRound.y;
            `,end:`
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `},fragment:{header:`
                in float vTextureId;

                uniform sampler2D uTextures[${i}];

            `,main:`

                ${fA(i)}
            `}}),td[i]}const Fs={name:"round-pixels-bit",vertex:{header:`
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}},Us={name:"round-pixels-bit",vertex:{header:`
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `}},Mg={};function sd(i){let e=Mg[i];if(e)return e;const t=new Int32Array(i);for(let s=0;s<i;s++)t[s]=s;return e=Mg[i]=new We({uTextures:{value:t,type:"i32",size:i}},{isStatic:!0}),e}class Fg extends lt{constructor(e){const t=Ms({name:"batch",bits:[Ju,id(e),Us]}),s=ks({name:"batch",bits:[Zu,ed(e),Fs]});super({glProgram:t,gpuProgram:s,resources:{batchSamplers:sd(e)}}),this.maxTextures=e}}let Bs=null;const Ug=class tv extends $C{constructor(e){super(e),this.geometry=new jC,this.name=tv.extension.name,this.vertexSize=6,Bs??(Bs=new Fg(e.maxTextures)),this.shader=Bs}packAttributes(e,t,s,r,n){const o=n<<16|e.roundPixels&65535,a=e.transform,l=a.a,c=a.b,h=a.c,u=a.d,d=a.tx,f=a.ty,{positions:m,uvs:g}=e,p=e.color,_=e.attributeOffset,x=_+e.attributeSize;for(let v=_;v<x;v++){const y=v*2,T=m[y],S=m[y+1];t[r++]=l*T+h*S+d,t[r++]=u*S+c*T+f,t[r++]=g[y],t[r++]=g[y+1],s[r++]=p,s[r++]=o}}packQuadAttributes(e,t,s,r,n){const o=e.texture,a=e.transform,l=a.a,c=a.b,h=a.c,u=a.d,d=a.tx,f=a.ty,m=e.bounds,g=m.maxX,p=m.minX,_=m.maxY,x=m.minY,v=o.uvs,y=e.color,T=n<<16|e.roundPixels&65535;t[r+0]=l*p+h*x+d,t[r+1]=u*x+c*p+f,t[r+2]=v.x0,t[r+3]=v.y0,s[r+4]=y,s[r+5]=T,t[r+6]=l*g+h*x+d,t[r+7]=u*x+c*g+f,t[r+8]=v.x1,t[r+9]=v.y1,s[r+10]=y,s[r+11]=T,t[r+12]=l*g+h*_+d,t[r+13]=u*_+c*g+f,t[r+14]=v.x2,t[r+15]=v.y2,s[r+16]=y,s[r+17]=T,t[r+18]=l*p+h*_+d,t[r+19]=u*_+c*p+f,t[r+20]=v.x3,t[r+21]=v.y3,s[r+22]=y,s[r+23]=T}_updateMaxTextures(e){this.shader.maxTextures!==e&&(Bs=new Fg(e),this.shader=Bs)}destroy(){this.shader=null,super.destroy()}};Ug.extension={type:[b.Batcher],name:"default"};let rd=Ug;class st{constructor(e){this.items=Object.create(null);const{renderer:t,type:s,onUnload:r,priority:n,name:o}=e;this._renderer=t,t.gc.addResourceHash(this,"items",s,n??0),this._onUnload=r,this.name=o}add(e){return this.items[e.uid]?!1:(this.items[e.uid]=e,e.once("unload",this.remove,this),e._gcLastUsed=this._renderer.gc.now,!0)}remove(e,...t){if(!this.items[e.uid])return;const s=e._gpuData[this._renderer.uid];s&&(this._onUnload?.(e,...t),s.destroy(),e._gpuData[this._renderer.uid]=null,this.items[e.uid]=null)}removeAll(...e){Object.values(this.items).forEach(t=>t&&this.remove(t,...e))}destroy(...e){this.removeAll(...e),this.items=Object.create(null),this._renderer=null,this._onUnload=null}}function pA(i,e,t,s,r,n,o,a=null){let l=0;t*=e,r*=n;const c=a.a,h=a.b,u=a.c,d=a.d,f=a.tx,m=a.ty;for(;l<o;){const g=i[t],p=i[t+1];s[r]=c*g+u*p+f,s[r+1]=h*g+d*p+m,r+=n,t+=e,l++}}function mA(i,e,t,s){let r=0;for(e*=t;r<s;)i[e]=0,i[e+1]=0,e+=t,r++}function Bg(i,e,t,s,r){const n=e.a,o=e.b,a=e.c,l=e.d,c=e.tx,h=e.ty;t||(t=0),s||(s=2),r||(r=i.length/s-t);let u=t*s;for(let d=0;d<r;d++){const f=i[u],m=i[u+1];i[u]=n*f+a*m+c,i[u+1]=o*f+l*m+h,u+=s}}const gA=new O;class nd{constructor(){this.packAsQuad=!1,this.batcherName="default",this.topology="triangle-list",this.applyTransform=!0,this.roundPixels=0,this._batcher=null,this._batch=null}get uvs(){return this.geometryData.uvs}get positions(){return this.geometryData.vertices}get indices(){return this.geometryData.indices}get blendMode(){return this.renderable&&this.applyTransform?this.renderable.groupBlendMode:"normal"}get color(){const e=this.baseColor,t=e>>16|e&65280|(e&255)<<16,s=this.renderable;return s?lm(t,s.groupColor)+(this.alpha*s.groupAlpha*255<<24):t+(this.alpha*255<<24)}get transform(){return this.renderable?.groupTransform||gA}copyTo(e){e.indexOffset=this.indexOffset,e.indexSize=this.indexSize,e.attributeOffset=this.attributeOffset,e.attributeSize=this.attributeSize,e.baseColor=this.baseColor,e.alpha=this.alpha,e.texture=this.texture,e.geometryData=this.geometryData,e.topology=this.topology}reset(){this.applyTransform=!0,this.renderable=null,this.topology="triangle-list"}destroy(){this.renderable=null,this.texture=null,this.geometryData=null,this._batcher=null,this._batch=null}}const Os={extension:{type:b.ShapeBuilder,name:"circle"},build(i,e){let t,s,r,n,o,a;if(i.type==="circle"){const y=i;if(o=a=y.radius,o<=0)return!1;t=y.x,s=y.y,r=n=0}else if(i.type==="ellipse"){const y=i;if(o=y.halfWidth,a=y.halfHeight,o<=0||a<=0)return!1;t=y.x,s=y.y,r=n=0}else{const y=i,T=y.width/2,S=y.height/2;t=y.x+T,s=y.y+S,o=a=Math.max(0,Math.min(y.radius,Math.min(T,S))),r=T-o,n=S-a}if(r<0||n<0)return!1;const l=Math.ceil(2.3*Math.sqrt(o+a)),c=l*8+(r?4:0)+(n?4:0);if(c===0)return!1;if(l===0)return e[0]=e[6]=t+r,e[1]=e[3]=s+n,e[2]=e[4]=t-r,e[5]=e[7]=s-n,!0;let h=0,u=l*4+(r?2:0)+2,d=u,f=c,m=r+o,g=n,p=t+m,_=t-m,x=s+g;if(e[h++]=p,e[h++]=x,e[--u]=x,e[--u]=_,n){const y=s-g;e[d++]=_,e[d++]=y,e[--f]=y,e[--f]=p}for(let y=1;y<l;y++){const T=Math.PI/2*(y/l),S=r+Math.cos(T)*o,w=n+Math.sin(T)*a,E=t+S,P=t-S,C=s+w,A=s-w;e[h++]=E,e[h++]=C,e[--u]=C,e[--u]=P,e[d++]=P,e[d++]=A,e[--f]=A,e[--f]=E}m=r,g=n+a,p=t+m,_=t-m,x=s+g;const v=s-g;return e[h++]=p,e[h++]=x,e[--f]=v,e[--f]=p,r&&(e[h++]=_,e[h++]=x,e[--f]=v,e[--f]=_),!0},triangulate(i,e,t,s,r,n){if(i.length===0)return;let o=0,a=0;for(let h=0;h<i.length;h+=2)o+=i[h],a+=i[h+1];o/=i.length/2,a/=i.length/2;let l=s;e[l*t]=o,e[l*t+1]=a;const c=l++;for(let h=0;h<i.length;h+=2)e[l*t]=i[h],e[l*t+1]=i[h+1],h>0&&(r[n++]=l,r[n++]=c,r[n++]=l-1),l++;r[n++]=c+1,r[n++]=c,r[n++]=l-1}},_A={...Os,extension:{...Os.extension,name:"ellipse"}},xA={...Os,extension:{...Os.extension,name:"roundedRectangle"}},Og=1e-4,Dg=1e-4;function vA(i){const e=i.length;if(e<6)return 1;let t=0;for(let s=0,r=i[e-2],n=i[e-1];s<e;s+=2){const o=i[s],a=i[s+1];t+=(o-r)*(a+n),r=o,n=a}return t<0?-1:1}function Gg(i,e,t,s,r,n,o,a){const l=i-t*r,c=e-s*r,h=i+t*n,u=e+s*n;let d,f;o?(d=s,f=-t):(d=-s,f=t);const m=l+d,g=c+f,p=h+d,_=u+f;return a.push(m,g),a.push(p,_),2}function fi(i,e,t,s,r,n,o,a){const l=t-i,c=s-e;let h=Math.atan2(l,c),u=Math.atan2(r-i,n-e);a&&h<u?h+=Math.PI*2:!a&&h>u&&(u+=Math.PI*2);let d=h;const f=u-h,m=Math.abs(f),g=Math.sqrt(l*l+c*c),p=(15*m*Math.sqrt(g)/Math.PI>>0)+1,_=f/p;if(d+=_,a){o.push(i,e),o.push(t,s);for(let x=1,v=d;x<p;x++,v+=_)o.push(i,e),o.push(i+Math.sin(v)*g,e+Math.cos(v)*g);o.push(i,e),o.push(r,n)}else{o.push(t,s),o.push(i,e);for(let x=1,v=d;x<p;x++,v+=_)o.push(i+Math.sin(v)*g,e+Math.cos(v)*g),o.push(i,e);o.push(r,n),o.push(i,e)}return p*2}function yA(i,e,t,s,r,n){const o=Og;if(i.length===0)return;const a=e;let l=a.alignment;if(e.alignment!==.5){let G=vA(i);l=(l-.5)*G+.5}const c=new X(i[0],i[1]),h=new X(i[i.length-2],i[i.length-1]),u=s,d=Math.abs(c.x-h.x)<o&&Math.abs(c.y-h.y)<o;if(u){i=i.slice(),d&&(i.pop(),i.pop(),h.set(i[i.length-2],i[i.length-1]));const G=(c.x+h.x)*.5,ie=(h.y+c.y)*.5;i.unshift(G,ie),i.push(G,ie)}const f=r,m=i.length/2;let g=i.length;const p=f.length/2,_=a.width/2,x=_*_,v=a.miterLimit*a.miterLimit;let y=i[0],T=i[1],S=i[2],w=i[3],E=0,P=0,C=-(T-w),A=y-S,B=0,D=0,$=Math.sqrt(C*C+A*A);C/=$,A/=$,C*=_,A*=_;const pe=l,M=(1-pe)*2,F=pe*2;u||(a.cap==="round"?g+=fi(y-C*(M-F)*.5,T-A*(M-F)*.5,y-C*M,T-A*M,y+C*F,T+A*F,f,!0)+2:a.cap==="square"&&(g+=Gg(y,T,C,A,M,F,!0,f))),f.push(y-C*M,T-A*M),f.push(y+C*F,T+A*F);for(let G=1;G<m-1;++G){y=i[(G-1)*2],T=i[(G-1)*2+1],S=i[G*2],w=i[G*2+1],E=i[(G+1)*2],P=i[(G+1)*2+1],C=-(T-w),A=y-S,$=Math.sqrt(C*C+A*A),C/=$,A/=$,C*=_,A*=_,B=-(w-P),D=S-E,$=Math.sqrt(B*B+D*D),B/=$,D/=$,B*=_,D*=_;const ie=S-y,we=T-w,ce=S-E,Ce=P-w,Oe=ie*ce+we*Ce,N=we*ce-Ce*ie,q=N<0;if(Math.abs(N)<.001*Math.abs(Oe)){f.push(S-C*M,w-A*M),f.push(S+C*F,w+A*F),Oe>=0&&(a.join==="round"?g+=fi(S,w,S-C*M,w-A*M,S-B*M,w-D*M,f,!1)+4:g+=2,f.push(S-B*F,w-D*F),f.push(S+B*M,w+D*M));continue}const me=(-C+y)*(-A+w)-(-C+S)*(-A+T),Ie=(-B+E)*(-D+w)-(-B+S)*(-D+P),Ji=(ie*Ie-ce*me)/N,ii=(Ce*me-we*Ie)/N,Pt=(Ji-S)*(Ji-S)+(ii-w)*(ii-w),Ke=S+(Ji-S)*M,vt=w+(ii-w)*M,vi=S-(Ji-S)*F,yi=w-(ii-w)*F,vM=Math.min(ie*ie+we*we,ce*ce+Ce*Ce),Hx=q?M:F,yM=vM+Hx*Hx*x;Pt<=yM?a.join==="bevel"||Pt/x>v?(q?(f.push(Ke,vt),f.push(S+C*F,w+A*F),f.push(Ke,vt),f.push(S+B*F,w+D*F)):(f.push(S-C*M,w-A*M),f.push(vi,yi),f.push(S-B*M,w-D*M),f.push(vi,yi)),g+=2):a.join==="round"?q?(f.push(Ke,vt),f.push(S+C*F,w+A*F),g+=fi(S,w,S+C*F,w+A*F,S+B*F,w+D*F,f,!0)+4,f.push(Ke,vt),f.push(S+B*F,w+D*F)):(f.push(S-C*M,w-A*M),f.push(vi,yi),g+=fi(S,w,S-C*M,w-A*M,S-B*M,w-D*M,f,!1)+4,f.push(S-B*M,w-D*M),f.push(vi,yi)):(f.push(Ke,vt),f.push(vi,yi)):(f.push(S-C*M,w-A*M),f.push(S+C*F,w+A*F),a.join==="round"?q?g+=fi(S,w,S+C*F,w+A*F,S+B*F,w+D*F,f,!0)+2:g+=fi(S,w,S-C*M,w-A*M,S-B*M,w-D*M,f,!1)+2:a.join==="miter"&&Pt/x<=v&&(q?(f.push(vi,yi),f.push(vi,yi)):(f.push(Ke,vt),f.push(Ke,vt)),g+=2),f.push(S-B*M,w-D*M),f.push(S+B*F,w+D*F),g+=2)}y=i[(m-2)*2],T=i[(m-2)*2+1],S=i[(m-1)*2],w=i[(m-1)*2+1],C=-(T-w),A=y-S,$=Math.sqrt(C*C+A*A),C/=$,A/=$,C*=_,A*=_,f.push(S-C*M,w-A*M),f.push(S+C*F,w+A*F),u||(a.cap==="round"?g+=fi(S-C*(M-F)*.5,w-A*(M-F)*.5,S-C*M,w-A*M,S+C*F,w+A*F,f,!1)+2:a.cap==="square"&&(g+=Gg(S,w,C,A,M,F,!1,f)));const ne=Dg*Dg;for(let G=p;G<g+p-2;++G)y=f[G*2],T=f[G*2+1],S=f[(G+1)*2],w=f[(G+1)*2+1],E=f[(G+2)*2],P=f[(G+2)*2+1],!(Math.abs(y*(w-P)+S*(P-T)+E*(T-w))<ne)&&n.push(G,G+1,G+2)}function bA(i,e,t,s){const r=Og;if(i.length===0)return;const n=i[0],o=i[1],a=i[i.length-2],l=i[i.length-1],c=e||Math.abs(n-a)<r&&Math.abs(o-l)<r,h=t,u=i.length/2,d=h.length/2;for(let f=0;f<u;f++)h.push(i[f*2]),h.push(i[f*2+1]);for(let f=0;f<u-1;f++)s.push(d+f,d+f+1);c&&s.push(d+u-1,d)}function zg(i,e,t,s,r,n,o){const a=wC(i,e,2);if(!a)return;for(let c=0;c<a.length;c+=3)n[o++]=a[c]+r,n[o++]=a[c+1]+r,n[o++]=a[c+2]+r;let l=r*s;for(let c=0;c<i.length;c+=2)t[l]=i[c],t[l+1]=i[c+1],l+=s}const TA=[],wA={extension:{type:b.ShapeBuilder,name:"polygon"},build(i,e){for(let t=0;t<i.points.length;t++)e[t]=i.points[t];return!0},triangulate(i,e,t,s,r,n){zg(i,TA,e,t,s,r,n)}},SA={extension:{type:b.ShapeBuilder,name:"rectangle"},build(i,e){const t=i,s=t.x,r=t.y,n=t.width,o=t.height;return n>0&&o>0?(e[0]=s,e[1]=r,e[2]=s+n,e[3]=r,e[4]=s+n,e[5]=r+o,e[6]=s,e[7]=r+o,!0):!1},triangulate(i,e,t,s,r,n){let o=0;s*=t,e[s+o]=i[0],e[s+o+1]=i[1],o+=t,e[s+o]=i[2],e[s+o+1]=i[3],o+=t,e[s+o]=i[6],e[s+o+1]=i[7],o+=t,e[s+o]=i[4],e[s+o+1]=i[5],o+=t;const a=s/t;r[n++]=a,r[n++]=a+1,r[n++]=a+2,r[n++]=a+1,r[n++]=a+3,r[n++]=a+2}},CA={extension:{type:b.ShapeBuilder,name:"triangle"},build(i,e){return e[0]=i.x,e[1]=i.y,e[2]=i.x2,e[3]=i.y2,e[4]=i.x3,e[5]=i.y3,!0},triangulate(i,e,t,s,r,n){let o=0;s*=t,e[s+o]=i[0],e[s+o+1]=i[1],o+=t,e[s+o]=i[2],e[s+o+1]=i[3],o+=t,e[s+o]=i[4],e[s+o+1]=i[5];const a=s/t;r[n++]=a,r[n++]=a+1,r[n++]=a+2}},AA=new O,EA=new W;function IA(i,e,t,s){const r=e.matrix?i.copyFrom(e.matrix).invert():i.identity();if(e.textureSpace==="local"){const o=t.getBounds(EA);e.width&&o.pad(e.width);const{x:a,y:l}=o,c=1/o.width,h=1/o.height,u=-a*c,d=-l*h,f=r.a,m=r.b,g=r.c,p=r.d;r.a*=c,r.b*=c,r.c*=h,r.d*=h,r.tx=u*f+d*g+r.tx,r.ty=u*m+d*p+r.ty}else r.translate(e.texture.frame.x,e.texture.frame.y),r.scale(1/e.texture.source.width,1/e.texture.source.height);const n=e.texture.source.style;return!(e.fill instanceof ct)&&n.addressMode==="clamp-to-edge"&&(n.addressMode="repeat",n.update()),s&&r.append(AA.copyFrom(s).invert()),r}const en={};V.handleByMap(b.ShapeBuilder,en),V.add(SA,wA,CA,Os,_A,xA);const PA=new W,RA=new O;function kA(i,e){const{geometryData:t,batches:s}=e;s.length=0,t.indices.length=0,t.vertices.length=0,t.uvs.length=0;for(let r=0;r<i.instructions.length;r++){const n=i.instructions[r];if(n.action==="texture")MA(n.data,s,t);else if(n.action==="fill"||n.action==="stroke"){const o=n.action==="stroke",a=n.data.path.shapePath,l=n.data.style,c=n.data.hole;o&&c&&Lg(c.shapePath,l,!0,s,t),c&&(a.shapePrimitives[a.shapePrimitives.length-1].holes=c.shapePath.shapePrimitives),Lg(a,l,o,s,t)}}}function MA(i,e,t){const s=[],r=en.rectangle,n=PA;n.x=i.dx,n.y=i.dy,n.width=i.dw,n.height=i.dh;const o=i.transform;if(!r.build(n,s))return;const{vertices:a,uvs:l,indices:c}=t,h=c.length,u=a.length/2;o&&Bg(s,o),r.triangulate(s,a,2,u,c,h);const d=i.image,f=d.uvs;l.push(f.x0,f.y0,f.x1,f.y1,f.x3,f.y3,f.x2,f.y2);const m=Se.get(nd);m.indexOffset=h,m.indexSize=c.length-h,m.attributeOffset=u,m.attributeSize=a.length/2-u,m.baseColor=i.style,m.alpha=i.alpha,m.texture=d,m.geometryData=t,e.push(m)}function Lg(i,e,t,s,r){const{vertices:n,uvs:o,indices:a}=r;i.shapePrimitives.forEach(({shape:l,transform:c,holes:h})=>{const u=[],d=en[l.type];if(!d.build(l,u))return;const f=a.length,m=n.length/2;let g="triangle-list";if(c&&Bg(u,c),t){const v=l.closePath??!0,y=e;y.pixelLine?(bA(u,v,n,a),g="line-list"):yA(u,y,!1,v,n,a)}else if(h){const v=[],y=u.slice();FA(h).forEach(S=>{v.push(y.length/2),y.push(...S)}),zg(y,v,n,2,m,a,f)}else d.triangulate(u,n,2,m,a,f);const p=o.length/2,_=e.texture;if(_!==k.WHITE){const v=IA(RA,e,l,c);pA(n,2,m,o,p,2,n.length/2-m,v)}else mA(o,p,2,n.length/2-m);const x=Se.get(nd);x.indexOffset=f,x.indexSize=a.length-f,x.attributeOffset=m,x.attributeSize=n.length/2-m,x.baseColor=e.color,x.alpha=e.alpha,x.texture=_,x.geometryData=r,x.topology=g,s.push(x)})}function FA(i){const e=[];for(let t=0;t<i.length;t++){const s=i[t].shape,r=[];en[s.type].build(s,r)&&e.push(r)}return e}class UA{constructor(){this.batches=[],this.geometryData={vertices:[],uvs:[],indices:[]}}reset(){this.batches&&this.batches.forEach(e=>{Se.return(e)}),this.graphicsData&&Se.return(this.graphicsData),this.isBatchable=!1,this.context=null,this.batches.length=0,this.geometryData.indices.length=0,this.geometryData.vertices.length=0,this.geometryData.uvs.length=0,this.graphicsData=null}destroy(){this.reset(),this.batches=null,this.geometryData=null}}class BA{constructor(){this.instructions=new dm}init(e){const t=e.maxTextures;this.batcher?this.batcher._updateMaxTextures(t):this.batcher=new rd({maxTextures:t}),this.instructions.reset()}get geometry(){return L($w,"GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."),this.batcher.geometry}destroy(){this.batcher.destroy(),this.instructions.destroy(),this.batcher=null,this.instructions=null}}const od=class uf{constructor(e){this._renderer=e,this._managedContexts=new st({renderer:e,type:"resource",name:"graphicsContext"})}init(e){uf.defaultOptions.bezierSmoothness=e?.bezierSmoothness??uf.defaultOptions.bezierSmoothness}getContextRenderData(e){return e._gpuData[this._renderer.uid].graphicsData||this._initContextRenderData(e)}updateGpuContext(e){const t=!!e._gpuData[this._renderer.uid],s=e._gpuData[this._renderer.uid]||this._initContext(e);if(e.dirty||!t){t&&s.reset(),kA(e,s);const r=e.batchMode;e.customShader||r==="no-batch"?s.isBatchable=!1:r==="auto"?s.isBatchable=s.geometryData.vertices.length<400:s.isBatchable=!0,e.dirty=!1}return s}getGpuContext(e){return e._gpuData[this._renderer.uid]||this._initContext(e)}_initContextRenderData(e){const t=Se.get(BA,{maxTextures:this._renderer.limits.maxBatchableTextures}),s=e._gpuData[this._renderer.uid],{batches:r,geometryData:n}=s;s.graphicsData=t;const o=n.vertices.length,a=n.indices.length;for(let u=0;u<r.length;u++)r[u].applyTransform=!1;const l=t.batcher;l.ensureAttributeBuffer(o),l.ensureIndexBuffer(a),l.begin();for(let u=0;u<r.length;u++){const d=r[u];l.add(d)}l.finish(t.instructions);const c=l.geometry;c.indexBuffer.setDataWithSize(l.indexBuffer,l.indexSize,!0),c.buffers[0].setDataWithSize(l.attributeBuffer.float32View,l.attributeSize,!0);const h=l.batches;for(let u=0;u<h.length;u++){const d=h[u];d.bindGroup=qu(d.textures.textures,d.textures.count,this._renderer.limits.maxBatchableTextures)}return t}_initContext(e){const t=new UA;return t.context=e,e._gpuData[this._renderer.uid]=t,this._managedContexts.add(e),t}destroy(){this._managedContexts.destroy(),this._renderer=null}};od.extension={type:[b.WebGLSystem,b.WebGPUSystem,b.CanvasSystem],name:"graphicsContext"},od.defaultOptions={bezierSmoothness:.5};let ad=od;const OA=8,tn=11920929e-14,DA=1;function Ng(i,e,t,s,r,n,o,a,l,c){const u=Math.min(.99,Math.max(0,c??ad.defaultOptions.bezierSmoothness));let d=(DA-u)/1;return d*=d,GA(e,t,s,r,n,o,a,l,i,d),i}function GA(i,e,t,s,r,n,o,a,l,c){ld(i,e,t,s,r,n,o,a,l,c,0),l.push(o,a)}function ld(i,e,t,s,r,n,o,a,l,c,h){if(h>OA)return;const u=(i+t)/2,d=(e+s)/2,f=(t+r)/2,m=(s+n)/2,g=(r+o)/2,p=(n+a)/2,_=(u+f)/2,x=(d+m)/2,v=(f+g)/2,y=(m+p)/2,T=(_+v)/2,S=(x+y)/2;if(h>0){let w=o-i,E=a-e;const P=Math.abs((t-o)*E-(s-a)*w),C=Math.abs((r-o)*E-(n-a)*w);if(P>tn&&C>tn){if((P+C)*(P+C)<=c*(w*w+E*E)){l.push(T,S);return}}else if(P>tn){if(P*P<=c*(w*w+E*E)){l.push(T,S);return}}else if(C>tn){if(C*C<=c*(w*w+E*E)){l.push(T,S);return}}else if(w=T-(i+o)/2,E=S-(e+a)/2,w*w+E*E<=c){l.push(T,S);return}}ld(i,e,u,d,_,x,T,S,l,c,h+1),ld(T,S,v,y,g,p,o,a,l,c,h+1)}const zA=8,LA=11920929e-14,NA=1;function HA(i,e,t,s,r,n,o,a){const c=Math.min(.99,Math.max(0,a??ad.defaultOptions.bezierSmoothness));let h=(NA-c)/1;return h*=h,WA(e,t,s,r,n,o,i,h),i}function WA(i,e,t,s,r,n,o,a){cd(o,i,e,t,s,r,n,a,0),o.push(r,n)}function cd(i,e,t,s,r,n,o,a,l){if(l>zA)return;const c=(e+s)/2,h=(t+r)/2,u=(s+n)/2,d=(r+o)/2,f=(c+u)/2,m=(h+d)/2;let g=n-e,p=o-t;const _=Math.abs((s-n)*p-(r-o)*g);if(_>LA){if(_*_<=a*(g*g+p*p)){i.push(f,m);return}}else if(g=f-(e+n)/2,p=m-(t+o)/2,g*g+p*p<=a){i.push(f,m);return}cd(i,e,t,c,h,f,m,a,l+1),cd(i,f,m,u,d,n,o,a,l+1)}function Hg(i,e,t,s,r,n,o,a){let l=Math.abs(r-n);(!o&&r>n||o&&n>r)&&(l=2*Math.PI-l),a||(a=Math.max(6,Math.floor(6*Math.pow(s,1/3)*(l/Math.PI)))),a=Math.max(a,3);let c=l/a,h=r;c*=o?-1:1;for(let u=0;u<a+1;u++){const d=Math.cos(h),f=Math.sin(h),m=e+d*s,g=t+f*s;i.push(m,g),h+=c}}function VA(i,e,t,s,r,n){const o=i[i.length-2],l=i[i.length-1]-t,c=o-e,h=r-t,u=s-e,d=Math.abs(l*u-c*h);if(d<1e-8||n===0){(i[i.length-2]!==e||i[i.length-1]!==t)&&i.push(e,t);return}const f=l*l+c*c,m=h*h+u*u,g=l*h+c*u,p=n*Math.sqrt(f)/d,_=n*Math.sqrt(m)/d,x=p*g/f,v=_*g/m,y=p*u+_*c,T=p*h+_*l,S=c*(_+x),w=l*(_+x),E=u*(p+v),P=h*(p+v),C=Math.atan2(w-T,S-y),A=Math.atan2(P-T,E-y);Hg(i,y+e,T+t,n,C,A,c*h>u*l)}const Ds=Math.PI*2,hd={centerX:0,centerY:0,ang1:0,ang2:0},ud=({x:i,y:e},t,s,r,n,o,a,l)=>{i*=t,e*=s;const c=r*i-n*e,h=n*i+r*e;return l.x=c+o,l.y=h+a,l};function $A(i,e){const t=e===-1.5707963267948966?-.551915024494:1.3333333333333333*Math.tan(e/4),s=e===1.5707963267948966?.551915024494:t,r=Math.cos(i),n=Math.sin(i),o=Math.cos(i+e),a=Math.sin(i+e);return[{x:r-n*s,y:n+r*s},{x:o+a*s,y:a-o*s},{x:o,y:a}]}const Wg=(i,e,t,s)=>{const r=i*s-e*t<0?-1:1;let n=i*t+e*s;return n>1&&(n=1),n<-1&&(n=-1),r*Math.acos(n)},XA=(i,e,t,s,r,n,o,a,l,c,h,u,d)=>{const f=Math.pow(r,2),m=Math.pow(n,2),g=Math.pow(h,2),p=Math.pow(u,2);let _=f*m-f*p-m*g;_<0&&(_=0),_/=f*p+m*g,_=Math.sqrt(_)*(o===a?-1:1);const x=_*r/n*u,v=_*-n/r*h,y=c*x-l*v+(i+t)/2,T=l*x+c*v+(e+s)/2,S=(h-x)/r,w=(u-v)/n,E=(-h-x)/r,P=(-u-v)/n,C=Wg(1,0,S,w);let A=Wg(S,w,E,P);a===0&&A>0&&(A-=Ds),a===1&&A<0&&(A+=Ds),d.centerX=y,d.centerY=T,d.ang1=C,d.ang2=A};function YA(i,e,t,s,r,n,o,a=0,l=0,c=0){if(n===0||o===0)return;const h=Math.sin(a*Ds/360),u=Math.cos(a*Ds/360),d=u*(e-s)/2+h*(t-r)/2,f=-h*(e-s)/2+u*(t-r)/2;if(d===0&&f===0)return;n=Math.abs(n),o=Math.abs(o);const m=Math.pow(d,2)/Math.pow(n,2)+Math.pow(f,2)/Math.pow(o,2);m>1&&(n*=Math.sqrt(m),o*=Math.sqrt(m)),XA(e,t,s,r,n,o,l,c,h,u,d,f,hd);let{ang1:g,ang2:p}=hd;const{centerX:_,centerY:x}=hd;let v=Math.abs(p)/(Ds/4);Math.abs(1-v)<1e-7&&(v=1);const y=Math.max(Math.ceil(v),1);p/=y;let T=i[i.length-2],S=i[i.length-1];const w={x:0,y:0};for(let E=0;E<y;E++){const P=$A(g,p),{x:C,y:A}=ud(P[0],n,o,u,h,_,x,w),{x:B,y:D}=ud(P[1],n,o,u,h,_,x,w),{x:$,y:pe}=ud(P[2],n,o,u,h,_,x,w);Ng(i,T,S,C,A,B,D,$,pe),T=$,S=pe,g+=p}}function qA(i,e,t){const s=(o,a)=>{const l=a.x-o.x,c=a.y-o.y,h=Math.sqrt(l*l+c*c),u=l/h,d=c/h;return{len:h,nx:u,ny:d}},r=(o,a)=>{o===0?i.moveTo(a.x,a.y):i.lineTo(a.x,a.y)};let n=e[e.length-1];for(let o=0;o<e.length;o++){const a=e[o%e.length],l=a.radius??t;if(l<=0){r(o,a),n=a;continue}const c=e[(o+1)%e.length],h=s(a,n),u=s(a,c);if(h.len<1e-4||u.len<1e-4){r(o,a),n=a;continue}let d=Math.asin(h.nx*u.ny-h.ny*u.nx),f=1,m=!1;h.nx*u.nx-h.ny*-u.ny<0?d<0?d=Math.PI+d:(d=Math.PI-d,f=-1,m=!0):d>0&&(f=-1,m=!0);const g=d/2;let p,_=Math.abs(Math.cos(g)*l/Math.sin(g));_>Math.min(h.len/2,u.len/2)?(_=Math.min(h.len/2,u.len/2),p=Math.abs(_*Math.sin(g)/Math.cos(g))):p=l;const x=a.x+u.nx*_+-u.ny*p*f,v=a.y+u.ny*_+u.nx*p*f,y=Math.atan2(h.ny,h.nx)+Math.PI/2*f,T=Math.atan2(u.ny,u.nx)-Math.PI/2*f;o===0&&i.moveTo(x+Math.cos(y)*p,v+Math.sin(y)*p),i.arc(x,v,p,y,T,m),n=a}}function KA(i,e,t,s){const r=(a,l)=>Math.sqrt((a.x-l.x)**2+(a.y-l.y)**2),n=(a,l,c)=>({x:a.x+(l.x-a.x)*c,y:a.y+(l.y-a.y)*c}),o=e.length;for(let a=0;a<o;a++){const l=e[(a+1)%o],c=l.radius??t;if(c<=0){a===0?i.moveTo(l.x,l.y):i.lineTo(l.x,l.y);continue}const h=e[a],u=e[(a+2)%o],d=r(h,l);let f;if(d<1e-4)f=l;else{const p=Math.min(d/2,c);f=n(l,h,p/d)}const m=r(u,l);let g;if(m<1e-4)g=l;else{const p=Math.min(m/2,c);g=n(l,u,p/m)}a===0?i.moveTo(f.x,f.y):i.lineTo(f.x,f.y),i.quadraticCurveTo(l.x,l.y,g.x,g.y,s)}}const jA=new W;class ZA{constructor(e){this.shapePrimitives=[],this._currentPoly=null,this._bounds=new De,this._graphicsPath2D=e,this.signed=e.checkForHoles}moveTo(e,t){return this.startPoly(e,t),this}lineTo(e,t){this._ensurePoly();const s=this._currentPoly.points,r=s[s.length-2],n=s[s.length-1];return(r!==e||n!==t)&&s.push(e,t),this}arc(e,t,s,r,n,o){this._ensurePoly(!1);const a=this._currentPoly.points;return Hg(a,e,t,s,r,n,o),this}arcTo(e,t,s,r,n){this._ensurePoly();const o=this._currentPoly.points;return VA(o,e,t,s,r,n),this}arcToSvg(e,t,s,r,n,o,a){const l=this._currentPoly.points;return YA(l,this._currentPoly.lastX,this._currentPoly.lastY,o,a,e,t,s,r,n),this}bezierCurveTo(e,t,s,r,n,o,a){this._ensurePoly();const l=this._currentPoly;return Ng(this._currentPoly.points,l.lastX,l.lastY,e,t,s,r,n,o,a),this}quadraticCurveTo(e,t,s,r,n){this._ensurePoly();const o=this._currentPoly;return HA(this._currentPoly.points,o.lastX,o.lastY,e,t,s,r,n),this}closePath(){return this.endPoly(!0),this}addPath(e,t){this.endPoly(),t&&!t.isIdentity()&&(e=e.clone(!0),e.transform(t));const s=this.shapePrimitives,r=s.length;for(let n=0;n<e.instructions.length;n++){const o=e.instructions[n];this[o.action](...o.data)}if(e.checkForHoles&&s.length-r>1){let n=null;for(let o=r;o<s.length;o++){const a=s[o];if(a.shape.type==="polygon"){const l=a.shape,c=n?.shape;c&&c.containsPolygon(l)?(n.holes||(n.holes=[]),n.holes.push(a),s.copyWithin(o,o+1),s.length--,o--):n=a}}}return this}finish(e=!1){this.endPoly(e)}rect(e,t,s,r,n){return this.drawShape(new W(e,t,s,r),n),this}circle(e,t,s,r){return this.drawShape(new Zr(e,t,s),r),this}poly(e,t,s){const r=new As(e);return r.closePath=t,this.drawShape(r,s),this}regularPoly(e,t,s,r,n=0,o){r=Math.max(r|0,3);const a=-1*Math.PI/2+n,l=Math.PI*2/r,c=[];for(let h=0;h<r;h++){const u=a-h*l;c.push(e+s*Math.cos(u),t+s*Math.sin(u))}return this.poly(c,!0,o),this}roundPoly(e,t,s,r,n,o=0,a){if(r=Math.max(r|0,3),n<=0)return this.regularPoly(e,t,s,r,o);const l=s*Math.sin(Math.PI/r)-.001;n=Math.min(n,l);const c=-1*Math.PI/2+o,h=Math.PI*2/r,u=(r-2)*Math.PI/r/2;for(let d=0;d<r;d++){const f=d*h+c,m=e+s*Math.cos(f),g=t+s*Math.sin(f),p=f+Math.PI+u,_=f-Math.PI-u,x=m+n*Math.cos(p),v=g+n*Math.sin(p),y=m+n*Math.cos(_),T=g+n*Math.sin(_);d===0?this.moveTo(x,v):this.lineTo(x,v),this.quadraticCurveTo(m,g,y,T,a)}return this.closePath()}roundShape(e,t,s=!1,r){return e.length<3?this:(s?KA(this,e,t,r):qA(this,e,t),this.closePath())}filletRect(e,t,s,r,n){if(n===0)return this.rect(e,t,s,r);const o=Math.min(s,r)/2,a=Math.min(o,Math.max(-o,n)),l=e+s,c=t+r,h=a<0?-a:0,u=Math.abs(a);return this.moveTo(e,t+u).arcTo(e+h,t+h,e+u,t,u).lineTo(l-u,t).arcTo(l-h,t+h,l,t+u,u).lineTo(l,c-u).arcTo(l-h,c-h,e+s-u,c,u).lineTo(e+u,c).arcTo(e+h,c-h,e,c-u,u).closePath()}chamferRect(e,t,s,r,n,o){if(n<=0)return this.rect(e,t,s,r);const a=Math.min(n,Math.min(s,r)/2),l=e+s,c=t+r,h=[e+a,t,l-a,t,l,t+a,l,c-a,l-a,c,e+a,c,e,c-a,e,t+a];for(let u=h.length-1;u>=2;u-=2)h[u]===h[u-2]&&h[u-1]===h[u-3]&&h.splice(u-1,2);return this.poly(h,!0,o)}ellipse(e,t,s,r,n){return this.drawShape(new Xu(e,t,s,r),n),this}roundRect(e,t,s,r,n,o){return this.drawShape(new Yu(e,t,s,r,n),o),this}drawShape(e,t){return this.endPoly(),this.shapePrimitives.push({shape:e,transform:t}),this}startPoly(e,t){let s=this._currentPoly;return s&&this.endPoly(),s=new As,s.points.push(e,t),this._currentPoly=s,this}endPoly(e=!1){const t=this._currentPoly;return t&&t.points.length>2&&(t.closePath=e,this.shapePrimitives.push({shape:t})),this._currentPoly=null,this}_ensurePoly(e=!0){if(!this._currentPoly&&(this._currentPoly=new As,e)){const t=this.shapePrimitives[this.shapePrimitives.length-1];if(t){let s=t.shape.x,r=t.shape.y;if(t.transform&&!t.transform.isIdentity()){const n=t.transform,o=s;s=n.a*s+n.c*r+n.tx,r=n.b*o+n.d*r+n.ty}this._currentPoly.points.push(s,r)}else this._currentPoly.points.push(0,0)}}buildPath(){const e=this._graphicsPath2D;this.shapePrimitives.length=0,this._currentPoly=null;for(let t=0;t<e.instructions.length;t++){const s=e.instructions[t];this[s.action](...s.data)}this.finish()}get bounds(){const e=this._bounds;e.clear();const t=this.shapePrimitives;for(let s=0;s<t.length;s++){const r=t[s],n=r.shape.getBounds(jA);r.transform?e.addRect(n,r.transform):e.addRect(n)}return e}}class zt{constructor(e,t=!1){this.instructions=[],this.uid=le("graphicsPath"),this._dirty=!0,this.checkForHoles=t,typeof e=="string"?UC(e,this):this.instructions=e?.slice()??[]}get shapePath(){return this._shapePath||(this._shapePath=new ZA(this)),this._dirty&&(this._dirty=!1,this._shapePath.buildPath()),this._shapePath}addPath(e,t){return e=e.clone(),this.instructions.push({action:"addPath",data:[e,t]}),this._dirty=!0,this}arc(...e){return this.instructions.push({action:"arc",data:e}),this._dirty=!0,this}arcTo(...e){return this.instructions.push({action:"arcTo",data:e}),this._dirty=!0,this}arcToSvg(...e){return this.instructions.push({action:"arcToSvg",data:e}),this._dirty=!0,this}bezierCurveTo(...e){return this.instructions.push({action:"bezierCurveTo",data:e}),this._dirty=!0,this}bezierCurveToShort(e,t,s,r,n){const o=this.instructions[this.instructions.length-1],a=this.getLastPoint(X.shared);let l=0,c=0;if(!o||o.action!=="bezierCurveTo")l=a.x,c=a.y;else{l=o.data[2],c=o.data[3];const h=a.x,u=a.y;l=h+(h-l),c=u+(u-c)}return this.instructions.push({action:"bezierCurveTo",data:[l,c,e,t,s,r,n]}),this._dirty=!0,this}closePath(){return this.instructions.push({action:"closePath",data:[]}),this._dirty=!0,this}ellipse(...e){return this.instructions.push({action:"ellipse",data:e}),this._dirty=!0,this}lineTo(...e){return this.instructions.push({action:"lineTo",data:e}),this._dirty=!0,this}moveTo(...e){return this.instructions.push({action:"moveTo",data:e}),this}quadraticCurveTo(...e){return this.instructions.push({action:"quadraticCurveTo",data:e}),this._dirty=!0,this}quadraticCurveToShort(e,t,s){const r=this.instructions[this.instructions.length-1],n=this.getLastPoint(X.shared);let o=0,a=0;if(!r||r.action!=="quadraticCurveTo")o=n.x,a=n.y;else{o=r.data[0],a=r.data[1];const l=n.x,c=n.y;o=l+(l-o),a=c+(c-a)}return this.instructions.push({action:"quadraticCurveTo",data:[o,a,e,t,s]}),this._dirty=!0,this}rect(e,t,s,r,n){return this.instructions.push({action:"rect",data:[e,t,s,r,n]}),this._dirty=!0,this}circle(e,t,s,r){return this.instructions.push({action:"circle",data:[e,t,s,r]}),this._dirty=!0,this}roundRect(...e){return this.instructions.push({action:"roundRect",data:e}),this._dirty=!0,this}poly(...e){return this.instructions.push({action:"poly",data:e}),this._dirty=!0,this}regularPoly(...e){return this.instructions.push({action:"regularPoly",data:e}),this._dirty=!0,this}roundPoly(...e){return this.instructions.push({action:"roundPoly",data:e}),this._dirty=!0,this}roundShape(...e){return this.instructions.push({action:"roundShape",data:e}),this._dirty=!0,this}filletRect(...e){return this.instructions.push({action:"filletRect",data:e}),this._dirty=!0,this}chamferRect(...e){return this.instructions.push({action:"chamferRect",data:e}),this._dirty=!0,this}star(e,t,s,r,n,o,a){n||(n=r/2);const l=-1*Math.PI/2+o,c=s*2,h=Math.PI*2/c,u=[];for(let d=0;d<c;d++){const f=d%2?n:r,m=d*h+l;u.push(e+f*Math.cos(m),t+f*Math.sin(m))}return this.poly(u,!0,a),this}clone(e=!1){const t=new zt;if(t.checkForHoles=this.checkForHoles,!e)t.instructions=this.instructions.slice();else for(let s=0;s<this.instructions.length;s++){const r=this.instructions[s];t.instructions.push({action:r.action,data:r.data.slice()})}return t}clear(){return this.instructions.length=0,this._dirty=!0,this}transform(e){if(e.isIdentity())return this;const t=e.a,s=e.b,r=e.c,n=e.d,o=e.tx,a=e.ty;let l=0,c=0,h=0,u=0,d=0,f=0,m=0,g=0;for(let p=0;p<this.instructions.length;p++){const _=this.instructions[p],x=_.data;switch(_.action){case"moveTo":case"lineTo":l=x[0],c=x[1],x[0]=t*l+r*c+o,x[1]=s*l+n*c+a;break;case"bezierCurveTo":h=x[0],u=x[1],d=x[2],f=x[3],l=x[4],c=x[5],x[0]=t*h+r*u+o,x[1]=s*h+n*u+a,x[2]=t*d+r*f+o,x[3]=s*d+n*f+a,x[4]=t*l+r*c+o,x[5]=s*l+n*c+a;break;case"quadraticCurveTo":h=x[0],u=x[1],l=x[2],c=x[3],x[0]=t*h+r*u+o,x[1]=s*h+n*u+a,x[2]=t*l+r*c+o,x[3]=s*l+n*c+a;break;case"arcToSvg":l=x[5],c=x[6],m=x[0],g=x[1],x[0]=t*m+r*g,x[1]=s*m+n*g,x[5]=t*l+r*c+o,x[6]=s*l+n*c+a;break;case"circle":x[4]=Gs(x[3],e);break;case"rect":x[4]=Gs(x[4],e);break;case"ellipse":x[8]=Gs(x[8],e);break;case"roundRect":x[5]=Gs(x[5],e);break;case"addPath":x[0].transform(e);break;case"poly":x[2]=Gs(x[2],e);break;default:H("unknown transform action",_.action);break}}return this._dirty=!0,this}get bounds(){return this.shapePath.bounds}getLastPoint(e){let t=this.instructions.length-1,s=this.instructions[t];if(!s)return e.x=0,e.y=0,e;for(;s.action==="closePath";){if(t--,t<0)return e.x=0,e.y=0,e;s=this.instructions[t]}switch(s.action){case"moveTo":case"lineTo":e.x=s.data[0],e.y=s.data[1];break;case"quadraticCurveTo":e.x=s.data[2],e.y=s.data[3];break;case"bezierCurveTo":e.x=s.data[4],e.y=s.data[5];break;case"arc":case"arcToSvg":e.x=s.data[5],e.y=s.data[6];break;case"addPath":s.data[0].getLastPoint(e);break}return e}}function Gs(i,e){return i?i.prepend(e):e.clone()}function xe(i,e,t){const s=i.getAttribute(e);return s?Number(s):t}function JA(i,e){const t=i.querySelectorAll("defs");for(let s=0;s<t.length;s++){const r=t[s];for(let n=0;n<r.children.length;n++){const o=r.children[n];switch(o.nodeName.toLowerCase()){case"lineargradient":e.defs[o.id]=QA(o);break;case"radialgradient":e.defs[o.id]=eE();break}}}}function QA(i){const e=xe(i,"x1",0),t=xe(i,"y1",0),s=xe(i,"x2",1),r=xe(i,"y2",0),n=i.getAttribute("gradientUnits")||"objectBoundingBox",o=new ct(e,t,s,r,n==="objectBoundingBox"?"local":"global");for(let a=0;a<i.children.length;a++){const l=i.children[a],c=xe(l,"offset",0),h=ue.shared.setValue(l.getAttribute("stop-color")).toNumber();o.addColorStop(c,h)}return o}function eE(i){return H("[SVG Parser] Radial gradients are not yet supported"),new ct(0,0,1,0)}function Vg(i){const e=i.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);return e?e[1]:""}const $g={fill:{type:"paint",default:0},"fill-opacity":{type:"number",default:1},stroke:{type:"paint",default:0},"stroke-width":{type:"number",default:1},"stroke-opacity":{type:"number",default:1},"stroke-linecap":{type:"string",default:"butt"},"stroke-linejoin":{type:"string",default:"miter"},"stroke-miterlimit":{type:"number",default:10},"stroke-dasharray":{type:"string",default:"none"},"stroke-dashoffset":{type:"number",default:0},opacity:{type:"number",default:1}};function Xg(i,e){const t=i.getAttribute("style"),s={},r={},n={strokeStyle:s,fillStyle:r,useFill:!1,useStroke:!1};for(const o in $g){const a=i.getAttribute(o);a&&Yg(e,n,o,a.trim())}if(t){const o=t.split(";");for(let a=0;a<o.length;a++){const l=o[a].trim(),[c,h]=l.split(":");$g[c]&&Yg(e,n,c,h.trim())}}return{strokeStyle:n.useStroke?s:null,fillStyle:n.useFill?r:null,useFill:n.useFill,useStroke:n.useStroke}}function Yg(i,e,t,s){switch(t){case"stroke":if(s!=="none"){if(s.startsWith("url(")){const r=Vg(s);e.strokeStyle.fill=i.defs[r]}else e.strokeStyle.color=ue.shared.setValue(s).toNumber();e.useStroke=!0}break;case"stroke-width":e.strokeStyle.width=Number(s);break;case"fill":if(s!=="none"){if(s.startsWith("url(")){const r=Vg(s);e.fillStyle.fill=i.defs[r]}else e.fillStyle.color=ue.shared.setValue(s).toNumber();e.useFill=!0}break;case"fill-opacity":e.fillStyle.alpha=Number(s);break;case"stroke-opacity":e.strokeStyle.alpha=Number(s);break;case"opacity":e.fillStyle.alpha=Number(s),e.strokeStyle.alpha=Number(s);break}}function tE(i){if(i.length<=2)return!0;const e=i.map(a=>a.area).sort((a,l)=>l-a),[t,s]=e,r=e[e.length-1],n=t/s,o=s/r;return!(n>3&&o<2)}function iE(i){return i.split(/(?=[Mm])/).filter(s=>s.trim().length>0)}function sE(i){const e=i.match(/[-+]?[0-9]*\.?[0-9]+/g);if(!e||e.length<4)return 0;const t=e.map(Number),s=[],r=[];for(let h=0;h<t.length;h+=2)h+1<t.length&&(s.push(t[h]),r.push(t[h+1]));if(s.length===0||r.length===0)return 0;const n=Math.min(...s),o=Math.max(...s),a=Math.min(...r),l=Math.max(...r);return(o-n)*(l-a)}function qg(i,e){const t=new zt(i,!1);for(const s of t.instructions)e.instructions.push(s)}function rE(i,e){if(typeof i=="string"){const o=document.createElement("div");o.innerHTML=i.trim(),i=o.querySelector("svg")}const t={context:e,defs:{},path:new zt};JA(i,t);const s=i.children,{fillStyle:r,strokeStyle:n}=Xg(i,t);for(let o=0;o<s.length;o++){const a=s[o];a.nodeName.toLowerCase()!=="defs"&&Kg(a,t,r,n)}return e}function Kg(i,e,t,s){const r=i.children,{fillStyle:n,strokeStyle:o}=Xg(i,e);n&&t?t={...t,...n}:n&&(t=n),o&&s?s={...s,...o}:o&&(s=o);const a=!t&&!s;a&&(t={color:0});let l,c,h,u,d,f,m,g,p,_,x,v,y,T,S,w,E;switch(i.nodeName.toLowerCase()){case"path":{T=i.getAttribute("d");const P=i.getAttribute("fill-rule"),C=iE(T),A=P==="evenodd",B=C.length>1;if(A&&B){const $=C.map(M=>({path:M,area:sE(M)}));if($.sort((M,F)=>F.area-M.area),C.length>3||!tE($))for(let M=0;M<$.length;M++){const F=$[M],ne=M===0;e.context.beginPath();const G=new zt(void 0,!0);qg(F.path,G),e.context.path(G),ne?(t&&e.context.fill(t),s&&e.context.stroke(s)):e.context.cut()}else for(let M=0;M<$.length;M++){const F=$[M],ne=M%2===1;e.context.beginPath();const G=new zt(void 0,!0);qg(F.path,G),e.context.path(G),ne?e.context.cut():(t&&e.context.fill(t),s&&e.context.stroke(s))}}else{const $=P?P==="evenodd":!0;S=new zt(T,$),e.context.path(S),t&&e.context.fill(t),s&&e.context.stroke(s)}break}case"circle":m=xe(i,"cx",0),g=xe(i,"cy",0),p=xe(i,"r",0),e.context.ellipse(m,g,p,p),t&&e.context.fill(t),s&&e.context.stroke(s);break;case"rect":l=xe(i,"x",0),c=xe(i,"y",0),w=xe(i,"width",0),E=xe(i,"height",0),_=xe(i,"rx",0),x=xe(i,"ry",0),_||x?e.context.roundRect(l,c,w,E,_||x):e.context.rect(l,c,w,E),t&&e.context.fill(t),s&&e.context.stroke(s);break;case"ellipse":m=xe(i,"cx",0),g=xe(i,"cy",0),_=xe(i,"rx",0),x=xe(i,"ry",0),e.context.beginPath(),e.context.ellipse(m,g,_,x),t&&e.context.fill(t),s&&e.context.stroke(s);break;case"line":h=xe(i,"x1",0),u=xe(i,"y1",0),d=xe(i,"x2",0),f=xe(i,"y2",0),e.context.beginPath(),e.context.moveTo(h,u),e.context.lineTo(d,f),s&&e.context.stroke(s);break;case"polygon":y=i.getAttribute("points"),v=y.match(/-?\d+/g).map(P=>parseInt(P,10)),e.context.poly(v,!0),t&&e.context.fill(t),s&&e.context.stroke(s);break;case"polyline":y=i.getAttribute("points"),v=y.match(/-?\d+/g).map(P=>parseInt(P,10)),e.context.poly(v,!1),s&&e.context.stroke(s);break;case"g":case"svg":break;default:{H(`[SVG parser] <${i.nodeName}> elements unsupported`);break}}a&&(t=null);for(let P=0;P<r.length;P++)Kg(r[P],e,t,s)}function nE(i){return ue.isColorLike(i)}function jg(i){return i instanceof jr}function Zg(i){return i instanceof ct}function oE(i){return i instanceof k}function aE(i,e,t){const s=ue.shared.setValue(e??0);return i.color=s.toNumber(),i.alpha=s.alpha===1?t.alpha:s.alpha,i.texture=k.WHITE,{...t,...i}}function lE(i,e,t){return i.texture=e,{...t,...i}}function Jg(i,e,t){return i.fill=e,i.color=16777215,i.texture=e.texture,i.matrix=e.transform,{...t,...i}}function Qg(i,e,t){return e.buildGradient(),i.fill=e,i.color=16777215,i.texture=e.texture,i.matrix=e.transform,i.textureSpace=e.textureSpace,{...t,...i}}function cE(i,e){const t={...e,...i},s=ue.shared.setValue(t.color);return t.alpha*=s.alpha,t.color=s.toNumber(),t}function pi(i,e){if(i==null)return null;const t={},s=i;return nE(i)?aE(t,i,e):oE(i)?lE(t,i,e):jg(i)?Jg(t,i,e):Zg(i)?Qg(t,i,e):s.fill&&jg(s.fill)?Jg(s,s.fill,e):s.fill&&Zg(s.fill)?Qg(s,s.fill,e):cE(s,e)}function sn(i,e){const{width:t,alignment:s,miterLimit:r,cap:n,join:o,pixelLine:a,...l}=e,c=pi(i,l);return c?{width:t,alignment:s,miterLimit:r,cap:n,join:o,pixelLine:a,...c}:null}const hE=new X,e0=new O,dd=class Rt extends Ze{constructor(){super(...arguments),this._gpuData=Object.create(null),this.autoGarbageCollect=!0,this._gcLastUsed=-1,this.uid=le("graphicsContext"),this.dirty=!0,this.batchMode="auto",this.instructions=[],this.destroyed=!1,this._activePath=new zt,this._transform=new O,this._fillStyle={...Rt.defaultFillStyle},this._strokeStyle={...Rt.defaultStrokeStyle},this._stateStack=[],this._tick=0,this._bounds=new De,this._boundsDirty=!0}clone(){const e=new Rt;return e.batchMode=this.batchMode,e.instructions=this.instructions.slice(),e._activePath=this._activePath.clone(),e._transform=this._transform.clone(),e._fillStyle={...this._fillStyle},e._strokeStyle={...this._strokeStyle},e._stateStack=this._stateStack.slice(),e._bounds=this._bounds.clone(),e._boundsDirty=!0,e}get fillStyle(){return this._fillStyle}set fillStyle(e){this._fillStyle=pi(e,Rt.defaultFillStyle)}get strokeStyle(){return this._strokeStyle}set strokeStyle(e){this._strokeStyle=sn(e,Rt.defaultStrokeStyle)}setFillStyle(e){return this._fillStyle=pi(e,Rt.defaultFillStyle),this}setStrokeStyle(e){return this._strokeStyle=pi(e,Rt.defaultStrokeStyle),this}texture(e,t,s,r,n,o){return this.instructions.push({action:"texture",data:{image:e,dx:s||0,dy:r||0,dw:n||e.frame.width,dh:o||e.frame.height,transform:this._transform.clone(),alpha:this._fillStyle.alpha,style:t?ue.shared.setValue(t).toNumber():16777215}}),this.onUpdate(),this}beginPath(){return this._activePath=new zt,this}fill(e,t){let s;const r=this.instructions[this.instructions.length-1];return this._tick===0&&r?.action==="stroke"?s=r.data.path:s=this._activePath.clone(),s?(e!=null&&(t!==void 0&&typeof e=="number"&&(L(J,"GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"),e={color:e,alpha:t}),this._fillStyle=pi(e,Rt.defaultFillStyle)),this.instructions.push({action:"fill",data:{style:this.fillStyle,path:s}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}_initNextPathLocation(){const{x:e,y:t}=this._activePath.getLastPoint(X.shared);this._activePath.clear(),this._activePath.moveTo(e,t)}stroke(e){let t;const s=this.instructions[this.instructions.length-1];return this._tick===0&&s?.action==="fill"?t=s.data.path:t=this._activePath.clone(),t?(e!=null&&(this._strokeStyle=sn(e,Rt.defaultStrokeStyle)),this.instructions.push({action:"stroke",data:{style:this.strokeStyle,path:t}}),this.onUpdate(),this._initNextPathLocation(),this._tick=0,this):this}cut(){for(let e=0;e<2;e++){const t=this.instructions[this.instructions.length-1-e],s=this._activePath.clone();if(t&&(t.action==="stroke"||t.action==="fill"))if(t.data.hole)t.data.hole.addPath(s);else{t.data.hole=s;break}}return this._initNextPathLocation(),this}arc(e,t,s,r,n,o){this._tick++;const a=this._transform;return this._activePath.arc(a.a*e+a.c*t+a.tx,a.b*e+a.d*t+a.ty,s,r,n,o),this}arcTo(e,t,s,r,n){this._tick++;const o=this._transform;return this._activePath.arcTo(o.a*e+o.c*t+o.tx,o.b*e+o.d*t+o.ty,o.a*s+o.c*r+o.tx,o.b*s+o.d*r+o.ty,n),this}arcToSvg(e,t,s,r,n,o,a){this._tick++;const l=this._transform;return this._activePath.arcToSvg(e,t,s,r,n,l.a*o+l.c*a+l.tx,l.b*o+l.d*a+l.ty),this}bezierCurveTo(e,t,s,r,n,o,a){this._tick++;const l=this._transform;return this._activePath.bezierCurveTo(l.a*e+l.c*t+l.tx,l.b*e+l.d*t+l.ty,l.a*s+l.c*r+l.tx,l.b*s+l.d*r+l.ty,l.a*n+l.c*o+l.tx,l.b*n+l.d*o+l.ty,a),this}closePath(){return this._tick++,this._activePath?.closePath(),this}ellipse(e,t,s,r){return this._tick++,this._activePath.ellipse(e,t,s,r,this._transform.clone()),this}circle(e,t,s){return this._tick++,this._activePath.circle(e,t,s,this._transform.clone()),this}path(e){return this._tick++,this._activePath.addPath(e,this._transform.clone()),this}lineTo(e,t){this._tick++;const s=this._transform;return this._activePath.lineTo(s.a*e+s.c*t+s.tx,s.b*e+s.d*t+s.ty),this}moveTo(e,t){this._tick++;const s=this._transform,r=this._activePath.instructions,n=s.a*e+s.c*t+s.tx,o=s.b*e+s.d*t+s.ty;return r.length===1&&r[0].action==="moveTo"?(r[0].data[0]=n,r[0].data[1]=o,this):(this._activePath.moveTo(n,o),this)}quadraticCurveTo(e,t,s,r,n){this._tick++;const o=this._transform;return this._activePath.quadraticCurveTo(o.a*e+o.c*t+o.tx,o.b*e+o.d*t+o.ty,o.a*s+o.c*r+o.tx,o.b*s+o.d*r+o.ty,n),this}rect(e,t,s,r){return this._tick++,this._activePath.rect(e,t,s,r,this._transform.clone()),this}roundRect(e,t,s,r,n){return this._tick++,this._activePath.roundRect(e,t,s,r,n,this._transform.clone()),this}poly(e,t){return this._tick++,this._activePath.poly(e,t,this._transform.clone()),this}regularPoly(e,t,s,r,n=0,o){return this._tick++,this._activePath.regularPoly(e,t,s,r,n,o),this}roundPoly(e,t,s,r,n,o){return this._tick++,this._activePath.roundPoly(e,t,s,r,n,o),this}roundShape(e,t,s,r){return this._tick++,this._activePath.roundShape(e,t,s,r),this}filletRect(e,t,s,r,n){return this._tick++,this._activePath.filletRect(e,t,s,r,n),this}chamferRect(e,t,s,r,n,o){return this._tick++,this._activePath.chamferRect(e,t,s,r,n,o),this}star(e,t,s,r,n=0,o=0){return this._tick++,this._activePath.star(e,t,s,r,n,o,this._transform.clone()),this}svg(e){return this._tick++,rE(e,this),this}restore(){const e=this._stateStack.pop();return e&&(this._transform=e.transform,this._fillStyle=e.fillStyle,this._strokeStyle=e.strokeStyle),this}save(){return this._stateStack.push({transform:this._transform.clone(),fillStyle:{...this._fillStyle},strokeStyle:{...this._strokeStyle}}),this}getTransform(){return this._transform}resetTransform(){return this._transform.identity(),this}rotate(e){return this._transform.rotate(e),this}scale(e,t=e){return this._transform.scale(e,t),this}setTransform(e,t,s,r,n,o){return e instanceof O?(this._transform.set(e.a,e.b,e.c,e.d,e.tx,e.ty),this):(this._transform.set(e,t,s,r,n,o),this)}transform(e,t,s,r,n,o){return e instanceof O?(this._transform.append(e),this):(e0.set(e,t,s,r,n,o),this._transform.append(e0),this)}translate(e,t=e){return this._transform.translate(e,t),this}clear(){return this._activePath.clear(),this.instructions.length=0,this.resetTransform(),this.onUpdate(),this}onUpdate(){this._boundsDirty=!0,!this.dirty&&(this.emit("update",this,16),this.dirty=!0)}get bounds(){if(!this._boundsDirty)return this._bounds;this._boundsDirty=!1;const e=this._bounds;e.clear();for(let t=0;t<this.instructions.length;t++){const s=this.instructions[t],r=s.action;if(r==="fill"){const n=s.data;e.addBounds(n.path.bounds)}else if(r==="texture"){const n=s.data;e.addFrame(n.dx,n.dy,n.dx+n.dw,n.dy+n.dh,n.transform)}if(r==="stroke"){const n=s.data,o=n.style.alignment,a=n.style.width*(1-o),l=n.path.bounds;e.addFrame(l.minX-a,l.minY-a,l.maxX+a,l.maxY+a)}}return e}containsPoint(e){if(!this.bounds.containsPoint(e.x,e.y))return!1;const t=this.instructions;let s=!1;for(let r=0;r<t.length;r++){const n=t[r],o=n.data,a=o.path;if(!n.action||!a)continue;const l=o.style,c=a.shapePath.shapePrimitives;for(let h=0;h<c.length;h++){const u=c[h].shape;if(!l||!u)continue;const d=c[h].transform,f=d?d.applyInverse(e,hE):e;if(n.action==="fill")s=u.contains(f.x,f.y);else{const g=l;s=u.strokeContains(f.x,f.y,g.width,g.alignment)}const m=o.hole;if(m){const g=m.shapePath?.shapePrimitives;if(g)for(let p=0;p<g.length;p++)g[p].shape.contains(f.x,f.y)&&(s=!1)}if(s)return!0}}return s}unload(){this.emit("unload",this);for(const e in this._gpuData)this._gpuData[e]?.destroy();this._gpuData=Object.create(null)}destroy(e=!1){if(this.destroyed)return;if(this.destroyed=!0,this._stateStack.length=0,this._transform=null,this.unload(),this.emit("destroy",this),this.removeAllListeners(),typeof e=="boolean"?e:e?.texture){const s=typeof e=="boolean"?e:e?.textureSource;this._fillStyle.texture&&(this._fillStyle.fill&&"uid"in this._fillStyle.fill?this._fillStyle.fill.destroy():this._fillStyle.texture.destroy(s)),this._strokeStyle.texture&&(this._strokeStyle.fill&&"uid"in this._strokeStyle.fill?this._strokeStyle.fill.destroy():this._strokeStyle.texture.destroy(s))}this._fillStyle=null,this._strokeStyle=null,this.instructions=null,this._activePath=null,this._bounds=null,this._stateStack=null,this.customShader=null,this._transform=null}};dd.defaultFillStyle={color:16777215,alpha:1,texture:k.WHITE,matrix:null,fill:null,textureSpace:"local"},dd.defaultStrokeStyle={width:1,color:16777215,alpha:1,alignment:.5,miterLimit:10,cap:"butt",join:"miter",texture:k.WHITE,matrix:null,fill:null,textureSpace:"local",pixelLine:!1};let ht=dd;const fd=class Qi extends Ze{constructor(e={}){super(),this.uid=le("textStyle"),this._tick=0,uE(e);const t={...Qi.defaultTextStyle,...e};for(const s in t){const r=s;this[r]=t[s]}this.update(),this._tick=0}get align(){return this._align}set align(e){this._align!==e&&(this._align=e,this.update())}get breakWords(){return this._breakWords}set breakWords(e){this._breakWords!==e&&(this._breakWords=e,this.update())}get dropShadow(){return this._dropShadow}set dropShadow(e){this._dropShadow!==e&&(e!==null&&typeof e=="object"?this._dropShadow=this._createProxy({...Qi.defaultDropShadow,...e}):this._dropShadow=e?this._createProxy({...Qi.defaultDropShadow}):null,this.update())}get fontFamily(){return this._fontFamily}set fontFamily(e){this._fontFamily!==e&&(this._fontFamily=e,this.update())}get fontSize(){return this._fontSize}set fontSize(e){this._fontSize!==e&&(typeof e=="string"?this._fontSize=parseInt(e,10):this._fontSize=e,this.update())}get fontStyle(){return this._fontStyle}set fontStyle(e){this._fontStyle!==e&&(this._fontStyle=e.toLowerCase(),this.update())}get fontVariant(){return this._fontVariant}set fontVariant(e){this._fontVariant!==e&&(this._fontVariant=e,this.update())}get fontWeight(){return this._fontWeight}set fontWeight(e){this._fontWeight!==e&&(this._fontWeight=e,this.update())}get leading(){return this._leading}set leading(e){this._leading!==e&&(this._leading=e,this.update())}get letterSpacing(){return this._letterSpacing}set letterSpacing(e){this._letterSpacing!==e&&(this._letterSpacing=e,this.update())}get lineHeight(){return this._lineHeight}set lineHeight(e){this._lineHeight!==e&&(this._lineHeight=e,this.update())}get padding(){return this._padding}set padding(e){this._padding!==e&&(this._padding=e,this.update())}get filters(){return this._filters}set filters(e){this._filters!==e&&(this._filters=Object.freeze(e),this.update())}get trim(){return this._trim}set trim(e){this._trim!==e&&(this._trim=e,this.update())}get textBaseline(){return this._textBaseline}set textBaseline(e){this._textBaseline!==e&&(this._textBaseline=e,this.update())}get whiteSpace(){return this._whiteSpace}set whiteSpace(e){this._whiteSpace!==e&&(this._whiteSpace=e,this.update())}get wordWrap(){return this._wordWrap}set wordWrap(e){this._wordWrap!==e&&(this._wordWrap=e,this.update())}get wordWrapWidth(){return this._wordWrapWidth}set wordWrapWidth(e){this._wordWrapWidth!==e&&(this._wordWrapWidth=e,this.update())}get fill(){return this._originalFill}set fill(e){e!==this._originalFill&&(this._originalFill=e,this._isFillStyle(e)&&(this._originalFill=this._createProxy({...ht.defaultFillStyle,...e},()=>{this._fill=pi({...this._originalFill},ht.defaultFillStyle)})),this._fill=pi(e===0?"black":e,ht.defaultFillStyle),this.update())}get stroke(){return this._originalStroke}set stroke(e){e!==this._originalStroke&&(this._originalStroke=e,this._isFillStyle(e)&&(this._originalStroke=this._createProxy({...ht.defaultStrokeStyle,...e},()=>{this._stroke=sn({...this._originalStroke},ht.defaultStrokeStyle)})),this._stroke=sn(e,ht.defaultStrokeStyle),this.update())}update(){this._tick++,this.emit("update",this)}reset(){const e=Qi.defaultTextStyle;for(const t in e)this[t]=e[t]}get styleKey(){return`${this.uid}-${this._tick}`}clone(){return new Qi({align:this.align,breakWords:this.breakWords,dropShadow:this._dropShadow?{...this._dropShadow}:null,fill:this._fill,fontFamily:this.fontFamily,fontSize:this.fontSize,fontStyle:this.fontStyle,fontVariant:this.fontVariant,fontWeight:this.fontWeight,leading:this.leading,letterSpacing:this.letterSpacing,lineHeight:this.lineHeight,padding:this.padding,stroke:this._stroke,textBaseline:this.textBaseline,whiteSpace:this.whiteSpace,wordWrap:this.wordWrap,wordWrapWidth:this.wordWrapWidth,filters:this._filters?[...this._filters]:void 0})}_getFinalPadding(){let e=0;if(this._filters)for(let t=0;t<this._filters.length;t++)e+=this._filters[t].padding;return Math.max(this._padding,e)}destroy(e=!1){if(this.removeAllListeners(),typeof e=="boolean"?e:e?.texture){const s=typeof e=="boolean"?e:e?.textureSource;this._fill?.texture&&this._fill.texture.destroy(s),this._originalFill?.texture&&this._originalFill.texture.destroy(s),this._stroke?.texture&&this._stroke.texture.destroy(s),this._originalStroke?.texture&&this._originalStroke.texture.destroy(s)}this._fill=null,this._stroke=null,this.dropShadow=null,this._originalStroke=null,this._originalFill=null}_createProxy(e,t){return new Proxy(e,{set:(s,r,n)=>(s[r]===n||(s[r]=n,t?.(r,n),this.update()),!0)})}_isFillStyle(e){return(e??null)!==null&&!(ue.isColorLike(e)||e instanceof ct||e instanceof jr)}};fd.defaultDropShadow={alpha:1,angle:Math.PI/6,blur:0,color:"black",distance:5},fd.defaultTextStyle={align:"left",breakWords:!1,dropShadow:null,fill:"black",fontFamily:"Arial",fontSize:26,fontStyle:"normal",fontVariant:"normal",fontWeight:"normal",leading:0,letterSpacing:0,lineHeight:0,padding:0,stroke:null,textBaseline:"alphabetic",trim:!1,whiteSpace:"pre",wordWrap:!1,wordWrapWidth:100};let Ye=fd;function uE(i){const e=i;if(typeof e.dropShadow=="boolean"&&e.dropShadow){const t=Ye.defaultDropShadow;i.dropShadow={alpha:e.dropShadowAlpha??t.alpha,angle:e.dropShadowAngle??t.angle,blur:e.dropShadowBlur??t.blur,color:e.dropShadowColor??t.color,distance:e.dropShadowDistance??t.distance}}if(e.strokeThickness!==void 0){L(J,"strokeThickness is now a part of stroke");const t=e.stroke;let s={};if(ue.isColorLike(t))s.color=t;else if(t instanceof ct||t instanceof jr)s.fill=t;else if(Object.hasOwnProperty.call(t,"color")||Object.hasOwnProperty.call(t,"fill"))s=t;else throw new Error("Invalid stroke value.");i.stroke={...s,width:e.strokeThickness}}if(Array.isArray(e.fillGradientStops)){if(L(J,"gradient fill is now a fill pattern: `new FillGradient(...)`"),!Array.isArray(e.fill)||e.fill.length===0)throw new Error("Invalid fill value. Expected an array of colors for gradient fill.");e.fill.length!==e.fillGradientStops.length&&H("The number of fill colors must match the number of fill gradient stops.");const t=new ct({start:{x:0,y:0},end:{x:0,y:1},textureSpace:"local"}),s=e.fillGradientStops.slice(),r=e.fill.map(n=>ue.shared.setValue(n).toNumber());s.forEach((n,o)=>{t.addColorStop(n,r[o])}),i.fill={fill:t}}}class dE{constructor(e){this._canvasPool=Object.create(null),this.canvasOptions=e||{},this.enableFullScreen=!1}_createCanvasAndContext(e,t){const s=Y.get().createCanvas();s.width=e,s.height=t;const r=s.getContext("2d");return{canvas:s,context:r}}getOptimalCanvasAndContext(e,t,s=1){e=Math.ceil(e*s-1e-6),t=Math.ceil(t*s-1e-6),e=Mi(e),t=Mi(t);const r=(e<<17)+(t<<1);this._canvasPool[r]||(this._canvasPool[r]=[]);let n=this._canvasPool[r].pop();return n||(n=this._createCanvasAndContext(e,t)),n}returnCanvasAndContext(e){const t=e.canvas,{width:s,height:r}=t,n=(s<<17)+(r<<1);e.context.resetTransform(),e.context.clearRect(0,0,s,r),this._canvasPool[n].push(e)}clear(){this._canvasPool={}}}const Lt=new dE;Ui.register(Lt);const t0=1e5;function rn(i,e,t,s=0){if(i.texture===k.WHITE&&!i.fill)return ue.shared.setValue(i.color).setAlpha(i.alpha??1).toHexa();if(i.fill){if(i.fill instanceof jr){const r=i.fill,n=e.createPattern(r.texture.source.resource,"repeat"),o=r.transform.copyTo(O.shared);return o.scale(r.texture.frame.width,r.texture.frame.height),n.setTransform(o),n}else if(i.fill instanceof ct){const r=i.fill,n=r.type==="linear",o=r.textureSpace==="local";let a=1,l=1;o&&t&&(a=t.width+s,l=t.height+s);let c,h=!1;if(n){const{start:u,end:d}=r;c=e.createLinearGradient(u.x*a,u.y*l,d.x*a,d.y*l),h=Math.abs(d.x-u.x)<Math.abs((d.y-u.y)*.1)}else{const{center:u,innerRadius:d,outerCenter:f,outerRadius:m}=r;c=e.createRadialGradient(u.x*a,u.y*l,d*a,f.x*a,f.y*l,m*a)}if(h&&o&&t){const u=t.lineHeight/l;for(let d=0;d<t.lines.length;d++){const f=(d*t.lineHeight+s/2)/l;r.colorStops.forEach(m=>{const g=f+m.offset*u;c.addColorStop(Math.floor(g*t0)/t0,ue.shared.setValue(m.color).toHex())})}}else r.colorStops.forEach(u=>{c.addColorStop(u.offset,ue.shared.setValue(u.color).toHex())});return c}}else{const r=e.createPattern(i.texture.source.resource,"repeat"),n=i.matrix.copyTo(O.shared);return n.scale(i.texture.frame.width,i.texture.frame.height),r.setTransform(n),r}return H("FillStyle not recognised",i),"red"}const i0=class iv extends ug{constructor(e){super(),this.resolution=1,this.pages=[],this._padding=0,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentMaxCharHeight=0,this._currentPageIndex=-1,this._skipKerning=!1;const t={...iv.defaultOptions,...e};this._textureSize=t.textureSize,this._mipmap=t.mipmap;const s=t.style.clone();t.overrideFill&&(s._fill.color=16777215,s._fill.alpha=1,s._fill.texture=k.WHITE,s._fill.fill=null),this.applyFillAsTint=t.overrideFill;const r=s.fontSize;s.fontSize=this.baseMeasurementFontSize;const n=Kr(s);t.overrideSize?s._stroke&&(s._stroke.width*=this.baseRenderedFontSize/r):s.fontSize=this.baseRenderedFontSize=r,this._style=s,this._skipKerning=t.skipKerning??!1,this.resolution=t.resolution??1,this._padding=t.padding??4,t.textureStyle&&(this._textureStyle=t.textureStyle instanceof Ct?t.textureStyle:new Ct(t.textureStyle)),this.fontMetrics=Xe.measureFont(n),this.lineHeight=s.lineHeight||this.fontMetrics.fontSize||s.fontSize}ensureCharacters(e){const t=Xe.graphemeSegmenter(e).filter(p=>!this._currentChars.includes(p)).filter((p,_,x)=>x.indexOf(p)===_);if(!t.length)return;this._currentChars=[...this._currentChars,...t];let s;this._currentPageIndex===-1?s=this._nextPage():s=this.pages[this._currentPageIndex];let{canvas:r,context:n}=s.canvasAndContext,o=s.texture.source;const a=this._style;let l=this._currentX,c=this._currentY,h=this._currentMaxCharHeight;const u=this.baseRenderedFontSize/this.baseMeasurementFontSize,d=this._padding*u;let f=!1;const m=r.width/this.resolution,g=r.height/this.resolution;for(let p=0;p<t.length;p++){const _=t[p],x=Xe.measureText(_,a,r,!1);x.lineHeight=x.height;const v=x.width*u,y=Math.ceil((a.fontStyle==="italic"?2:1)*v),T=x.height*u,S=y+d*2,w=T+d*2;if(f=!1,_!==`
`&&_!=="\r"&&_!=="	"&&_!==" "&&(f=!0,h=Math.ceil(Math.max(w,h))),l+S>m&&(c+=h,h=w,l=0,c+h>g)){o.update();const P=this._nextPage();r=P.canvasAndContext.canvas,n=P.canvasAndContext.context,o=P.texture.source,l=0,c=0,h=0}const E=v/u-(a.dropShadow?.distance??0)-(a._stroke?.width??0);if(this.chars[_]={id:_.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:E,kerning:{}},f){this._drawGlyph(n,x,l+d,c+d,u,a);const P=o.width*u,C=o.height*u,A=new W(l/P*o.width,c/C*o.height,S/P*o.width,w/C*o.height);this.chars[_].texture=new k({source:o,frame:A}),l+=Math.ceil(S)}}o.update(),this._currentX=l,this._currentY=c,this._currentMaxCharHeight=h,this._skipKerning&&this._applyKerning(t,n)}get pageTextures(){return L(J,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(e,t){const s=this._measureCache;for(let r=0;r<e.length;r++){const n=e[r];for(let o=0;o<this._currentChars.length;o++){const a=this._currentChars[o];let l=s[n];l||(l=s[n]=t.measureText(n).width);let c=s[a];c||(c=s[a]=t.measureText(a).width);let h=t.measureText(n+a).width,u=h-(l+c);u&&(this.chars[n].kerning[a]=u),h=t.measureText(n+a).width,u=h-(l+c),u&&(this.chars[a].kerning[n]=u)}}}_nextPage(){this._currentPageIndex++;const e=this.resolution,t=Lt.getOptimalCanvasAndContext(this._textureSize,this._textureSize,e);this._setupContext(t.context,this._style,e);const s=e*(this.baseRenderedFontSize/this.baseMeasurementFontSize),r=new k({source:new Et({resource:t.canvas,resolution:s,alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:this._mipmap})});this._textureStyle&&(r.source.style=this._textureStyle);const n={canvasAndContext:t,texture:r};return this.pages[this._currentPageIndex]=n,n}_setupContext(e,t,s){t.fontSize=this.baseRenderedFontSize,e.scale(s,s),e.font=Kr(t),t.fontSize=this.baseMeasurementFontSize,e.textBaseline=t.textBaseline;const r=t._stroke,n=r?.width??0;if(r&&(e.lineWidth=n,e.lineJoin=r.join,e.miterLimit=r.miterLimit,e.strokeStyle=rn(r,e)),t._fill&&(e.fillStyle=rn(t._fill,e)),t.dropShadow){const o=t.dropShadow,a=ue.shared.setValue(o.color).toArray(),l=o.blur*s,c=o.distance*s;e.shadowColor=`rgba(${a[0]*255},${a[1]*255},${a[2]*255},${o.alpha})`,e.shadowBlur=l,e.shadowOffsetX=Math.cos(o.angle)*c,e.shadowOffsetY=Math.sin(o.angle)*c}else e.shadowColor="black",e.shadowBlur=0,e.shadowOffsetX=0,e.shadowOffsetY=0}_drawGlyph(e,t,s,r,n,o){const a=t.text,l=t.fontProperties,h=(o._stroke?.width??0)*n,u=s+h/2,d=r-h/2,f=l.descent*n,m=t.lineHeight*n;let g=!1;o.stroke&&h&&(g=!0,e.strokeText(a,u,d+m-f));const{shadowBlur:p,shadowOffsetX:_,shadowOffsetY:x}=e;o._fill&&(g&&(e.shadowBlur=0,e.shadowOffsetX=0,e.shadowOffsetY=0),e.fillText(a,u,d+m-f)),g&&(e.shadowBlur=p,e.shadowOffsetX=_,e.shadowOffsetY=x)}destroy(){super.destroy();for(let e=0;e<this.pages.length;e++){const{canvasAndContext:t,texture:s}=this.pages[e];Lt.returnCanvasAndContext(t),s.destroy(!0)}this.pages=null}};i0.defaultOptions={textureSize:512,style:new Ye,mipmap:!0};let s0=i0;function pd(i,e,t,s){const r={width:0,height:0,offsetY:0,scale:e.fontSize/t.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};r.offsetY=t.baseLineOffset;let n=r.lines[0],o=null,a=!0;const l={width:0,start:0,index:0,positions:[],chars:[]},c=t.baseMeasurementFontSize/e.fontSize,h=e.letterSpacing*c,u=e.wordWrapWidth*c,d=e.lineHeight?e.lineHeight*c:t.lineHeight,f=e.wordWrap&&e.breakWords,m=_=>{const x=n.width;for(let v=0;v<l.index;v++){const y=_.positions[v];n.chars.push(_.chars[v]),n.charPositions.push(y+x)}n.width+=_.width,a=!1,l.width=0,l.index=0,l.chars.length=0},g=()=>{let _=n.chars.length-1;if(s){let x=n.chars[_];for(;x===" ";)n.width-=t.chars[x].xAdvance,x=n.chars[--_]}r.width=Math.max(r.width,n.width),n={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},a=!0,r.lines.push(n),r.height+=d},p=_=>_-h>u;for(let _=0;_<i.length+1;_++){let x;const v=_===i.length;v||(x=i[_]);const y=t.chars[x]||t.chars[" "];if(/(?:\s)/.test(x)||x==="\r"||x===`
`||v){if(!a&&e.wordWrap&&p(n.width+l.width)?(g(),m(l),v||n.charPositions.push(0)):(l.start=n.width,m(l),v||n.charPositions.push(0)),x==="\r"||x===`
`)g();else if(!v){const E=y.xAdvance+(y.kerning[o]||0)+h;n.width+=E,n.spaceWidth=E,n.spacesIndex.push(n.charPositions.length),n.chars.push(x)}}else{const w=y.kerning[o]||0,E=y.xAdvance+w+h;f&&p(n.width+l.width+E)&&(m(l),g()),l.positions[l.index++]=l.width+w,l.chars.push(x),l.width+=E}o=x}return g(),e.align==="center"?fE(r):e.align==="right"?pE(r):e.align==="justify"&&mE(r),r}function fE(i){for(let e=0;e<i.lines.length;e++){const t=i.lines[e],s=i.width/2-t.width/2;for(let r=0;r<t.charPositions.length;r++)t.charPositions[r]+=s}}function pE(i){for(let e=0;e<i.lines.length;e++){const t=i.lines[e],s=i.width-t.width;for(let r=0;r<t.charPositions.length;r++)t.charPositions[r]+=s}}function mE(i){const e=i.width;for(let t=0;t<i.lines.length;t++){const s=i.lines[t];let r=0,n=s.spacesIndex[r++],o=0;const a=s.spacesIndex.length,c=(e-s.width)/a;for(let h=0;h<s.charPositions.length;h++)h===n&&(n=s.spacesIndex[r++],o+=c),s.charPositions[h]+=o}}function gE(i){if(i==="")return[];typeof i=="string"&&(i=[i]);const e=[];for(let t=0,s=i.length;t<s;t++){const r=i[t];if(Array.isArray(r)){if(r.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${r.length}.`);if(r[0].length===0||r[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const n=r[0].charCodeAt(0),o=r[1].charCodeAt(0);if(o<n)throw new Error("[BitmapFont]: Invalid character range.");for(let a=n,l=o;a<=l;a++)e.push(String.fromCharCode(a))}else e.push(...Array.from(r))}if(e.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return e}let nn=0;class _E{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1,textureStyle:null},this.measureCache=dg(1e3)}getFont(e,t){let s=`${t.fontFamily}-bitmap`,r=!0;if(t._fill.fill&&!t._stroke?(s+=t._fill.fill.styleKey,r=!1):(t._stroke||t.dropShadow)&&(s=`${t.styleKey}-bitmap`,r=!1),!ae.has(s)){const o=Object.create(t);o.lineHeight=0;const a=new s0({style:o,overrideFill:r,overrideSize:!0,...this.defaultOptions});nn++,nn>50&&H("BitmapText",`You have dynamically created ${nn} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),a.once("destroy",()=>{nn--,ae.remove(s)}),ae.set(s,a)}const n=ae.get(s);return n.ensureCharacters?.(e),n}getLayout(e,t,s=!0){const r=this.getFont(e,t),n=`${e}-${t.styleKey}-${s}`;if(this.measureCache.has(n))return this.measureCache.get(n);const o=Xe.graphemeSegmenter(e),a=pd(o,t,r,s);return this.measureCache.set(n,a),a}measureText(e,t,s=!0){return this.getLayout(e,t,s)}install(...e){let t=e[0];typeof t=="string"&&(t={name:t,style:e[1],chars:e[2]?.chars,resolution:e[2]?.resolution,padding:e[2]?.padding,skipKerning:e[2]?.skipKerning},L(J,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const s=t?.name;if(!s)throw new Error("[BitmapFontManager] Property `name` is required.");t={...this.defaultOptions,...t};const r=t.style,n=r instanceof Ye?r:new Ye(r),o=t.dynamicFill??this._canUseTintForStyle(n),a=new s0({style:n,overrideFill:o,skipKerning:t.skipKerning,padding:t.padding,resolution:t.resolution,overrideSize:!1,textureStyle:t.textureStyle}),l=gE(t.chars);return a.ensureCharacters(l.join("")),ae.set(`${s}-bitmap`,a),a.once("destroy",()=>ae.remove(`${s}-bitmap`)),a}uninstall(e){const t=`${e}-bitmap`,s=ae.get(t);s&&s.destroy()}_canUseTintForStyle(e){return!e._stroke&&(!e.dropShadow||e.dropShadow.color===0)&&!e._fill.fill&&e._fill.color===16777215}}const zs=new _E;class r0 extends ug{constructor(e,t){super();const{textures:s,data:r}=e;Object.keys(r.pages).forEach(n=>{const o=r.pages[parseInt(n,10)],a=s[o.id];this.pages.push({texture:a})}),Object.keys(r.chars).forEach(n=>{const o=r.chars[n],{frame:a,source:l,rotate:c}=s[o.page],h=oe.transformRectCoords(o,a,c,new W),u=new k({frame:h,orig:new W(0,0,o.width,o.height),source:l,rotate:c});this.chars[n]={id:n.codePointAt(0),xOffset:o.xOffset,yOffset:o.yOffset,xAdvance:o.xAdvance,kerning:o.kerning??{},texture:u}}),this.baseRenderedFontSize=r.fontSize,this.baseMeasurementFontSize=r.fontSize,this.fontMetrics={ascent:0,descent:0,fontSize:r.fontSize},this.baseLineOffset=r.baseLineOffset,this.lineHeight=r.lineHeight,this.fontFamily=r.fontFamily,this.distanceField=r.distanceField??{type:"none",range:0},this.url=t}destroy(){super.destroy();for(let e=0;e<this.pages.length;e++){const{texture:t}=this.pages[e];t.destroy(!0)}this.pages=null}static install(e){zs.install(e)}static uninstall(e){zs.uninstall(e)}}const md={test(i){return typeof i=="string"&&i.startsWith("info face=")},parse(i){const e=i.match(/^[a-z]+\s+.+$/gm),t={info:[],common:[],page:[],char:[],chars:[],kerning:[],kernings:[],distanceField:[]};for(const u in e){const d=e[u].match(/^[a-z]+/gm)[0],f=e[u].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),m={};for(const g in f){const p=f[g].split("="),_=p[0],x=p[1].replace(/"/gm,""),v=parseFloat(x),y=isNaN(v)?x:v;m[_]=y}t[d].push(m)}const s={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},[r]=t.info,[n]=t.common,[o]=t.distanceField??[];o&&(s.distanceField={range:parseInt(o.distanceRange,10),type:o.fieldType}),s.fontSize=parseInt(r.size,10),s.fontFamily=r.face,s.lineHeight=parseInt(n.lineHeight,10);const a=t.page;for(let u=0;u<a.length;u++)s.pages.push({id:parseInt(a[u].id,10)||0,file:a[u].file});const l={};s.baseLineOffset=s.lineHeight-parseInt(n.base,10);const c=t.char;for(let u=0;u<c.length;u++){const d=c[u],f=parseInt(d.id,10);let m=d.letter??d.char??String.fromCharCode(f);m==="space"&&(m=" "),l[f]=m,s.chars[m]={id:f,page:parseInt(d.page,10)||0,x:parseInt(d.x,10),y:parseInt(d.y,10),width:parseInt(d.width,10),height:parseInt(d.height,10),xOffset:parseInt(d.xoffset,10),yOffset:parseInt(d.yoffset,10),xAdvance:parseInt(d.xadvance,10),kerning:{}}}const h=t.kerning||[];for(let u=0;u<h.length;u++){const d=parseInt(h[u].first,10),f=parseInt(h[u].second,10),m=parseInt(h[u].amount,10);s.chars[l[f]].kerning[l[d]]=m}return s}},n0={test(i){const e=i;return typeof e!="string"&&"getElementsByTagName"in e&&e.getElementsByTagName("page").length&&e.getElementsByTagName("info")[0].getAttribute("face")!==null},parse(i){const e={chars:{},pages:[],lineHeight:0,fontSize:0,fontFamily:"",distanceField:null,baseLineOffset:0},t=i.getElementsByTagName("info")[0],s=i.getElementsByTagName("common")[0],r=i.getElementsByTagName("distanceField")[0];r&&(e.distanceField={type:r.getAttribute("fieldType"),range:parseInt(r.getAttribute("distanceRange"),10)});const n=i.getElementsByTagName("page"),o=i.getElementsByTagName("char"),a=i.getElementsByTagName("kerning");e.fontSize=parseInt(t.getAttribute("size"),10),e.fontFamily=t.getAttribute("face"),e.lineHeight=parseInt(s.getAttribute("lineHeight"),10);for(let c=0;c<n.length;c++)e.pages.push({id:parseInt(n[c].getAttribute("id"),10)||0,file:n[c].getAttribute("file")});const l={};e.baseLineOffset=e.lineHeight-parseInt(s.getAttribute("base"),10);for(let c=0;c<o.length;c++){const h=o[c],u=parseInt(h.getAttribute("id"),10);let d=h.getAttribute("letter")??h.getAttribute("char")??String.fromCharCode(u);d==="space"&&(d=" "),l[u]=d,e.chars[d]={id:u,page:parseInt(h.getAttribute("page"),10)||0,x:parseInt(h.getAttribute("x"),10),y:parseInt(h.getAttribute("y"),10),width:parseInt(h.getAttribute("width"),10),height:parseInt(h.getAttribute("height"),10),xOffset:parseInt(h.getAttribute("xoffset"),10),yOffset:parseInt(h.getAttribute("yoffset"),10),xAdvance:parseInt(h.getAttribute("xadvance"),10),kerning:{}}}for(let c=0;c<a.length;c++){const h=parseInt(a[c].getAttribute("first"),10),u=parseInt(a[c].getAttribute("second"),10),d=parseInt(a[c].getAttribute("amount"),10);e.chars[l[u]].kerning[l[h]]=d}return e}},o0={test(i){return typeof i=="string"&&i.match(/<font(\s|>)/)?n0.test(Y.get().parseXML(i)):!1},parse(i){return n0.parse(Y.get().parseXML(i))}},xE=[".xml",".fnt"],vE={extension:{type:b.CacheParser,name:"cacheBitmapFont"},test:i=>i instanceof r0,getCacheableAssets(i,e){const t={};return i.forEach(s=>{t[s]=e,t[`${s}-bitmap`]=e}),t[`${e.fontFamily}-bitmap`]=e,t}},yE={extension:{type:b.LoadParser,priority:jt.Normal},name:"loadBitmapFont",id:"bitmap-font",test(i){return xE.includes(Qe.extname(i).toLowerCase())},async testParse(i){return md.test(i)||o0.test(i)},async parse(i,e,t){const s=md.test(i)?md.parse(i):o0.parse(i),{src:r}=e,{pages:n}=s,o=[],a=s.distanceField?{scaleMode:"linear",alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:!1,resolution:1}:{};for(let u=0;u<n.length;++u){const d=n[u].file;let f=Qe.join(Qe.dirname(r),d);f=Cu(f,r),o.push({src:f,data:a})}const l=await t.load(o),c=o.map(u=>l[u.src]);return new r0({data:s,textures:c},r)},async load(i,e){return await(await Y.get().fetch(i)).text()},async unload(i,e,t){await Promise.all(i.pages.map(s=>t.unload(s.texture.source._sourceOrigin))),i.destroy()}};class bE{constructor(e,t=!1){this._loader=e,this._assetList=[],this._isLoading=!1,this._maxConcurrent=1,this.verbose=t}add(e){e.forEach(t=>{this._assetList.push(t)}),this.verbose&&console.log("[BackgroundLoader] assets: ",this._assetList),this._isActive&&!this._isLoading&&this._next()}async _next(){if(this._assetList.length&&this._isActive){this._isLoading=!0;const e=[],t=Math.min(this._assetList.length,this._maxConcurrent);for(let s=0;s<t;s++)e.push(this._assetList.pop());await this._loader.load(e),this._isLoading=!1,this._next()}}get active(){return this._isActive}set active(e){this._isActive!==e&&(this._isActive=e,e&&!this._isLoading&&this._next())}}const TE={extension:{type:b.CacheParser,name:"cacheTextureArray"},test:i=>Array.isArray(i)&&i.every(e=>e instanceof k),getCacheableAssets:(i,e)=>{const t={};return i.forEach(s=>{e.forEach((r,n)=>{t[s+(n===0?"":n+1)]=r})}),t}};async function a0(i){if("Image"in globalThis)return new Promise(e=>{const t=new Image;t.onload=()=>{e(!0)},t.onerror=()=>{e(!1)},t.src=i});if("createImageBitmap"in globalThis&&"fetch"in globalThis){try{const e=await(await fetch(i)).blob();await createImageBitmap(e)}catch{return!1}return!0}return!1}const wE={extension:{type:b.DetectionParser,priority:1},test:async()=>a0("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),add:async i=>[...i,"avif"],remove:async i=>i.filter(e=>e!=="avif")},l0=["png","jpg","jpeg"],SE={extension:{type:b.DetectionParser,priority:-1},test:()=>Promise.resolve(!0),add:async i=>[...i,...l0],remove:async i=>i.filter(e=>!l0.includes(e))},CE="WorkerGlobalScope"in globalThis&&globalThis instanceof globalThis.WorkerGlobalScope;function on(i){return CE?!1:document.createElement("video").canPlayType(i)!==""}const AE={extension:{type:b.DetectionParser,priority:0},test:async()=>on("video/mp4"),add:async i=>[...i,"mp4","m4v"],remove:async i=>i.filter(e=>e!=="mp4"&&e!=="m4v")},EE={extension:{type:b.DetectionParser,priority:0},test:async()=>on("video/ogg"),add:async i=>[...i,"ogv"],remove:async i=>i.filter(e=>e!=="ogv")},IE={extension:{type:b.DetectionParser,priority:0},test:async()=>on("video/webm"),add:async i=>[...i,"webm"],remove:async i=>i.filter(e=>e!=="webm")},PE={extension:{type:b.DetectionParser,priority:0},test:async()=>a0("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),add:async i=>[...i,"webp"],remove:async i=>i.filter(e=>e!=="webp")},c0=class _n{constructor(){this.loadOptions={..._n.defaultOptions},this._parsers=[],this._parsersValidated=!1,this.parsers=new Proxy(this._parsers,{set:(e,t,s)=>(this._parsersValidated=!1,e[t]=s,!0)}),this.promiseCache={}}reset(){this._parsersValidated=!1,this.promiseCache={}}_getLoadPromiseAndParser(e,t){const s={promise:null,parser:null};return s.promise=(async()=>{let r=null,n=null;if((t.parser||t.loadParser)&&(n=this._parserHash[t.parser||t.loadParser],t.loadParser&&H(`[Assets] "loadParser" is deprecated, use "parser" instead for ${e}`),n||H(`[Assets] specified load parser "${t.parser||t.loadParser}" not found while loading ${e}`)),!n){for(let o=0;o<this.parsers.length;o++){const a=this.parsers[o];if(a.load&&a.test?.(e,t,this)){n=a;break}}if(!n)return H(`[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`),null}r=await n.load(e,t,this),s.parser=n;for(let o=0;o<this.parsers.length;o++){const a=this.parsers[o];a.parse&&a.parse&&await a.testParse?.(r,t,this)&&(r=await a.parse(r,t,this)||r,s.parser=a)}return r})(),s}async load(e,t){this._parsersValidated||this._validateParsers();const s=typeof t=="function"?{..._n.defaultOptions,...this.loadOptions,onProgress:t}:{..._n.defaultOptions,...this.loadOptions,...t||{}},{onProgress:r,onError:n,strategy:o,retryCount:a,retryDelay:l}=s;let c=0;const h={},u=zr(e),d=ft(e,g=>({alias:[g],src:g,data:{}})),f=d.reduce((g,p)=>g+(p.progressSize||1),0),m=d.map(async g=>{const p=Qe.toAbsolute(g.src);h[g.src]||(await this._loadAssetWithRetry(p,g,{onProgress:r,onError:n,strategy:o,retryCount:a,retryDelay:l},h),c+=g.progressSize||1,r&&r(c/f))});return await Promise.all(m),u?h[d[0].src]:h}async unload(e){const s=ft(e,r=>({alias:[r],src:r})).map(async r=>{const n=Qe.toAbsolute(r.src),o=this.promiseCache[n];if(o){const a=await o.promise;delete this.promiseCache[n],await o.parser?.unload?.(a,r,this)}});await Promise.all(s)}_validateParsers(){this._parsersValidated=!0,this._parserHash=this._parsers.filter(e=>e.name||e.id).reduce((e,t)=>(!t.name&&!t.id?H("[Assets] parser should have an id"):(e[t.name]||e[t.id])&&H(`[Assets] parser id conflict "${t.id}"`),e[t.name]=t,t.id&&(e[t.id]=t),e),{})}async _loadAssetWithRetry(e,t,s,r){let n=0;const{onError:o,strategy:a,retryCount:l,retryDelay:c}=s,h=u=>new Promise(d=>setTimeout(d,u));for(;;)try{this.promiseCache[e]||(this.promiseCache[e]=this._getLoadPromiseAndParser(e,t)),r[t.src]=await this.promiseCache[e].promise;return}catch(u){delete this.promiseCache[e],delete r[t.src],n++;const d=a!=="retry"||n>l;if(a==="retry"&&!d){o&&o(u,t),await h(c);continue}if(a==="skip"){o&&o(u,t);return}o&&o(u,t);const f=new Error(`[Loader.load] Failed to load ${e}.
${u}`);throw u instanceof Error&&u.stack&&(f.stack=u.stack),f}}};c0.defaultOptions={onProgress:void 0,onError:void 0,strategy:"throw",retryCount:3,retryDelay:250};let RE=c0;function Hi(i,e){if(Array.isArray(e)){for(const t of e)if(i.startsWith(`data:${t}`))return!0;return!1}return i.startsWith(`data:${e}`)}function Wi(i,e){const t=i.split("?")[0],s=Qe.extname(t).toLowerCase();return Array.isArray(e)?e.includes(s):s===e}const kE=".json",ME="application/json",FE={extension:{type:b.LoadParser,priority:jt.Low},name:"loadJson",id:"json",test(i){return Hi(i,ME)||Wi(i,kE)},async load(i){return await(await Y.get().fetch(i)).json()}},UE=".txt",BE="text/plain",OE={name:"loadTxt",id:"text",extension:{type:b.LoadParser,priority:jt.Low,name:"loadTxt"},test(i){return Hi(i,BE)||Wi(i,UE)},async load(i){return await(await Y.get().fetch(i)).text()}},DE=["normal","bold","100","200","300","400","500","600","700","800","900"],GE=[".ttf",".otf",".woff",".woff2"],zE=["font/ttf","font/otf","font/woff","font/woff2"],LE=/^(--|-?[A-Z_])[0-9A-Z_-]*$/i;function NE(i){const e=Qe.extname(i),r=Qe.basename(i,e).replace(/(-|_)/g," ").toLowerCase().split(" ").map(a=>a.charAt(0).toUpperCase()+a.slice(1));let n=r.length>0;for(const a of r)if(!a.match(LE)){n=!1;break}let o=r.join(" ");return n||(o=`"${o.replace(/[\\"]/g,"\\$&")}"`),o}const HE=/^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;function WE(i){return HE.test(i)?i:encodeURI(i)}const VE={extension:{type:b.LoadParser,priority:jt.Low},name:"loadWebFont",id:"web-font",test(i){return Hi(i,zE)||Wi(i,GE)},async load(i,e){const t=Y.get().getFontFaceSet();if(t){const s=[],r=e.data?.family??NE(i),n=e.data?.weights?.filter(a=>DE.includes(a))??["normal"],o=e.data??{};for(let a=0;a<n.length;a++){const l=n[a],c=new FontFace(r,`url(${WE(i)})`,{...o,weight:l});await c.load(),t.add(c),s.push(c)}return ae.has(`${r}-and-url`)?ae.get(`${r}-and-url`).entries.push({url:i,faces:s}):ae.set(`${r}-and-url`,{entries:[{url:i,faces:s}]}),s.length===1?s[0]:s}return H("[loadWebFont] FontFace API is not supported. Skipping loading font"),null},unload(i){const e=Array.isArray(i)?i:[i],t=e[0].family,s=ae.get(`${t}-and-url`),r=s.entries.find(n=>n.faces.some(o=>e.indexOf(o)!==-1));r.faces=r.faces.filter(n=>e.indexOf(n)===-1),r.faces.length===0&&(s.entries=s.entries.filter(n=>n!==r)),e.forEach(n=>{Y.get().getFontFaceSet().delete(n)}),s.entries.length===0&&ae.remove(`${t}-and-url`)}};function gd(i,e=1){const t=Oi.RETINA_PREFIX?.exec(i);return t?parseFloat(t[1]):e}function _d(i,e,t){i.label=t,i._sourceOrigin=t;const s=new k({source:i,label:t}),r=()=>{delete e.promiseCache[t],ae.has(t)&&ae.remove(t)};return s.source.once("destroy",()=>{e.promiseCache[t]&&(H("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."),r())}),s.once("destroy",()=>{i.destroyed||(H("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."),r())}),s}const $E=".svg",XE="image/svg+xml",YE={extension:{type:b.LoadParser,priority:jt.Low,name:"loadSVG"},name:"loadSVG",id:"svg",config:{crossOrigin:"anonymous",parseAsGraphicsContext:!1},test(i){return Hi(i,XE)||Wi(i,$E)},async load(i,e,t){return e.data?.parseAsGraphicsContext??this.config.parseAsGraphicsContext?KE(i):qE(i,e,t,this.config.crossOrigin)},unload(i){i.destroy(!0)}};async function qE(i,e,t,s){const r=await Y.get().fetch(i),n=Y.get().createImage();n.src=`data:image/svg+xml;charset=utf-8,${encodeURIComponent(await r.text())}`,n.crossOrigin=s,await n.decode();const o=e.data?.width??n.width,a=e.data?.height??n.height,l=e.data?.resolution||gd(i),c=Math.ceil(o*l),h=Math.ceil(a*l),u=Y.get().createCanvas(c,h),d=u.getContext("2d");d.imageSmoothingEnabled=!0,d.imageSmoothingQuality="high",d.drawImage(n,0,0,o*l,a*l);const{parseAsGraphicsContext:f,...m}=e.data??{},g=new Et({resource:u,alphaMode:"premultiply-alpha-on-upload",resolution:l,...m});return _d(g,t,i)}async function KE(i){const t=await(await Y.get().fetch(i)).text(),s=new ht;return s.svg(t),s}const jE=`(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;let Vi=null,xd=class{constructor(){Vi||(Vi=URL.createObjectURL(new Blob([jE],{type:"application/javascript"}))),this.worker=new Worker(Vi)}};xd.revokeObjectURL=function(){Vi&&(URL.revokeObjectURL(Vi),Vi=null)};const ZE=`(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;let $i=null;class h0{constructor(){$i||($i=URL.createObjectURL(new Blob([ZE],{type:"application/javascript"}))),this.worker=new Worker($i)}}h0.revokeObjectURL=function(){$i&&(URL.revokeObjectURL($i),$i=null)};let u0=0,vd;class JE{constructor(){this._initialized=!1,this._createdWorkers=0,this._workerPool=[],this._queue=[],this._resolveHash={}}isImageBitmapSupported(){return this._isImageBitmapSupported!==void 0?this._isImageBitmapSupported:(this._isImageBitmapSupported=new Promise(e=>{const{worker:t}=new xd;t.addEventListener("message",s=>{t.terminate(),xd.revokeObjectURL(),e(s.data)})}),this._isImageBitmapSupported)}loadImageBitmap(e,t){return this._run("loadImageBitmap",[e,t?.data?.alphaMode])}async _initWorkers(){this._initialized||(this._initialized=!0)}_getWorker(){vd===void 0&&(vd=navigator.hardwareConcurrency||4);let e=this._workerPool.pop();return!e&&this._createdWorkers<vd&&(this._createdWorkers++,e=new h0().worker,e.addEventListener("message",t=>{this._complete(t.data),this._returnWorker(t.target),this._next()})),e}_returnWorker(e){this._workerPool.push(e)}_complete(e){this._resolveHash[e.uuid]&&(e.error!==void 0?this._resolveHash[e.uuid].reject(e.error):this._resolveHash[e.uuid].resolve(e.data),delete this._resolveHash[e.uuid])}async _run(e,t){await this._initWorkers();const s=new Promise((r,n)=>{this._queue.push({id:e,arguments:t,resolve:r,reject:n})});return this._next(),s}_next(){if(!this._queue.length)return;const e=this._getWorker();if(!e)return;const t=this._queue.pop(),s=t.id;this._resolveHash[u0]={resolve:t.resolve,reject:t.reject},e.postMessage({data:t.arguments,uuid:u0++,id:s})}reset(){this._workerPool.forEach(e=>e.terminate()),this._workerPool.length=0,Object.values(this._resolveHash).forEach(({reject:e})=>{e?.(new Error("WorkerManager has been reset before completion"))}),this._resolveHash={},this._queue.length=0,this._initialized=!1,this._createdWorkers=0}}const d0=new JE,QE=[".jpeg",".jpg",".png",".webp",".avif"],eI=["image/jpeg","image/png","image/webp","image/avif"];async function tI(i,e){const t=await Y.get().fetch(i);if(!t.ok)throw new Error(`[loadImageBitmap] Failed to fetch ${i}: ${t.status} ${t.statusText}`);const s=await t.blob();return e?.data?.alphaMode==="premultiplied-alpha"?createImageBitmap(s,{premultiplyAlpha:"none"}):createImageBitmap(s)}const f0={name:"loadTextures",id:"texture",extension:{type:b.LoadParser,priority:jt.High,name:"loadTextures"},config:{preferWorkers:!0,preferCreateImageBitmap:!0,crossOrigin:"anonymous"},test(i){return Hi(i,eI)||Wi(i,QE)},async load(i,e,t){let s=null;globalThis.createImageBitmap&&this.config.preferCreateImageBitmap?this.config.preferWorkers&&await d0.isImageBitmapSupported()?s=await d0.loadImageBitmap(i,e):s=await tI(i,e):s=await new Promise((n,o)=>{s=Y.get().createImage(),s.crossOrigin=this.config.crossOrigin,s.src=i,s.complete?n(s):(s.onload=()=>{n(s)},s.onerror=o)});const r=new Et({resource:s,alphaMode:"premultiply-alpha-on-upload",resolution:e.data?.resolution||gd(i),...e.data});return _d(r,t,i)},unload(i){i.destroy(!0)}},iI=[".mp4",".m4v",".webm",".ogg",".ogv",".h264",".avi",".mov"];let yd,bd;function sI(i,e,t){t===void 0&&!e.startsWith("data:")?i.crossOrigin=nI(e):t!==!1&&(i.crossOrigin=typeof t=="string"?t:"anonymous")}function rI(i){return new Promise((e,t)=>{i.addEventListener("canplaythrough",s),i.addEventListener("error",r),i.load();function s(){n(),e()}function r(o){n(),t(o)}function n(){i.removeEventListener("canplaythrough",s),i.removeEventListener("error",r)}})}function nI(i,e=globalThis.location){if(i.startsWith("data:"))return"";e||(e=globalThis.location);const t=new URL(i,document.baseURI);return t.hostname!==e.hostname||t.port!==e.port||t.protocol!==e.protocol?"anonymous":""}function oI(){const i=[],e=[];for(const t of iI){const s=ps.MIME_TYPES[t.substring(1)]||`video/${t.substring(1)}`;on(s)&&(i.push(t),e.includes(s)||e.push(s))}return{validVideoExtensions:i,validVideoMime:e}}const aI={name:"loadVideo",id:"video",extension:{type:b.LoadParser,name:"loadVideo"},test(i){if(!yd||!bd){const{validVideoExtensions:s,validVideoMime:r}=oI();yd=s,bd=r}const e=Hi(i,bd),t=Wi(i,yd);return e||t},async load(i,e,t){const s={...ps.defaultOptions,resolution:e.data?.resolution||gd(i),alphaMode:e.data?.alphaMode||await bm(),...e.data},r=document.createElement("video"),n={preload:s.autoLoad!==!1?"auto":void 0,"webkit-playsinline":s.playsinline!==!1?"":void 0,playsinline:s.playsinline!==!1?"":void 0,muted:s.muted===!0?"":void 0,loop:s.loop===!0?"":void 0,autoplay:s.autoPlay!==!1?"":void 0};Object.keys(n).forEach(l=>{const c=n[l];c!==void 0&&r.setAttribute(l,c)}),s.muted===!0&&(r.muted=!0),sI(r,i,s.crossorigin);const o=document.createElement("source");let a;if(s.mime)a=s.mime;else if(i.startsWith("data:"))a=i.slice(5,i.indexOf(";"));else if(!i.startsWith("blob:")){const l=i.split("?")[0].slice(i.lastIndexOf(".")+1).toLowerCase();a=ps.MIME_TYPES[l]||`video/${l}`}return o.src=i,a&&(o.type=a),new Promise(l=>{const c=async()=>{const h=new ps({...s,resource:r});r.removeEventListener("canplay",c),e.data.preload&&await rI(r),l(_d(h,t,i))};s.preload&&!s.autoPlay&&r.load(),r.addEventListener("canplay",c),r.appendChild(o)})},unload(i){i.destroy(!0)}},p0={extension:{type:b.ResolveParser,name:"resolveTexture"},test:f0.test,parse:i=>({resolution:parseFloat(Oi.RETINA_PREFIX.exec(i)?.[1]??"1"),format:i.split(".").pop(),src:i})},lI={extension:{type:b.ResolveParser,priority:-2,name:"resolveJson"},test:i=>Oi.RETINA_PREFIX.test(i)&&i.endsWith(".json"),parse:p0.parse};class cI{constructor(){this._detections=[],this._initialized=!1,this.resolver=new Oi,this.loader=new RE,this.cache=ae,this._backgroundLoader=new bE(this.loader),this._backgroundLoader.active=!0,this.reset()}async init(e={}){if(this._initialized){H("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");return}if(this._initialized=!0,e.defaultSearchParams&&this.resolver.setDefaultSearchParams(e.defaultSearchParams),e.basePath&&(this.resolver.basePath=e.basePath),e.bundleIdentifier&&this.resolver.setBundleIdentifier(e.bundleIdentifier),e.manifest){let n=e.manifest;typeof n=="string"&&(n=await this.load(n)),this.resolver.addManifest(n)}const t=e.texturePreference?.resolution??1,s=typeof t=="number"?[t]:t,r=await this._detectFormats({preferredFormats:e.texturePreference?.format,skipDetections:e.skipDetections,detections:this._detections});this.resolver.prefer({params:{format:r,resolution:s}}),e.preferences&&this.setPreferences(e.preferences),e.loadOptions&&(this.loader.loadOptions={...this.loader.loadOptions,...e.loadOptions})}add(e){this.resolver.add(e)}async load(e,t){this._initialized||await this.init();const s=zr(e),r=ft(e).map(a=>{if(typeof a!="string"){const l=this.resolver.getAlias(a);return l.some(c=>!this.resolver.hasKey(c))&&this.add(a),Array.isArray(l)?l[0]:l}return this.resolver.hasKey(a)||this.add({alias:a,src:a}),a}),n=this.resolver.resolve(r),o=await this._mapLoadToResolve(n,t);return s?o[r[0]]:o}addBundle(e,t){this.resolver.addBundle(e,t)}async loadBundle(e,t){this._initialized||await this.init();let s=!1;typeof e=="string"&&(s=!0,e=[e]);const r=this.resolver.resolveBundle(e),n={},o=Object.keys(r);let a=0;const l=[],c=()=>{t?.(l.reduce((u,d)=>u+d,0)/a)},h=o.map((u,d)=>{const f=r[u],m=Object.values(f),p=[...new Set(m.flat())].reduce((_,x)=>_+(x.progressSize||1),0);return l.push(0),a+=p,this._mapLoadToResolve(f,_=>{l[d]=_*p,c()}).then(_=>{n[u]=_})});return await Promise.all(h),s?n[e[0]]:n}async backgroundLoad(e){this._initialized||await this.init(),typeof e=="string"&&(e=[e]);const t=this.resolver.resolve(e);this._backgroundLoader.add(Object.values(t))}async backgroundLoadBundle(e){this._initialized||await this.init(),typeof e=="string"&&(e=[e]);const t=this.resolver.resolveBundle(e);Object.values(t).forEach(s=>{this._backgroundLoader.add(Object.values(s))})}reset(){this.resolver.reset(),this.loader.reset(),this.cache.reset(),this._initialized=!1}get(e){if(typeof e=="string")return ae.get(e);const t={};for(let s=0;s<e.length;s++)t[s]=ae.get(e[s]);return t}async _mapLoadToResolve(e,t){const s=[...new Set(Object.values(e))];this._backgroundLoader.active=!1;const r=await this.loader.load(s,t);this._backgroundLoader.active=!0;const n={};return s.forEach(o=>{const a=r[o.src],l=[o.src];o.alias&&l.push(...o.alias),l.forEach(c=>{n[c]=a}),ae.set(l,a)}),n}async unload(e){this._initialized||await this.init();const t=ft(e).map(r=>typeof r!="string"?r.src:r),s=this.resolver.resolve(t);await this._unloadFromResolved(s)}async unloadBundle(e){this._initialized||await this.init(),e=ft(e);const t=this.resolver.resolveBundle(e),s=Object.keys(t).map(r=>this._unloadFromResolved(t[r]));await Promise.all(s)}async _unloadFromResolved(e){const t=Object.values(e);t.forEach(s=>{ae.remove(s.src)}),await this.loader.unload(t)}async _detectFormats(e){let t=[];e.preferredFormats&&(t=Array.isArray(e.preferredFormats)?e.preferredFormats:[e.preferredFormats]);for(const s of e.detections)e.skipDetections||await s.test()?t=await s.add(t):e.skipDetections||(t=await s.remove(t));return t=t.filter((s,r)=>t.indexOf(s)===r),t}get detections(){return this._detections}setPreferences(e){this.loader.parsers.forEach(t=>{t.config&&Object.keys(t.config).filter(s=>s in e).forEach(s=>{t.config[s]=e[s]})})}}const Ls=new cI;V.handleByList(b.LoadParser,Ls.loader.parsers).handleByList(b.ResolveParser,Ls.resolver.parsers).handleByList(b.CacheParser,Ls.cache.parsers).handleByList(b.DetectionParser,Ls.detections),V.add(TE,SE,wE,PE,AE,EE,IE,FE,OE,VE,YE,f0,aI,yE,vE,p0,lI);const m0={loader:b.LoadParser,resolver:b.ResolveParser,cache:b.CacheParser,detection:b.DetectionParser};V.handle(b.Asset,i=>{const e=i.ref;Object.entries(m0).filter(([t])=>!!e[t]).forEach(([t,s])=>V.add(Object.assign(e[t],{extension:e[t].extension??s})))},i=>{const e=i.ref;Object.keys(m0).filter(t=>!!e[t]).forEach(t=>V.remove(e[t]))});class g0{constructor(e){this._attachedDomElements=[],this._renderer=e,this._renderer.runners.postrender.add(this),this._renderer.runners.init.add(this),this._domElement=document.createElement("div"),this._domElement.style.position="absolute",this._domElement.style.top="0",this._domElement.style.left="0",this._domElement.style.pointerEvents="none",this._domElement.style.zIndex="1000"}init(){this._canvasObserver=new Em({domElement:this._domElement,renderer:this._renderer})}addRenderable(e,t){this._attachedDomElements.includes(e)||this._attachedDomElements.push(e)}updateRenderable(e){}validateRenderable(e){return!0}postrender(){const e=this._attachedDomElements;if(e.length===0){this._domElement.remove();return}this._canvasObserver.ensureAttached();for(let t=0;t<e.length;t++){const s=e[t],r=s.element;if(!s.parent||s.globalDisplayStatus<7)r?.remove(),e.splice(t,1),t--;else{this._domElement.contains(r)||(r.style.position="absolute",r.style.pointerEvents="auto",this._domElement.appendChild(r));const n=s.worldTransform,o=s._anchor,a=s.width*o.x,l=s.height*o.y;r.style.transformOrigin=`${a}px ${l}px`,r.style.transform=`matrix(${n.a}, ${n.b}, ${n.c}, ${n.d}, ${n.tx-a}, ${n.ty-l})`,r.style.opacity=s.groupAlpha.toString()}}}destroy(){this._renderer.runners.postrender.remove(this);for(let e=0;e<this._attachedDomElements.length;e++)this._attachedDomElements[e].element?.remove();this._attachedDomElements.length=0,this._domElement.remove(),this._canvasObserver.destroy(),this._renderer=null}}g0.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"dom"};class hI{constructor(){this.interactionFrequency=10,this._deltaTime=0,this._didMove=!1,this._tickerAdded=!1,this._pauseUpdate=!0}init(e){this.removeTickerListener(),this.events=e,this.interactionFrequency=10,this._deltaTime=0,this._didMove=!1,this._tickerAdded=!1,this._pauseUpdate=!0}get pauseUpdate(){return this._pauseUpdate}set pauseUpdate(e){this._pauseUpdate=e}addTickerListener(){this._tickerAdded||!this.domElement||(Je.system.add(this._tickerUpdate,this,Bi.INTERACTION),this._tickerAdded=!0)}removeTickerListener(){this._tickerAdded&&(Je.system.remove(this._tickerUpdate,this),this._tickerAdded=!1)}pointerMoved(){this._didMove=!0}_update(){if(!this.domElement||this._pauseUpdate)return;if(this._didMove){this._didMove=!1;return}const e=this.events._rootPointerEvent;this.events.supportsTouchEvents&&e.pointerType==="touch"||globalThis.document.dispatchEvent(this.events.supportsPointerEvents?new PointerEvent("pointermove",{clientX:e.clientX,clientY:e.clientY,pointerType:e.pointerType,pointerId:e.pointerId}):new MouseEvent("mousemove",{clientX:e.clientX,clientY:e.clientY}))}_tickerUpdate(e){this._deltaTime+=e.deltaTime,!(this._deltaTime<this.interactionFrequency)&&(this._deltaTime=0,this._update())}destroy(){this.removeTickerListener(),this.events=null,this.domElement=null,this._deltaTime=0,this._didMove=!1,this._tickerAdded=!1,this._pauseUpdate=!0}}const Nt=new hI;class an extends gs{constructor(){super(...arguments),this.client=new X,this.movement=new X,this.offset=new X,this.global=new X,this.screen=new X}get clientX(){return this.client.x}get clientY(){return this.client.y}get x(){return this.clientX}get y(){return this.clientY}get movementX(){return this.movement.x}get movementY(){return this.movement.y}get offsetX(){return this.offset.x}get offsetY(){return this.offset.y}get globalX(){return this.global.x}get globalY(){return this.global.y}get screenX(){return this.screen.x}get screenY(){return this.screen.y}getLocalPosition(e,t,s){return e.worldTransform.applyInverse(s||this.global,t)}getModifierState(e){return"getModifierState"in this.nativeEvent&&this.nativeEvent.getModifierState(e)}initMouseEvent(e,t,s,r,n,o,a,l,c,h,u,d,f,m,g){throw new Error("Method not implemented.")}}class _t extends an{constructor(){super(...arguments),this.width=0,this.height=0,this.isPrimary=!1}getCoalescedEvents(){return this.type==="pointermove"||this.type==="mousemove"||this.type==="touchmove"?[this]:[]}getPredictedEvents(){throw new Error("getPredictedEvents is not supported!")}}class Xi extends an{constructor(){super(...arguments),this.DOM_DELTA_PIXEL=0,this.DOM_DELTA_LINE=1,this.DOM_DELTA_PAGE=2}}Xi.DOM_DELTA_PIXEL=0,Xi.DOM_DELTA_LINE=1,Xi.DOM_DELTA_PAGE=2;const uI=2048,dI=new X,Ns=new X;class fI{constructor(e){this.dispatch=new Ze,this.moveOnAll=!1,this.enableGlobalMoveEvents=!0,this.mappingState={trackingData:{}},this.eventPool=new Map,this._allInteractiveElements=[],this._hitElements=[],this._isPointerMoveEvent=!1,this.rootTarget=e,this.hitPruneFn=this.hitPruneFn.bind(this),this.hitTestFn=this.hitTestFn.bind(this),this.mapPointerDown=this.mapPointerDown.bind(this),this.mapPointerMove=this.mapPointerMove.bind(this),this.mapPointerOut=this.mapPointerOut.bind(this),this.mapPointerOver=this.mapPointerOver.bind(this),this.mapPointerUp=this.mapPointerUp.bind(this),this.mapPointerUpOutside=this.mapPointerUpOutside.bind(this),this.mapWheel=this.mapWheel.bind(this),this.mappingTable={},this.addEventMapping("pointerdown",this.mapPointerDown),this.addEventMapping("pointermove",this.mapPointerMove),this.addEventMapping("pointerout",this.mapPointerOut),this.addEventMapping("pointerleave",this.mapPointerOut),this.addEventMapping("pointerover",this.mapPointerOver),this.addEventMapping("pointerup",this.mapPointerUp),this.addEventMapping("pointerupoutside",this.mapPointerUpOutside),this.addEventMapping("wheel",this.mapWheel)}addEventMapping(e,t){this.mappingTable[e]||(this.mappingTable[e]=[]),this.mappingTable[e].push({fn:t,priority:0}),this.mappingTable[e].sort((s,r)=>s.priority-r.priority)}dispatchEvent(e,t){e.propagationStopped=!1,e.propagationImmediatelyStopped=!1,this.propagate(e,t),this.dispatch.emit(t||e.type,e)}mapEvent(e){if(!this.rootTarget)return;const t=this.mappingTable[e.type];if(t)for(let s=0,r=t.length;s<r;s++)t[s].fn(e);else H(`[EventBoundary]: Event mapping not defined for ${e.type}`)}hitTest(e,t){Nt.pauseUpdate=!0;const r=this._isPointerMoveEvent&&this.enableGlobalMoveEvents?"hitTestMoveRecursive":"hitTestRecursive",n=this[r](this.rootTarget,this.rootTarget.eventMode,dI.set(e,t),this.hitTestFn,this.hitPruneFn);return n&&n[0]}propagate(e,t){if(!e.target)return;const s=e.composedPath();e.eventPhase=e.CAPTURING_PHASE;for(let r=0,n=s.length-1;r<n;r++)if(e.currentTarget=s[r],this.notifyTarget(e,t),e.propagationStopped||e.propagationImmediatelyStopped)return;if(e.eventPhase=e.AT_TARGET,e.currentTarget=e.target,this.notifyTarget(e,t),!(e.propagationStopped||e.propagationImmediatelyStopped)){e.eventPhase=e.BUBBLING_PHASE;for(let r=s.length-2;r>=0;r--)if(e.currentTarget=s[r],this.notifyTarget(e,t),e.propagationStopped||e.propagationImmediatelyStopped)return}}all(e,t,s=this._allInteractiveElements){if(s.length===0)return;e.eventPhase=e.BUBBLING_PHASE;const r=Array.isArray(t)?t:[t];for(let n=s.length-1;n>=0;n--)r.forEach(o=>{e.currentTarget=s[n],this.notifyTarget(e,o)})}propagationPath(e){const t=[e];for(let s=0;s<uI&&e!==this.rootTarget&&e.parent;s++){if(!e.parent)throw new Error("Cannot find propagation path to disconnected target");t.push(e.parent),e=e.parent}return t.reverse(),t}hitTestMoveRecursive(e,t,s,r,n,o=!1){let a=!1;if(this._interactivePrune(e))return null;if((e.eventMode==="dynamic"||t==="dynamic")&&(Nt.pauseUpdate=!1),e.interactiveChildren&&e.children){const h=e.children;for(let u=h.length-1;u>=0;u--){const d=h[u],f=this.hitTestMoveRecursive(d,this._isInteractive(t)?t:d.eventMode,s,r,n,o||n(e,s));if(f){if(f.length>0&&!f[f.length-1].parent)continue;const m=e.isInteractive();(f.length>0||m)&&(m&&this._allInteractiveElements.push(e),f.push(e)),this._hitElements.length===0&&(this._hitElements=f),a=!0}}}const l=this._isInteractive(t),c=e.isInteractive();return c&&c&&this._allInteractiveElements.push(e),o||this._hitElements.length>0?null:a?this._hitElements:l&&!n(e,s)&&r(e,s)?c?[e]:[]:null}hitTestRecursive(e,t,s,r,n){if(this._interactivePrune(e)||n(e,s))return null;if((e.eventMode==="dynamic"||t==="dynamic")&&(Nt.pauseUpdate=!1),e.interactiveChildren&&e.children){const l=e.children,c=s;for(let h=l.length-1;h>=0;h--){const u=l[h],d=this.hitTestRecursive(u,this._isInteractive(t)?t:u.eventMode,c,r,n);if(d){if(d.length>0&&!d[d.length-1].parent)continue;const f=e.isInteractive();return(d.length>0||f)&&d.push(e),d}}}const o=this._isInteractive(t),a=e.isInteractive();return o&&r(e,s)?a?[e]:[]:null}_isInteractive(e){return e==="static"||e==="dynamic"}_interactivePrune(e){return!e||!e.visible||!e.renderable||!e.measurable||e.eventMode==="none"||e.eventMode==="passive"&&!e.interactiveChildren}hitPruneFn(e,t){if(e.hitArea&&(e.worldTransform.applyInverse(t,Ns),!e.hitArea.contains(Ns.x,Ns.y)))return!0;if(e.effects&&e.effects.length)for(let s=0;s<e.effects.length;s++){const r=e.effects[s];if(r.containsPoint&&!r.containsPoint(t,this.hitTestFn))return!0}return!1}hitTestFn(e,t){return e.hitArea?!0:e?.containsPoint?(e.worldTransform.applyInverse(t,Ns),e.containsPoint(Ns)):!1}notifyTarget(e,t){if(!e.currentTarget.isInteractive())return;t??(t=e.type);const s=`on${t}`;e.currentTarget[s]?.(e);const r=e.eventPhase===e.CAPTURING_PHASE||e.eventPhase===e.AT_TARGET?`${t}capture`:t;this._notifyListeners(e,r),e.eventPhase===e.AT_TARGET&&this._notifyListeners(e,t)}mapPointerDown(e){if(!(e instanceof _t)){H("EventBoundary cannot map a non-pointer event as a pointer event");return}const t=this.createPointerEvent(e);if(this.dispatchEvent(t,"pointerdown"),t.pointerType==="touch")this.dispatchEvent(t,"touchstart");else if(t.pointerType==="mouse"||t.pointerType==="pen"){const r=t.button===2;this.dispatchEvent(t,r?"rightdown":"mousedown")}const s=this.trackingData(e.pointerId);s.pressTargetsByButton[e.button]=t.composedPath(),this.freeEvent(t)}mapPointerMove(e){if(!(e instanceof _t)){H("EventBoundary cannot map a non-pointer event as a pointer event");return}this._allInteractiveElements.length=0,this._hitElements.length=0,this._isPointerMoveEvent=!0;const t=this.createPointerEvent(e);this._isPointerMoveEvent=!1;const s=t.pointerType==="mouse"||t.pointerType==="pen",r=this.trackingData(e.pointerId),n=this.findMountedTarget(r.overTargets);if(r.overTargets?.length>0&&n!==t.target){const l=e.type==="mousemove"?"mouseout":"pointerout",c=this.createPointerEvent(e,l,n);if(this.dispatchEvent(c,"pointerout"),s&&this.dispatchEvent(c,"mouseout"),!t.composedPath().includes(n)){const h=this.createPointerEvent(e,"pointerleave",n);for(h.eventPhase=h.AT_TARGET;h.target&&!t.composedPath().includes(h.target);)h.currentTarget=h.target,this.notifyTarget(h),s&&this.notifyTarget(h,"mouseleave"),h.target=h.target.parent;this.freeEvent(h)}this.freeEvent(c)}if(n!==t.target){const l=e.type==="mousemove"?"mouseover":"pointerover",c=this.clonePointerEvent(t,l);this.dispatchEvent(c,"pointerover"),s&&this.dispatchEvent(c,"mouseover");let h=n?.parent;for(;h&&h!==this.rootTarget.parent&&h!==t.target;)h=h.parent;if(!h||h===this.rootTarget.parent){const d=this.clonePointerEvent(t,"pointerenter");for(d.eventPhase=d.AT_TARGET;d.target&&d.target!==n&&d.target!==this.rootTarget.parent;)d.currentTarget=d.target,this.notifyTarget(d),s&&this.notifyTarget(d,"mouseenter"),d.target=d.target.parent;this.freeEvent(d)}this.freeEvent(c)}const o=[],a=this.enableGlobalMoveEvents??!0;this.moveOnAll?o.push("pointermove"):this.dispatchEvent(t,"pointermove"),a&&o.push("globalpointermove"),t.pointerType==="touch"&&(this.moveOnAll?o.splice(1,0,"touchmove"):this.dispatchEvent(t,"touchmove"),a&&o.push("globaltouchmove")),s&&(this.moveOnAll?o.splice(1,0,"mousemove"):this.dispatchEvent(t,"mousemove"),a&&o.push("globalmousemove"),this.cursor=t.target?.cursor),o.length>0&&this.all(t,o),this._allInteractiveElements.length=0,this._hitElements.length=0,r.overTargets=t.composedPath(),this.freeEvent(t)}mapPointerOver(e){if(!(e instanceof _t)){H("EventBoundary cannot map a non-pointer event as a pointer event");return}const t=this.trackingData(e.pointerId),s=this.createPointerEvent(e),r=s.pointerType==="mouse"||s.pointerType==="pen";this.dispatchEvent(s,"pointerover"),r&&this.dispatchEvent(s,"mouseover"),s.pointerType==="mouse"&&(this.cursor=s.target?.cursor);const n=this.clonePointerEvent(s,"pointerenter");for(n.eventPhase=n.AT_TARGET;n.target&&n.target!==this.rootTarget.parent;)n.currentTarget=n.target,this.notifyTarget(n),r&&this.notifyTarget(n,"mouseenter"),n.target=n.target.parent;t.overTargets=s.composedPath(),this.freeEvent(s),this.freeEvent(n)}mapPointerOut(e){if(!(e instanceof _t)){H("EventBoundary cannot map a non-pointer event as a pointer event");return}const t=this.trackingData(e.pointerId);if(t.overTargets){const s=e.pointerType==="mouse"||e.pointerType==="pen",r=this.findMountedTarget(t.overTargets),n=this.createPointerEvent(e,"pointerout",r);this.dispatchEvent(n),s&&this.dispatchEvent(n,"mouseout");const o=this.createPointerEvent(e,"pointerleave",r);for(o.eventPhase=o.AT_TARGET;o.target&&o.target!==this.rootTarget.parent;)o.currentTarget=o.target,this.notifyTarget(o),s&&this.notifyTarget(o,"mouseleave"),o.target=o.target.parent;t.overTargets=null,this.freeEvent(n),this.freeEvent(o)}this.cursor=null}mapPointerUp(e){if(!(e instanceof _t)){H("EventBoundary cannot map a non-pointer event as a pointer event");return}const t=performance.now(),s=this.createPointerEvent(e);if(this.dispatchEvent(s,"pointerup"),s.pointerType==="touch")this.dispatchEvent(s,"touchend");else if(s.pointerType==="mouse"||s.pointerType==="pen"){const a=s.button===2;this.dispatchEvent(s,a?"rightup":"mouseup")}const r=this.trackingData(e.pointerId),n=this.findMountedTarget(r.pressTargetsByButton[e.button]);let o=n;if(n&&!s.composedPath().includes(n)){let a=n;for(;a&&!s.composedPath().includes(a);){if(s.currentTarget=a,this.notifyTarget(s,"pointerupoutside"),s.pointerType==="touch")this.notifyTarget(s,"touchendoutside");else if(s.pointerType==="mouse"||s.pointerType==="pen"){const l=s.button===2;this.notifyTarget(s,l?"rightupoutside":"mouseupoutside")}a=a.parent}delete r.pressTargetsByButton[e.button],o=a}if(o){const a=this.clonePointerEvent(s,"click");a.target=o,a.path=null,r.clicksByButton[e.button]||(r.clicksByButton[e.button]={clickCount:0,target:a.target,timeStamp:t});const l=r.clicksByButton[e.button];if(l.target===a.target&&t-l.timeStamp<200?++l.clickCount:l.clickCount=1,l.target=a.target,l.timeStamp=t,a.detail=l.clickCount,a.pointerType==="mouse"){const c=a.button===2;this.dispatchEvent(a,c?"rightclick":"click")}else a.pointerType==="touch"&&this.dispatchEvent(a,"tap");this.dispatchEvent(a,"pointertap"),this.freeEvent(a)}this.freeEvent(s)}mapPointerUpOutside(e){if(!(e instanceof _t)){H("EventBoundary cannot map a non-pointer event as a pointer event");return}const t=this.trackingData(e.pointerId),s=this.findMountedTarget(t.pressTargetsByButton[e.button]),r=this.createPointerEvent(e);if(s){let n=s;for(;n;)r.currentTarget=n,this.notifyTarget(r,"pointerupoutside"),r.pointerType==="touch"?this.notifyTarget(r,"touchendoutside"):(r.pointerType==="mouse"||r.pointerType==="pen")&&this.notifyTarget(r,r.button===2?"rightupoutside":"mouseupoutside"),n=n.parent;delete t.pressTargetsByButton[e.button]}this.freeEvent(r)}mapWheel(e){if(!(e instanceof Xi)){H("EventBoundary cannot map a non-wheel event as a wheel event");return}const t=this.createWheelEvent(e);this.dispatchEvent(t),this.freeEvent(t)}findMountedTarget(e){if(!e)return null;let t=e[0];for(let s=1;s<e.length&&e[s].parent===t;s++)t=e[s];return t}createPointerEvent(e,t,s){const r=this.allocateEvent(_t);return this.copyPointerData(e,r),this.copyMouseData(e,r),this.copyData(e,r),r.nativeEvent=e.nativeEvent,r.originalEvent=e,r.target=s??this.hitTest(r.global.x,r.global.y)??this._hitElements[0],typeof t=="string"&&(r.type=t),r}createWheelEvent(e){const t=this.allocateEvent(Xi);return this.copyWheelData(e,t),this.copyMouseData(e,t),this.copyData(e,t),t.nativeEvent=e.nativeEvent,t.originalEvent=e,t.target=this.hitTest(t.global.x,t.global.y),t}clonePointerEvent(e,t){const s=this.allocateEvent(_t);return s.nativeEvent=e.nativeEvent,s.originalEvent=e.originalEvent,this.copyPointerData(e,s),this.copyMouseData(e,s),this.copyData(e,s),s.target=e.target,s.path=e.composedPath().slice(),s.type=t??s.type,s}copyWheelData(e,t){t.deltaMode=e.deltaMode,t.deltaX=e.deltaX,t.deltaY=e.deltaY,t.deltaZ=e.deltaZ}copyPointerData(e,t){e instanceof _t&&t instanceof _t&&(t.pointerId=e.pointerId,t.width=e.width,t.height=e.height,t.isPrimary=e.isPrimary,t.pointerType=e.pointerType,t.pressure=e.pressure,t.tangentialPressure=e.tangentialPressure,t.tiltX=e.tiltX,t.tiltY=e.tiltY,t.twist=e.twist)}copyMouseData(e,t){e instanceof an&&t instanceof an&&(t.altKey=e.altKey,t.button=e.button,t.buttons=e.buttons,t.client.copyFrom(e.client),t.ctrlKey=e.ctrlKey,t.metaKey=e.metaKey,t.movement.copyFrom(e.movement),t.screen.copyFrom(e.screen),t.shiftKey=e.shiftKey,t.global.copyFrom(e.global))}copyData(e,t){t.isTrusted=e.isTrusted,t.srcElement=e.srcElement,t.timeStamp=performance.now(),t.type=e.type,t.detail=e.detail,t.view=e.view,t.which=e.which,t.layer.copyFrom(e.layer),t.page.copyFrom(e.page)}trackingData(e){return this.mappingState.trackingData[e]||(this.mappingState.trackingData[e]={pressTargetsByButton:{},clicksByButton:{},overTarget:null}),this.mappingState.trackingData[e]}allocateEvent(e){this.eventPool.has(e)||this.eventPool.set(e,[]);const t=this.eventPool.get(e).pop()||new e(this);return t.eventPhase=t.NONE,t.currentTarget=null,t.defaultPrevented=!1,t.path=null,t.target=null,t}freeEvent(e){if(e.manager!==this)throw new Error("It is illegal to free an event not managed by this EventBoundary!");const t=e.constructor;this.eventPool.has(t)||this.eventPool.set(t,[]),this.eventPool.get(t).push(e)}_notifyListeners(e,t){const s=e.currentTarget._events[t];if(s)if("fn"in s)s.once&&e.currentTarget.removeListener(t,s.fn,void 0,!0),s.fn.call(s.context,e);else for(let r=0,n=s.length;r<n&&!e.propagationImmediatelyStopped;r++)s[r].once&&e.currentTarget.removeListener(t,s[r].fn,void 0,!0),s[r].fn.call(s[r].context,e)}}const pI=1,mI={touchstart:"pointerdown",touchend:"pointerup",touchendoutside:"pointerupoutside",touchmove:"pointermove",touchcancel:"pointercancel"},Td=class df{constructor(e){this.supportsTouchEvents="ontouchstart"in globalThis,this.supportsPointerEvents=!!globalThis.PointerEvent,this.domElement=null,this.resolution=1,this.renderer=e,this.rootBoundary=new fI(null),Nt.init(this),this.autoPreventDefault=!0,this._eventsAdded=!1,this._rootPointerEvent=new _t(null),this._rootWheelEvent=new Xi(null),this.cursorStyles={default:"inherit",pointer:"pointer"},this.features=new Proxy({...df.defaultEventFeatures},{set:(t,s,r)=>(s==="globalMove"&&(this.rootBoundary.enableGlobalMoveEvents=r),t[s]=r,!0)}),this._onPointerDown=this._onPointerDown.bind(this),this._onPointerMove=this._onPointerMove.bind(this),this._onPointerUp=this._onPointerUp.bind(this),this._onPointerOverOut=this._onPointerOverOut.bind(this),this.onWheel=this.onWheel.bind(this)}static get defaultEventMode(){return this._defaultEventMode}init(e){const{canvas:t,resolution:s}=this.renderer;this.setTargetElement(t),this.resolution=s,df._defaultEventMode=e.eventMode??"passive",Object.assign(this.features,e.eventFeatures??{}),this.rootBoundary.enableGlobalMoveEvents=this.features.globalMove}resolutionChange(e){this.resolution=e}destroy(){Nt.destroy(),this.setTargetElement(null),this.renderer=null,this._currentCursor=null}setCursor(e){e||(e="default");let t=!0;if(globalThis.OffscreenCanvas&&this.domElement instanceof OffscreenCanvas&&(t=!1),this._currentCursor===e)return;this._currentCursor=e;const s=this.cursorStyles[e];if(s)switch(typeof s){case"string":t&&(this.domElement.style.cursor=s);break;case"function":s(e);break;case"object":t&&Object.assign(this.domElement.style,s);break}else t&&typeof e=="string"&&!Object.prototype.hasOwnProperty.call(this.cursorStyles,e)&&(this.domElement.style.cursor=e)}get pointer(){return this._rootPointerEvent}_onPointerDown(e){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;const t=this._normalizeToPointerData(e);this.autoPreventDefault&&t[0].isNormalized&&(e.cancelable||!("cancelable"in e))&&e.preventDefault();for(let s=0,r=t.length;s<r;s++){const n=t[s],o=this._bootstrapEvent(this._rootPointerEvent,n);this.rootBoundary.mapEvent(o)}this.setCursor(this.rootBoundary.cursor)}_onPointerMove(e){if(!this.features.move)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered,Nt.pointerMoved();const t=this._normalizeToPointerData(e);for(let s=0,r=t.length;s<r;s++){const n=this._bootstrapEvent(this._rootPointerEvent,t[s]);this.rootBoundary.mapEvent(n)}this.setCursor(this.rootBoundary.cursor)}_onPointerUp(e){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;let t=e.target;e.composedPath&&e.composedPath().length>0&&(t=e.composedPath()[0]);const s=t!==this.domElement?"outside":"",r=this._normalizeToPointerData(e);for(let n=0,o=r.length;n<o;n++){const a=this._bootstrapEvent(this._rootPointerEvent,r[n]);a.type+=s,this.rootBoundary.mapEvent(a)}this.setCursor(this.rootBoundary.cursor)}_onPointerOverOut(e){if(!this.features.click)return;this.rootBoundary.rootTarget=this.renderer.lastObjectRendered;const t=this._normalizeToPointerData(e);for(let s=0,r=t.length;s<r;s++){const n=this._bootstrapEvent(this._rootPointerEvent,t[s]);this.rootBoundary.mapEvent(n)}this.setCursor(this.rootBoundary.cursor)}onWheel(e){if(!this.features.wheel)return;const t=this.normalizeWheelEvent(e);this.rootBoundary.rootTarget=this.renderer.lastObjectRendered,this.rootBoundary.mapEvent(t)}setTargetElement(e){this._removeEvents(),this.domElement=e,Nt.domElement=e,this._addEvents()}_addEvents(){if(this._eventsAdded||!this.domElement)return;Nt.addTickerListener();const e=this.domElement.style;e&&(globalThis.navigator.msPointerEnabled?(e.msContentZooming="none",e.msTouchAction="none"):this.supportsPointerEvents&&(e.touchAction="none")),this.supportsPointerEvents?(globalThis.document.addEventListener("pointermove",this._onPointerMove,!0),this.domElement.addEventListener("pointerdown",this._onPointerDown,!0),this.domElement.addEventListener("pointerleave",this._onPointerOverOut,!0),this.domElement.addEventListener("pointerover",this._onPointerOverOut,!0),globalThis.addEventListener("pointerup",this._onPointerUp,!0)):(globalThis.document.addEventListener("mousemove",this._onPointerMove,!0),this.domElement.addEventListener("mousedown",this._onPointerDown,!0),this.domElement.addEventListener("mouseout",this._onPointerOverOut,!0),this.domElement.addEventListener("mouseover",this._onPointerOverOut,!0),globalThis.addEventListener("mouseup",this._onPointerUp,!0),this.supportsTouchEvents&&(this.domElement.addEventListener("touchstart",this._onPointerDown,!0),this.domElement.addEventListener("touchend",this._onPointerUp,!0),this.domElement.addEventListener("touchmove",this._onPointerMove,!0))),this.domElement.addEventListener("wheel",this.onWheel,{passive:!0,capture:!0}),this._eventsAdded=!0}_removeEvents(){if(!this._eventsAdded||!this.domElement)return;Nt.removeTickerListener();const e=this.domElement.style;e&&(globalThis.navigator.msPointerEnabled?(e.msContentZooming="",e.msTouchAction=""):this.supportsPointerEvents&&(e.touchAction="")),this.supportsPointerEvents?(globalThis.document.removeEventListener("pointermove",this._onPointerMove,!0),this.domElement.removeEventListener("pointerdown",this._onPointerDown,!0),this.domElement.removeEventListener("pointerleave",this._onPointerOverOut,!0),this.domElement.removeEventListener("pointerover",this._onPointerOverOut,!0),globalThis.removeEventListener("pointerup",this._onPointerUp,!0)):(globalThis.document.removeEventListener("mousemove",this._onPointerMove,!0),this.domElement.removeEventListener("mousedown",this._onPointerDown,!0),this.domElement.removeEventListener("mouseout",this._onPointerOverOut,!0),this.domElement.removeEventListener("mouseover",this._onPointerOverOut,!0),globalThis.removeEventListener("mouseup",this._onPointerUp,!0),this.supportsTouchEvents&&(this.domElement.removeEventListener("touchstart",this._onPointerDown,!0),this.domElement.removeEventListener("touchend",this._onPointerUp,!0),this.domElement.removeEventListener("touchmove",this._onPointerMove,!0))),this.domElement.removeEventListener("wheel",this.onWheel,!0),this.domElement=null,this._eventsAdded=!1}mapPositionToPoint(e,t,s){const r=this.domElement.isConnected?this.domElement.getBoundingClientRect():{width:this.domElement.width,height:this.domElement.height,left:0,top:0},n=1/this.resolution;e.x=(t-r.left)*(this.domElement.width/r.width)*n,e.y=(s-r.top)*(this.domElement.height/r.height)*n}_normalizeToPointerData(e){const t=[];if(this.supportsTouchEvents&&e instanceof TouchEvent)for(let s=0,r=e.changedTouches.length;s<r;s++){const n=e.changedTouches[s];typeof n.button>"u"&&(n.button=0),typeof n.buttons>"u"&&(n.buttons=1),typeof n.isPrimary>"u"&&(n.isPrimary=e.touches.length===1&&e.type==="touchstart"),typeof n.width>"u"&&(n.width=n.radiusX||1),typeof n.height>"u"&&(n.height=n.radiusY||1),typeof n.tiltX>"u"&&(n.tiltX=0),typeof n.tiltY>"u"&&(n.tiltY=0),typeof n.pointerType>"u"&&(n.pointerType="touch"),typeof n.pointerId>"u"&&(n.pointerId=n.identifier||0),typeof n.pressure>"u"&&(n.pressure=n.force||.5),typeof n.twist>"u"&&(n.twist=0),typeof n.tangentialPressure>"u"&&(n.tangentialPressure=0),typeof n.layerX>"u"&&(n.layerX=n.offsetX=n.clientX),typeof n.layerY>"u"&&(n.layerY=n.offsetY=n.clientY),n.isNormalized=!0,n.type=e.type,t.push(n)}else if(!globalThis.MouseEvent||e instanceof MouseEvent&&(!this.supportsPointerEvents||!(e instanceof globalThis.PointerEvent))){const s=e;typeof s.isPrimary>"u"&&(s.isPrimary=!0),typeof s.width>"u"&&(s.width=1),typeof s.height>"u"&&(s.height=1),typeof s.tiltX>"u"&&(s.tiltX=0),typeof s.tiltY>"u"&&(s.tiltY=0),typeof s.pointerType>"u"&&(s.pointerType="mouse"),typeof s.pointerId>"u"&&(s.pointerId=pI),typeof s.pressure>"u"&&(s.pressure=.5),typeof s.twist>"u"&&(s.twist=0),typeof s.tangentialPressure>"u"&&(s.tangentialPressure=0),s.isNormalized=!0,t.push(s)}else t.push(e);return t}normalizeWheelEvent(e){const t=this._rootWheelEvent;return this._transferMouseData(t,e),t.deltaX=e.deltaX,t.deltaY=e.deltaY,t.deltaZ=e.deltaZ,t.deltaMode=e.deltaMode,this.mapPositionToPoint(t.screen,e.clientX,e.clientY),t.global.copyFrom(t.screen),t.offset.copyFrom(t.screen),t.nativeEvent=e,t.type=e.type,t}_bootstrapEvent(e,t){return e.originalEvent=null,e.nativeEvent=t,e.pointerId=t.pointerId,e.width=t.width,e.height=t.height,e.isPrimary=t.isPrimary,e.pointerType=t.pointerType,e.pressure=t.pressure,e.tangentialPressure=t.tangentialPressure,e.tiltX=t.tiltX,e.tiltY=t.tiltY,e.twist=t.twist,this._transferMouseData(e,t),this.mapPositionToPoint(e.screen,t.clientX,t.clientY),e.global.copyFrom(e.screen),e.offset.copyFrom(e.screen),e.isTrusted=t.isTrusted,e.type==="pointerleave"&&(e.type="pointerout"),e.type.startsWith("mouse")&&(e.type=e.type.replace("mouse","pointer")),e.type.startsWith("touch")&&(e.type=mI[e.type]||e.type),e}_transferMouseData(e,t){e.isTrusted=t.isTrusted,e.srcElement=t.srcElement,e.timeStamp=performance.now(),e.type=t.type,e.altKey=t.altKey,e.button=t.button,e.buttons=t.buttons,e.client.x=t.clientX,e.client.y=t.clientY,e.ctrlKey=t.ctrlKey,e.metaKey=t.metaKey,e.movement.x=t.movementX,e.movement.y=t.movementY,e.page.x=t.pageX,e.page.y=t.pageY,e.relatedTarget=null,e.shiftKey=t.shiftKey}};Td.extension={name:"events",type:[b.WebGLSystem,b.CanvasSystem,b.WebGPUSystem],priority:-1},Td.defaultEventFeatures={move:!0,globalMove:!0,click:!0,wheel:!0};let _0=Td;const gI={onclick:null,onmousedown:null,onmouseenter:null,onmouseleave:null,onmousemove:null,onglobalmousemove:null,onmouseout:null,onmouseover:null,onmouseup:null,onmouseupoutside:null,onpointercancel:null,onpointerdown:null,onpointerenter:null,onpointerleave:null,onpointermove:null,onglobalpointermove:null,onpointerout:null,onpointerover:null,onpointertap:null,onpointerup:null,onpointerupoutside:null,onrightclick:null,onrightdown:null,onrightup:null,onrightupoutside:null,ontap:null,ontouchcancel:null,ontouchend:null,ontouchendoutside:null,ontouchmove:null,onglobaltouchmove:null,ontouchstart:null,onwheel:null,get interactive(){return this.eventMode==="dynamic"||this.eventMode==="static"},set interactive(i){this.eventMode=i?"static":"passive"},_internalEventMode:void 0,get eventMode(){return this._internalEventMode??_0.defaultEventMode},set eventMode(i){this._internalEventMode=i},isInteractive(){return this.eventMode==="static"||this.eventMode==="dynamic"},interactiveChildren:!0,hitArea:null,addEventListener(i,e,t){const s=typeof t=="boolean"&&t||typeof t=="object"&&t.capture,r=typeof t=="object"?t.signal:void 0,n=typeof t=="object"?t.once===!0:!1,o=typeof e=="function"?void 0:e;i=s?`${i}capture`:i;const a=typeof e=="function"?e:e.handleEvent,l=this;r&&r.addEventListener("abort",()=>{l.off(i,a,o)}),n?l.once(i,a,o):l.on(i,a,o)},removeEventListener(i,e,t){const s=typeof t=="boolean"&&t||typeof t=="object"&&t.capture,r=typeof e=="function"?void 0:e;i=s?`${i}capture`:i,e=typeof e=="function"?e:e.handleEvent,this.off(i,e,r)},dispatchEvent(i){if(!(i instanceof gs))throw new Error("Container cannot propagate events outside of the Federated Events API");return i.defaultPrevented=!1,i.path=null,i.target=this,i.manager.dispatchEvent(i),!i.defaultPrevented}};var _I=`in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
    
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;const x0={5:[.153388,.221461,.250301],7:[.071303,.131514,.189879,.214607],9:[.028532,.067234,.124009,.179044,.20236],11:[.0093,.028002,.065984,.121703,.175713,.198596],13:[.002406,.009255,.027867,.065666,.121117,.174868,.197641],15:[489e-6,.002403,.009246,.02784,.065602,.120999,.174697,.197448]},xI=["in vec2 vBlurTexCoords[%size%];","uniform sampler2D uTexture;","out vec4 finalColor;","void main(void)","{","    finalColor = vec4(0.0);","    %blur%","}"].join(`
`);function vI(i){const e=x0[i],t=e.length;let s=xI,r="";const n="finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;";let o;for(let a=0;a<i;a++){let l=n.replace("%index%",a.toString());o=a,a>=t&&(o=i-a-1),l=l.replace("%value%",e[o].toString()),r+=l,r+=`
`}return s=s.replace("%blur%",r),s=s.replace("%size%",i.toString()),s}const yI=`
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;

    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;function bI(i,e){const t=Math.ceil(i/2);let s=yI,r="",n;e?n="vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);":n="vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";for(let o=0;o<i;o++){let a=n.replace("%index%",o.toString());a=a.replace("%sampleIndex%",`${o-(t-1)}.0`),r+=a,r+=`
`}return s=s.replace("%blur%",r),s=s.replace("%size%",i.toString()),s=s.replace("%dimension%",e?"z":"w"),s}function TI(i,e){const t=bI(e,i),s=vI(e);return It.from({vertex:t,fragment:s,name:`blur-${i?"horizontal":"vertical"}-pass-filter`})}var wI=`

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct BlurUniforms {
  uStrength:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    %blur-struct%
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}


@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {

  let filteredCord = filterTextureCoord(aPosition);

  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;

  return VSOutput(
   filterVertexPosition(aPosition),
    %blur-vertex-out%
  );
}

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  %blur-fragment-in%
) -> @location(0) vec4<f32> {

    var   finalColor = vec4(0.0);

    %blur-sampling%

    return finalColor;
}`;function SI(i,e){const t=x0[e],s=t.length,r=[],n=[],o=[];for(let u=0;u<e;u++){r[u]=`@location(${u}) offset${u}: vec2<f32>,`,i?n[u]=`filteredCord + vec2(${u-s+1} * pixelStrength, 0.0),`:n[u]=`filteredCord + vec2(0.0, ${u-s+1} * pixelStrength),`;const d=u<s?u:e-u-1,f=t[d].toString();o[u]=`finalColor += textureSample(uTexture, uSampler, offset${u}) * ${f};`}const a=r.join(`
`),l=n.join(`
`),c=o.join(`
`),h=wI.replace("%blur-struct%",a).replace("%blur-vertex-out%",l).replace("%blur-fragment-in%",a).replace("%blur-sampling%",c).replace("%dimension%",i?"z":"w");return Dt.from({vertex:{source:h,entryPoint:"mainVertex"},fragment:{source:h,entryPoint:"mainFragment"}})}const v0=class sv extends Gi{constructor(e){e={...sv.defaultOptions,...e};const t=TI(e.horizontal,e.kernelSize),s=SI(e.horizontal,e.kernelSize);super({glProgram:t,gpuProgram:s,resources:{blurUniforms:{uStrength:{value:0,type:"f32"}}},...e}),this.horizontal=e.horizontal,this._quality=0,this.quality=e.quality,this.blur=e.strength,this._uniforms=this.resources.blurUniforms.uniforms}apply(e,t,s,r){if(this._uniforms.uStrength=this.strength/this.passes,this.passes===1)e.applyFilter(this,t,s,r);else{const n=ye.getSameSizeTexture(t);let o=t,a=n;this._state.blend=!1;const l=e.renderer.type===et.WEBGPU;for(let c=0;c<this.passes-1;c++){e.applyFilter(this,o,a,c===0?!0:l);const h=a;a=o,o=h}this._state.blend=!0,e.applyFilter(this,o,s,r),ye.returnTexture(n)}}get blur(){return this.strength}set blur(e){this.padding=1+Math.abs(e)*2,this.strength=e}get quality(){return this._quality}set quality(e){this._quality=e,this.passes=e}};v0.defaultOptions={strength:8,quality:4,kernelSize:5};let wd=v0;class y0 extends Gi{constructor(...e){let t=e[0]??{};typeof t=="number"&&(L(J,"BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }"),t={strength:t},e[1]!==void 0&&(t.quality=e[1]),e[2]!==void 0&&(t.resolution=e[2]||"inherit"),e[3]!==void 0&&(t.kernelSize=e[3])),t={...wd.defaultOptions,...t};const{strength:s,strengthX:r,strengthY:n,quality:o,...a}=t;super({...a,compatibleRenderers:et.BOTH,resources:{}}),this._repeatEdgePixels=!1,this.blurXFilter=new wd({horizontal:!0,...t}),this.blurYFilter=new wd({horizontal:!1,...t}),this.quality=o,this.strengthX=r??s,this.strengthY=n??s,this.repeatEdgePixels=!1}apply(e,t,s,r){const n=Math.abs(this.blurXFilter.strength),o=Math.abs(this.blurYFilter.strength);if(n&&o){const a=ye.getSameSizeTexture(t);this.blurXFilter.blendMode="normal",this.blurXFilter.apply(e,t,a,!0),this.blurYFilter.blendMode=this.blendMode,this.blurYFilter.apply(e,a,s,r),ye.returnTexture(a)}else o?(this.blurYFilter.blendMode=this.blendMode,this.blurYFilter.apply(e,t,s,r)):(this.blurXFilter.blendMode=this.blendMode,this.blurXFilter.apply(e,t,s,r))}updatePadding(){this._repeatEdgePixels?this.padding=0:this.padding=Math.max(Math.abs(this.blurXFilter.blur),Math.abs(this.blurYFilter.blur))*2}get strength(){if(this.strengthX!==this.strengthY)throw new Error("BlurFilter's strengthX and strengthY are different");return this.strengthX}set strength(e){this.blurXFilter.blur=this.blurYFilter.blur=e,this.updatePadding()}get quality(){return this.blurXFilter.quality}set quality(e){this.blurXFilter.quality=this.blurYFilter.quality=e}get strengthX(){return this.blurXFilter.blur}set strengthX(e){this.blurXFilter.blur=e,this.updatePadding()}get strengthY(){return this.blurYFilter.blur}set strengthY(e){this.blurYFilter.blur=e,this.updatePadding()}get blur(){return L("8.3.0","BlurFilter.blur is deprecated, please use BlurFilter.strength instead."),this.strength}set blur(e){L("8.3.0","BlurFilter.blur is deprecated, please use BlurFilter.strength instead."),this.strength=e}get blurX(){return L("8.3.0","BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead."),this.strengthX}set blurX(e){L("8.3.0","BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead."),this.strengthX=e}get blurY(){return L("8.3.0","BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead."),this.strengthY}set blurY(e){L("8.3.0","BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead."),this.strengthY=e}get repeatEdgePixels(){return this._repeatEdgePixels}set repeatEdgePixels(e){this._repeatEdgePixels=e,this.updatePadding()}}y0.defaultOptions={strength:8,quality:4,kernelSize:5};var CI=`in vec2 vTextureCoord;
out vec4 finalColor;
uniform sampler2D uTexture;
void main() {
    finalColor = texture(uTexture, vTextureCoord);
}
`,b0=`struct GlobalFilterUniforms {
  uInputSize: vec4<f32>,
  uInputPixel: vec4<f32>,
  uInputClamp: vec4<f32>,
  uOutputFrame: vec4<f32>,
  uGlobalFrame: vec4<f32>,
  uOutputTexture: vec4<f32>,
};

@group(0) @binding(0) var <uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler: sampler;

struct VSOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) uv: vec2<f32>
};

fn filterVertexPosition(aPosition: vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0 * gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord(aPosition: vec2<f32>) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

@vertex
fn mainVertex(
  @location(0) aPosition: vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
) -> @location(0) vec4<f32> {
    return textureSample(uTexture, uSampler, uv);
}
`;class AI extends Gi{constructor(){const e=Dt.from({vertex:{source:b0,entryPoint:"mainVertex"},fragment:{source:b0,entryPoint:"mainFragment"},name:"passthrough-filter"}),t=It.from({vertex:_I,fragment:CI,name:"passthrough-filter"});super({gpuProgram:e,glProgram:t})}}class T0{constructor(e){this._renderer=e}push(e,t,s){this._renderer.renderPipes.batch.break(s),s.add({renderPipeId:"filter",canBundle:!1,action:"pushFilter",container:t,filterEffect:e})}pop(e,t,s){this._renderer.renderPipes.batch.break(s),s.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}execute(e){e.action==="pushFilter"?this._renderer.filter.push(e):e.action==="popFilter"&&this._renderer.filter.pop()}destroy(){this._renderer=null}}T0.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"filter"};const w0=new O;function EI(i,e){e.clear();const t=e.matrix;for(let s=0;s<i.length;s++){const r=i[s];if(r.globalDisplayStatus<7)continue;const n=r.renderGroup??r.parentRenderGroup;n?.isCachedAsTexture?e.matrix=w0.copyFrom(n.textureOffsetInverseTransform).append(r.worldTransform):n?._parentCacheAsTextureRenderGroup?e.matrix=w0.copyFrom(n._parentCacheAsTextureRenderGroup.inverseWorldTransform).append(r.groupTransform):e.matrix=r.worldTransform,e.addBounds(r.bounds)}return e.matrix=t,e}const II=new Rs({attributes:{aPosition:{buffer:new Float32Array([0,0,1,0,1,1,0,1]),format:"float32x2",stride:8,offset:0}},indexBuffer:new Uint32Array([0,1,2,0,2,3])});class PI{constructor(){this.skip=!1,this.inputTexture=null,this.backTexture=null,this.filters=null,this.bounds=new De,this.container=null,this.blendRequired=!1,this.outputRenderSurface=null,this.globalFrame={x:0,y:0,width:0,height:0},this.firstEnabledIndex=-1,this.lastEnabledIndex=-1}}class S0{constructor(e){this._filterStackIndex=0,this._filterStack=[],this._filterGlobalUniforms=new We({uInputSize:{value:new Float32Array(4),type:"vec4<f32>"},uInputPixel:{value:new Float32Array(4),type:"vec4<f32>"},uInputClamp:{value:new Float32Array(4),type:"vec4<f32>"},uOutputFrame:{value:new Float32Array(4),type:"vec4<f32>"},uGlobalFrame:{value:new Float32Array(4),type:"vec4<f32>"},uOutputTexture:{value:new Float32Array(4),type:"vec4<f32>"}}),this._globalFilterBindGroup=new Gt({}),this.renderer=e}get activeBackTexture(){return this._activeFilterData?.backTexture}push(e){const t=this.renderer,s=e.filterEffect.filters,r=this._pushFilterData();r.skip=!1,r.filters=s,r.container=e.container,r.outputRenderSurface=t.renderTarget.renderSurface;const n=t.renderTarget.renderTarget.colorTexture.source,o=n.resolution,a=n.antialias;if(s.every(f=>!f.enabled)){r.skip=!0;return}const l=r.bounds;if(this._calculateFilterArea(e,l),this._calculateFilterBounds(r,t.renderTarget.rootViewPort,a,o,1),r.skip)return;const c=this._getPreviousFilterData(),h=this._findFilterResolution(o);let u=0,d=0;c&&(u=c.bounds.minX,d=c.bounds.minY),this._calculateGlobalFrame(r,u,d,h,n.width,n.height),this._setupFilterTextures(r,l,t,c)}generateFilteredTexture({texture:e,filters:t}){const s=this._pushFilterData();this._activeFilterData=s,s.skip=!1,s.filters=t;const r=e.source,n=r.resolution,o=r.antialias;if(t.every(f=>!f.enabled))return s.skip=!0,e;const a=s.bounds;if(a.addRect(e.frame),this._calculateFilterBounds(s,a.rectangle,o,n,0),s.skip)return e;const l=n;this._calculateGlobalFrame(s,0,0,l,r.width,r.height),s.outputRenderSurface=ye.getOptimalTexture(a.width,a.height,s.resolution,s.antialias),s.backTexture=k.EMPTY,s.inputTexture=e,this.renderer.renderTarget.finishRenderPass(),this._applyFiltersToTexture(s,!0);const d=s.outputRenderSurface;return d.source.alphaMode="premultiplied-alpha",d}pop(){const e=this.renderer,t=this._popFilterData();t.skip||(e.globalUniforms.pop(),e.renderTarget.finishRenderPass(),this._activeFilterData=t,this._applyFiltersToTexture(t,!1),t.blendRequired&&ye.returnTexture(t.backTexture),ye.returnTexture(t.inputTexture))}getBackTexture(e,t,s){const r=e.colorTexture.source._resolution,n=ye.getOptimalTexture(t.width,t.height,r,!1);let o=t.minX,a=t.minY;s&&(o-=s.minX,a-=s.minY),o=Math.floor(o*r),a=Math.floor(a*r);const l=Math.ceil(t.width*r),c=Math.ceil(t.height*r);return this.renderer.renderTarget.copyToTexture(e,n,{x:o,y:a},{width:l,height:c},{x:0,y:0}),n}applyFilter(e,t,s,r){const n=this.renderer,o=this._activeFilterData,l=o.outputRenderSurface===s,c=n.renderTarget.rootRenderTarget.colorTexture.source._resolution,h=this._findFilterResolution(c);let u=0,d=0;if(l){const m=this._findPreviousFilterOffset();u=m.x,d=m.y}this._updateFilterUniforms(t,s,o,u,d,h,l,r);const f=e.enabled?e:this._getPassthroughFilter();this._setupBindGroupsAndRender(f,t,n)}calculateSpriteMatrix(e,t){const s=this._activeFilterData,r=e.set(s.inputTexture._source.width,0,0,s.inputTexture._source.height,s.bounds.minX,s.bounds.minY),n=t.worldTransform.copyTo(O.shared),o=t.renderGroup||t.parentRenderGroup;return o&&o.cacheToLocalTransform&&n.prepend(o.cacheToLocalTransform),n.invert(),r.prepend(n),r.scale(1/t.texture.orig.width,1/t.texture.orig.height),r.translate(t.anchor.x,t.anchor.y),r}destroy(){this._passthroughFilter?.destroy(!0),this._passthroughFilter=null}_getPassthroughFilter(){return this._passthroughFilter??(this._passthroughFilter=new AI),this._passthroughFilter}_setupBindGroupsAndRender(e,t,s){if(s.renderPipes.uniformBatch){const r=s.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);this._globalFilterBindGroup.setResource(r,0)}else this._globalFilterBindGroup.setResource(this._filterGlobalUniforms,0);this._globalFilterBindGroup.setResource(t.source,1),this._globalFilterBindGroup.setResource(t.source.style,2),e.groups[0]=this._globalFilterBindGroup,s.encoder.draw({geometry:II,shader:e,state:e._state,topology:"triangle-list"}),s.type===et.WEBGL&&s.renderTarget.finishRenderPass()}_setupFilterTextures(e,t,s,r){if(e.backTexture=k.EMPTY,e.inputTexture=ye.getOptimalTexture(t.width,t.height,e.resolution,e.antialias),e.blendRequired){s.renderTarget.finishRenderPass();const n=s.renderTarget.getRenderTarget(e.outputRenderSurface);e.backTexture=this.getBackTexture(n,t,r?.bounds)}s.renderTarget.bind(e.inputTexture,!0),s.globalUniforms.push({offset:t})}_calculateGlobalFrame(e,t,s,r,n,o){const a=e.globalFrame;a.x=t*r,a.y=s*r,a.width=n*r,a.height=o*r}_updateFilterUniforms(e,t,s,r,n,o,a,l){const c=this._filterGlobalUniforms.uniforms,h=c.uOutputFrame,u=c.uInputSize,d=c.uInputPixel,f=c.uInputClamp,m=c.uGlobalFrame,g=c.uOutputTexture;a?(h[0]=s.bounds.minX-r,h[1]=s.bounds.minY-n):(h[0]=0,h[1]=0),h[2]=e.frame.width,h[3]=e.frame.height,u[0]=e.source.width,u[1]=e.source.height,u[2]=1/u[0],u[3]=1/u[1],d[0]=e.source.pixelWidth,d[1]=e.source.pixelHeight,d[2]=1/d[0],d[3]=1/d[1],f[0]=.5*d[2],f[1]=.5*d[3],f[2]=e.frame.width*u[2]-.5*d[2],f[3]=e.frame.height*u[3]-.5*d[3];const p=this.renderer.renderTarget.rootRenderTarget.colorTexture;m[0]=r*o,m[1]=n*o,m[2]=p.source.width*o,m[3]=p.source.height*o,t instanceof k&&(t.source.resource=null);const _=this.renderer.renderTarget.getRenderTarget(t);this.renderer.renderTarget.bind(t,!!l),t instanceof k?(g[0]=t.frame.width,g[1]=t.frame.height):(g[0]=_.width,g[1]=_.height),g[2]=_.isRoot?-1:1,this._filterGlobalUniforms.update()}_findFilterResolution(e){let t=this._filterStackIndex-1;for(;t>0&&this._filterStack[t].skip;)--t;return t>0&&this._filterStack[t].inputTexture?this._filterStack[t].inputTexture.source._resolution:e}_findPreviousFilterOffset(){let e=0,t=0,s=this._filterStackIndex;for(;s>0;){s--;const r=this._filterStack[s];if(!r.skip){e=r.bounds.minX,t=r.bounds.minY;break}}return{x:e,y:t}}_calculateFilterArea(e,t){if(e.renderables?EI(e.renderables,t):e.filterEffect.filterArea?(t.clear(),t.addRect(e.filterEffect.filterArea),t.applyMatrix(e.container.worldTransform)):e.container.getFastGlobalBounds(!0,t),e.container){const r=(e.container.renderGroup||e.container.parentRenderGroup).cacheToLocalTransform;r&&t.applyMatrix(r)}}_applyFiltersToTexture(e,t){const s=e.inputTexture,r=e.bounds,n=e.filters,o=e.firstEnabledIndex,a=e.lastEnabledIndex;if(this._globalFilterBindGroup.setResource(s.source.style,2),this._globalFilterBindGroup.setResource(e.backTexture.source,3),o===a)n[o].apply(this,s,e.outputRenderSurface,t);else{let l=e.inputTexture;const c=ye.getOptimalTexture(r.width,r.height,l.source._resolution,!1);let h=c;for(let u=o;u<a;u++){const d=n[u];if(!d.enabled)continue;d.apply(this,l,h,!0);const f=l;l=h,h=f}n[a].apply(this,l,e.outputRenderSurface,t),ye.returnTexture(c)}}_calculateFilterBounds(e,t,s,r,n){const o=this.renderer,a=e.bounds,l=e.filters;let c=1/0,h=0,u=!0,d=!1,f=!1,m=!0,g=-1,p=-1;for(let _=0;_<l.length;_++){const x=l[_];if(!x.enabled)continue;if(g===-1&&(g=_),p=_,c=Math.min(c,x.resolution==="inherit"?r:x.resolution),h+=x.padding,x.antialias==="off"?u=!1:x.antialias==="inherit"&&u&&(u=s),x.clipToViewport||(m=!1),!!!(x.compatibleRenderers&o.type)){f=!1;break}if(x.blendRequired&&!(o.backBuffer?.useBackBuffer??!0)){H("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."),f=!1;break}f=!0,d||(d=x.blendRequired)}if(!f){e.skip=!0;return}if(m&&a.fitBounds(0,t.width/r,0,t.height/r),a.scale(c).ceil().scale(1/c).pad((h|0)*n),!a.isPositive){e.skip=!0;return}e.antialias=u,e.resolution=c,e.blendRequired=d,e.firstEnabledIndex=g,e.lastEnabledIndex=p}_popFilterData(){return this._filterStackIndex--,this._filterStack[this._filterStackIndex]}_getPreviousFilterData(){let e,t=this._filterStackIndex-1;for(;t>0&&(t--,e=this._filterStack[t],!!e.skip););return e}_pushFilterData(){let e=this._filterStack[this._filterStackIndex];return e||(e=this._filterStack[this._filterStackIndex]=new PI),this._filterStackIndex++,e}}S0.extension={type:[b.WebGLSystem,b.WebGPUSystem],name:"filter"};var RI=`in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`,kI=`in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`,C0=`struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`;class MI extends Gi{constructor(e){const{sprite:t,...s}=e,r=new Xp(t.texture),n=new We({uFilterMatrix:{value:new O,type:"mat3x3<f32>"},uMaskClamp:{value:r.uClampFrame,type:"vec4<f32>"},uAlpha:{value:1,type:"f32"},uInverse:{value:e.inverse?1:0,type:"f32"}}),o=Dt.from({vertex:{source:C0,entryPoint:"mainVertex"},fragment:{source:C0,entryPoint:"mainFragment"}}),a=It.from({vertex:kI,fragment:RI,name:"mask-filter"});super({...s,gpuProgram:o,glProgram:a,clipToViewport:!1,resources:{filterUniforms:n,uMaskTexture:t.texture.source}}),this.sprite=t,this._textureMatrix=r}set inverse(e){this.resources.filterUniforms.uniforms.uInverse=e?1:0}get inverse(){return this.resources.filterUniforms.uniforms.uInverse===1}apply(e,t,s,r){this._textureMatrix.texture=this.sprite.texture,e.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix,this.sprite).prepend(this._textureMatrix.mapCoord),this.resources.uMaskTexture=this.sprite.texture.source,e.applyFilter(this,t,s,r)}}class _e extends bu{constructor(e){e instanceof ht&&(e={context:e});const{context:t,roundPixels:s,...r}=e||{};super({label:"Graphics",...r}),this.renderPipeId="graphics",t?this.context=t:(this.context=this._ownedContext=new ht,this.context.autoGarbageCollect=this.autoGarbageCollect),this.didViewUpdate=!0,this.allowChildren=!1,this.roundPixels=s??!1}set context(e){e!==this._context&&(this._context&&(this._context.off("update",this.onViewUpdate,this),this._context.off("unload",this.unload,this)),this._context=e,this._context.on("update",this.onViewUpdate,this),this._context.on("unload",this.unload,this),this.onViewUpdate())}get context(){return this._context}get bounds(){return this._context.bounds}updateBounds(){}containsPoint(e){return this._context.containsPoint(e)}destroy(e){this._ownedContext&&!e?this._ownedContext.destroy(e):(e===!0||e?.context===!0)&&this._context.destroy(e),this._ownedContext=null,this._context=null,super.destroy(e)}_onTouch(e){this._gcLastUsed=e,this._context._gcLastUsed=e}_callContextMethod(e,t){return this.context[e](...t),this}setFillStyle(...e){return this._callContextMethod("setFillStyle",e)}setStrokeStyle(...e){return this._callContextMethod("setStrokeStyle",e)}fill(...e){return this._callContextMethod("fill",e)}stroke(...e){return this._callContextMethod("stroke",e)}texture(...e){return this._callContextMethod("texture",e)}beginPath(){return this._callContextMethod("beginPath",[])}cut(){return this._callContextMethod("cut",[])}arc(...e){return this._callContextMethod("arc",e)}arcTo(...e){return this._callContextMethod("arcTo",e)}arcToSvg(...e){return this._callContextMethod("arcToSvg",e)}bezierCurveTo(...e){return this._callContextMethod("bezierCurveTo",e)}closePath(){return this._callContextMethod("closePath",[])}ellipse(...e){return this._callContextMethod("ellipse",e)}circle(...e){return this._callContextMethod("circle",e)}path(...e){return this._callContextMethod("path",e)}lineTo(...e){return this._callContextMethod("lineTo",e)}moveTo(...e){return this._callContextMethod("moveTo",e)}quadraticCurveTo(...e){return this._callContextMethod("quadraticCurveTo",e)}rect(...e){return this._callContextMethod("rect",e)}roundRect(...e){return this._callContextMethod("roundRect",e)}poly(...e){return this._callContextMethod("poly",e)}regularPoly(...e){return this._callContextMethod("regularPoly",e)}roundPoly(...e){return this._callContextMethod("roundPoly",e)}roundShape(...e){return this._callContextMethod("roundShape",e)}filletRect(...e){return this._callContextMethod("filletRect",e)}chamferRect(...e){return this._callContextMethod("chamferRect",e)}star(...e){return this._callContextMethod("star",e)}svg(...e){return this._callContextMethod("svg",e)}restore(...e){return this._callContextMethod("restore",e)}save(){return this._callContextMethod("save",[])}getTransform(){return this.context.getTransform()}resetTransform(){return this._callContextMethod("resetTransform",[])}rotateTransform(...e){return this._callContextMethod("rotate",e)}scaleTransform(...e){return this._callContextMethod("scale",e)}setTransform(...e){return this._callContextMethod("setTransform",e)}transform(...e){return this._callContextMethod("transform",e)}translateTransform(...e){return this._callContextMethod("translate",e)}clear(){return this._callContextMethod("clear",[])}get fillStyle(){return this._context.fillStyle}set fillStyle(e){this._context.fillStyle=e}get strokeStyle(){return this._context.strokeStyle}set strokeStyle(e){this._context.strokeStyle=e}clone(e=!1){return e?new _e(this._context.clone()):(this._ownedContext=null,new _e(this._context))}lineStyle(e,t,s){L(J,"Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");const r={};return e&&(r.width=e),t&&(r.color=t),s&&(r.alpha=s),this.context.strokeStyle=r,this}beginFill(e,t){L(J,"Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");const s={};return e!==void 0&&(s.color=e),t!==void 0&&(s.alpha=t),this.context.fillStyle=s,this}endFill(){L(J,"Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."),this.context.fill();const e=this.context.strokeStyle;return(e.width!==ht.defaultStrokeStyle.width||e.color!==ht.defaultStrokeStyle.color||e.alpha!==ht.defaultStrokeStyle.alpha)&&this.context.stroke(),this}drawCircle(...e){return L(J,"Graphics#drawCircle has been renamed to Graphics#circle"),this._callContextMethod("circle",e)}drawEllipse(...e){return L(J,"Graphics#drawEllipse has been renamed to Graphics#ellipse"),this._callContextMethod("ellipse",e)}drawPolygon(...e){return L(J,"Graphics#drawPolygon has been renamed to Graphics#poly"),this._callContextMethod("poly",e)}drawRect(...e){return L(J,"Graphics#drawRect has been renamed to Graphics#rect"),this._callContextMethod("rect",e)}drawRoundedRect(...e){return L(J,"Graphics#drawRoundedRect has been renamed to Graphics#roundRect"),this._callContextMethod("roundRect",e)}drawStar(...e){return L(J,"Graphics#drawStar has been renamed to Graphics#star"),this._callContextMethod("star",e)}}const A0=class rv extends Rs{constructor(...e){let t=e[0]??{};t instanceof Float32Array&&(L(J,"use new MeshGeometry({ positions, uvs, indices }) instead"),t={positions:t,uvs:e[1],indices:e[2]}),t={...rv.defaultOptions,...t};const s=t.positions||new Float32Array([0,0,1,0,1,1,0,1]);let r=t.uvs;r||(t.positions?r=new Float32Array(s.length):r=new Float32Array([0,0,1,0,1,1,0,1]));const n=t.indices||new Uint32Array([0,1,2,0,2,3]),o=t.shrinkBuffersToFit,a=new it({data:s,label:"attribute-mesh-positions",shrinkToFit:o,usage:K.VERTEX|K.COPY_DST}),l=new it({data:r,label:"attribute-mesh-uvs",shrinkToFit:o,usage:K.VERTEX|K.COPY_DST}),c=new it({data:n,label:"index-mesh-buffer",shrinkToFit:o,usage:K.INDEX|K.COPY_DST});super({attributes:{aPosition:{buffer:a,format:"float32x2",stride:8,offset:0},aUV:{buffer:l,format:"float32x2",stride:8,offset:0}},indexBuffer:c,topology:t.topology}),this.batchMode="auto"}get positions(){return this.attributes.aPosition.buffer.data}set positions(e){this.attributes.aPosition.buffer.data=e}get uvs(){return this.attributes.aUV.buffer.data}set uvs(e){this.attributes.aUV.buffer.data=e}get indices(){return this.indexBuffer.data}set indices(e){this.indexBuffer.data=e}};A0.defaultOptions={topology:"triangle-list",shrinkBuffersToFit:!1};let Sd=A0;class E0 extends bu{constructor(e,t){const{text:s,resolution:r,style:n,anchor:o,width:a,height:l,roundPixels:c,...h}=e;super({...h}),this.batched=!0,this._resolution=null,this._autoResolution=!0,this._didTextUpdate=!0,this._styleClass=t,this.text=s??"",this.style=n,this.resolution=r??null,this.allowChildren=!1,this._anchor=new Ue({_onUpdate:()=>{this.onViewUpdate()}}),o&&(this.anchor=o),this.roundPixels=c??!1,a!==void 0&&(this.width=a),l!==void 0&&(this.height=l)}get anchor(){return this._anchor}set anchor(e){typeof e=="number"?this._anchor.set(e):this._anchor.copyFrom(e)}set text(e){e=e.toString(),this._text!==e&&(this._text=e,this.onViewUpdate())}get text(){return this._text}set resolution(e){this._autoResolution=e===null,this._resolution=e,this.onViewUpdate()}get resolution(){return this._resolution}get style(){return this._style}set style(e){e||(e={}),this._style?.off("update",this.onViewUpdate,this),e instanceof this._styleClass?this._style=e:this._style=new this._styleClass(e),this._style.on("update",this.onViewUpdate,this),this.onViewUpdate()}get width(){return Math.abs(this.scale.x)*this.bounds.width}set width(e){this._setWidth(e,this.bounds.width)}get height(){return Math.abs(this.scale.y)*this.bounds.height}set height(e){this._setHeight(e,this.bounds.height)}getSize(e){return e||(e={}),e.width=Math.abs(this.scale.x)*this.bounds.width,e.height=Math.abs(this.scale.y)*this.bounds.height,e}setSize(e,t){typeof e=="object"?(t=e.height??e.width,e=e.width):t??(t=e),e!==void 0&&this._setWidth(e,this.bounds.width),t!==void 0&&this._setHeight(t,this.bounds.height)}containsPoint(e){const t=this.bounds.width,s=this.bounds.height,r=-t*this.anchor.x;let n=0;return e.x>=r&&e.x<=r+t&&(n=-s*this.anchor.y,e.y>=n&&e.y<=n+s)}onViewUpdate(){this.didViewUpdate||(this._didTextUpdate=!0),super.onViewUpdate()}destroy(e=!1){super.destroy(e),this.owner=null,this._bounds=null,this._anchor=null,(typeof e=="boolean"?e:e?.style)&&this._style.destroy(e),this._style=null,this._text=null}get styleKey(){return`${this._text}:${this._style.styleKey}:${this._resolution}`}}function I0(i,e){let t=i[0]??{};return(typeof t=="string"||i[1])&&(L(J,`use new ${e}({ text: "hi!", style }) instead`),t={text:t,style:i[1]}),t}let mi=null,Ht=null;function FI(i,e){mi||(mi=Y.get().createCanvas(256,128),Ht=mi.getContext("2d",{willReadFrequently:!0}),Ht.globalCompositeOperation="copy",Ht.globalAlpha=1),(mi.width<i||mi.height<e)&&(mi.width=Mi(i),mi.height=Mi(e))}function P0(i,e,t){for(let s=0,r=4*t*e;s<e;++s,r+=4)if(i[r+3]!==0)return!1;return!0}function R0(i,e,t,s,r){const n=4*e;for(let o=s,a=s*n+4*t;o<=r;++o,a+=n)if(i[a+3]!==0)return!1;return!0}function UI(...i){let e=i[0];e.canvas||(e={canvas:i[0],resolution:i[1]});const{canvas:t}=e,s=Math.min(e.resolution??1,1),r=e.width??t.width,n=e.height??t.height;let o=e.output;if(FI(r,n),!Ht)throw new TypeError("Failed to get canvas 2D context");Ht.drawImage(t,0,0,r,n,0,0,r*s,n*s);const l=Ht.getImageData(0,0,r,n).data;let c=0,h=0,u=r-1,d=n-1;for(;h<n&&P0(l,r,h);)++h;if(h===n)return W.EMPTY;for(;P0(l,r,d);)--d;for(;R0(l,r,c,h,d);)++c;for(;R0(l,r,u,h,d);)--u;return++u,++d,Ht.globalCompositeOperation="source-over",Ht.strokeRect(c,h,u-c,d-h),Ht.globalCompositeOperation="copy",o??(o=new W),o.set(c/s,h/s,(u-c)/s,(d-h)/s),o}const k0=new W;class BI{getCanvasAndContext(e){const{text:t,style:s,resolution:r=1}=e,n=s._getFinalPadding(),o=Xe.measureText(t||" ",s),a=Math.ceil(Math.ceil(Math.max(1,o.width)+n*2)*r),l=Math.ceil(Math.ceil(Math.max(1,o.height)+n*2)*r),c=Lt.getOptimalCanvasAndContext(a,l);this._renderTextToCanvas(t,s,n,r,c);const h=s.trim?UI({canvas:c.canvas,width:a,height:l,resolution:1,output:k0}):k0.set(0,0,a,l);return{canvasAndContext:c,frame:h}}returnCanvasAndContext(e){Lt.returnCanvasAndContext(e)}_renderTextToCanvas(e,t,s,r,n){const{canvas:o,context:a}=n,l=Kr(t),c=Xe.measureText(e||" ",t),h=c.lines,u=c.lineHeight,d=c.lineWidths,f=c.maxLineWidth,m=c.fontProperties,g=o.height;if(a.resetTransform(),a.scale(r,r),a.textBaseline=t.textBaseline,t._stroke?.width){const v=t._stroke;a.lineWidth=v.width,a.miterLimit=v.miterLimit,a.lineJoin=v.join,a.lineCap=v.cap}a.font=l;let p,_;const x=t.dropShadow?2:1;for(let v=0;v<x;++v){const y=t.dropShadow&&v===0,T=y?Math.ceil(Math.max(1,g)+s*2):0,S=T*r;if(y){a.fillStyle="black",a.strokeStyle="black";const P=t.dropShadow,C=P.color,A=P.alpha;a.shadowColor=ue.shared.setValue(C).setAlpha(A).toRgbaString();const B=P.blur*r,D=P.distance*r;a.shadowBlur=B,a.shadowOffsetX=Math.cos(P.angle)*D,a.shadowOffsetY=Math.sin(P.angle)*D+S}else{if(a.fillStyle=t._fill?rn(t._fill,a,c,s*2):null,t._stroke?.width){const P=t._stroke.width*.5+s*2;a.strokeStyle=rn(t._stroke,a,c,P)}a.shadowColor="black"}let w=(u-m.fontSize)/2;u-m.fontSize<0&&(w=0);const E=t._stroke?.width??0;for(let P=0;P<h.length;P++)p=E/2,_=E/2+P*u+m.ascent+w,t.align==="right"?p+=f-d[P]:t.align==="center"&&(p+=(f-d[P])/2),t._stroke?.width&&this._drawLetterSpacing(h[P],t,n,p+s,_+s-T,!0),t._fill!==void 0&&this._drawLetterSpacing(h[P],t,n,p+s,_+s-T)}}_drawLetterSpacing(e,t,s,r,n,o=!1){const{context:a}=s,l=t.letterSpacing;let c=!1;if(Xe.experimentalLetterSpacingSupported&&(Xe.experimentalLetterSpacing?(a.letterSpacing=`${l}px`,a.textLetterSpacing=`${l}px`,c=!0):(a.letterSpacing="0px",a.textLetterSpacing="0px")),l===0||c){o?a.strokeText(e,r,n):a.fillText(e,r,n);return}let h=r;const u=Xe.graphemeSegmenter(e);let d=a.measureText(e).width,f=0;for(let m=0;m<u.length;++m){const g=u[m];o?a.strokeText(g,h,n):a.fillText(g,h,n);let p="";for(let _=m+1;_<u.length;++_)p+=u[_];f=a.measureText(p).width,h+=d-f+l,d=f}}}const Hs=new BI;class OI extends E0{constructor(...e){const t=I0(e,"Text");super(t,Ye),this.renderPipeId="text",t.textureStyle&&(this.textureStyle=t.textureStyle instanceof Ct?t.textureStyle:new Ct(t.textureStyle))}updateBounds(){const e=this._bounds,t=this._anchor;let s=0,r=0;if(this._style.trim){const{frame:n,canvasAndContext:o}=Hs.getCanvasAndContext({text:this.text,style:this._style,resolution:1});Hs.returnCanvasAndContext(o),s=n.width,r=n.height}else{const n=Xe.measureText(this._text,this._style);s=n.width,r=n.height}e.minX=-t._x*s,e.maxX=e.minX+s,e.minY=-t._y*r,e.maxY=e.minY+r}}class DI extends E0{constructor(...e){var t;const s=I0(e,"BitmapText");s.style??(s.style=s.style||{}),(t=s.style).fill??(t.fill=16777215),super(s,Ye),this.renderPipeId="bitmapText"}_onTouch(e){this._gcLastUsed=e;for(const t in this._gpuData)this._gpuData[t]?._onTouch(e)}updateBounds(){const e=this._bounds,t=this._anchor,s=zs.measureText(this.text,this._style),r=s.scale,n=s.offsetY*r;let o=s.width*r,a=s.height*r;const l=this._style._stroke;l&&(o+=l.width,a+=l.width),e.minX=-t._x*o,e.maxX=e.minX+o,e.minY=-t._y*(a+n),e.maxY=e.minY+a}set resolution(e){e!==null&&H("[BitmapText] dynamically updating the resolution is not supported. Resolution should be managed by the BitmapFont.")}get resolution(){return this._resolution}}const M0="http://www.w3.org/2000/svg",F0="http://www.w3.org/1999/xhtml";class U0{constructor(){this.svgRoot=document.createElementNS(M0,"svg"),this.foreignObject=document.createElementNS(M0,"foreignObject"),this.domElement=document.createElementNS(F0,"div"),this.styleElement=document.createElementNS(F0,"style");const{foreignObject:e,svgRoot:t,styleElement:s,domElement:r}=this;e.setAttribute("width","10000"),e.setAttribute("height","10000"),e.style.overflow="hidden",t.appendChild(e),e.appendChild(s),e.appendChild(r),this.image=Y.get().createImage()}destroy(){this.svgRoot.remove(),this.foreignObject.remove(),this.styleElement.remove(),this.domElement.remove(),this.image.src="",this.image.remove(),this.svgRoot=null,this.foreignObject=null,this.styleElement=null,this.domElement=null,this.image=null,this.canvasAndContext=null}}let B0;function GI(i,e,t,s){s||(s=B0||(B0=new U0));const{domElement:r,styleElement:n,svgRoot:o}=s;r.innerHTML=`<style>${e.cssStyle};</style><div style='padding:0'>${i}</div>`,r.setAttribute("style","transform-origin: top left; display: inline-block"),t&&(n.textContent=t),document.body.appendChild(o);const a=r.getBoundingClientRect();o.remove();const l=e.padding*2;return{width:a.width-l,height:a.height-l}}class O0{constructor(){this._tempState=mt.for2d(),this._didUploadHash={}}init(e){e.renderer.runners.contextChange.add(this)}contextChange(){this._didUploadHash={}}start(e,t,s){const r=e.renderer,n=this._didUploadHash[s.uid];r.shader.bind(s,n),n||(this._didUploadHash[s.uid]=!0),r.shader.updateUniformGroup(r.globalUniforms.uniformGroup),r.geometry.bind(t,s.glProgram)}execute(e,t){const s=e.renderer;this._tempState.blendMode=t.blendMode,s.state.set(this._tempState);const r=t.textures.textures;for(let n=0;n<t.textures.count;n++)s.texture.bind(r[n],n);s.geometry.draw(t.topology,t.size,t.start)}}O0.extension={type:[b.WebGLPipesAdaptor],name:"batch"};const ln=mt.for2d();class D0{start(e,t,s){const r=e.renderer,n=r.encoder,o=s.gpuProgram;this._shader=s,this._geometry=t,n.setGeometry(t,o),ln.blendMode="normal",r.pipeline.getPipeline(t,o,ln);const a=r.globalUniforms.bindGroup;n.resetBindGroup(1),n.setBindGroup(0,a,o)}execute(e,t){const s=this._shader.gpuProgram,r=e.renderer,n=r.encoder;if(!t.bindGroup){const l=t.textures;t.bindGroup=qu(l.textures,l.count,r.limits.maxBatchableTextures)}ln.blendMode=t.blendMode;const o=r.bindGroup.getBindGroup(t.bindGroup,s,1),a=r.pipeline.getPipeline(this._geometry,s,ln,t.topology);t.bindGroup._touch(r.gc.now,r.tick),n.setPipeline(a),n.renderPassEncoder.setBindGroup(1,o),n.renderPassEncoder.drawIndexed(t.size,1,t.start)}}D0.extension={type:[b.WebGPUPipesAdaptor],name:"batch"};const Cd=class nv{constructor(e,t){this.state=mt.for2d(),this._batchersByInstructionSet=Object.create(null),this._activeBatches=Object.create(null),this.renderer=e,this._adaptor=t,this._adaptor.init?.(this)}static getBatcher(e){return new this._availableBatchers[e]}buildStart(e){let t=this._batchersByInstructionSet[e.uid];t||(t=this._batchersByInstructionSet[e.uid]=Object.create(null),t.default||(t.default=new rd({maxTextures:this.renderer.limits.maxBatchableTextures}))),this._activeBatches=t,this._activeBatch=this._activeBatches.default;for(const s in this._activeBatches)this._activeBatches[s].begin()}addToBatch(e,t){if(this._activeBatch.name!==e.batcherName){this._activeBatch.break(t);let s=this._activeBatches[e.batcherName];s||(s=this._activeBatches[e.batcherName]=nv.getBatcher(e.batcherName),s.begin()),this._activeBatch=s}this._activeBatch.add(e)}break(e){this._activeBatch.break(e)}buildEnd(e){this._activeBatch.break(e);const t=this._activeBatches;for(const s in t){const r=t[s],n=r.geometry;n.indexBuffer.setDataWithSize(r.indexBuffer,r.indexSize,!0),n.buffers[0].setDataWithSize(r.attributeBuffer.float32View,r.attributeSize,!1)}}upload(e){const t=this._batchersByInstructionSet[e.uid];for(const s in t){const r=t[s],n=r.geometry;r.dirty&&(r.dirty=!1,n.buffers[0].update(r.attributeSize*4))}}execute(e){if(e.action==="startBatch"){const t=e.batcher,s=t.geometry,r=t.shader;this._adaptor.start(this,s,r)}this._adaptor.execute(this,e)}destroy(){this.state=null,this.renderer=null,this._adaptor=null;for(const e in this._activeBatches)this._activeBatches[e].destroy();this._activeBatches=null}};Cd.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"batch"},Cd._availableBatchers=Object.create(null);let G0=Cd;V.handleByMap(b.Batcher,G0._availableBatchers),V.add(rd);const Ws={name:"local-uniform-bit",vertex:{header:`

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `}},zI={...Ws,vertex:{...Ws.vertex,header:Ws.vertex.header.replace("group(1)","group(2)")}},Ad={name:"local-uniform-bit",vertex:{header:`

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `}},LI={name:"texture-bit",vertex:{header:`

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,main:`
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `},fragment:{header:`
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;


        `,main:`
            outColor = textureSample(uTexture, uSampler, vUV);
        `}},NI={name:"texture-bit",vertex:{header:`
            uniform mat3 uTextureMatrix;
        `,main:`
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `},fragment:{header:`
        uniform sampler2D uTexture;


        `,main:`
            outColor = texture(uTexture, vUV);
        `}},HI=new De;class WI extends Mr{constructor(){super(),this.filters=[new MI({sprite:new Be(k.EMPTY),inverse:!1,resolution:"inherit",antialias:"inherit"})]}get sprite(){return this.filters[0].sprite}set sprite(e){this.filters[0].sprite=e}get inverse(){return this.filters[0].inverse}set inverse(e){this.filters[0].inverse=e}}class z0{constructor(e){this._activeMaskStage=[],this._renderer=e}push(e,t,s){const r=this._renderer;if(r.renderPipes.batch.break(s),s.add({renderPipeId:"alphaMask",action:"pushMaskBegin",mask:e,inverse:t._maskOptions.inverse,canBundle:!1,maskedContainer:t}),e.inverse=t._maskOptions.inverse,e.renderMaskToTexture){const n=e.mask;n.includeInBuild=!0,n.collectRenderables(s,r,null),n.includeInBuild=!1}r.renderPipes.batch.break(s),s.add({renderPipeId:"alphaMask",action:"pushMaskEnd",mask:e,maskedContainer:t,inverse:t._maskOptions.inverse,canBundle:!1})}pop(e,t,s){this._renderer.renderPipes.batch.break(s),s.add({renderPipeId:"alphaMask",action:"popMaskEnd",mask:e,inverse:t._maskOptions.inverse,canBundle:!1})}execute(e){const t=this._renderer,s=e.mask.renderMaskToTexture;if(e.action==="pushMaskBegin"){const r=Se.get(WI);if(r.inverse=e.inverse,s){e.mask.mask.measurable=!0;const n=pu(e.mask.mask,!0,HI);e.mask.mask.measurable=!1,n.ceil();const o=t.renderTarget.renderTarget.colorTexture.source,a=ye.getOptimalTexture(n.width,n.height,o._resolution,o.antialias);t.renderTarget.push(a,!0),t.globalUniforms.push({offset:n,worldColor:4294967295});const l=r.sprite;l.texture=a,l.worldTransform.tx=n.minX,l.worldTransform.ty=n.minY,this._activeMaskStage.push({filterEffect:r,maskedContainer:e.maskedContainer,filterTexture:a})}else r.sprite=e.mask.mask,this._activeMaskStage.push({filterEffect:r,maskedContainer:e.maskedContainer})}else if(e.action==="pushMaskEnd"){const r=this._activeMaskStage[this._activeMaskStage.length-1];s&&(t.type===et.WEBGL&&t.renderTarget.finishRenderPass(),t.renderTarget.pop(),t.globalUniforms.pop()),t.filter.push({renderPipeId:"filter",action:"pushFilter",container:r.maskedContainer,filterEffect:r.filterEffect,canBundle:!1})}else if(e.action==="popMaskEnd"){t.filter.pop();const r=this._activeMaskStage.pop();s&&ye.returnTexture(r.filterTexture),Se.return(r.filterEffect)}}destroy(){this._renderer=null,this._activeMaskStage=null}}z0.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"alphaMask"};class L0{constructor(e){this._colorStack=[],this._colorStackIndex=0,this._currentColor=0,this._renderer=e}buildStart(){this._colorStack[0]=15,this._colorStackIndex=1,this._currentColor=15}push(e,t,s){this._renderer.renderPipes.batch.break(s);const n=this._colorStack;n[this._colorStackIndex]=n[this._colorStackIndex-1]&e.mask;const o=this._colorStack[this._colorStackIndex];o!==this._currentColor&&(this._currentColor=o,s.add({renderPipeId:"colorMask",colorMask:o,canBundle:!1})),this._colorStackIndex++}pop(e,t,s){this._renderer.renderPipes.batch.break(s);const n=this._colorStack;this._colorStackIndex--;const o=n[this._colorStackIndex-1];o!==this._currentColor&&(this._currentColor=o,s.add({renderPipeId:"colorMask",colorMask:o,canBundle:!1}))}execute(e){this._renderer.colorMask.setMask(e.colorMask)}destroy(){this._renderer=null,this._colorStack=null}}L0.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"colorMask"};class N0{constructor(e){this._maskStackHash={},this._maskHash=new WeakMap,this._renderer=e}push(e,t,s){var r;const n=e,o=this._renderer;o.renderPipes.batch.break(s),o.renderPipes.blendMode.setBlendMode(n.mask,"none",s),s.add({renderPipeId:"stencilMask",action:"pushMaskBegin",mask:e,inverse:t._maskOptions.inverse,canBundle:!1});const a=n.mask;a.includeInBuild=!0,this._maskHash.has(n)||this._maskHash.set(n,{instructionsStart:0,instructionsLength:0});const l=this._maskHash.get(n);l.instructionsStart=s.instructionSize,a.collectRenderables(s,o,null),a.includeInBuild=!1,o.renderPipes.batch.break(s),s.add({renderPipeId:"stencilMask",action:"pushMaskEnd",mask:e,inverse:t._maskOptions.inverse,canBundle:!1});const c=s.instructionSize-l.instructionsStart-1;l.instructionsLength=c;const h=o.renderTarget.renderTarget.uid;(r=this._maskStackHash)[h]??(r[h]=0)}pop(e,t,s){const r=e,n=this._renderer;n.renderPipes.batch.break(s),n.renderPipes.blendMode.setBlendMode(r.mask,"none",s),s.add({renderPipeId:"stencilMask",action:"popMaskBegin",inverse:t._maskOptions.inverse,canBundle:!1});const o=this._maskHash.get(e);for(let a=0;a<o.instructionsLength;a++)s.instructions[s.instructionSize++]=s.instructions[o.instructionsStart++];s.add({renderPipeId:"stencilMask",action:"popMaskEnd",canBundle:!1})}execute(e){var t;const s=this._renderer,r=s.renderTarget.renderTarget.uid;let n=(t=this._maskStackHash)[r]??(t[r]=0);e.action==="pushMaskBegin"?(s.renderTarget.ensureDepthStencil(),s.stencil.setStencilMode(be.RENDERING_MASK_ADD,n),n++,s.colorMask.setMask(0)):e.action==="pushMaskEnd"?(e.inverse?s.stencil.setStencilMode(be.INVERSE_MASK_ACTIVE,n):s.stencil.setStencilMode(be.MASK_ACTIVE,n),s.colorMask.setMask(15)):e.action==="popMaskBegin"?(s.colorMask.setMask(0),n!==0?s.stencil.setStencilMode(be.RENDERING_MASK_REMOVE,n):(s.renderTarget.clear(null,tt.STENCIL),s.stencil.setStencilMode(be.DISABLED,n)),n--):e.action==="popMaskEnd"&&(e.inverse?s.stencil.setStencilMode(be.INVERSE_MASK_ACTIVE,n):s.stencil.setStencilMode(be.MASK_ACTIVE,n),s.colorMask.setMask(15)),this._maskStackHash[r]=n}destroy(){this._renderer=null,this._maskStackHash=null,this._maskHash=null}}N0.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"stencilMask"};var cn=(i=>(i[i.ELEMENT_ARRAY_BUFFER=34963]="ELEMENT_ARRAY_BUFFER",i[i.ARRAY_BUFFER=34962]="ARRAY_BUFFER",i[i.UNIFORM_BUFFER=35345]="UNIFORM_BUFFER",i))(cn||{});class VI{constructor(e,t){this._lastBindBaseLocation=-1,this._lastBindCallId=-1,this.buffer=e||null,this.updateID=-1,this.byteLength=-1,this.type=t}destroy(){this.buffer=null,this.updateID=-1,this.byteLength=-1,this.type=-1,this._lastBindBaseLocation=-1,this._lastBindCallId=-1}}class H0{constructor(e){this._boundBufferBases=Object.create(null),this._minBaseLocation=0,this._nextBindBaseIndex=this._minBaseLocation,this._bindCallId=0,this._renderer=e,this._managedBuffers=new st({renderer:e,type:"resource",onUnload:this.onBufferUnload.bind(this),name:"glBuffer"})}destroy(){this._managedBuffers.destroy(),this._renderer=null,this._gl=null,this._boundBufferBases={}}contextChange(){this._gl=this._renderer.gl,this.destroyAll(!0),this._maxBindings=this._renderer.limits.maxUniformBindings}getGlBuffer(e){return e._gcLastUsed=this._renderer.gc.now,e._gpuData[this._renderer.uid]||this.createGLBuffer(e)}bind(e){const{_gl:t}=this,s=this.getGlBuffer(e);t.bindBuffer(s.type,s.buffer)}bindBufferBase(e,t){const{_gl:s}=this;this._boundBufferBases[t]!==e&&(this._boundBufferBases[t]=e,e._lastBindBaseLocation=t,s.bindBufferBase(s.UNIFORM_BUFFER,t,e.buffer))}nextBindBase(e){this._bindCallId++,this._minBaseLocation=0,e&&(this._boundBufferBases[0]=null,this._minBaseLocation=1,this._nextBindBaseIndex<1&&(this._nextBindBaseIndex=1))}freeLocationForBufferBase(e){let t=this.getLastBindBaseLocation(e);if(t>=this._minBaseLocation)return e._lastBindCallId=this._bindCallId,t;let s=0,r=this._nextBindBaseIndex;for(;s<2;){r>=this._maxBindings&&(r=this._minBaseLocation,s++);const n=this._boundBufferBases[r];if(n&&n._lastBindCallId===this._bindCallId){r++;continue}break}return t=r,this._nextBindBaseIndex=r+1,s>=2?-1:(e._lastBindCallId=this._bindCallId,this._boundBufferBases[t]=null,t)}getLastBindBaseLocation(e){const t=e._lastBindBaseLocation;return this._boundBufferBases[t]===e?t:-1}bindBufferRange(e,t,s,r){const{_gl:n}=this;s||(s=0),t||(t=0),this._boundBufferBases[t]=null,n.bindBufferRange(n.UNIFORM_BUFFER,t||0,e.buffer,s*256,r||256)}updateBuffer(e){const{_gl:t}=this,s=this.getGlBuffer(e);if(e._updateID===s.updateID)return s;s.updateID=e._updateID,t.bindBuffer(s.type,s.buffer);const r=e.data,n=e.descriptor.usage&K.STATIC?t.STATIC_DRAW:t.DYNAMIC_DRAW;return r?s.byteLength>=r.byteLength?t.bufferSubData(s.type,0,r,0,e._updateSize/r.BYTES_PER_ELEMENT):(s.byteLength=r.byteLength,t.bufferData(s.type,r,n)):(s.byteLength=e.descriptor.size,t.bufferData(s.type,s.byteLength,n)),s}destroyAll(e=!1){this._managedBuffers.removeAll(e)}onBufferUnload(e,t=!1){const s=e._gpuData[this._renderer.uid];s&&(t||this._gl.deleteBuffer(s.buffer))}createGLBuffer(e){const{_gl:t}=this;let s=cn.ARRAY_BUFFER;e.descriptor.usage&K.INDEX?s=cn.ELEMENT_ARRAY_BUFFER:e.descriptor.usage&K.UNIFORM&&(s=cn.UNIFORM_BUFFER);const r=new VI(t.createBuffer(),s);return e._gpuData[this._renderer.uid]=r,this._managedBuffers.add(e),r}resetState(){this._boundBufferBases=Object.create(null)}}H0.extension={type:[b.WebGLSystem],name:"buffer"};const Ed=class ov{constructor(e){this.supports={uint32Indices:!0,uniformBufferObject:!0,vertexArrayObject:!0,srgbTextures:!0,nonPowOf2wrapping:!0,msaa:!0,nonPowOf2mipmaps:!0},this._renderer=e,this.extensions=Object.create(null),this.handleContextLost=this.handleContextLost.bind(this),this.handleContextRestored=this.handleContextRestored.bind(this)}get isLost(){return!this.gl||this.gl.isContextLost()}contextChange(e){this.gl=e,this._renderer.gl=e}init(e){e={...ov.defaultOptions,...e};let t=this.multiView=e.multiView;if(e.context&&t&&(H("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together."),t=!1),t?this.canvas=Y.get().createCanvas(this._renderer.canvas.width,this._renderer.canvas.height):this.canvas=this._renderer.view.canvas,e.context)this.initFromContext(e.context);else{const s=this._renderer.background.alpha<1,r=e.premultipliedAlpha??!0,n=e.antialias&&!this._renderer.backBuffer.useBackBuffer;this.createContext(e.preferWebGLVersion,{alpha:s,premultipliedAlpha:r,antialias:n,stencil:!0,preserveDrawingBuffer:e.preserveDrawingBuffer,powerPreference:e.powerPreference??"default"})}}ensureCanvasSize(e){if(!this.multiView){e!==this.canvas&&H("multiView is disabled, but targetCanvas is not the main canvas");return}const{canvas:t}=this;(t.width<e.width||t.height<e.height)&&(t.width=Math.max(e.width,e.width),t.height=Math.max(e.height,e.height))}initFromContext(e){this.gl=e,this.webGLVersion=e instanceof Y.get().getWebGLRenderingContext()?1:2,this.getExtensions(),this.validateContext(e),this._renderer.runners.contextChange.emit(e);const t=this._renderer.view.canvas;t.addEventListener("webglcontextlost",this.handleContextLost,!1),t.addEventListener("webglcontextrestored",this.handleContextRestored,!1)}createContext(e,t){let s;const r=this.canvas;if(e===2&&(s=r.getContext("webgl2",t)),!s&&(s=r.getContext("webgl",t),!s))throw new Error("This browser does not support WebGL. Try using the canvas renderer");this.gl=s,this.initFromContext(this.gl)}getExtensions(){const{gl:e}=this,t={anisotropicFiltering:e.getExtension("EXT_texture_filter_anisotropic"),floatTextureLinear:e.getExtension("OES_texture_float_linear"),s3tc:e.getExtension("WEBGL_compressed_texture_s3tc"),s3tc_sRGB:e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),etc:e.getExtension("WEBGL_compressed_texture_etc"),etc1:e.getExtension("WEBGL_compressed_texture_etc1"),pvrtc:e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),atc:e.getExtension("WEBGL_compressed_texture_atc"),astc:e.getExtension("WEBGL_compressed_texture_astc"),bptc:e.getExtension("EXT_texture_compression_bptc"),rgtc:e.getExtension("EXT_texture_compression_rgtc"),loseContext:e.getExtension("WEBGL_lose_context")};if(this.webGLVersion===1)this.extensions={...t,drawBuffers:e.getExtension("WEBGL_draw_buffers"),depthTexture:e.getExtension("WEBGL_depth_texture"),vertexArrayObject:e.getExtension("OES_vertex_array_object")||e.getExtension("MOZ_OES_vertex_array_object")||e.getExtension("WEBKIT_OES_vertex_array_object"),uint32ElementIndex:e.getExtension("OES_element_index_uint"),floatTexture:e.getExtension("OES_texture_float"),floatTextureLinear:e.getExtension("OES_texture_float_linear"),textureHalfFloat:e.getExtension("OES_texture_half_float"),textureHalfFloatLinear:e.getExtension("OES_texture_half_float_linear"),vertexAttribDivisorANGLE:e.getExtension("ANGLE_instanced_arrays"),srgb:e.getExtension("EXT_sRGB")};else{this.extensions={...t,colorBufferFloat:e.getExtension("EXT_color_buffer_float")};const s=e.getExtension("WEBGL_provoking_vertex");s&&s.provokingVertexWEBGL(s.FIRST_VERTEX_CONVENTION_WEBGL)}}handleContextLost(e){e.preventDefault(),this._contextLossForced&&(this._contextLossForced=!1,setTimeout(()=>{this.gl.isContextLost()&&this.extensions.loseContext?.restoreContext()},0))}handleContextRestored(){this.getExtensions(),this._renderer.runners.contextChange.emit(this.gl)}destroy(){const e=this._renderer.view.canvas;this._renderer=null,e.removeEventListener("webglcontextlost",this.handleContextLost),e.removeEventListener("webglcontextrestored",this.handleContextRestored),this.gl.useProgram(null),this.extensions.loseContext?.loseContext()}forceContextLoss(){this.extensions.loseContext?.loseContext(),this._contextLossForced=!0}validateContext(e){const t=e.getContextAttributes();t&&!t.stencil&&H("Provided WebGL context does not have a stencil buffer, masks may not render correctly");const s=this.supports,r=this.webGLVersion===2,n=this.extensions;s.uint32Indices=r||!!n.uint32ElementIndex,s.uniformBufferObject=r,s.vertexArrayObject=r||!!n.vertexArrayObject,s.srgbTextures=r||!!n.srgb,s.nonPowOf2wrapping=r,s.nonPowOf2mipmaps=r,s.msaa=r,s.uint32Indices||H("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly")}};Ed.extension={type:[b.WebGLSystem],name:"context"},Ed.defaultOptions={context:null,premultipliedAlpha:!0,preserveDrawingBuffer:!1,powerPreference:void 0,preferWebGLVersion:2,multiView:!1};let $I=Ed;function W0(i,e){for(const t in i.attributes){const s=i.attributes[t],r=e[t];r?(s.format??(s.format=r.format),s.offset??(s.offset=r.offset),s.instance??(s.instance=r.instance)):H(`Attribute ${t} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`)}XI(i)}function XI(i){const{buffers:e,attributes:t}=i,s={},r={};for(const n in e){const o=e[n];s[o.uid]=0,r[o.uid]=0}for(const n in t){const o=t[n];s[o.buffer.uid]+=Zt(o.format).stride}for(const n in t){const o=t[n];o.stride??(o.stride=s[o.buffer.uid]),o.start??(o.start=r[o.buffer.uid]),r[o.buffer.uid]+=Zt(o.format).stride}}var Id=(i=>(i[i.RGBA=6408]="RGBA",i[i.RGB=6407]="RGB",i[i.RG=33319]="RG",i[i.RED=6403]="RED",i[i.RGBA_INTEGER=36249]="RGBA_INTEGER",i[i.RGB_INTEGER=36248]="RGB_INTEGER",i[i.RG_INTEGER=33320]="RG_INTEGER",i[i.RED_INTEGER=36244]="RED_INTEGER",i[i.ALPHA=6406]="ALPHA",i[i.LUMINANCE=6409]="LUMINANCE",i[i.LUMINANCE_ALPHA=6410]="LUMINANCE_ALPHA",i[i.DEPTH_COMPONENT=6402]="DEPTH_COMPONENT",i[i.DEPTH_STENCIL=34041]="DEPTH_STENCIL",i))(Id||{}),V0=(i=>(i[i.TEXTURE_2D=3553]="TEXTURE_2D",i[i.TEXTURE_CUBE_MAP=34067]="TEXTURE_CUBE_MAP",i[i.TEXTURE_2D_ARRAY=35866]="TEXTURE_2D_ARRAY",i[i.TEXTURE_CUBE_MAP_POSITIVE_X=34069]="TEXTURE_CUBE_MAP_POSITIVE_X",i[i.TEXTURE_CUBE_MAP_NEGATIVE_X=34070]="TEXTURE_CUBE_MAP_NEGATIVE_X",i[i.TEXTURE_CUBE_MAP_POSITIVE_Y=34071]="TEXTURE_CUBE_MAP_POSITIVE_Y",i[i.TEXTURE_CUBE_MAP_NEGATIVE_Y=34072]="TEXTURE_CUBE_MAP_NEGATIVE_Y",i[i.TEXTURE_CUBE_MAP_POSITIVE_Z=34073]="TEXTURE_CUBE_MAP_POSITIVE_Z",i[i.TEXTURE_CUBE_MAP_NEGATIVE_Z=34074]="TEXTURE_CUBE_MAP_NEGATIVE_Z",i))(V0||{}),te=(i=>(i[i.UNSIGNED_BYTE=5121]="UNSIGNED_BYTE",i[i.UNSIGNED_SHORT=5123]="UNSIGNED_SHORT",i[i.UNSIGNED_SHORT_5_6_5=33635]="UNSIGNED_SHORT_5_6_5",i[i.UNSIGNED_SHORT_4_4_4_4=32819]="UNSIGNED_SHORT_4_4_4_4",i[i.UNSIGNED_SHORT_5_5_5_1=32820]="UNSIGNED_SHORT_5_5_5_1",i[i.UNSIGNED_INT=5125]="UNSIGNED_INT",i[i.UNSIGNED_INT_10F_11F_11F_REV=35899]="UNSIGNED_INT_10F_11F_11F_REV",i[i.UNSIGNED_INT_2_10_10_10_REV=33640]="UNSIGNED_INT_2_10_10_10_REV",i[i.UNSIGNED_INT_24_8=34042]="UNSIGNED_INT_24_8",i[i.UNSIGNED_INT_5_9_9_9_REV=35902]="UNSIGNED_INT_5_9_9_9_REV",i[i.BYTE=5120]="BYTE",i[i.SHORT=5122]="SHORT",i[i.INT=5124]="INT",i[i.FLOAT=5126]="FLOAT",i[i.FLOAT_32_UNSIGNED_INT_24_8_REV=36269]="FLOAT_32_UNSIGNED_INT_24_8_REV",i[i.HALF_FLOAT=36193]="HALF_FLOAT",i))(te||{});const $0={uint8x2:te.UNSIGNED_BYTE,uint8x4:te.UNSIGNED_BYTE,sint8x2:te.BYTE,sint8x4:te.BYTE,unorm8x2:te.UNSIGNED_BYTE,unorm8x4:te.UNSIGNED_BYTE,snorm8x2:te.BYTE,snorm8x4:te.BYTE,uint16x2:te.UNSIGNED_SHORT,uint16x4:te.UNSIGNED_SHORT,sint16x2:te.SHORT,sint16x4:te.SHORT,unorm16x2:te.UNSIGNED_SHORT,unorm16x4:te.UNSIGNED_SHORT,snorm16x2:te.SHORT,snorm16x4:te.SHORT,float16x2:te.HALF_FLOAT,float16x4:te.HALF_FLOAT,float32:te.FLOAT,float32x2:te.FLOAT,float32x3:te.FLOAT,float32x4:te.FLOAT,uint32:te.UNSIGNED_INT,uint32x2:te.UNSIGNED_INT,uint32x3:te.UNSIGNED_INT,uint32x4:te.UNSIGNED_INT,sint32:te.INT,sint32x2:te.INT,sint32x3:te.INT,sint32x4:te.INT};function YI(i){return $0[i]??$0.float32}const qI={"point-list":0,"line-list":1,"line-strip":3,"triangle-list":4,"triangle-strip":5};class KI{constructor(){this.vaoCache=Object.create(null)}destroy(){this.vaoCache=Object.create(null)}}class X0{constructor(e){this._renderer=e,this._activeGeometry=null,this._activeVao=null,this.hasVao=!0,this.hasInstance=!0,this._managedGeometries=new st({renderer:e,type:"resource",onUnload:this.onGeometryUnload.bind(this),name:"glGeometry"})}contextChange(){const e=this.gl=this._renderer.gl;if(!this._renderer.context.supports.vertexArrayObject)throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");this.destroyAll(!0);const t=this._renderer.context.extensions.vertexArrayObject;t&&(e.createVertexArray=()=>t.createVertexArrayOES(),e.bindVertexArray=r=>t.bindVertexArrayOES(r),e.deleteVertexArray=r=>t.deleteVertexArrayOES(r));const s=this._renderer.context.extensions.vertexAttribDivisorANGLE;s&&(e.drawArraysInstanced=(r,n,o,a)=>{s.drawArraysInstancedANGLE(r,n,o,a)},e.drawElementsInstanced=(r,n,o,a,l)=>{s.drawElementsInstancedANGLE(r,n,o,a,l)},e.vertexAttribDivisor=(r,n)=>s.vertexAttribDivisorANGLE(r,n)),this._activeGeometry=null,this._activeVao=null}bind(e,t){const s=this.gl;this._activeGeometry=e;const r=this.getVao(e,t);this._activeVao!==r&&(this._activeVao=r,s.bindVertexArray(r)),this.updateBuffers()}resetState(){this.unbind()}updateBuffers(){const e=this._activeGeometry,t=this._renderer.buffer;for(let s=0;s<e.buffers.length;s++){const r=e.buffers[s];t.updateBuffer(r)}e._gcLastUsed=this._renderer.gc.now}checkCompatibility(e,t){const s=e.attributes,r=t._attributeData;for(const n in r)if(!s[n])throw new Error(`shader and geometry incompatible, geometry missing the "${n}" attribute`)}getSignature(e,t){const s=e.attributes,r=t._attributeData,n=["g",e.uid];for(const o in s)r[o]&&n.push(o,r[o].location);return n.join("-")}getVao(e,t){return e._gpuData[this._renderer.uid]?.vaoCache[t._key]||this.initGeometryVao(e,t)}initGeometryVao(e,t,s=!0){const r=this._renderer.gl,n=this._renderer.buffer;this._renderer.shader._getProgramData(t),this.checkCompatibility(e,t);const o=this.getSignature(e,t),a=new KI;e._gpuData[this._renderer.uid]=a,this._managedGeometries.add(e);const l=a.vaoCache;let c=l[o];if(c)return l[t._key]=c,c;W0(e,t._attributeData);const h=e.buffers;c=r.createVertexArray(),r.bindVertexArray(c);for(let u=0;u<h.length;u++){const d=h[u];n.bind(d)}return this.activateVao(e,t),l[t._key]=c,l[o]=c,r.bindVertexArray(null),c}onGeometryUnload(e,t=!1){const s=e._gpuData[this._renderer.uid];if(!s)return;const r=s.vaoCache;if(!t)for(const n in r)this._activeVao!==r[n]&&this.resetState(),this.gl.deleteVertexArray(r[n])}destroyAll(e=!1){this._managedGeometries.removeAll(e)}activateVao(e,t){const s=this._renderer.gl,r=this._renderer.buffer,n=e.attributes;e.indexBuffer&&r.bind(e.indexBuffer);let o=null;for(const a in n){const l=n[a],c=l.buffer,h=r.getGlBuffer(c),u=t._attributeData[a];if(u){o!==h&&(r.bind(c),o=h);const d=u.location;s.enableVertexAttribArray(d);const f=Zt(l.format),m=YI(l.format);if(u.format?.substring(1,4)==="int"?s.vertexAttribIPointer(d,f.size,m,l.stride,l.offset):s.vertexAttribPointer(d,f.size,m,f.normalised,l.stride,l.offset),l.instance)if(this.hasInstance){const g=l.divisor??1;s.vertexAttribDivisor(d,g)}else throw new Error("geometry error, GPU Instancing is not supported on this device")}}}draw(e,t,s,r){const{gl:n}=this._renderer,o=this._activeGeometry,a=qI[e||o.topology];if(r??(r=o.instanceCount),o.indexBuffer){const l=o.indexBuffer.data.BYTES_PER_ELEMENT,c=l===2?n.UNSIGNED_SHORT:n.UNSIGNED_INT;r!==1?n.drawElementsInstanced(a,t||o.indexBuffer.data.length,c,(s||0)*l,r):n.drawElements(a,t||o.indexBuffer.data.length,c,(s||0)*l)}else r!==1?n.drawArraysInstanced(a,s||0,t||o.getSize(),r):n.drawArrays(a,s||0,t||o.getSize());return this}unbind(){this.gl.bindVertexArray(null),this._activeVao=null,this._activeGeometry=null}destroy(){this._managedGeometries.destroy(),this._renderer=null,this.gl=null,this._activeVao=null,this._activeGeometry=null}}X0.extension={type:[b.WebGLSystem],name:"geometry"};const jI=new Rs({attributes:{aPosition:[-1,-1,3,-1,-1,3]}}),Pd=class av{constructor(e){this.useBackBuffer=!1,this._useBackBufferThisRender=!1,this._renderer=e}init(e={}){const{useBackBuffer:t,antialias:s}={...av.defaultOptions,...e};this.useBackBuffer=t,this._antialias=s,this._renderer.context.supports.msaa||(H("antialiasing, is not supported on when using the back buffer"),this._antialias=!1),this._state=mt.for2d();const r=new It({vertex:`
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,fragment:`
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,name:"big-triangle"});this._bigTriangleShader=new lt({glProgram:r,resources:{uTexture:k.WHITE.source}})}renderStart(e){const t=this._renderer.renderTarget.getRenderTarget(e.target);if(this._useBackBufferThisRender=this.useBackBuffer&&!!t.isRoot,this._useBackBufferThisRender){const s=this._renderer.renderTarget.getRenderTarget(e.target);this._targetTexture=s.colorTexture,e.target=this._getBackBufferTexture(s.colorTexture)}}renderEnd(){this._presentBackBuffer()}_presentBackBuffer(){const e=this._renderer;e.renderTarget.finishRenderPass(),this._useBackBufferThisRender&&(e.renderTarget.bind(this._targetTexture,!1),this._bigTriangleShader.resources.uTexture=this._backBufferTexture.source,e.encoder.draw({geometry:jI,shader:this._bigTriangleShader,state:this._state}))}_getBackBufferTexture(e){return this._backBufferTexture=this._backBufferTexture||new k({source:new Ee({width:e.width,height:e.height,resolution:e._resolution,antialias:this._antialias})}),this._backBufferTexture.source.resize(e.width,e.height,e._resolution),this._backBufferTexture}destroy(){this._backBufferTexture&&(this._backBufferTexture.destroy(),this._backBufferTexture=null)}};Pd.extension={type:[b.WebGLSystem],name:"backBuffer",priority:1},Pd.defaultOptions={useBackBuffer:!1};let ZI=Pd;class Y0{constructor(e){this._colorMaskCache=15,this._renderer=e}setMask(e){this._colorMaskCache!==e&&(this._colorMaskCache=e,this._renderer.gl.colorMask(!!(e&8),!!(e&4),!!(e&2),!!(e&1)))}}Y0.extension={type:[b.WebGLSystem],name:"colorMask"};class q0{constructor(e){this.commandFinished=Promise.resolve(),this._renderer=e}setGeometry(e,t){this._renderer.geometry.bind(e,t.glProgram)}finishRenderPass(){}draw(e){const t=this._renderer,{geometry:s,shader:r,state:n,skipSync:o,topology:a,size:l,start:c,instanceCount:h}=e;t.shader.bind(r,o),t.geometry.bind(s,t.shader._activeProgram),n&&t.state.set(n),t.geometry.draw(a,l,c,h??s.instanceCount)}destroy(){this._renderer=null}}q0.extension={type:[b.WebGLSystem],name:"encoder"};class K0{constructor(e){this._renderer=e}contextChange(){const e=this._renderer.gl;this.maxTextures=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.maxBatchableTextures=vg(this.maxTextures,e);const t=this._renderer.context.webGLVersion===2;this.maxUniformBindings=t?e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS):0}destroy(){}}K0.extension={type:[b.WebGLSystem],name:"limits"};class JI{constructor(){this.width=-1,this.height=-1,this.msaa=!1,this.msaaRenderBuffer=[]}}const Qt=[];Qt[be.NONE]=void 0,Qt[be.DISABLED]={stencilWriteMask:0,stencilReadMask:0},Qt[be.RENDERING_MASK_ADD]={stencilFront:{compare:"equal",passOp:"increment-clamp"},stencilBack:{compare:"equal",passOp:"increment-clamp"}},Qt[be.RENDERING_MASK_REMOVE]={stencilFront:{compare:"equal",passOp:"decrement-clamp"},stencilBack:{compare:"equal",passOp:"decrement-clamp"}},Qt[be.MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"equal",passOp:"keep"},stencilBack:{compare:"equal",passOp:"keep"}},Qt[be.INVERSE_MASK_ACTIVE]={stencilWriteMask:0,stencilFront:{compare:"not-equal",passOp:"keep"},stencilBack:{compare:"not-equal",passOp:"keep"}};class j0{constructor(e){this._stencilCache={enabled:!1,stencilReference:0,stencilMode:be.NONE},this._renderTargetStencilState=Object.create(null),e.renderTarget.onRenderTargetChange.add(this)}contextChange(e){this._gl=e,this._comparisonFuncMapping={always:e.ALWAYS,never:e.NEVER,equal:e.EQUAL,"not-equal":e.NOTEQUAL,less:e.LESS,"less-equal":e.LEQUAL,greater:e.GREATER,"greater-equal":e.GEQUAL},this._stencilOpsMapping={keep:e.KEEP,zero:e.ZERO,replace:e.REPLACE,invert:e.INVERT,"increment-clamp":e.INCR,"decrement-clamp":e.DECR,"increment-wrap":e.INCR_WRAP,"decrement-wrap":e.DECR_WRAP},this.resetState()}onRenderTargetChange(e){if(this._activeRenderTarget===e)return;this._activeRenderTarget=e;let t=this._renderTargetStencilState[e.uid];t||(t=this._renderTargetStencilState[e.uid]={stencilMode:be.DISABLED,stencilReference:0}),this.setStencilMode(t.stencilMode,t.stencilReference)}resetState(){this._stencilCache.enabled=!1,this._stencilCache.stencilMode=be.NONE,this._stencilCache.stencilReference=0}setStencilMode(e,t){const s=this._renderTargetStencilState[this._activeRenderTarget.uid],r=this._gl,n=Qt[e],o=this._stencilCache;if(s.stencilMode=e,s.stencilReference=t,e===be.DISABLED){this._stencilCache.enabled&&(this._stencilCache.enabled=!1,r.disable(r.STENCIL_TEST));return}this._stencilCache.enabled||(this._stencilCache.enabled=!0,r.enable(r.STENCIL_TEST)),(e!==o.stencilMode||o.stencilReference!==t)&&(o.stencilMode=e,o.stencilReference=t,r.stencilFunc(this._comparisonFuncMapping[n.stencilBack.compare],t,255),r.stencilOp(r.KEEP,r.KEEP,this._stencilOpsMapping[n.stencilBack.passOp]))}}j0.extension={type:[b.WebGLSystem],name:"stencil"};class Z0{constructor(e){this._syncFunctionHash=Object.create(null),this._adaptor=e,this._systemCheck()}_systemCheck(){if(!jm())throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")}ensureUniformGroup(e){const t=this.getUniformGroupData(e);e.buffer||(e.buffer=new it({data:new Float32Array(t.layout.size/4),usage:K.UNIFORM|K.COPY_DST}))}getUniformGroupData(e){return this._syncFunctionHash[e._signature]||this._initUniformGroup(e)}_initUniformGroup(e){const t=e._signature;let s=this._syncFunctionHash[t];if(!s){const r=Object.keys(e.uniformStructures).map(a=>e.uniformStructures[a]),n=this._adaptor.createUboElements(r),o=this._generateUboSync(n.uboElements);s=this._syncFunctionHash[t]={layout:n,syncFunction:o}}return this._syncFunctionHash[t]}_generateUboSync(e){return this._adaptor.generateUboSync(e)}syncUniformGroup(e,t,s){const r=this.getUniformGroupData(e);e.buffer||(e.buffer=new it({data:new Float32Array(r.layout.size/4),usage:K.UNIFORM|K.COPY_DST}));let n=null;return t||(t=e.buffer.data,n=e.buffer.dataInt32),s||(s=0),r.syncFunction(e.uniforms,t,n,s),!0}updateUniformGroup(e){if(e.isStatic&&!e._dirtyId)return!1;e._dirtyId=0;const t=this.syncUniformGroup(e);return e.buffer.update(),t}destroy(){this._syncFunctionHash=null}}const J0={f32:4,i32:4,"vec2<f32>":8,"vec3<f32>":12,"vec4<f32>":16,"vec2<i32>":8,"vec3<i32>":12,"vec4<i32>":16,"mat2x2<f32>":32,"mat3x3<f32>":48,"mat4x4<f32>":64};function QI(i){const e=i.map(n=>({data:n,offset:0,size:0})),t=16;let s=0,r=0;for(let n=0;n<e.length;n++){const o=e[n];if(s=J0[o.data.type],!s)throw new Error(`Unknown type ${o.data.type}`);o.data.size>1&&(s=Math.max(s,t)*o.data.size);const a=s===12?16:s;o.size=s;const l=r%t;l>0&&t-l<a?r+=(t-l)%16:r+=(s-l%s)%s,o.offset=r,r+=s}return r=Math.ceil(r/16)*16,{uboElements:e,size:r}}const gi=[{type:"mat3x3<f32>",test:i=>i.value.a!==void 0,ubo:`
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,uniform:`
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `},{type:"vec4<f32>",test:i=>i.type==="vec4<f32>"&&i.size===1&&i.value.width!==void 0,ubo:`
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,uniform:`
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `},{type:"vec2<f32>",test:i=>i.type==="vec2<f32>"&&i.size===1&&i.value.x!==void 0,ubo:`
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,uniform:`
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `},{type:"vec4<f32>",test:i=>i.type==="vec4<f32>"&&i.size===1&&i.value.red!==void 0,ubo:`
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,uniform:`
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `},{type:"vec3<f32>",test:i=>i.type==="vec3<f32>"&&i.size===1&&i.value.red!==void 0,ubo:`
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,uniform:`
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `}];function Q0(i,e,t,s){const r=[`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];let n=0;for(let a=0;a<i.length;a++){const l=i[a],c=l.data.name;let h=!1,u=0;for(let d=0;d<gi.length;d++)if(gi[d].test(l.data)){u=l.offset/4,r.push(`name = "${c}";`,`offset += ${u-n};`,gi[d][e]||gi[d].ubo),h=!0;break}if(!h)if(l.data.size>1)u=l.offset/4,r.push(t(l,u-n));else{const d=s[l.data.type];u=l.offset/4,r.push(`
                    v = uv.${c};
                    offset += ${u-n};
                    ${d};
                `)}n=u}const o=r.join(`
`);return new Function("uv","data","dataInt32","offset",o)}function Yi(i,e){return`
        for (let i = 0; i < ${i*e}; i++) {
            data[offset + (((i / ${i})|0) * 4) + (i % ${i})] = v[i];
        }
    `}const e_={f32:`
        data[offset] = v;`,i32:`
        dataInt32[offset] = v;`,"vec2<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];`,"vec3<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,"vec4<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,"vec2<i32>":`
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,"vec3<i32>":`
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,"vec4<i32>":`
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,"mat2x2<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,"mat3x3<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,"mat4x4<f32>":`
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,"mat3x2<f32>":Yi(3,2),"mat4x2<f32>":Yi(4,2),"mat2x3<f32>":Yi(2,3),"mat4x3<f32>":Yi(4,3),"mat2x4<f32>":Yi(2,4),"mat3x4<f32>":Yi(3,4)},e3={...e_,"mat2x2<f32>":`
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `};function t3(i,e){const t=Math.max(J0[i.data.type]/16,1),s=i.data.value.length/i.data.size,r=(4-s%4)%4,n=i.data.type.indexOf("i32")>=0?"dataInt32":"data";return`
        v = uv.${i.data.name};
        offset += ${e};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${i.data.size*t}; i++)
        {
            for(var j = 0; j < ${s}; j++)
            {
                ${n}[arrayOffset++] = v[t++];
            }
            ${r!==0?`arrayOffset += ${r};`:""}
        }
    `}function i3(i){return Q0(i,"uboStd40",t3,e_)}class t_ extends Z0{constructor(){super({createUboElements:QI,generateUboSync:i3})}}t_.extension={type:[b.WebGLSystem],name:"ubo"};class s3{constructor(){this._clearColorCache=[0,0,0,0],this._viewPortCache=new W}init(e,t){this._renderer=e,this._renderTargetSystem=t,e.runners.contextChange.add(this)}contextChange(){this._clearColorCache=[0,0,0,0],this._viewPortCache=new W;const e=this._renderer.gl;this._drawBuffersCache=[];for(let t=1;t<=16;t++)this._drawBuffersCache[t]=Array.from({length:t},(s,r)=>e.COLOR_ATTACHMENT0+r)}copyToTexture(e,t,s,r,n){const o=this._renderTargetSystem,a=this._renderer,l=o.getGpuRenderTarget(e),c=a.gl;return this.finishRenderPass(e),c.bindFramebuffer(c.FRAMEBUFFER,l.resolveTargetFramebuffer),a.texture.bind(t,0),c.copyTexSubImage2D(c.TEXTURE_2D,0,n.x,n.y,s.x,s.y,r.width,r.height),t}startRenderPass(e,t=!0,s,r){const n=this._renderTargetSystem,o=e.colorTexture,a=n.getGpuRenderTarget(e);let l=r.y;e.isRoot&&(l=o.pixelHeight-r.height-r.y),e.colorTextures.forEach(u=>{this._renderer.texture.unbind(u)});const c=this._renderer.gl;c.bindFramebuffer(c.FRAMEBUFFER,a.framebuffer),e.colorTextures.length>1&&this._setDrawBuffers(e,c);const h=this._viewPortCache;(h.x!==r.x||h.y!==l||h.width!==r.width||h.height!==r.height)&&(h.x=r.x,h.y=l,h.width=r.width,h.height=r.height,c.viewport(r.x,l,r.width,r.height)),!a.depthStencilRenderBuffer&&(e.stencil||e.depth)&&this._initStencil(a),this.clear(e,t,s)}finishRenderPass(e){const s=this._renderTargetSystem.getGpuRenderTarget(e);if(!s.msaa)return;const r=this._renderer.gl;r.bindFramebuffer(r.FRAMEBUFFER,s.resolveTargetFramebuffer),r.bindFramebuffer(r.READ_FRAMEBUFFER,s.framebuffer),r.blitFramebuffer(0,0,s.width,s.height,0,0,s.width,s.height,r.COLOR_BUFFER_BIT,r.NEAREST),r.bindFramebuffer(r.FRAMEBUFFER,s.framebuffer)}initGpuRenderTarget(e){const s=this._renderer.gl,r=new JI;return e.colorTexture instanceof Bt?(this._renderer.context.ensureCanvasSize(e.colorTexture.resource),r.framebuffer=null,r):(this._initColor(e,r),s.bindFramebuffer(s.FRAMEBUFFER,null),r)}destroyGpuRenderTarget(e){const t=this._renderer.gl;e.framebuffer&&(t.deleteFramebuffer(e.framebuffer),e.framebuffer=null),e.resolveTargetFramebuffer&&(t.deleteFramebuffer(e.resolveTargetFramebuffer),e.resolveTargetFramebuffer=null),e.depthStencilRenderBuffer&&(t.deleteRenderbuffer(e.depthStencilRenderBuffer),e.depthStencilRenderBuffer=null),e.msaaRenderBuffer.forEach(s=>{t.deleteRenderbuffer(s)}),e.msaaRenderBuffer=null}clear(e,t,s){if(!t)return;const r=this._renderTargetSystem;typeof t=="boolean"&&(t=t?tt.ALL:tt.NONE);const n=this._renderer.gl;if(t&tt.COLOR){s??(s=r.defaultClearColor);const o=this._clearColorCache,a=s;(o[0]!==a[0]||o[1]!==a[1]||o[2]!==a[2]||o[3]!==a[3])&&(o[0]=a[0],o[1]=a[1],o[2]=a[2],o[3]=a[3],n.clearColor(a[0],a[1],a[2],a[3]))}n.clear(t)}resizeGpuRenderTarget(e){if(e.isRoot)return;const s=this._renderTargetSystem.getGpuRenderTarget(e);this._resizeColor(e,s),(e.stencil||e.depth)&&this._resizeStencil(s)}_initColor(e,t){const s=this._renderer,r=s.gl,n=r.createFramebuffer();if(t.resolveTargetFramebuffer=n,r.bindFramebuffer(r.FRAMEBUFFER,n),t.width=e.colorTexture.source.pixelWidth,t.height=e.colorTexture.source.pixelHeight,e.colorTextures.forEach((a,l)=>{const c=a.source;c.antialias&&(s.context.supports.msaa?t.msaa=!0:H("[RenderTexture] Antialiasing on textures is not supported in WebGL1")),s.texture.bindSource(c,0);const u=s.texture.getGlSource(c).texture;r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0+l,3553,u,0)}),t.msaa){const a=r.createFramebuffer();t.framebuffer=a,r.bindFramebuffer(r.FRAMEBUFFER,a),e.colorTextures.forEach((l,c)=>{const h=r.createRenderbuffer();t.msaaRenderBuffer[c]=h})}else t.framebuffer=n;this._resizeColor(e,t)}_resizeColor(e,t){const s=e.colorTexture.source;if(t.width=s.pixelWidth,t.height=s.pixelHeight,e.colorTextures.forEach((r,n)=>{n!==0&&r.source.resize(s.width,s.height,s._resolution)}),t.msaa){const r=this._renderer,n=r.gl,o=t.framebuffer;n.bindFramebuffer(n.FRAMEBUFFER,o),e.colorTextures.forEach((a,l)=>{const c=a.source;r.texture.bindSource(c,0);const u=r.texture.getGlSource(c).internalFormat,d=t.msaaRenderBuffer[l];n.bindRenderbuffer(n.RENDERBUFFER,d),n.renderbufferStorageMultisample(n.RENDERBUFFER,4,u,c.pixelWidth,c.pixelHeight),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+l,n.RENDERBUFFER,d)})}}_initStencil(e){if(e.framebuffer===null)return;const t=this._renderer.gl,s=t.createRenderbuffer();e.depthStencilRenderBuffer=s,t.bindRenderbuffer(t.RENDERBUFFER,s),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.RENDERBUFFER,s),this._resizeStencil(e)}_resizeStencil(e){const t=this._renderer.gl;t.bindRenderbuffer(t.RENDERBUFFER,e.depthStencilRenderBuffer),e.msaa?t.renderbufferStorageMultisample(t.RENDERBUFFER,4,t.DEPTH24_STENCIL8,e.width,e.height):t.renderbufferStorage(t.RENDERBUFFER,this._renderer.context.webGLVersion===2?t.DEPTH24_STENCIL8:t.DEPTH_STENCIL,e.width,e.height)}prerender(e){const t=e.colorTexture.resource;this._renderer.context.multiView&&Bt.test(t)&&this._renderer.context.ensureCanvasSize(t)}postrender(e){if(this._renderer.context.multiView&&Bt.test(e.colorTexture.resource)){const t=this._renderer.context.canvas,s=e.colorTexture;s.context2D.drawImage(t,0,s.pixelHeight-t.height)}}_setDrawBuffers(e,t){const s=e.colorTextures.length,r=this._drawBuffersCache[s];if(this._renderer.context.webGLVersion===1){const n=this._renderer.context.extensions.drawBuffers;n?n.drawBuffersWEBGL(r):H("[RenderTexture] This WebGL1 context does not support rendering to multiple targets")}else t.drawBuffers(r)}}function r3(i,e,t,s,r,n){const o=n?1:-1;return i.identity(),i.a=1/s*2,i.d=o*(1/r*2),i.tx=-1-e*i.a,i.ty=-o-t*i.d,i}const qi=new Map;Ui.register(qi);function i_(i,e){if(!qi.has(i)){const t=new k({source:new Bt({resource:i,...e})}),s=()=>{qi.get(i)===t&&qi.delete(i)};t.once("destroy",s),t.source.once("destroy",s),qi.set(i,t)}return qi.get(i)}function n3(i){const e=i.colorTexture.source.resource;return globalThis.HTMLCanvasElement&&e instanceof HTMLCanvasElement&&document.body.contains(e)}const s_=class lv{constructor(e={}){if(this.uid=le("renderTarget"),this.colorTextures=[],this.dirtyId=0,this.isRoot=!1,this._size=new Float32Array(2),this._managedColorTextures=!1,e={...lv.defaultOptions,...e},this.stencil=e.stencil,this.depth=e.depth,this.isRoot=e.isRoot,typeof e.colorTextures=="number"){this._managedColorTextures=!0;for(let t=0;t<e.colorTextures;t++)this.colorTextures.push(new Ee({width:e.width,height:e.height,resolution:e.resolution,antialias:e.antialias}))}else{this.colorTextures=[...e.colorTextures.map(s=>s.source)];const t=this.colorTexture.source;this.resize(t.width,t.height,t._resolution)}this.colorTexture.source.on("resize",this.onSourceResize,this),(e.depthStencilTexture||this.stencil)&&(e.depthStencilTexture instanceof k||e.depthStencilTexture instanceof Ee?this.depthStencilTexture=e.depthStencilTexture.source:this.ensureDepthStencilTexture())}get size(){const e=this._size;return e[0]=this.pixelWidth,e[1]=this.pixelHeight,e}get width(){return this.colorTexture.source.width}get height(){return this.colorTexture.source.height}get pixelWidth(){return this.colorTexture.source.pixelWidth}get pixelHeight(){return this.colorTexture.source.pixelHeight}get resolution(){return this.colorTexture.source._resolution}get colorTexture(){return this.colorTextures[0]}onSourceResize(e){this.resize(e.width,e.height,e._resolution,!0)}ensureDepthStencilTexture(){this.depthStencilTexture||(this.depthStencilTexture=new Ee({width:this.width,height:this.height,resolution:this.resolution,format:"depth24plus-stencil8",autoGenerateMipmaps:!1,antialias:!1,mipLevelCount:1}))}resize(e,t,s=this.resolution,r=!1){this.dirtyId++,this.colorTextures.forEach((n,o)=>{r&&o===0||n.source.resize(e,t,s)}),this.depthStencilTexture&&this.depthStencilTexture.source.resize(e,t,s)}destroy(){this.colorTexture.source.off("resize",this.onSourceResize,this),this._managedColorTextures&&this.colorTextures.forEach(e=>{e.destroy()}),this.depthStencilTexture&&(this.depthStencilTexture.destroy(),delete this.depthStencilTexture)}};s_.defaultOptions={width:0,height:0,resolution:1,colorTextures:1,stencil:!1,depth:!1,antialias:!1,isRoot:!1};let Rd=s_;class r_{constructor(e){this.rootViewPort=new W,this.viewport=new W,this.onRenderTargetChange=new sg("onRenderTargetChange"),this.projectionMatrix=new O,this.defaultClearColor=[0,0,0,0],this._renderSurfaceToRenderTargetHash=new Map,this._gpuRenderTargetHash=Object.create(null),this._renderTargetStack=[],this._renderer=e,e.renderableGC.addManagedHash(this,"_gpuRenderTargetHash")}finishRenderPass(){this.adaptor.finishRenderPass(this.renderTarget)}renderStart({target:e,clear:t,clearColor:s,frame:r}){this._renderTargetStack.length=0,this.push(e,t,s,r),this.rootViewPort.copyFrom(this.viewport),this.rootRenderTarget=this.renderTarget,this.renderingToScreen=n3(this.rootRenderTarget),this.adaptor.prerender?.(this.rootRenderTarget)}postrender(){this.adaptor.postrender?.(this.rootRenderTarget)}bind(e,t=!0,s,r){const n=this.getRenderTarget(e),o=this.renderTarget!==n;this.renderTarget=n,this.renderSurface=e;const a=this.getGpuRenderTarget(n);(n.pixelWidth!==a.width||n.pixelHeight!==a.height)&&(this.adaptor.resizeGpuRenderTarget(n),a.width=n.pixelWidth,a.height=n.pixelHeight);const l=n.colorTexture,c=this.viewport,h=l.pixelWidth,u=l.pixelHeight;if(!r&&e instanceof k&&(r=e.frame),r){const d=l._resolution;c.x=r.x*d+.5|0,c.y=r.y*d+.5|0,c.width=r.width*d+.5|0,c.height=r.height*d+.5|0}else c.x=0,c.y=0,c.width=h,c.height=u;return r3(this.projectionMatrix,0,0,c.width/l.resolution,c.height/l.resolution,!n.isRoot),this.adaptor.startRenderPass(n,t,s,c),o&&this.onRenderTargetChange.emit(n),n}clear(e,t=tt.ALL,s){t&&(e&&(e=this.getRenderTarget(e)),this.adaptor.clear(e||this.renderTarget,t,s,this.viewport))}contextChange(){this._gpuRenderTargetHash=Object.create(null)}push(e,t=tt.ALL,s,r){const n=this.bind(e,t,s,r);return this._renderTargetStack.push({renderTarget:n,frame:r}),n}pop(){this._renderTargetStack.pop();const e=this._renderTargetStack[this._renderTargetStack.length-1];this.bind(e.renderTarget,!1,null,e.frame)}getRenderTarget(e){return e.isTexture&&(e=e.source),this._renderSurfaceToRenderTargetHash.get(e)??this._initRenderTarget(e)}copyToTexture(e,t,s,r,n){s.x<0&&(r.width+=s.x,n.x-=s.x,s.x=0),s.y<0&&(r.height+=s.y,n.y-=s.y,s.y=0);const{pixelWidth:o,pixelHeight:a}=e;return r.width=Math.min(r.width,o-s.x),r.height=Math.min(r.height,a-s.y),this.adaptor.copyToTexture(e,t,s,r,n)}ensureDepthStencil(){this.renderTarget.stencil||(this.renderTarget.stencil=!0,this.adaptor.startRenderPass(this.renderTarget,!1,null,this.viewport))}destroy(){this._renderer=null,this._renderSurfaceToRenderTargetHash.forEach((e,t)=>{e!==t&&e.destroy()}),this._renderSurfaceToRenderTargetHash.clear(),this._gpuRenderTargetHash=Object.create(null)}_initRenderTarget(e){let t=null;return Bt.test(e)&&(e=i_(e).source),e instanceof Rd?t=e:e instanceof Ee&&(t=new Rd({colorTextures:[e]}),e.source instanceof Bt&&(t.isRoot=!0),e.once("destroy",()=>{t.destroy(),this._renderSurfaceToRenderTargetHash.delete(e);const s=this._gpuRenderTargetHash[t.uid];s&&(this._gpuRenderTargetHash[t.uid]=null,this.adaptor.destroyGpuRenderTarget(s))})),this._renderSurfaceToRenderTargetHash.set(e,t),t}getGpuRenderTarget(e){return this._gpuRenderTargetHash[e.uid]||(this._gpuRenderTargetHash[e.uid]=this.adaptor.initGpuRenderTarget(e))}resetState(){this.renderTarget=null,this.renderSurface=null}}class n_ extends r_{constructor(e){super(e),this.adaptor=new s3,this.adaptor.init(e,this)}}n_.extension={type:[b.WebGLSystem],name:"renderTarget"};class kd extends Ze{constructor({buffer:e,offset:t,size:s}){super(),this.uid=le("buffer"),this._resourceType="bufferResource",this._touched=0,this._resourceId=le("resource"),this._bufferResource=!0,this.destroyed=!1,this.buffer=e,this.offset=t|0,this.size=s,this.buffer.on("change",this.onBufferChange,this)}onBufferChange(){this._resourceId=le("resource"),this.emit("change",this)}destroy(e=!1){this.destroyed=!0,e&&this.buffer.destroy(),this.emit("change",this),this.buffer=null,this.removeAllListeners()}}function o3(i,e){const t=[],s=[`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];let r=!1,n=0;const o=e._getProgramData(i.glProgram);for(const l in i.groups){const c=i.groups[l];t.push(`
            resources = g[${l}].resources;
        `);for(const h in c.resources){const u=c.resources[h];if(u instanceof We)if(u.ubo){const d=i._uniformBindMap[l][Number(h)];t.push(`
                        sS.bindUniformBlock(
                            resources[${h}],
                            '${d}',
                            ${i.glProgram._uniformBlockData[d].index}
                        );
                    `)}else t.push(`
                        ugS.updateUniformGroup(resources[${h}], p, sD);
                    `);else if(u instanceof kd){const d=i._uniformBindMap[l][Number(h)];t.push(`
                    sS.bindUniformBlock(
                        resources[${h}],
                        '${d}',
                        ${i.glProgram._uniformBlockData[d].index}
                    );
                `)}else if(u instanceof Ee){const d=i._uniformBindMap[l][h],f=o.uniformData[d];f&&(r||(r=!0,s.push(`
                        var tS = r.texture;
                        `)),e._gl.uniform1i(f.location,n),t.push(`
                        tS.bind(resources[${h}], ${n});
                    `),n++)}}}const a=[...s,...t].join(`
`);return new Function("r","s","sD",a)}class a3{constructor(e,t){this.program=e,this.uniformData=t,this.uniformGroups={},this.uniformDirtyGroups={},this.uniformBlockBindings={}}destroy(){this.uniformData=null,this.uniformGroups=null,this.uniformDirtyGroups=null,this.uniformBlockBindings=null,this.program=null}}function o_(i,e,t){const s=i.createShader(e);return i.shaderSource(s,t),i.compileShader(s),s}function Md(i){const e=new Array(i);for(let t=0;t<e.length;t++)e[t]=!1;return e}function a_(i,e){switch(i){case"float":return 0;case"vec2":return new Float32Array(2*e);case"vec3":return new Float32Array(3*e);case"vec4":return new Float32Array(4*e);case"int":case"uint":case"sampler2D":case"sampler2DArray":return 0;case"ivec2":return new Int32Array(2*e);case"ivec3":return new Int32Array(3*e);case"ivec4":return new Int32Array(4*e);case"uvec2":return new Uint32Array(2*e);case"uvec3":return new Uint32Array(3*e);case"uvec4":return new Uint32Array(4*e);case"bool":return!1;case"bvec2":return Md(2*e);case"bvec3":return Md(3*e);case"bvec4":return Md(4*e);case"mat2":return new Float32Array([1,0,0,1]);case"mat3":return new Float32Array([1,0,0,0,1,0,0,0,1]);case"mat4":return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}return null}let hn=null;const l_={FLOAT:"float",FLOAT_VEC2:"vec2",FLOAT_VEC3:"vec3",FLOAT_VEC4:"vec4",INT:"int",INT_VEC2:"ivec2",INT_VEC3:"ivec3",INT_VEC4:"ivec4",UNSIGNED_INT:"uint",UNSIGNED_INT_VEC2:"uvec2",UNSIGNED_INT_VEC3:"uvec3",UNSIGNED_INT_VEC4:"uvec4",BOOL:"bool",BOOL_VEC2:"bvec2",BOOL_VEC3:"bvec3",BOOL_VEC4:"bvec4",FLOAT_MAT2:"mat2",FLOAT_MAT3:"mat3",FLOAT_MAT4:"mat4",SAMPLER_2D:"sampler2D",INT_SAMPLER_2D:"sampler2D",UNSIGNED_INT_SAMPLER_2D:"sampler2D",SAMPLER_CUBE:"samplerCube",INT_SAMPLER_CUBE:"samplerCube",UNSIGNED_INT_SAMPLER_CUBE:"samplerCube",SAMPLER_2D_ARRAY:"sampler2DArray",INT_SAMPLER_2D_ARRAY:"sampler2DArray",UNSIGNED_INT_SAMPLER_2D_ARRAY:"sampler2DArray"},l3={float:"float32",vec2:"float32x2",vec3:"float32x3",vec4:"float32x4",int:"sint32",ivec2:"sint32x2",ivec3:"sint32x3",ivec4:"sint32x4",uint:"uint32",uvec2:"uint32x2",uvec3:"uint32x3",uvec4:"uint32x4",bool:"uint32",bvec2:"uint32x2",bvec3:"uint32x3",bvec4:"uint32x4"};function c_(i,e){if(!hn){const t=Object.keys(l_);hn={};for(let s=0;s<t.length;++s){const r=t[s];hn[i[r]]=l_[r]}}return hn[e]}function c3(i,e){const t=c_(i,e);return l3[t]||"float32"}function h3(i,e,t=!1){const s={},r=e.getProgramParameter(i,e.ACTIVE_ATTRIBUTES);for(let o=0;o<r;o++){const a=e.getActiveAttrib(i,o);if(a.name.startsWith("gl_"))continue;const l=c3(e,a.type);s[a.name]={location:0,format:l,stride:Zt(l).stride,offset:0,instance:!1,start:0}}const n=Object.keys(s);if(t){n.sort((o,a)=>o>a?1:-1);for(let o=0;o<n.length;o++)s[n[o]].location=o,e.bindAttribLocation(i,o,n[o]);e.linkProgram(i)}else for(let o=0;o<n.length;o++)s[n[o]].location=e.getAttribLocation(i,n[o]);return s}function u3(i,e){if(!e.ACTIVE_UNIFORM_BLOCKS)return{};const t={},s=e.getProgramParameter(i,e.ACTIVE_UNIFORM_BLOCKS);for(let r=0;r<s;r++){const n=e.getActiveUniformBlockName(i,r),o=e.getUniformBlockIndex(i,n),a=e.getActiveUniformBlockParameter(i,r,e.UNIFORM_BLOCK_DATA_SIZE);t[n]={name:n,index:o,size:a}}return t}function d3(i,e){const t={},s=e.getProgramParameter(i,e.ACTIVE_UNIFORMS);for(let r=0;r<s;r++){const n=e.getActiveUniform(i,r),o=n.name.replace(/\[.*?\]$/,""),a=!!n.name.match(/\[.*?\]$/),l=c_(e,n.type);t[o]={name:o,index:r,type:l,size:n.size,isArray:a,value:a_(l,n.size)}}return t}function h_(i,e){const t=i.getShaderSource(e).split(`
`).map((c,h)=>`${h}: ${c}`),s=i.getShaderInfoLog(e),r=s.split(`
`),n={},o=r.map(c=>parseFloat(c.replace(/^ERROR\: 0\:([\d]+)\:.*$/,"$1"))).filter(c=>c&&!n[c]?(n[c]=!0,!0):!1),a=[""];o.forEach(c=>{t[c-1]=`%c${t[c-1]}%c`,a.push("background: #FF0000; color:#FFFFFF; font-size: 10px","font-size: 10px")});const l=t.join(`
`);a[0]=l,console.error(s),console.groupCollapsed("click to view full shader code"),console.warn(...a),console.groupEnd()}function f3(i,e,t,s){i.getProgramParameter(e,i.LINK_STATUS)||(i.getShaderParameter(t,i.COMPILE_STATUS)||h_(i,t),i.getShaderParameter(s,i.COMPILE_STATUS)||h_(i,s),console.error("PixiJS Error: Could not initialize shader."),i.getProgramInfoLog(e)!==""&&console.warn("PixiJS Warning: gl.getProgramInfoLog()",i.getProgramInfoLog(e)))}function p3(i,e){const t=o_(i,i.VERTEX_SHADER,e.vertex),s=o_(i,i.FRAGMENT_SHADER,e.fragment),r=i.createProgram();i.attachShader(r,t),i.attachShader(r,s);const n=e.transformFeedbackVaryings;n&&(typeof i.transformFeedbackVaryings!="function"?H("TransformFeedback is not supported but TransformFeedbackVaryings are given."):i.transformFeedbackVaryings(r,n.names,n.bufferMode==="separate"?i.SEPARATE_ATTRIBS:i.INTERLEAVED_ATTRIBS)),i.linkProgram(r),i.getProgramParameter(r,i.LINK_STATUS)||f3(i,r,t,s),e._attributeData=h3(r,i,!/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertex)),e._uniformData=d3(r,i),e._uniformBlockData=u3(r,i),i.deleteShader(t),i.deleteShader(s);const o={};for(const l in e._uniformData){const c=e._uniformData[l];o[l]={location:i.getUniformLocation(r,l),value:a_(c.type,c.size)}}return new a3(r,o)}const un={textureCount:0,blockIndex:0};class u_{constructor(e){this._activeProgram=null,this._programDataHash=Object.create(null),this._shaderSyncFunctions=Object.create(null),this._renderer=e}contextChange(e){this._gl=e,this._programDataHash=Object.create(null),this._shaderSyncFunctions=Object.create(null),this._activeProgram=null}bind(e,t){if(this._setProgram(e.glProgram),t)return;un.textureCount=0,un.blockIndex=0;let s=this._shaderSyncFunctions[e.glProgram._key];s||(s=this._shaderSyncFunctions[e.glProgram._key]=this._generateShaderSync(e,this)),this._renderer.buffer.nextBindBase(!!e.glProgram.transformFeedbackVaryings),s(this._renderer,e,un)}updateUniformGroup(e){this._renderer.uniformGroup.updateUniformGroup(e,this._activeProgram,un)}bindUniformBlock(e,t,s=0){const r=this._renderer.buffer,n=this._getProgramData(this._activeProgram),o=e._bufferResource;o||this._renderer.ubo.updateUniformGroup(e);const a=e.buffer,l=r.updateBuffer(a),c=r.freeLocationForBufferBase(l);if(o){const{offset:u,size:d}=e;u===0&&d===a.data.byteLength?r.bindBufferBase(l,c):r.bindBufferRange(l,c,u)}else r.getLastBindBaseLocation(l)!==c&&r.bindBufferBase(l,c);const h=this._activeProgram._uniformBlockData[t].index;n.uniformBlockBindings[s]!==c&&(n.uniformBlockBindings[s]=c,this._renderer.gl.uniformBlockBinding(n.program,h,c))}_setProgram(e){if(this._activeProgram===e)return;this._activeProgram=e;const t=this._getProgramData(e);this._gl.useProgram(t.program)}_getProgramData(e){return this._programDataHash[e._key]||this._createProgramData(e)}_createProgramData(e){const t=e._key;return this._programDataHash[t]=p3(this._gl,e),this._programDataHash[t]}destroy(){for(const e of Object.keys(this._programDataHash))this._programDataHash[e].destroy();this._programDataHash=null,this._shaderSyncFunctions=null,this._activeProgram=null,this._renderer=null,this._gl=null}_generateShaderSync(e,t){return o3(e,t)}resetState(){this._activeProgram=null}}u_.extension={type:[b.WebGLSystem],name:"shader"};const m3={f32:`if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,"vec2<f32>":`if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,"vec3<f32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,"vec4<f32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,i32:`if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,"vec2<i32>":`if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,"vec3<i32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,"vec4<i32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,u32:`if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,"vec2<u32>":`if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,"vec3<u32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,"vec4<u32>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,bool:`if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,"vec2<bool>":`if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,"vec3<bool>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,"vec4<bool>":`if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,"mat2x2<f32>":"gl.uniformMatrix2fv(location, false, v);","mat3x3<f32>":"gl.uniformMatrix3fv(location, false, v);","mat4x4<f32>":"gl.uniformMatrix4fv(location, false, v);"},g3={f32:"gl.uniform1fv(location, v);","vec2<f32>":"gl.uniform2fv(location, v);","vec3<f32>":"gl.uniform3fv(location, v);","vec4<f32>":"gl.uniform4fv(location, v);","mat2x2<f32>":"gl.uniformMatrix2fv(location, false, v);","mat3x3<f32>":"gl.uniformMatrix3fv(location, false, v);","mat4x4<f32>":"gl.uniformMatrix4fv(location, false, v);",i32:"gl.uniform1iv(location, v);","vec2<i32>":"gl.uniform2iv(location, v);","vec3<i32>":"gl.uniform3iv(location, v);","vec4<i32>":"gl.uniform4iv(location, v);",u32:"gl.uniform1iv(location, v);","vec2<u32>":"gl.uniform2iv(location, v);","vec3<u32>":"gl.uniform3iv(location, v);","vec4<u32>":"gl.uniform4iv(location, v);",bool:"gl.uniform1iv(location, v);","vec2<bool>":"gl.uniform2iv(location, v);","vec3<bool>":"gl.uniform3iv(location, v);","vec4<bool>":"gl.uniform4iv(location, v);"};function _3(i,e){const t=[`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];for(const s in i.uniforms){if(!e[s]){i.uniforms[s]instanceof We?i.uniforms[s].ubo?t.push(`
                        renderer.shader.bindUniformBlock(uv.${s}, "${s}");
                    `):t.push(`
                        renderer.shader.updateUniformGroup(uv.${s});
                    `):i.uniforms[s]instanceof kd&&t.push(`
                        renderer.shader.bindBufferResource(uv.${s}, "${s}");
                    `);continue}const r=i.uniformStructures[s];let n=!1;for(let o=0;o<gi.length;o++){const a=gi[o];if(r.type===a.type&&a.test(r)){t.push(`name = "${s}";`,gi[o].uniform),n=!0;break}}if(!n){const a=(r.size===1?m3:g3)[r.type].replace("location",`ud["${s}"].location`);t.push(`
            cu = ud["${s}"];
            cv = cu.value;
            v = uv["${s}"];
            ${a};`)}}return new Function("ud","uv","renderer","syncData",t.join(`
`))}class d_{constructor(e){this._cache={},this._uniformGroupSyncHash={},this._renderer=e,this.gl=null,this._cache={}}contextChange(e){this.gl=e}updateUniformGroup(e,t,s){const r=this._renderer.shader._getProgramData(t);(!e.isStatic||e._dirtyId!==r.uniformDirtyGroups[e.uid])&&(r.uniformDirtyGroups[e.uid]=e._dirtyId,this._getUniformSyncFunction(e,t)(r.uniformData,e.uniforms,this._renderer,s))}_getUniformSyncFunction(e,t){return this._uniformGroupSyncHash[e._signature]?.[t._key]||this._createUniformSyncFunction(e,t)}_createUniformSyncFunction(e,t){const s=this._uniformGroupSyncHash[e._signature]||(this._uniformGroupSyncHash[e._signature]={}),r=this._getSignature(e,t._uniformData,"u");return this._cache[r]||(this._cache[r]=this._generateUniformsSync(e,t._uniformData)),s[t._key]=this._cache[r],s[t._key]}_generateUniformsSync(e,t){return _3(e,t)}_getSignature(e,t,s){const r=e.uniforms,n=[`${s}-`];for(const o in r)n.push(o),t[o]&&n.push(t[o].type);return n.join("-")}destroy(){this._renderer=null,this._cache=null}}d_.extension={type:[b.WebGLSystem],name:"uniformGroup"};function x3(i){const e={};if(e.normal=[i.ONE,i.ONE_MINUS_SRC_ALPHA],e.add=[i.ONE,i.ONE],e.multiply=[i.DST_COLOR,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA],e.screen=[i.ONE,i.ONE_MINUS_SRC_COLOR,i.ONE,i.ONE_MINUS_SRC_ALPHA],e.none=[0,0],e["normal-npm"]=[i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA],e["add-npm"]=[i.SRC_ALPHA,i.ONE,i.ONE,i.ONE],e["screen-npm"]=[i.SRC_ALPHA,i.ONE_MINUS_SRC_COLOR,i.ONE,i.ONE_MINUS_SRC_ALPHA],e.erase=[i.ZERO,i.ONE_MINUS_SRC_ALPHA],!(i instanceof Y.get().getWebGLRenderingContext()))e.min=[i.ONE,i.ONE,i.ONE,i.ONE,i.MIN,i.MIN],e.max=[i.ONE,i.ONE,i.ONE,i.ONE,i.MAX,i.MAX];else{const s=i.getExtension("EXT_blend_minmax");s&&(e.min=[i.ONE,i.ONE,i.ONE,i.ONE,s.MIN_EXT,s.MIN_EXT],e.max=[i.ONE,i.ONE,i.ONE,i.ONE,s.MAX_EXT,s.MAX_EXT])}return e}const v3=0,y3=1,b3=2,T3=3,w3=4,S3=5,f_=class ff{constructor(e){this._invertFrontFace=!1,this.gl=null,this.stateId=0,this.polygonOffset=0,this.blendMode="none",this._blendEq=!1,this.map=[],this.map[v3]=this.setBlend,this.map[y3]=this.setOffset,this.map[b3]=this.setCullFace,this.map[T3]=this.setDepthTest,this.map[w3]=this.setFrontFace,this.map[S3]=this.setDepthMask,this.checks=[],this.defaultState=mt.for2d(),e.renderTarget.onRenderTargetChange.add(this)}onRenderTargetChange(e){this._invertFrontFace=!e.isRoot,this._cullFace?this.setFrontFace(this._frontFace):this._frontFaceDirty=!0}contextChange(e){this.gl=e,this.blendModesMap=x3(e),this.resetState()}set(e){if(e||(e=this.defaultState),this.stateId!==e.data){let t=this.stateId^e.data,s=0;for(;t;)t&1&&this.map[s].call(this,!!(e.data&1<<s)),t>>=1,s++;this.stateId=e.data}for(let t=0;t<this.checks.length;t++)this.checks[t](this,e)}forceState(e){e||(e=this.defaultState);for(let t=0;t<this.map.length;t++)this.map[t].call(this,!!(e.data&1<<t));for(let t=0;t<this.checks.length;t++)this.checks[t](this,e);this.stateId=e.data}setBlend(e){this._updateCheck(ff._checkBlendMode,e),this.gl[e?"enable":"disable"](this.gl.BLEND)}setOffset(e){this._updateCheck(ff._checkPolygonOffset,e),this.gl[e?"enable":"disable"](this.gl.POLYGON_OFFSET_FILL)}setDepthTest(e){this.gl[e?"enable":"disable"](this.gl.DEPTH_TEST)}setDepthMask(e){this.gl.depthMask(e)}setCullFace(e){this._cullFace=e,this.gl[e?"enable":"disable"](this.gl.CULL_FACE),this._cullFace&&this._frontFaceDirty&&this.setFrontFace(this._frontFace)}setFrontFace(e){this._frontFace=e,this._frontFaceDirty=!1;const t=this._invertFrontFace?!e:e;this._glFrontFace!==t&&(this._glFrontFace=t,this.gl.frontFace(this.gl[t?"CW":"CCW"]))}setBlendMode(e){if(this.blendModesMap[e]||(e="normal"),e===this.blendMode)return;this.blendMode=e;const t=this.blendModesMap[e],s=this.gl;t.length===2?s.blendFunc(t[0],t[1]):s.blendFuncSeparate(t[0],t[1],t[2],t[3]),t.length===6?(this._blendEq=!0,s.blendEquationSeparate(t[4],t[5])):this._blendEq&&(this._blendEq=!1,s.blendEquationSeparate(s.FUNC_ADD,s.FUNC_ADD))}setPolygonOffset(e,t){this.gl.polygonOffset(e,t)}resetState(){this._glFrontFace=!1,this._frontFace=!1,this._cullFace=!1,this._frontFaceDirty=!1,this._invertFrontFace=!1,this.gl.frontFace(this.gl.CCW),this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL,!1),this.forceState(this.defaultState),this._blendEq=!0,this.blendMode="",this.setBlendMode("normal")}_updateCheck(e,t){const s=this.checks.indexOf(e);t&&s===-1?this.checks.push(e):!t&&s!==-1&&this.checks.splice(s,1)}static _checkBlendMode(e,t){e.setBlendMode(t.blendMode)}static _checkPolygonOffset(e,t){e.setPolygonOffset(1,t.polygonOffset)}destroy(){this.gl=null,this.checks.length=0}};f_.extension={type:[b.WebGLSystem],name:"state"};let C3=f_;class A3{constructor(e){this.target=V0.TEXTURE_2D,this.texture=e,this.width=-1,this.height=-1,this.type=te.UNSIGNED_BYTE,this.internalFormat=Id.RGBA,this.format=Id.RGBA,this.samplerType=0}destroy(){}}const E3={id:"buffer",upload(i,e,t){e.width===i.width||e.height===i.height?t.texSubImage2D(t.TEXTURE_2D,0,0,0,i.width,i.height,e.format,e.type,i.resource):t.texImage2D(e.target,0,e.internalFormat,i.width,i.height,0,e.format,e.type,i.resource),e.width=i.width,e.height=i.height}},I3={"bc1-rgba-unorm":!0,"bc1-rgba-unorm-srgb":!0,"bc2-rgba-unorm":!0,"bc2-rgba-unorm-srgb":!0,"bc3-rgba-unorm":!0,"bc3-rgba-unorm-srgb":!0,"bc4-r-unorm":!0,"bc4-r-snorm":!0,"bc5-rg-unorm":!0,"bc5-rg-snorm":!0,"bc6h-rgb-ufloat":!0,"bc6h-rgb-float":!0,"bc7-rgba-unorm":!0,"bc7-rgba-unorm-srgb":!0,"etc2-rgb8unorm":!0,"etc2-rgb8unorm-srgb":!0,"etc2-rgb8a1unorm":!0,"etc2-rgb8a1unorm-srgb":!0,"etc2-rgba8unorm":!0,"etc2-rgba8unorm-srgb":!0,"eac-r11unorm":!0,"eac-r11snorm":!0,"eac-rg11unorm":!0,"eac-rg11snorm":!0,"astc-4x4-unorm":!0,"astc-4x4-unorm-srgb":!0,"astc-5x4-unorm":!0,"astc-5x4-unorm-srgb":!0,"astc-5x5-unorm":!0,"astc-5x5-unorm-srgb":!0,"astc-6x5-unorm":!0,"astc-6x5-unorm-srgb":!0,"astc-6x6-unorm":!0,"astc-6x6-unorm-srgb":!0,"astc-8x5-unorm":!0,"astc-8x5-unorm-srgb":!0,"astc-8x6-unorm":!0,"astc-8x6-unorm-srgb":!0,"astc-8x8-unorm":!0,"astc-8x8-unorm-srgb":!0,"astc-10x5-unorm":!0,"astc-10x5-unorm-srgb":!0,"astc-10x6-unorm":!0,"astc-10x6-unorm-srgb":!0,"astc-10x8-unorm":!0,"astc-10x8-unorm-srgb":!0,"astc-10x10-unorm":!0,"astc-10x10-unorm-srgb":!0,"astc-12x10-unorm":!0,"astc-12x10-unorm-srgb":!0,"astc-12x12-unorm":!0,"astc-12x12-unorm-srgb":!0},P3={id:"compressed",upload(i,e,t){t.pixelStorei(t.UNPACK_ALIGNMENT,4);let s=i.pixelWidth,r=i.pixelHeight;const n=!!I3[i.format];for(let o=0;o<i.resource.length;o++){const a=i.resource[o];n?t.compressedTexImage2D(t.TEXTURE_2D,o,e.internalFormat,s,r,0,a):t.texImage2D(t.TEXTURE_2D,o,e.internalFormat,s,r,0,e.format,e.type,a),s=Math.max(s>>1,1),r=Math.max(r>>1,1)}}},p_={id:"image",upload(i,e,t,s){const r=e.width,n=e.height,o=i.pixelWidth,a=i.pixelHeight,l=i.resourceWidth,c=i.resourceHeight;l<o||c<a?((r!==o||n!==a)&&t.texImage2D(e.target,0,e.internalFormat,o,a,0,e.format,e.type,null),s===2?t.texSubImage2D(t.TEXTURE_2D,0,0,0,l,c,e.format,e.type,i.resource):t.texSubImage2D(t.TEXTURE_2D,0,0,0,e.format,e.type,i.resource)):r===o&&n===a?t.texSubImage2D(t.TEXTURE_2D,0,0,0,e.format,e.type,i.resource):s===2?t.texImage2D(e.target,0,e.internalFormat,o,a,0,e.format,e.type,i.resource):t.texImage2D(e.target,0,e.internalFormat,e.format,e.type,i.resource),e.width=o,e.height=a}},R3={id:"video",upload(i,e,t,s){if(!i.isValid){t.texImage2D(e.target,0,e.internalFormat,1,1,0,e.format,e.type,null);return}p_.upload(i,e,t,s)}},m_={linear:9729,nearest:9728},k3={linear:{linear:9987,nearest:9985},nearest:{linear:9986,nearest:9984}},Fd={"clamp-to-edge":33071,repeat:10497,"mirror-repeat":33648},M3={never:512,less:513,equal:514,"less-equal":515,greater:516,"not-equal":517,"greater-equal":518,always:519};function g_(i,e,t,s,r,n,o,a){const l=n;if(!a||i.addressModeU!=="repeat"||i.addressModeV!=="repeat"||i.addressModeW!=="repeat"){const c=Fd[o?"clamp-to-edge":i.addressModeU],h=Fd[o?"clamp-to-edge":i.addressModeV],u=Fd[o?"clamp-to-edge":i.addressModeW];e[r](l,e.TEXTURE_WRAP_S,c),e[r](l,e.TEXTURE_WRAP_T,h),e.TEXTURE_WRAP_R&&e[r](l,e.TEXTURE_WRAP_R,u)}if((!a||i.magFilter!=="linear")&&e[r](l,e.TEXTURE_MAG_FILTER,m_[i.magFilter]),t){if(!a||i.mipmapFilter!=="linear"){const c=k3[i.minFilter][i.mipmapFilter];e[r](l,e.TEXTURE_MIN_FILTER,c)}}else e[r](l,e.TEXTURE_MIN_FILTER,m_[i.minFilter]);if(s&&i.maxAnisotropy>1){const c=Math.min(i.maxAnisotropy,e.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT));e[r](l,s.TEXTURE_MAX_ANISOTROPY_EXT,c)}i.compare&&e[r](l,e.TEXTURE_COMPARE_FUNC,M3[i.compare])}function F3(i){return{r8unorm:i.RED,r8snorm:i.RED,r8uint:i.RED,r8sint:i.RED,r16uint:i.RED,r16sint:i.RED,r16float:i.RED,rg8unorm:i.RG,rg8snorm:i.RG,rg8uint:i.RG,rg8sint:i.RG,r32uint:i.RED,r32sint:i.RED,r32float:i.RED,rg16uint:i.RG,rg16sint:i.RG,rg16float:i.RG,rgba8unorm:i.RGBA,"rgba8unorm-srgb":i.RGBA,rgba8snorm:i.RGBA,rgba8uint:i.RGBA,rgba8sint:i.RGBA,bgra8unorm:i.RGBA,"bgra8unorm-srgb":i.RGBA,rgb9e5ufloat:i.RGB,rgb10a2unorm:i.RGBA,rg11b10ufloat:i.RGB,rg32uint:i.RG,rg32sint:i.RG,rg32float:i.RG,rgba16uint:i.RGBA,rgba16sint:i.RGBA,rgba16float:i.RGBA,rgba32uint:i.RGBA,rgba32sint:i.RGBA,rgba32float:i.RGBA,stencil8:i.STENCIL_INDEX8,depth16unorm:i.DEPTH_COMPONENT,depth24plus:i.DEPTH_COMPONENT,"depth24plus-stencil8":i.DEPTH_STENCIL,depth32float:i.DEPTH_COMPONENT,"depth32float-stencil8":i.DEPTH_STENCIL}}function U3(i,e){let t={},s=i.RGBA;return i instanceof Y.get().getWebGLRenderingContext()?e.srgb&&(t={"rgba8unorm-srgb":e.srgb.SRGB8_ALPHA8_EXT,"bgra8unorm-srgb":e.srgb.SRGB8_ALPHA8_EXT}):(t={"rgba8unorm-srgb":i.SRGB8_ALPHA8,"bgra8unorm-srgb":i.SRGB8_ALPHA8},s=i.RGBA8),{r8unorm:i.R8,r8snorm:i.R8_SNORM,r8uint:i.R8UI,r8sint:i.R8I,r16uint:i.R16UI,r16sint:i.R16I,r16float:i.R16F,rg8unorm:i.RG8,rg8snorm:i.RG8_SNORM,rg8uint:i.RG8UI,rg8sint:i.RG8I,r32uint:i.R32UI,r32sint:i.R32I,r32float:i.R32F,rg16uint:i.RG16UI,rg16sint:i.RG16I,rg16float:i.RG16F,rgba8unorm:i.RGBA,...t,rgba8snorm:i.RGBA8_SNORM,rgba8uint:i.RGBA8UI,rgba8sint:i.RGBA8I,bgra8unorm:s,rgb9e5ufloat:i.RGB9_E5,rgb10a2unorm:i.RGB10_A2,rg11b10ufloat:i.R11F_G11F_B10F,rg32uint:i.RG32UI,rg32sint:i.RG32I,rg32float:i.RG32F,rgba16uint:i.RGBA16UI,rgba16sint:i.RGBA16I,rgba16float:i.RGBA16F,rgba32uint:i.RGBA32UI,rgba32sint:i.RGBA32I,rgba32float:i.RGBA32F,stencil8:i.STENCIL_INDEX8,depth16unorm:i.DEPTH_COMPONENT16,depth24plus:i.DEPTH_COMPONENT24,"depth24plus-stencil8":i.DEPTH24_STENCIL8,depth32float:i.DEPTH_COMPONENT32F,"depth32float-stencil8":i.DEPTH32F_STENCIL8,...e.s3tc?{"bc1-rgba-unorm":e.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,"bc2-rgba-unorm":e.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,"bc3-rgba-unorm":e.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT}:{},...e.s3tc_sRGB?{"bc1-rgba-unorm-srgb":e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,"bc2-rgba-unorm-srgb":e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,"bc3-rgba-unorm-srgb":e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}:{},...e.rgtc?{"bc4-r-unorm":e.rgtc.COMPRESSED_RED_RGTC1_EXT,"bc4-r-snorm":e.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,"bc5-rg-unorm":e.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,"bc5-rg-snorm":e.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}:{},...e.bptc?{"bc6h-rgb-float":e.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,"bc6h-rgb-ufloat":e.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,"bc7-rgba-unorm":e.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,"bc7-rgba-unorm-srgb":e.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT}:{},...e.etc?{"etc2-rgb8unorm":e.etc.COMPRESSED_RGB8_ETC2,"etc2-rgb8unorm-srgb":e.etc.COMPRESSED_SRGB8_ETC2,"etc2-rgb8a1unorm":e.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,"etc2-rgb8a1unorm-srgb":e.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,"etc2-rgba8unorm":e.etc.COMPRESSED_RGBA8_ETC2_EAC,"etc2-rgba8unorm-srgb":e.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,"eac-r11unorm":e.etc.COMPRESSED_R11_EAC,"eac-rg11unorm":e.etc.COMPRESSED_SIGNED_RG11_EAC}:{},...e.astc?{"astc-4x4-unorm":e.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,"astc-4x4-unorm-srgb":e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,"astc-5x4-unorm":e.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,"astc-5x4-unorm-srgb":e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,"astc-5x5-unorm":e.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,"astc-5x5-unorm-srgb":e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,"astc-6x5-unorm":e.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,"astc-6x5-unorm-srgb":e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,"astc-6x6-unorm":e.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,"astc-6x6-unorm-srgb":e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,"astc-8x5-unorm":e.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,"astc-8x5-unorm-srgb":e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,"astc-8x6-unorm":e.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,"astc-8x6-unorm-srgb":e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,"astc-8x8-unorm":e.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,"astc-8x8-unorm-srgb":e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,"astc-10x5-unorm":e.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,"astc-10x5-unorm-srgb":e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,"astc-10x6-unorm":e.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,"astc-10x6-unorm-srgb":e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,"astc-10x8-unorm":e.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,"astc-10x8-unorm-srgb":e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,"astc-10x10-unorm":e.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,"astc-10x10-unorm-srgb":e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,"astc-12x10-unorm":e.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,"astc-12x10-unorm-srgb":e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,"astc-12x12-unorm":e.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,"astc-12x12-unorm-srgb":e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR}:{}}}function B3(i){return{r8unorm:i.UNSIGNED_BYTE,r8snorm:i.BYTE,r8uint:i.UNSIGNED_BYTE,r8sint:i.BYTE,r16uint:i.UNSIGNED_SHORT,r16sint:i.SHORT,r16float:i.HALF_FLOAT,rg8unorm:i.UNSIGNED_BYTE,rg8snorm:i.BYTE,rg8uint:i.UNSIGNED_BYTE,rg8sint:i.BYTE,r32uint:i.UNSIGNED_INT,r32sint:i.INT,r32float:i.FLOAT,rg16uint:i.UNSIGNED_SHORT,rg16sint:i.SHORT,rg16float:i.HALF_FLOAT,rgba8unorm:i.UNSIGNED_BYTE,"rgba8unorm-srgb":i.UNSIGNED_BYTE,rgba8snorm:i.BYTE,rgba8uint:i.UNSIGNED_BYTE,rgba8sint:i.BYTE,bgra8unorm:i.UNSIGNED_BYTE,"bgra8unorm-srgb":i.UNSIGNED_BYTE,rgb9e5ufloat:i.UNSIGNED_INT_5_9_9_9_REV,rgb10a2unorm:i.UNSIGNED_INT_2_10_10_10_REV,rg11b10ufloat:i.UNSIGNED_INT_10F_11F_11F_REV,rg32uint:i.UNSIGNED_INT,rg32sint:i.INT,rg32float:i.FLOAT,rgba16uint:i.UNSIGNED_SHORT,rgba16sint:i.SHORT,rgba16float:i.HALF_FLOAT,rgba32uint:i.UNSIGNED_INT,rgba32sint:i.INT,rgba32float:i.FLOAT,stencil8:i.UNSIGNED_BYTE,depth16unorm:i.UNSIGNED_SHORT,depth24plus:i.UNSIGNED_INT,"depth24plus-stencil8":i.UNSIGNED_INT_24_8,depth32float:i.FLOAT,"depth32float-stencil8":i.FLOAT_32_UNSIGNED_INT_24_8_REV}}const O3=4;class __{constructor(e){this._glSamplers=Object.create(null),this._boundTextures=[],this._activeTextureLocation=-1,this._boundSamplers=Object.create(null),this._uploads={image:p_,buffer:E3,video:R3,compressed:P3},this._premultiplyAlpha=!1,this._useSeparateSamplers=!1,this._renderer=e,this._managedTextures=new st({renderer:e,type:"resource",onUnload:this.onSourceUnload.bind(this),name:"glTexture"})}get managedTextures(){return Object.values(this._managedTextures.items)}contextChange(e){this._gl=e,this._mapFormatToInternalFormat||(this._mapFormatToInternalFormat=U3(e,this._renderer.context.extensions),this._mapFormatToType=B3(e),this._mapFormatToFormat=F3(e)),this._managedTextures.removeAll(!0),this._glSamplers=Object.create(null),this._boundSamplers=Object.create(null),this._premultiplyAlpha=!1;for(let t=0;t<16;t++)this.bind(k.EMPTY,t)}initSource(e){this.bind(e)}bind(e,t=0){const s=e.source;e?(this.bindSource(s,t),this._useSeparateSamplers&&this._bindSampler(s.style,t)):(this.bindSource(null,t),this._useSeparateSamplers&&this._bindSampler(null,t))}bindSource(e,t=0){const s=this._gl;if(e._gcLastUsed=this._renderer.gc.now,this._boundTextures[t]!==e){this._boundTextures[t]=e,this._activateLocation(t),e||(e=k.EMPTY.source);const r=this.getGlSource(e);s.bindTexture(r.target,r.texture)}}_bindSampler(e,t=0){const s=this._gl;if(!e){this._boundSamplers[t]=null,s.bindSampler(t,null);return}const r=this._getGlSampler(e);this._boundSamplers[t]!==r&&(this._boundSamplers[t]=r,s.bindSampler(t,r))}unbind(e){const t=e.source,s=this._boundTextures,r=this._gl;for(let n=0;n<s.length;n++)if(s[n]===t){this._activateLocation(n);const o=this.getGlSource(t);r.bindTexture(o.target,null),s[n]=null}}_activateLocation(e){this._activeTextureLocation!==e&&(this._activeTextureLocation=e,this._gl.activeTexture(this._gl.TEXTURE0+e))}_initSource(e){const t=this._gl,s=new A3(t.createTexture());if(s.type=this._mapFormatToType[e.format],s.internalFormat=this._mapFormatToInternalFormat[e.format],s.format=this._mapFormatToFormat[e.format],e.autoGenerateMipmaps&&(this._renderer.context.supports.nonPowOf2mipmaps||e.isPowerOfTwo)){const n=Math.max(e.width,e.height);e.mipLevelCount=Math.floor(Math.log2(n))+1}return e._gpuData[this._renderer.uid]=s,this._managedTextures.add(e)&&(e.on("update",this.onSourceUpdate,this),e.on("resize",this.onSourceUpdate,this),e.on("styleChange",this.onStyleChange,this),e.on("updateMipmaps",this.onUpdateMipmaps,this)),this.onSourceUpdate(e),this.updateStyle(e,!1),s}onStyleChange(e){this.updateStyle(e,!1)}updateStyle(e,t){const s=this._gl,r=this.getGlSource(e);s.bindTexture(s.TEXTURE_2D,r.texture),this._boundTextures[this._activeTextureLocation]=e,g_(e.style,s,e.mipLevelCount>1,this._renderer.context.extensions.anisotropicFiltering,"texParameteri",s.TEXTURE_2D,!this._renderer.context.supports.nonPowOf2wrapping&&!e.isPowerOfTwo,t)}onSourceUnload(e,t=!1){const s=e._gpuData[this._renderer.uid];s&&(t||(this.unbind(e),this._gl.deleteTexture(s.texture)),e.off("update",this.onSourceUpdate,this),e.off("resize",this.onSourceUpdate,this),e.off("styleChange",this.onStyleChange,this),e.off("updateMipmaps",this.onUpdateMipmaps,this))}onSourceUpdate(e){const t=this._gl,s=this.getGlSource(e);t.bindTexture(t.TEXTURE_2D,s.texture),this._boundTextures[this._activeTextureLocation]=e;const r=e.alphaMode==="premultiply-alpha-on-upload";this._premultiplyAlpha!==r&&(this._premultiplyAlpha=r,t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r)),this._uploads[e.uploadMethodId]?this._uploads[e.uploadMethodId].upload(e,s,t,this._renderer.context.webGLVersion):t.texImage2D(t.TEXTURE_2D,0,s.internalFormat,e.pixelWidth,e.pixelHeight,0,s.format,s.type,null),e.autoGenerateMipmaps&&e.mipLevelCount>1&&this.onUpdateMipmaps(e,!1)}onUpdateMipmaps(e,t=!0){t&&this.bindSource(e,0);const s=this.getGlSource(e);this._gl.generateMipmap(s.target)}_initSampler(e){const t=this._gl,s=this._gl.createSampler();return this._glSamplers[e._resourceId]=s,g_(e,t,this._boundTextures[this._activeTextureLocation].mipLevelCount>1,this._renderer.context.extensions.anisotropicFiltering,"samplerParameteri",s,!1,!0),this._glSamplers[e._resourceId]}_getGlSampler(e){return this._glSamplers[e._resourceId]||this._initSampler(e)}getGlSource(e){return e._gcLastUsed=this._renderer.gc.now,e._gpuData[this._renderer.uid]||this._initSource(e)}generateCanvas(e){const{pixels:t,width:s,height:r}=this.getPixels(e),n=Y.get().createCanvas();n.width=s,n.height=r;const o=n.getContext("2d");if(o){const a=o.createImageData(s,r);a.data.set(t),o.putImageData(a,0,0)}return n}getPixels(e){const t=e.source.resolution,s=e.frame,r=Math.max(Math.round(s.width*t),1),n=Math.max(Math.round(s.height*t),1),o=new Uint8Array(O3*r*n),a=this._renderer,l=a.renderTarget.getRenderTarget(e),c=a.renderTarget.getGpuRenderTarget(l),h=a.gl;return h.bindFramebuffer(h.FRAMEBUFFER,c.resolveTargetFramebuffer),h.readPixels(Math.round(s.x*t),Math.round(s.y*t),r,n,h.RGBA,h.UNSIGNED_BYTE,o),{pixels:new Uint8ClampedArray(o.buffer),width:r,height:n}}destroy(){this._managedTextures.destroy(),this._glSamplers=null,this._boundTextures=null,this._boundSamplers=null,this._mapFormatToInternalFormat=null,this._mapFormatToType=null,this._mapFormatToFormat=null,this._uploads=null,this._renderer=null}resetState(){this._activeTextureLocation=-1,this._boundTextures.fill(k.EMPTY.source),this._boundSamplers=Object.create(null);const e=this._gl;this._premultiplyAlpha=!1,e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,this._premultiplyAlpha)}}__.extension={type:[b.WebGLSystem],name:"texture"};class x_{contextChange(e){const t=new We({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new O,type:"mat3x3<f32>"},uRound:{value:0,type:"f32"}}),s=e.limits.maxBatchableTextures,r=Ms({name:"graphics",bits:[Ju,id(s),Ad,Us]});this.shader=new lt({glProgram:r,resources:{localUniforms:t,batchSamplers:sd(s)}})}execute(e,t){const s=t.context,r=s.customShader||this.shader,n=e.renderer,o=n.graphicsContext,{batcher:a,instructions:l}=o.getContextRenderData(s);r.groups[0]=n.globalUniforms.bindGroup,n.state.set(e.state),n.shader.bind(r),n.geometry.bind(a.geometry,r.glProgram);const c=l.instructions;for(let h=0;h<l.instructionSize;h++){const u=c[h];if(u.size){for(let d=0;d<u.textures.count;d++)n.texture.bind(u.textures.textures[d],d);n.geometry.draw(u.topology,u.size,u.start)}}}destroy(){this.shader.destroy(!0),this.shader=null}}x_.extension={type:[b.WebGLPipesAdaptor],name:"graphics"};class v_{init(){const e=Ms({name:"mesh",bits:[Ad,NI,Us]});this._shader=new lt({glProgram:e,resources:{uTexture:k.EMPTY.source,textureUniforms:{uTextureMatrix:{type:"mat3x3<f32>",value:new O}}}})}execute(e,t){const s=e.renderer;let r=t._shader;if(r){if(!r.glProgram){H("Mesh shader has no glProgram",t.shader);return}}else{r=this._shader;const n=t.texture,o=n.source;r.resources.uTexture=o,r.resources.uSampler=o.style,r.resources.textureUniforms.uniforms.uTextureMatrix=n.textureMatrix.mapCoord}r.groups[100]=s.globalUniforms.bindGroup,r.groups[101]=e.localUniformsBindGroup,s.encoder.draw({geometry:t._geometry,shader:r,state:t.state})}destroy(){this._shader.destroy(!0),this._shader=null}}v_.extension={type:[b.WebGLPipesAdaptor],name:"mesh"};class y_{constructor(e){this._renderer=e}updateRenderable(){}destroyRenderable(){}validateRenderable(){return!1}addRenderable(e,t){this._renderer.renderPipes.batch.break(t),t.add(e)}execute(e){e.isRenderable&&e.render(this._renderer)}destroy(){this._renderer=null}}y_.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"customRender"};class dn{constructor(){this.batcherName="default",this.topology="triangle-list",this.attributeSize=4,this.indexSize=6,this.packAsQuad=!0,this.roundPixels=0,this._attributeStart=0,this._batcher=null,this._batch=null}get blendMode(){return this.renderable.groupBlendMode}get color(){return this.renderable.groupColorAlpha}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.bounds=null}destroy(){this.reset()}}function Ud(i,e){const t=i.instructionSet,s=t.instructions;for(let r=0;r<t.instructionSize;r++){const n=s[r];e[n.renderPipeId].execute(n)}}const D3=new O;class b_{constructor(e){this._renderer=e}addRenderGroup(e,t){e.isCachedAsTexture?this._addRenderableCacheAsTexture(e,t):this._addRenderableDirect(e,t)}execute(e){e.isRenderable&&(e.isCachedAsTexture?this._executeCacheAsTexture(e):this._executeDirect(e))}destroy(){this._renderer=null}_addRenderableDirect(e,t){this._renderer.renderPipes.batch.break(t),e._batchableRenderGroup&&(Se.return(e._batchableRenderGroup),e._batchableRenderGroup=null),t.add(e)}_addRenderableCacheAsTexture(e,t){const s=e._batchableRenderGroup??(e._batchableRenderGroup=Se.get(dn));s.renderable=e.root,s.transform=e.root.relativeGroupTransform,s.texture=e.texture,s.bounds=e._textureBounds,t.add(e),this._renderer.renderPipes.blendMode.pushBlendMode(e,e.root.groupBlendMode,t),this._renderer.renderPipes.batch.addToBatch(s,t),this._renderer.renderPipes.blendMode.popBlendMode(t)}_executeCacheAsTexture(e){if(e.textureNeedsUpdate){e.textureNeedsUpdate=!1;const t=D3.identity().translate(-e._textureBounds.x,-e._textureBounds.y);this._renderer.renderTarget.push(e.texture,!0,null,e.texture.frame),this._renderer.globalUniforms.push({worldTransformMatrix:t,worldColor:4294967295,offset:{x:0,y:0}}),Ud(e,this._renderer.renderPipes),this._renderer.renderTarget.finishRenderPass(),this._renderer.renderTarget.pop(),this._renderer.globalUniforms.pop()}e._batchableRenderGroup._batcher.updateElement(e._batchableRenderGroup),e._batchableRenderGroup._batcher.geometry.buffers[0].update()}_executeDirect(e){this._renderer.globalUniforms.push({worldTransformMatrix:e.inverseParentTextureTransform,worldColor:e.worldColorAlpha}),Ud(e,this._renderer.renderPipes),this._renderer.globalUniforms.pop()}}b_.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"renderGroup"};function Bd(i,e){e||(e=0);for(let t=e;t<i.length&&i[t];t++)i[t]=null}const G3=new se,T_=fs|Dr|yu;function w_(i,e=!1){z3(i);const t=i.childrenToUpdate,s=i.updateTick++;for(const r in t){const n=Number(r),o=t[r],a=o.list,l=o.index;for(let c=0;c<l;c++){const h=a[c];h.parentRenderGroup===i&&h.relativeRenderGroupDepth===n&&S_(h,s,0)}Bd(a,l),o.index=0}if(e)for(let r=0;r<i.renderGroupChildren.length;r++)w_(i.renderGroupChildren[r],e)}function z3(i){const e=i.root;let t;if(i.renderGroupParent){const s=i.renderGroupParent;i.worldTransform.appendFrom(e.relativeGroupTransform,s.worldTransform),i.worldColor=Fr(e.groupColor,s.worldColor),t=e.groupAlpha*s.worldAlpha}else i.worldTransform.copyFrom(e.localTransform),i.worldColor=e.localColor,t=e.localAlpha;t=t<0?0:t>1?1:t,i.worldAlpha=t,i.worldColorAlpha=i.worldColor+((t*255|0)<<24)}function S_(i,e,t){if(e===i.updateTick)return;i.updateTick=e,i.didChange=!1;const s=i.localTransform;i.updateLocalTransform();const r=i.parent;if(r&&!r.renderGroup?(t|=i._updateFlags,i.relativeGroupTransform.appendFrom(s,r.relativeGroupTransform),t&T_&&C_(i,r,t)):(t=i._updateFlags,i.relativeGroupTransform.copyFrom(s),t&T_&&C_(i,G3,t)),!i.renderGroup){const n=i.children,o=n.length;for(let c=0;c<o;c++)S_(n[c],e,t);const a=i.parentRenderGroup,l=i;l.renderPipeId&&!a.structureDidChange&&a.updateRenderable(l)}}function C_(i,e,t){if(t&Dr){i.groupColor=Fr(i.localColor,e.groupColor);let s=i.localAlpha*e.groupAlpha;s=s<0?0:s>1?1:s,i.groupAlpha=s,i.groupColorAlpha=i.groupColor+((s*255|0)<<24)}t&yu&&(i.groupBlendMode=i.localBlendMode==="inherit"?e.groupBlendMode:i.localBlendMode),t&fs&&(i.globalDisplayStatus=i.localDisplayStatus&e.globalDisplayStatus),i._updateFlags=0}function L3(i,e){const{list:t}=i.childrenRenderablesToUpdate;let s=!1;for(let r=0;r<i.childrenRenderablesToUpdate.index;r++){const n=t[r];if(s=e[n.renderPipeId].validateRenderable(n),s)break}return i.structureDidChange=s,s}const N3=new O;class A_{constructor(e){this._renderer=e}render({container:e,transform:t}){const s=e.parent,r=e.renderGroup.renderGroupParent;e.parent=null,e.renderGroup.renderGroupParent=null;const n=this._renderer,o=N3;t&&(o.copyFrom(e.renderGroup.localTransform),e.renderGroup.localTransform.copyFrom(t));const a=n.renderPipes;this._updateCachedRenderGroups(e.renderGroup,null),this._updateRenderGroups(e.renderGroup),n.globalUniforms.start({worldTransformMatrix:t?e.renderGroup.localTransform:e.renderGroup.worldTransform,worldColor:e.renderGroup.worldColorAlpha}),Ud(e.renderGroup,a),a.uniformBatch&&a.uniformBatch.renderEnd(),t&&e.renderGroup.localTransform.copyFrom(o),e.parent=s,e.renderGroup.renderGroupParent=r}destroy(){this._renderer=null}_updateCachedRenderGroups(e,t){if(e._parentCacheAsTextureRenderGroup=t,e.isCachedAsTexture){if(!e.textureNeedsUpdate)return;t=e}for(let s=e.renderGroupChildren.length-1;s>=0;s--)this._updateCachedRenderGroups(e.renderGroupChildren[s],t);if(e.invalidateMatrices(),e.isCachedAsTexture){if(e.textureNeedsUpdate){const s=e.root.getLocalBounds();s.ceil();const r=e.texture;e.texture&&ye.returnTexture(e.texture,!0);const n=this._renderer,o=e.textureOptions.resolution||n.view.resolution,a=e.textureOptions.antialias??n.view.antialias,l=e.textureOptions.scaleMode??"linear",c=ye.getOptimalTexture(s.width,s.height,o,a);c._source.style=new Ct({scaleMode:l}),e.texture=c,e._textureBounds||(e._textureBounds=new De),e._textureBounds.copyFrom(s),r!==e.texture&&e.renderGroupParent&&(e.renderGroupParent.structureDidChange=!0)}}else e.texture&&(ye.returnTexture(e.texture,!0),e.texture=null)}_updateRenderGroups(e){const t=this._renderer,s=t.renderPipes;if(e.runOnRender(t),e.instructionSet.renderPipes=s,e.structureDidChange?Bd(e.childrenRenderablesToUpdate.list,0):L3(e,s),w_(e),e.structureDidChange?(e.structureDidChange=!1,this._buildInstructions(e,t)):this._updateRenderables(e),e.childrenRenderablesToUpdate.index=0,t.renderPipes.batch.upload(e.instructionSet),!(e.isCachedAsTexture&&!e.textureNeedsUpdate))for(let r=0;r<e.renderGroupChildren.length;r++)this._updateRenderGroups(e.renderGroupChildren[r])}_updateRenderables(e){const{list:t,index:s}=e.childrenRenderablesToUpdate;for(let r=0;r<s;r++){const n=t[r];n.didViewUpdate&&e.updateRenderable(n)}Bd(t,s)}_buildInstructions(e,t){const s=e.root,r=e.instructionSet;r.reset();const n=t.renderPipes?t:t.batch.renderer,o=n.renderPipes;o.batch.buildStart(r),o.blendMode.buildStart(),o.colorMask.buildStart(),s.sortableChildren&&s.sortChildren(),s.collectRenderablesWithEffects(r,n,null),o.batch.buildEnd(r),o.blendMode.buildEnd(r)}}A_.extension={type:[b.WebGLSystem,b.WebGPUSystem,b.CanvasSystem],name:"renderGroup"};class E_{constructor(e){this._renderer=e}addRenderable(e,t){const s=this._getGpuSprite(e);e.didViewUpdate&&this._updateBatchableSprite(e,s),this._renderer.renderPipes.batch.addToBatch(s,t)}updateRenderable(e){const t=this._getGpuSprite(e);e.didViewUpdate&&this._updateBatchableSprite(e,t),t._batcher.updateElement(t)}validateRenderable(e){const t=this._getGpuSprite(e);return!t._batcher.checkAndUpdateTexture(t,e._texture)}_updateBatchableSprite(e,t){t.bounds=e.visualBounds,t.texture=e._texture}_getGpuSprite(e){return e._gpuData[this._renderer.uid]||this._initGPUSprite(e)}_initGPUSprite(e){const t=new dn;return t.renderable=e,t.transform=e.groupTransform,t.texture=e._texture,t.bounds=e.visualBounds,t.roundPixels=this._renderer._roundPixels|e._roundPixels,e._gpuData[this._renderer.uid]=t,t}destroy(){this._renderer=null}}E_.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"sprite"};const Od=class cv{constructor(){this.clearBeforeRender=!0,this._backgroundColor=new ue(0),this.color=this._backgroundColor,this.alpha=1}init(e){e={...cv.defaultOptions,...e},this.clearBeforeRender=e.clearBeforeRender,this.color=e.background||e.backgroundColor||this._backgroundColor,this.alpha=e.backgroundAlpha,this._backgroundColor.setAlpha(e.backgroundAlpha)}get color(){return this._backgroundColor}set color(e){ue.shared.setValue(e).alpha<1&&this._backgroundColor.alpha===1&&H("Cannot set a transparent background on an opaque canvas. To enable transparency, set backgroundAlpha < 1 when initializing your Application."),this._backgroundColor.setValue(e)}get alpha(){return this._backgroundColor.alpha}set alpha(e){this._backgroundColor.setAlpha(e)}get colorRgba(){return this._backgroundColor.toArray()}destroy(){}};Od.extension={type:[b.WebGLSystem,b.WebGPUSystem,b.CanvasSystem],name:"background",priority:0},Od.defaultOptions={backgroundAlpha:1,backgroundColor:0,clearBeforeRender:!0};let H3=Od;const Vs={};V.handle(b.BlendMode,i=>{if(!i.name)throw new Error("BlendMode extension must have a name property");Vs[i.name]=i.ref},i=>{delete Vs[i.name]});class I_{constructor(e){this._blendModeStack=[],this._isAdvanced=!1,this._filterHash=Object.create(null),this._renderer=e,this._renderer.runners.prerender.add(this)}prerender(){this._activeBlendMode="normal",this._isAdvanced=!1}pushBlendMode(e,t,s){this._blendModeStack.push(t),this.setBlendMode(e,t,s)}popBlendMode(e){this._blendModeStack.pop();const t=this._blendModeStack[this._activeBlendMode.length-1]??"normal";this.setBlendMode(null,t,e)}setBlendMode(e,t,s){const r=e instanceof _u;if(this._activeBlendMode===t){this._isAdvanced&&e&&!r&&this._renderableList?.push(e);return}this._isAdvanced&&this._endAdvancedBlendMode(s),this._activeBlendMode=t,e&&(this._isAdvanced=!!Vs[t],this._isAdvanced&&this._beginAdvancedBlendMode(e,s))}_beginAdvancedBlendMode(e,t){this._renderer.renderPipes.batch.break(t);const s=this._activeBlendMode;if(!Vs[s]){H(`Unable to assign BlendMode: '${s}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);return}const r=this._ensureFilterEffect(s),n=e instanceof _u,o={renderPipeId:"filter",action:"pushFilter",filterEffect:r,renderables:n?null:[e],container:n?e.root:null,canBundle:!1};this._renderableList=o.renderables,t.add(o)}_ensureFilterEffect(e){let t=this._filterHash[e];return t||(t=this._filterHash[e]=new Mr,t.filters=[new Vs[e]]),t}_endAdvancedBlendMode(e){this._isAdvanced=!1,this._renderableList=null,this._renderer.renderPipes.batch.break(e),e.add({renderPipeId:"filter",action:"popFilter",canBundle:!1})}buildStart(){this._isAdvanced=!1}buildEnd(e){this._isAdvanced&&this._endAdvancedBlendMode(e)}destroy(){this._renderer=null,this._renderableList=null;for(const e in this._filterHash)this._filterHash[e].destroy();this._filterHash=null}}I_.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"blendMode"};const Dd={png:"image/png",jpg:"image/jpeg",webp:"image/webp"},Gd=class hv{constructor(e){this._renderer=e}_normalizeOptions(e,t={}){return e instanceof se||e instanceof k?{target:e,...t}:{...t,...e}}async image(e){const t=Y.get().createImage();return t.src=await this.base64(e),t}async base64(e){e=this._normalizeOptions(e,hv.defaultImageOptions);const{format:t,quality:s}=e,r=this.canvas(e);if(r.toBlob!==void 0)return new Promise((n,o)=>{r.toBlob(a=>{if(!a){o(new Error("ICanvas.toBlob failed!"));return}const l=new FileReader;l.onload=()=>n(l.result),l.onerror=o,l.readAsDataURL(a)},Dd[t],s)});if(r.toDataURL!==void 0)return r.toDataURL(Dd[t],s);if(r.convertToBlob!==void 0){const n=await r.convertToBlob({type:Dd[t],quality:s});return new Promise((o,a)=>{const l=new FileReader;l.onload=()=>o(l.result),l.onerror=a,l.readAsDataURL(n)})}throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")}canvas(e){e=this._normalizeOptions(e);const t=e.target,s=this._renderer;if(t instanceof k)return s.texture.generateCanvas(t);const r=s.textureGenerator.generateTexture(e),n=s.texture.generateCanvas(r);return r.destroy(!0),n}pixels(e){e=this._normalizeOptions(e);const t=e.target,s=this._renderer,r=t instanceof k?t:s.textureGenerator.generateTexture(e),n=s.texture.getPixels(r);return t instanceof se&&r.destroy(!0),n}texture(e){return e=this._normalizeOptions(e),e.target instanceof k?e.target:this._renderer.textureGenerator.generateTexture(e)}download(e){e=this._normalizeOptions(e);const t=this.canvas(e),s=document.createElement("a");s.download=e.filename??"image.png",s.href=t.toDataURL("image/png"),document.body.appendChild(s),s.click(),document.body.removeChild(s)}log(e){const t=e.width??200;e=this._normalizeOptions(e);const s=this.canvas(e),r=s.toDataURL();console.log(`[Pixi Texture] ${s.width}px ${s.height}px`);const n=["font-size: 1px;",`padding: ${t}px 300px;`,`background: url(${r}) no-repeat;`,"background-size: contain;"].join(" ");console.log("%c ",n)}destroy(){this._renderer=null}};Gd.extension={type:[b.WebGLSystem,b.WebGPUSystem],name:"extract"},Gd.defaultImageOptions={format:"png",quality:1};let W3=Gd;class Ge extends k{static create(e){const{dynamic:t,...s}=e;return new Ge({source:new Ee(s),dynamic:t??!1})}resize(e,t,s){return this.source.resize(e,t,s),this}}const V3=new W,$3=new De,X3=[0,0,0,0];class P_{constructor(e){this._renderer=e}generateTexture(e){e instanceof se&&(e={target:e,frame:void 0,textureSourceOptions:{},resolution:void 0});const t=e.resolution||this._renderer.resolution,s=e.antialias||this._renderer.view.antialias,r=e.target;let n=e.clearColor;n?n=Array.isArray(n)&&n.length===4?n:ue.shared.setValue(n).toArray():n=X3;const o=e.frame?.copyTo(V3)||gu(r,$3).rectangle;o.width=Math.max(o.width,1/t)|0,o.height=Math.max(o.height,1/t)|0;const a=Ge.create({...e.textureSourceOptions,width:o.width,height:o.height,resolution:t,antialias:s}),l=O.shared.translate(-o.x,-o.y);return this._renderer.render({container:r,transform:l,target:a,clearColor:n}),a.source.updateMipmaps(),a}destroy(){this._renderer=null}}P_.extension={type:[b.WebGLSystem,b.WebGPUSystem],name:"textureGenerator"};const zd=class uv{constructor(e){this._managedResources=[],this._managedResourceHashes=[],this._ready=!1,this._renderer=e}init(e){e={...uv.defaultOptions,...e},this.maxUnusedTime=e.gcMaxUnusedTime,this._frequency=e.gcFrequency,this.enabled=e.gcActive,this.now=performance.now()}get enabled(){return!!this._handler}set enabled(e){this.enabled!==e&&(e?this._handler=this._renderer.scheduler.repeat(()=>{this._ready=!0},this._frequency,!1):(this._renderer.scheduler.cancel(this._handler),this._handler=0))}prerender({container:e}){this.now=performance.now(),e.renderGroup.gcTick=this._renderer.tick++,this._updateInstructionGCTick(e.renderGroup,e.renderGroup.gcTick)}postrender(){!this._ready||!this.enabled||(this.run(),this._ready=!1)}_updateInstructionGCTick(e,t){e.instructionSet.gcTick=t;for(const s of e.renderGroupChildren)this._updateInstructionGCTick(s,t)}addResource(e,t){if(e._gcLastUsed!==-1){e._gcLastUsed=this.now,e._onTouch?.(this.now);return}const s=this._managedResources.length;e._gcData={index:s,type:t},e._gcLastUsed=this.now,e._onTouch?.(this.now),e.once("unload",this.removeResource,this),this._managedResources.push(e)}removeResource(e){const t=e._gcData;if(!t)return;const s=t.index,r=this._managedResources.length-1;if(s!==r){const n=this._managedResources[r];this._managedResources[s]=n,n._gcData.index=s}this._managedResources.length--,e._gcData=null,e._gcLastUsed=-1}addResourceHash(e,t,s,r=0){this._managedResourceHashes.push({context:e,hash:t,type:s,priority:r}),this._managedResourceHashes.sort((n,o)=>n.priority-o.priority)}run(){const e=performance.now(),t=this._managedResourceHashes;for(const r of t)this.runOnHash(r,e);let s=0;for(let r=0;r<this._managedResources.length;r++){const n=this._managedResources[r];s=this.runOnResource(n,e,s)}this._managedResources.length=s}updateRenderableGCTick(e,t){const s=e.renderGroup??e.parentRenderGroup,r=s?.instructionSet?.gcTick??-1;(s?.gcTick??0)===r&&(e._gcLastUsed=t,e._onTouch?.(t))}runOnResource(e,t,s){const r=e._gcData;return r.type==="renderable"&&this.updateRenderableGCTick(e,t),t-e._gcLastUsed<this.maxUnusedTime||!e.autoGarbageCollect?(this._managedResources[s]=e,r.index=s,s++):(e.unload(),e._gcData=null,e._gcLastUsed=-1,e.off("unload",this.removeResource,this)),s}_createHashClone(e,t){const s=Object.create(null);for(const r in e){if(r===t)break;e[r]!==null&&(s[r]=e[r])}return s}runOnHash(e,t){const{context:s,hash:r,type:n}=e,o=s[r];let a=null,l=0;for(const c in o){const h=o[c];if(h===null){l++,l===1e4&&!a&&(a=this._createHashClone(o,c));continue}if(h._gcLastUsed===-1){h._gcLastUsed=t,h._onTouch?.(t),a&&(a[c]=h);continue}n==="renderable"&&this.updateRenderableGCTick(h,t),!(t-h._gcLastUsed<this.maxUnusedTime)&&h.autoGarbageCollect?(a||(l+1!==1e4?(o[c]=null,l++):a=this._createHashClone(o,c)),h.unload(),h._gcData=null,h._gcLastUsed=-1):a&&(a[c]=h)}a&&(s[r]=a)}destroy(){this.enabled=!1,this._managedResources.forEach(e=>{e.off("unload",this.removeResource,this)}),this._managedResources.length=0,this._managedResourceHashes.length=0,this._renderer=null}};zd.extension={type:[b.WebGLSystem,b.WebGPUSystem],name:"gc",priority:0},zd.defaultOptions={gcActive:!0,gcMaxUnusedTime:6e4,gcFrequency:3e4};let Y3=zd;function $s(i,e,t){const s=(i>>24&255)/255;e[t++]=(i&255)/255*s,e[t++]=(i>>8&255)/255*s,e[t++]=(i>>16&255)/255*s,e[t++]=s}class R_{constructor(e){this._stackIndex=0,this._globalUniformDataStack=[],this._uniformsPool=[],this._activeUniforms=[],this._bindGroupPool=[],this._activeBindGroups=[],this._renderer=e}reset(){this._stackIndex=0;for(let e=0;e<this._activeUniforms.length;e++)this._uniformsPool.push(this._activeUniforms[e]);for(let e=0;e<this._activeBindGroups.length;e++)this._bindGroupPool.push(this._activeBindGroups[e]);this._activeUniforms.length=0,this._activeBindGroups.length=0}start(e){this.reset(),this.push(e)}bind({size:e,projectionMatrix:t,worldTransformMatrix:s,worldColor:r,offset:n}){const o=this._renderer.renderTarget.renderTarget,a=this._stackIndex?this._globalUniformDataStack[this._stackIndex-1]:{worldTransformMatrix:new O,worldColor:4294967295,offset:new X},l={projectionMatrix:t||this._renderer.renderTarget.projectionMatrix,resolution:e||o.size,worldTransformMatrix:s||a.worldTransformMatrix,worldColor:r||a.worldColor,offset:n||a.offset,bindGroup:null},c=this._uniformsPool.pop()||this._createUniforms();this._activeUniforms.push(c);const h=c.uniforms;h.uProjectionMatrix=l.projectionMatrix,h.uResolution=l.resolution,h.uWorldTransformMatrix.copyFrom(l.worldTransformMatrix),h.uWorldTransformMatrix.tx-=l.offset.x,h.uWorldTransformMatrix.ty-=l.offset.y,$s(l.worldColor,h.uWorldColorAlpha,0),c.update();let u;this._renderer.renderPipes.uniformBatch?u=this._renderer.renderPipes.uniformBatch.getUniformBindGroup(c,!1):(u=this._bindGroupPool.pop()||new Gt,this._activeBindGroups.push(u),u.setResource(c,0)),l.bindGroup=u,this._currentGlobalUniformData=l}push(e){this.bind(e),this._globalUniformDataStack[this._stackIndex++]=this._currentGlobalUniformData}pop(){this._currentGlobalUniformData=this._globalUniformDataStack[--this._stackIndex-1],this._renderer.type===et.WEBGL&&this._currentGlobalUniformData.bindGroup.resources[0].update()}get bindGroup(){return this._currentGlobalUniformData.bindGroup}get globalUniformData(){return this._currentGlobalUniformData}get uniformGroup(){return this._currentGlobalUniformData.bindGroup.resources[0]}_createUniforms(){return new We({uProjectionMatrix:{value:new O,type:"mat3x3<f32>"},uWorldTransformMatrix:{value:new O,type:"mat3x3<f32>"},uWorldColorAlpha:{value:new Float32Array(4),type:"vec4<f32>"},uResolution:{value:[0,0],type:"vec2<f32>"}},{isStatic:!0})}destroy(){this._renderer=null,this._globalUniformDataStack.length=0,this._uniformsPool.length=0,this._activeUniforms.length=0,this._bindGroupPool.length=0,this._activeBindGroups.length=0,this._currentGlobalUniformData=null}}R_.extension={type:[b.WebGLSystem,b.WebGPUSystem,b.CanvasSystem],name:"globalUniforms"};let q3=1;class k_{constructor(){this._tasks=[],this._offset=0}init(){Je.system.add(this._update,this)}repeat(e,t,s=!0){const r=q3++;let n=0;return s&&(this._offset+=1e3,n=this._offset),this._tasks.push({func:e,duration:t,start:performance.now(),offset:n,last:performance.now(),repeat:!0,id:r}),r}cancel(e){for(let t=0;t<this._tasks.length;t++)if(this._tasks[t].id===e){this._tasks.splice(t,1);return}}_update(){const e=performance.now();for(let t=0;t<this._tasks.length;t++){const s=this._tasks[t];if(e-s.offset-s.last>=s.duration){const r=e-s.start;s.func(r),s.last=e}}}destroy(){Je.system.remove(this._update,this),this._tasks.length=0}}k_.extension={type:[b.WebGLSystem,b.WebGPUSystem,b.CanvasSystem],name:"scheduler",priority:0};let M_=!1;function K3(i){if(!M_){if(Y.get().getNavigator().userAgent.toLowerCase().indexOf("chrome")>-1){const e=[`%c  %c  %c  %c  %c PixiJS %c v${qr} (${i}) http://www.pixijs.com/

`,"background: #E72264; padding:5px 0;","background: #6CA2EA; padding:5px 0;","background: #B5D33D; padding:5px 0;","background: #FED23F; padding:5px 0;","color: #FFFFFF; background: #E72264; padding:5px 0;","color: #E72264; background: #FFFFFF; padding:5px 0;"];globalThis.console.log(...e)}else globalThis.console&&globalThis.console.log(`PixiJS ${qr} - ${i} - http://www.pixijs.com/`);M_=!0}}class Ld{constructor(e){this._renderer=e}init(e){if(e.hello){let t=this._renderer.name;this._renderer.type===et.WEBGL&&(t+=` ${this._renderer.context.webGLVersion}`),K3(t)}}}Ld.extension={type:[b.WebGLSystem,b.WebGPUSystem,b.CanvasSystem],name:"hello",priority:-2},Ld.defaultOptions={hello:!1};function j3(i){let e=!1;for(const s in i)if(i[s]==null){e=!0;break}if(!e)return i;const t=Object.create(null);for(const s in i){const r=i[s];r&&(t[s]=r)}return t}function Z3(i){let e=0;for(let t=0;t<i.length;t++)i[t]==null?e++:i[t-e]=i[t];return i.length-=e,i}let J3=0;const Nd=class dv{constructor(e){this._managedRenderables=[],this._managedHashes=[],this._managedArrays=[],this._renderer=e}init(e){e={...dv.defaultOptions,...e},this.maxUnusedTime=e.renderableGCMaxUnusedTime,this._frequency=e.renderableGCFrequency,this.enabled=e.renderableGCActive}get enabled(){return!!this._handler}set enabled(e){this.enabled!==e&&(e?(this._handler=this._renderer.scheduler.repeat(()=>this.run(),this._frequency,!1),this._hashHandler=this._renderer.scheduler.repeat(()=>{for(const t of this._managedHashes)t.context[t.hash]=j3(t.context[t.hash])},this._frequency),this._arrayHandler=this._renderer.scheduler.repeat(()=>{for(const t of this._managedArrays)Z3(t.context[t.hash])},this._frequency)):(this._renderer.scheduler.cancel(this._handler),this._renderer.scheduler.cancel(this._hashHandler),this._renderer.scheduler.cancel(this._arrayHandler)))}addManagedHash(e,t){this._managedHashes.push({context:e,hash:t})}addManagedArray(e,t){this._managedArrays.push({context:e,hash:t})}prerender({container:e}){this._now=performance.now(),e.renderGroup.gcTick=J3++,this._updateInstructionGCTick(e.renderGroup,e.renderGroup.gcTick)}addRenderable(e){this.enabled&&(e._lastUsed===-1&&(this._managedRenderables.push(e),e.once("destroyed",this._removeRenderable,this)),e._lastUsed=this._now)}run(){const e=this._now,t=this._managedRenderables,s=this._renderer.renderPipes;let r=0;for(let n=0;n<t.length;n++){const o=t[n];if(o===null){r++;continue}const a=o.renderGroup??o.parentRenderGroup,l=a?.instructionSet?.gcTick??-1;if((a?.gcTick??0)===l&&(o._lastUsed=e),e-o._lastUsed>this.maxUnusedTime){if(!o.destroyed){const c=s;a&&(a.structureDidChange=!0),c[o.renderPipeId].destroyRenderable(o)}o._lastUsed=-1,r++,o.off("destroyed",this._removeRenderable,this)}else t[n-r]=o}t.length-=r}destroy(){this.enabled=!1,this._renderer=null,this._managedRenderables.length=0,this._managedHashes.length=0,this._managedArrays.length=0}_removeRenderable(e){const t=this._managedRenderables.indexOf(e);t>=0&&(e.off("destroyed",this._removeRenderable,this),this._managedRenderables[t]=null)}_updateInstructionGCTick(e,t){e.instructionSet.gcTick=t;for(const s of e.renderGroupChildren)this._updateInstructionGCTick(s,t)}};Nd.extension={type:[b.WebGLSystem,b.WebGPUSystem],name:"renderableGC",priority:0},Nd.defaultOptions={renderableGCActive:!0,renderableGCMaxUnusedTime:6e4,renderableGCFrequency:3e4};let Q3=Nd;const Hd=class xn{get count(){return this._renderer.tick}get checkCount(){return this._checkCount}set checkCount(e){L("8.15.0","TextureGCSystem.run is deprecated, please use the GCSystem instead."),this._checkCount=e}get maxIdle(){return this._renderer.gc.maxUnusedTime/1e3*60}set maxIdle(e){L("8.15.0","TextureGCSystem.run is deprecated, please use the GCSystem instead."),this._renderer.gc.maxUnusedTime=e/60*1e3}get checkCountMax(){return Math.floor(this._renderer.gc._frequency/1e3)}set checkCountMax(e){L("8.15.0","TextureGCSystem.run is deprecated, please use the GCSystem instead.")}get active(){return this._renderer.gc.enabled}set active(e){L("8.15.0","TextureGCSystem.run is deprecated, please use the GCSystem instead."),this._renderer.gc.enabled=e}constructor(e){this._renderer=e,this._checkCount=0}init(e){e.textureGCActive!==xn.defaultOptions.textureGCActive&&(this.active=e.textureGCActive),e.textureGCMaxIdle!==xn.defaultOptions.textureGCMaxIdle&&(this.maxIdle=e.textureGCMaxIdle),e.textureGCCheckCountMax!==xn.defaultOptions.textureGCCheckCountMax&&(this.checkCountMax=e.textureGCCheckCountMax)}run(){L("8.15.0","TextureGCSystem.run is deprecated, please use the GCSystem instead."),this._renderer.gc.run()}destroy(){this._renderer=null}};Hd.extension={type:[b.WebGLSystem,b.WebGPUSystem],name:"textureGC"},Hd.defaultOptions={textureGCActive:!0,textureGCAMaxIdle:null,textureGCMaxIdle:3600,textureGCCheckCountMax:600};let eP=Hd;const Wd=class fv{get autoDensity(){return this.texture.source.autoDensity}set autoDensity(e){this.texture.source.autoDensity=e}get resolution(){return this.texture.source._resolution}set resolution(e){this.texture.source.resize(this.texture.source.width,this.texture.source.height,e)}init(e){e={...fv.defaultOptions,...e},e.view&&(L(J,"ViewSystem.view has been renamed to ViewSystem.canvas"),e.canvas=e.view),this.screen=new W(0,0,e.width,e.height),this.canvas=e.canvas||Y.get().createCanvas(),this.antialias=!!e.antialias,this.texture=i_(this.canvas,e),this.renderTarget=new Rd({colorTextures:[this.texture],depth:!!e.depth,isRoot:!0}),this.texture.source.transparent=e.backgroundAlpha<1,this.resolution=e.resolution}resize(e,t,s){this.texture.source.resize(e,t,s),this.screen.width=this.texture.frame.width,this.screen.height=this.texture.frame.height}destroy(e=!1){(typeof e=="boolean"?e:e?.removeView)&&this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas),this.texture.destroy()}};Wd.extension={type:[b.WebGLSystem,b.WebGPUSystem,b.CanvasSystem],name:"view",priority:0},Wd.defaultOptions={width:800,height:600,autoDensity:!1,antialias:!1};const F_=[H3,R_,Ld,Wd,A_,Y3,eP,P_,W3,ag,Q3,k_],U_=[I_,G0,E_,b_,z0,N0,L0,y_],tP=[...F_,t_,ZI,$I,K0,H0,__,n_,X0,d_,u_,q0,C3,j0,Y0],iP=[...U_],sP=[O0,v_,x_],B_=[],O_=[],D_=[];V.handleByNamedList(b.WebGLSystem,B_),V.handleByNamedList(b.WebGLPipes,O_),V.handleByNamedList(b.WebGLPipesAdaptor,D_),V.add(...tP,...iP,...sP);class rP extends $r{constructor(){const e={name:"webgl",type:et.WEBGL,systems:B_,renderPipes:O_,renderPipeAdaptors:D_};super(e)}}const nP=Object.freeze(Object.defineProperty({__proto__:null,WebGLRenderer:rP},Symbol.toStringTag,{value:"Module"}));class G_{constructor(e){this._hash=Object.create(null),this._renderer=e}contextChange(e){this._gpu=e}getBindGroup(e,t,s){return e._updateKey(),this._hash[e._key]||this._createBindGroup(e,t,s)}_createBindGroup(e,t,s){const r=this._gpu.device,n=t.layout[s],o=[],a=this._renderer;for(const h in n){const u=e.resources[h]??e.resources[n[h]];let d;if(u._resourceType==="uniformGroup"){const f=u;a.ubo.updateUniformGroup(f);const m=f.buffer;d={buffer:a.buffer.getGPUBuffer(m),offset:0,size:m.descriptor.size}}else if(u._resourceType==="buffer"){const f=u;d={buffer:a.buffer.getGPUBuffer(f),offset:0,size:f.descriptor.size}}else if(u._resourceType==="bufferResource"){const f=u;d={buffer:a.buffer.getGPUBuffer(f.buffer),offset:f.offset,size:f.size}}else if(u._resourceType==="textureSampler"){const f=u;d=a.texture.getGpuSampler(f)}else if(u._resourceType==="textureSource"){const f=u;d=a.texture.getGpuSource(f).createView()}o.push({binding:n[h],resource:d})}const l=a.shader.getProgramData(t).bindGroups[s],c=r.createBindGroup({layout:l,entries:o});return this._hash[e._key]=c,c}destroy(){this._hash=null,this._renderer=null}}G_.extension={type:[b.WebGPUSystem],name:"bindGroup"};class oP{constructor(e){this.gpuBuffer=e}destroy(){this.gpuBuffer.destroy(),this.gpuBuffer=null}}class z_{constructor(e){this._renderer=e,this._managedBuffers=new st({renderer:e,type:"resource",onUnload:this.onBufferUnload.bind(this),name:"gpuBuffer"})}contextChange(e){this._gpu=e}getGPUBuffer(e){return e._gcLastUsed=this._renderer.gc.now,e._gpuData[this._renderer.uid]?.gpuBuffer||this.createGPUBuffer(e)}updateBuffer(e){const t=this.getGPUBuffer(e),s=e.data;return e._updateID&&s&&(e._updateID=0,this._gpu.device.queue.writeBuffer(t,0,s.buffer,0,(e._updateSize||s.byteLength)+3&-4)),t}destroyAll(){this._managedBuffers.removeAll()}onBufferUnload(e){e.off("update",this.updateBuffer,this),e.off("change",this.onBufferChange,this)}createGPUBuffer(e){const t=this._gpu.device.createBuffer(e.descriptor);return e._updateID=0,e._resourceId=le("resource"),e.data&&(Ku(e.data.buffer,t.getMappedRange()),t.unmap()),e._gpuData[this._renderer.uid]=new oP(t),this._managedBuffers.add(e)&&(e.on("update",this.updateBuffer,this),e.on("change",this.onBufferChange,this)),t}onBufferChange(e){this._managedBuffers.remove(e),e._updateID=0,this.createGPUBuffer(e)}destroy(){this._managedBuffers.destroy(),this._renderer=null,this._gpu=null}}z_.extension={type:[b.WebGPUSystem],name:"buffer"};class aP{constructor({minUniformOffsetAlignment:e}){this._minUniformOffsetAlignment=256,this.byteIndex=0,this._minUniformOffsetAlignment=e,this.data=new Float32Array(65535)}clear(){this.byteIndex=0}addEmptyGroup(e){if(e>this._minUniformOffsetAlignment/4)throw new Error(`UniformBufferBatch: array is too large: ${e*4}`);const t=this.byteIndex;let s=t+e*4;if(s=Math.ceil(s/this._minUniformOffsetAlignment)*this._minUniformOffsetAlignment,s>this.data.length*4)throw new Error("UniformBufferBatch: ubo batch got too big");return this.byteIndex=s,t}addGroup(e){const t=this.addEmptyGroup(e.length);for(let s=0;s<e.length;s++)this.data[t/4+s]=e[s];return t}destroy(){this.data=null}}class L_{constructor(e){this._colorMaskCache=15,this._renderer=e}setMask(e){this._colorMaskCache!==e&&(this._colorMaskCache=e,this._renderer.pipeline.setColorMask(e))}destroy(){this._renderer=null,this._colorMaskCache=null}}L_.extension={type:[b.WebGPUSystem],name:"colorMask"};class Vd{constructor(e){this._renderer=e}async init(e){return this._initPromise?this._initPromise:(this._initPromise=(e.gpu?Promise.resolve(e.gpu):this._createDeviceAndAdaptor(e)).then(t=>{this.gpu=t,this._renderer.runners.contextChange.emit(this.gpu)}),this._initPromise)}contextChange(e){this._renderer.gpu=e}async _createDeviceAndAdaptor(e){const t=await Y.get().getNavigator().gpu.requestAdapter({powerPreference:e.powerPreference,forceFallbackAdapter:e.forceFallbackAdapter}),s=["texture-compression-bc","texture-compression-astc","texture-compression-etc2"].filter(n=>t.features.has(n)),r=await t.requestDevice({requiredFeatures:s});return{adapter:t,device:r}}destroy(){this.gpu=null,this._renderer=null}}Vd.extension={type:[b.WebGPUSystem],name:"device"},Vd.defaultOptions={powerPreference:void 0,forceFallbackAdapter:!1};class N_{constructor(e){this._boundBindGroup=Object.create(null),this._boundVertexBuffer=Object.create(null),this._renderer=e}renderStart(){this.commandFinished=new Promise(e=>{this._resolveCommandFinished=e}),this.commandEncoder=this._renderer.gpu.device.createCommandEncoder()}beginRenderPass(e){this.endRenderPass(),this._clearCache(),this.renderPassEncoder=this.commandEncoder.beginRenderPass(e.descriptor)}endRenderPass(){this.renderPassEncoder&&this.renderPassEncoder.end(),this.renderPassEncoder=null}setViewport(e){this.renderPassEncoder.setViewport(e.x,e.y,e.width,e.height,0,1)}setPipelineFromGeometryProgramAndState(e,t,s,r){const n=this._renderer.pipeline.getPipeline(e,t,s,r);this.setPipeline(n)}setPipeline(e){this._boundPipeline!==e&&(this._boundPipeline=e,this.renderPassEncoder.setPipeline(e))}_setVertexBuffer(e,t){this._boundVertexBuffer[e]!==t&&(this._boundVertexBuffer[e]=t,this.renderPassEncoder.setVertexBuffer(e,this._renderer.buffer.updateBuffer(t)))}_setIndexBuffer(e){if(this._boundIndexBuffer===e)return;this._boundIndexBuffer=e;const t=e.data.BYTES_PER_ELEMENT===2?"uint16":"uint32";this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(e),t)}resetBindGroup(e){this._boundBindGroup[e]=null}setBindGroup(e,t,s){if(this._boundBindGroup[e]===t)return;this._boundBindGroup[e]=t,t._touch(this._renderer.gc.now,this._renderer.tick);const r=this._renderer.bindGroup.getBindGroup(t,s,e);this.renderPassEncoder.setBindGroup(e,r)}setGeometry(e,t){const s=this._renderer.pipeline.getBufferNamesToBind(e,t);for(const r in s)this._setVertexBuffer(parseInt(r,10),e.attributes[s[r]].buffer);e.indexBuffer&&this._setIndexBuffer(e.indexBuffer)}_setShaderBindGroups(e,t){for(const s in e.groups){const r=e.groups[s];t||this._syncBindGroup(r),this.setBindGroup(s,r,e.gpuProgram)}}_syncBindGroup(e){for(const t in e.resources){const s=e.resources[t];s.isUniformGroup&&this._renderer.ubo.updateUniformGroup(s)}}draw(e){const{geometry:t,shader:s,state:r,topology:n,size:o,start:a,instanceCount:l,skipSync:c}=e;this.setPipelineFromGeometryProgramAndState(t,s.gpuProgram,r,n),this.setGeometry(t,s.gpuProgram),this._setShaderBindGroups(s,c),t.indexBuffer?this.renderPassEncoder.drawIndexed(o||t.indexBuffer.data.length,l??t.instanceCount,a||0):this.renderPassEncoder.draw(o||t.getSize(),l??t.instanceCount,a||0)}finishRenderPass(){this.renderPassEncoder&&(this.renderPassEncoder.end(),this.renderPassEncoder=null)}postrender(){this.finishRenderPass(),this._gpu.device.queue.submit([this.commandEncoder.finish()]),this._resolveCommandFinished(),this.commandEncoder=null}restoreRenderPass(){const e=this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget,!1,[0,0,0,1]);this.renderPassEncoder=this.commandEncoder.beginRenderPass(e);const t=this._boundPipeline,s={...this._boundVertexBuffer},r=this._boundIndexBuffer,n={...this._boundBindGroup};this._clearCache();const o=this._renderer.renderTarget.viewport;this.renderPassEncoder.setViewport(o.x,o.y,o.width,o.height,0,1),this.setPipeline(t);for(const a in s)this._setVertexBuffer(a,s[a]);for(const a in n)this.setBindGroup(a,n[a],null);this._setIndexBuffer(r)}_clearCache(){for(let e=0;e<16;e++)this._boundBindGroup[e]=null,this._boundVertexBuffer[e]=null;this._boundIndexBuffer=null,this._boundPipeline=null}destroy(){this._renderer=null,this._gpu=null,this._boundBindGroup=null,this._boundVertexBuffer=null,this._boundIndexBuffer=null,this._boundPipeline=null}contextChange(e){this._gpu=e}}N_.extension={type:[b.WebGPUSystem],name:"encoder",priority:1};class H_{constructor(e){this._renderer=e}contextChange(){this.maxTextures=this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage,this.maxBatchableTextures=this.maxTextures}destroy(){}}H_.extension={type:[b.WebGPUSystem],name:"limits"};class W_{constructor(e){this._renderTargetStencilState=Object.create(null),this._renderer=e,e.renderTarget.onRenderTargetChange.add(this)}onRenderTargetChange(e){let t=this._renderTargetStencilState[e.uid];t||(t=this._renderTargetStencilState[e.uid]={stencilMode:be.DISABLED,stencilReference:0}),this._activeRenderTarget=e,this.setStencilMode(t.stencilMode,t.stencilReference)}setStencilMode(e,t){const s=this._renderTargetStencilState[this._activeRenderTarget.uid];s.stencilMode=e,s.stencilReference=t;const r=this._renderer;r.pipeline.setStencilMode(e),r.encoder.renderPassEncoder.setStencilReference(t)}destroy(){this._renderer.renderTarget.onRenderTargetChange.remove(this),this._renderer=null,this._activeRenderTarget=null,this._renderTargetStencilState=null}}W_.extension={type:[b.WebGPUSystem],name:"stencil"};const fn={i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},f16:{align:2,size:2},"vec2<i32>":{align:8,size:8},"vec2<u32>":{align:8,size:8},"vec2<f32>":{align:8,size:8},"vec2<f16>":{align:4,size:4},"vec3<i32>":{align:16,size:12},"vec3<u32>":{align:16,size:12},"vec3<f32>":{align:16,size:12},"vec3<f16>":{align:8,size:6},"vec4<i32>":{align:16,size:16},"vec4<u32>":{align:16,size:16},"vec4<f32>":{align:16,size:16},"vec4<f16>":{align:8,size:8},"mat2x2<f32>":{align:8,size:16},"mat2x2<f16>":{align:4,size:8},"mat3x2<f32>":{align:8,size:24},"mat3x2<f16>":{align:4,size:12},"mat4x2<f32>":{align:8,size:32},"mat4x2<f16>":{align:4,size:16},"mat2x3<f32>":{align:16,size:32},"mat2x3<f16>":{align:8,size:16},"mat3x3<f32>":{align:16,size:48},"mat3x3<f16>":{align:8,size:24},"mat4x3<f32>":{align:16,size:64},"mat4x3<f16>":{align:8,size:32},"mat2x4<f32>":{align:16,size:32},"mat2x4<f16>":{align:8,size:16},"mat3x4<f32>":{align:16,size:48},"mat3x4<f16>":{align:8,size:24},"mat4x4<f32>":{align:16,size:64},"mat4x4<f16>":{align:8,size:32}};function lP(i){const e=i.map(s=>({data:s,offset:0,size:0}));let t=0;for(let s=0;s<e.length;s++){const r=e[s];let n=fn[r.data.type].size;const o=fn[r.data.type].align;if(!fn[r.data.type])throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${r.data.type}`);r.data.size>1&&(n=Math.max(n,o)*r.data.size),t=Math.ceil(t/o)*o,r.size=n,r.offset=t,t+=n}return t=Math.ceil(t/16)*16,{uboElements:e,size:t}}function cP(i,e){const{size:t,align:s}=fn[i.data.type],r=(s-t)/4,n=i.data.type.indexOf("i32")>=0?"dataInt32":"data";return`
         v = uv.${i.data.name};
         ${e!==0?`offset += ${e};`:""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${i.data.size*(t/4)}; i++)
         {
             for(var j = 0; j < ${t/4}; j++)
             {
                 ${n}[arrayOffset++] = v[t++];
             }
             ${r!==0?`arrayOffset += ${r};`:""}
         }
     `}function hP(i){return Q0(i,"uboWgsl",cP,e3)}class V_ extends Z0{constructor(){super({createUboElements:lP,generateUboSync:hP})}}V_.extension={type:[b.WebGPUSystem],name:"ubo"};const ei=128;class $_{constructor(e){this._bindGroupHash=Object.create(null),this._buffers=[],this._bindGroups=[],this._bufferResources=[],this._renderer=e,this._batchBuffer=new aP({minUniformOffsetAlignment:ei});const t=256/ei;for(let s=0;s<t;s++){let r=K.UNIFORM|K.COPY_DST;s===0&&(r|=K.COPY_SRC),this._buffers.push(new it({data:this._batchBuffer.data,usage:r}))}}renderEnd(){this._uploadBindGroups(),this._resetBindGroups()}_resetBindGroups(){this._bindGroupHash=Object.create(null),this._batchBuffer.clear()}getUniformBindGroup(e,t){if(!t&&this._bindGroupHash[e.uid])return this._bindGroupHash[e.uid];this._renderer.ubo.ensureUniformGroup(e);const s=e.buffer.data,r=this._batchBuffer.addEmptyGroup(s.length);return this._renderer.ubo.syncUniformGroup(e,this._batchBuffer.data,r/4),this._bindGroupHash[e.uid]=this._getBindGroup(r/ei),this._bindGroupHash[e.uid]}getUboResource(e){this._renderer.ubo.updateUniformGroup(e);const t=e.buffer.data,s=this._batchBuffer.addGroup(t);return this._getBufferResource(s/ei)}getArrayBindGroup(e){const t=this._batchBuffer.addGroup(e);return this._getBindGroup(t/ei)}getArrayBufferResource(e){const s=this._batchBuffer.addGroup(e)/ei;return this._getBufferResource(s)}_getBufferResource(e){if(!this._bufferResources[e]){const t=this._buffers[e%2];this._bufferResources[e]=new kd({buffer:t,offset:(e/2|0)*256,size:ei})}return this._bufferResources[e]}_getBindGroup(e){if(!this._bindGroups[e]){const t=new Gt({0:this._getBufferResource(e)});this._bindGroups[e]=t}return this._bindGroups[e]}_uploadBindGroups(){const e=this._renderer.buffer,t=this._buffers[0];t.update(this._batchBuffer.byteIndex),e.updateBuffer(t);const s=this._renderer.gpu.device.createCommandEncoder();for(let r=1;r<this._buffers.length;r++){const n=this._buffers[r];s.copyBufferToBuffer(e.getGPUBuffer(t),ei,e.getGPUBuffer(n),0,this._batchBuffer.byteIndex)}this._renderer.gpu.device.queue.submit([s.finish()])}destroy(){for(let e=0;e<this._bindGroups.length;e++)this._bindGroups[e]?.destroy();this._bindGroups=null,this._bindGroupHash=null;for(let e=0;e<this._buffers.length;e++)this._buffers[e].destroy();this._buffers=null;for(let e=0;e<this._bufferResources.length;e++)this._bufferResources[e].destroy();this._bufferResources=null,this._batchBuffer.destroy(),this._renderer=null}}$_.extension={type:[b.WebGPUPipes],name:"uniformBatch"};const uP={"point-list":0,"line-list":1,"line-strip":2,"triangle-list":3,"triangle-strip":4};function dP(i,e,t,s,r){return i<<24|e<<16|t<<10|s<<5|r}function fP(i,e,t,s,r){return t<<8|i<<5|s<<3|r<<1|e}class X_{constructor(e){this._moduleCache=Object.create(null),this._bufferLayoutsCache=Object.create(null),this._bindingNamesCache=Object.create(null),this._pipeCache=Object.create(null),this._pipeStateCaches=Object.create(null),this._colorMask=15,this._multisampleCount=1,this._colorTargetCount=1,this._renderer=e}contextChange(e){this._gpu=e,this.setStencilMode(be.DISABLED),this._updatePipeHash()}setMultisampleCount(e){this._multisampleCount!==e&&(this._multisampleCount=e,this._updatePipeHash())}setRenderTarget(e){this._multisampleCount=e.msaaSamples,this._depthStencilAttachment=e.descriptor.depthStencilAttachment?1:0,this._colorTargetCount=e.colorTargetCount,this._updatePipeHash()}setColorMask(e){this._colorMask!==e&&(this._colorMask=e,this._updatePipeHash())}setStencilMode(e){this._stencilMode!==e&&(this._stencilMode=e,this._stencilState=Qt[e],this._updatePipeHash())}setPipeline(e,t,s,r){const n=this.getPipeline(e,t,s);r.setPipeline(n)}getPipeline(e,t,s,r){e._layoutKey||(W0(e,t.attributeData),this._generateBufferKey(e)),r||(r=e.topology);const n=dP(e._layoutKey,t._layoutKey,s.data,s._blendModeId,uP[r]);return this._pipeCache[n]?this._pipeCache[n]:(this._pipeCache[n]=this._createPipeline(e,t,s,r),this._pipeCache[n])}_createPipeline(e,t,s,r){const n=this._gpu.device,o=this._createVertexBufferLayouts(e,t),a=this._renderer.state.getColorTargets(s,this._colorTargetCount),l=this._stencilMode===be.RENDERING_MASK_ADD?0:this._colorMask;for(let d=0;d<a.length;d++)a[d].writeMask=l;const c=this._renderer.shader.getProgramData(t).pipeline,h={vertex:{module:this._getModule(t.vertex.source),entryPoint:t.vertex.entryPoint,buffers:o},fragment:{module:this._getModule(t.fragment.source),entryPoint:t.fragment.entryPoint,targets:a},primitive:{topology:r,cullMode:s.cullMode},layout:c,multisample:{count:this._multisampleCount},label:"PIXI Pipeline"};return this._depthStencilAttachment&&(h.depthStencil={...this._stencilState,format:"depth24plus-stencil8",depthWriteEnabled:s.depthTest,depthCompare:s.depthTest?"less":"always"}),n.createRenderPipeline(h)}_getModule(e){return this._moduleCache[e]||this._createModule(e)}_createModule(e){const t=this._gpu.device;return this._moduleCache[e]=t.createShaderModule({code:e}),this._moduleCache[e]}_generateBufferKey(e){const t=[];let s=0;const r=Object.keys(e.attributes).sort();for(let o=0;o<r.length;o++){const a=e.attributes[r[o]];t[s++]=a.offset,t[s++]=a.format,t[s++]=a.stride,t[s++]=a.instance}const n=t.join("|");return e._layoutKey=_s(n,"geometry"),e._layoutKey}_generateAttributeLocationsKey(e){const t=[];let s=0;const r=Object.keys(e.attributeData).sort();for(let o=0;o<r.length;o++){const a=e.attributeData[r[o]];t[s++]=a.location}const n=t.join("|");return e._attributeLocationsKey=_s(n,"programAttributes"),e._attributeLocationsKey}getBufferNamesToBind(e,t){const s=e._layoutKey<<16|t._attributeLocationsKey;if(this._bindingNamesCache[s])return this._bindingNamesCache[s];const r=this._createVertexBufferLayouts(e,t),n=Object.create(null),o=t.attributeData;for(let a=0;a<r.length;a++){const c=Object.values(r[a].attributes)[0].shaderLocation;for(const h in o)if(o[h].location===c){n[a]=h;break}}return this._bindingNamesCache[s]=n,n}_createVertexBufferLayouts(e,t){t._attributeLocationsKey||this._generateAttributeLocationsKey(t);const s=e._layoutKey<<16|t._attributeLocationsKey;if(this._bufferLayoutsCache[s])return this._bufferLayoutsCache[s];const r=[];return e.buffers.forEach(n=>{const o={arrayStride:0,stepMode:"vertex",attributes:[]},a=o.attributes;for(const l in t.attributeData){const c=e.attributes[l];(c.divisor??1)!==1&&H(`Attribute ${l} has an invalid divisor value of '${c.divisor}'. WebGPU only supports a divisor value of 1`),c.buffer===n&&(o.arrayStride=c.stride,o.stepMode=c.instance?"instance":"vertex",a.push({shaderLocation:t.attributeData[l].location,offset:c.offset,format:c.format}))}a.length&&r.push(o)}),this._bufferLayoutsCache[s]=r,r}_updatePipeHash(){const e=fP(this._stencilMode,this._multisampleCount,this._colorMask,this._depthStencilAttachment,this._colorTargetCount);this._pipeStateCaches[e]||(this._pipeStateCaches[e]=Object.create(null)),this._pipeCache=this._pipeStateCaches[e]}destroy(){this._renderer=null,this._bufferLayoutsCache=null}}X_.extension={type:[b.WebGPUSystem],name:"pipeline"};class pP{constructor(){this.contexts=[],this.msaaTextures=[],this.msaaSamples=1}}class mP{init(e,t){this._renderer=e,this._renderTargetSystem=t}copyToTexture(e,t,s,r,n){const o=this._renderer,a=this._getGpuColorTexture(e),l=o.texture.getGpuSource(t.source);return o.encoder.commandEncoder.copyTextureToTexture({texture:a,origin:s},{texture:l,origin:n},r),t}startRenderPass(e,t=!0,s,r){const o=this._renderTargetSystem.getGpuRenderTarget(e),a=this.getDescriptor(e,t,s);o.descriptor=a,this._renderer.pipeline.setRenderTarget(o),this._renderer.encoder.beginRenderPass(o),this._renderer.encoder.setViewport(r)}finishRenderPass(){this._renderer.encoder.endRenderPass()}_getGpuColorTexture(e){const t=this._renderTargetSystem.getGpuRenderTarget(e);return t.contexts[0]?t.contexts[0].getCurrentTexture():this._renderer.texture.getGpuSource(e.colorTextures[0].source)}getDescriptor(e,t,s){typeof t=="boolean"&&(t=t?tt.ALL:tt.NONE);const r=this._renderTargetSystem,n=r.getGpuRenderTarget(e),o=e.colorTextures.map((c,h)=>{const u=n.contexts[h];let d,f;u?d=u.getCurrentTexture().createView():d=this._renderer.texture.getGpuSource(c).createView({mipLevelCount:1}),n.msaaTextures[h]&&(f=d,d=this._renderer.texture.getTextureView(n.msaaTextures[h]));const m=t&tt.COLOR?"clear":"load";return s??(s=r.defaultClearColor),{view:d,resolveTarget:f,clearValue:s,storeOp:"store",loadOp:m}});let a;if((e.stencil||e.depth)&&!e.depthStencilTexture&&(e.ensureDepthStencilTexture(),e.depthStencilTexture.source.sampleCount=n.msaa?4:1),e.depthStencilTexture){const c=t&tt.STENCIL?"clear":"load",h=t&tt.DEPTH?"clear":"load";a={view:this._renderer.texture.getGpuSource(e.depthStencilTexture.source).createView(),stencilStoreOp:"store",stencilLoadOp:c,depthClearValue:1,depthLoadOp:h,depthStoreOp:"store"}}return{colorAttachments:o,depthStencilAttachment:a}}clear(e,t=!0,s,r){if(!t)return;const{gpu:n,encoder:o}=this._renderer,a=n.device;if(o.commandEncoder===null){const c=a.createCommandEncoder(),h=this.getDescriptor(e,t,s),u=c.beginRenderPass(h);u.setViewport(r.x,r.y,r.width,r.height,0,1),u.end();const d=c.finish();a.queue.submit([d])}else this.startRenderPass(e,t,s,r)}initGpuRenderTarget(e){e.isRoot=!0;const t=new pP;return t.colorTargetCount=e.colorTextures.length,e.colorTextures.forEach((s,r)=>{if(s instanceof Bt){const n=s.resource.getContext("webgpu"),o=s.transparent?"premultiplied":"opaque";try{n.configure({device:this._renderer.gpu.device,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,format:"bgra8unorm",alphaMode:o})}catch(a){console.error(a)}t.contexts[r]=n}if(t.msaa=s.source.antialias,s.source.antialias){const n=new Ee({width:0,height:0,sampleCount:4});t.msaaTextures[r]=n}}),t.msaa&&(t.msaaSamples=4,e.depthStencilTexture&&(e.depthStencilTexture.source.sampleCount=4)),t}destroyGpuRenderTarget(e){e.contexts.forEach(t=>{t.unconfigure()}),e.msaaTextures.forEach(t=>{t.destroy()}),e.msaaTextures.length=0,e.contexts.length=0}ensureDepthStencilTexture(e){const t=this._renderTargetSystem.getGpuRenderTarget(e);e.depthStencilTexture&&t.msaa&&(e.depthStencilTexture.source.sampleCount=4)}resizeGpuRenderTarget(e){const t=this._renderTargetSystem.getGpuRenderTarget(e);t.width=e.width,t.height=e.height,t.msaa&&e.colorTextures.forEach((s,r)=>{t.msaaTextures[r]?.resize(s.source.width,s.source.height,s.source._resolution)})}}class Y_ extends r_{constructor(e){super(e),this.adaptor=new mP,this.adaptor.init(e,this)}}Y_.extension={type:[b.WebGPUSystem],name:"renderTarget"};class q_{constructor(){this._gpuProgramData=Object.create(null)}contextChange(e){this._gpu=e}getProgramData(e){return this._gpuProgramData[e._layoutKey]||this._createGPUProgramData(e)}_createGPUProgramData(e){const t=this._gpu.device,s=e.gpuLayout.map(n=>t.createBindGroupLayout({entries:n})),r={bindGroupLayouts:s};return this._gpuProgramData[e._layoutKey]={bindGroups:s,pipeline:t.createPipelineLayout(r)},this._gpuProgramData[e._layoutKey]}destroy(){this._gpu=null,this._gpuProgramData=null}}q_.extension={type:[b.WebGPUSystem],name:"shader"};const qe={};qe.normal={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}},qe.add={alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one",operation:"add"}},qe.multiply={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"dst",dstFactor:"one-minus-src-alpha",operation:"add"}},qe.screen={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}},qe.overlay={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"one",dstFactor:"one-minus-src",operation:"add"}},qe.none={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"zero",operation:"add"}},qe["normal-npm"]={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"}},qe["add-npm"]={alpha:{srcFactor:"one",dstFactor:"one",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one",operation:"add"}},qe["screen-npm"]={alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"src-alpha",dstFactor:"one-minus-src",operation:"add"}},qe.erase={alpha:{srcFactor:"zero",dstFactor:"one-minus-src-alpha",operation:"add"},color:{srcFactor:"zero",dstFactor:"one-minus-src",operation:"add"}},qe.min={alpha:{srcFactor:"one",dstFactor:"one",operation:"min"},color:{srcFactor:"one",dstFactor:"one",operation:"min"}},qe.max={alpha:{srcFactor:"one",dstFactor:"one",operation:"max"},color:{srcFactor:"one",dstFactor:"one",operation:"max"}};class K_{constructor(){this.defaultState=new mt,this.defaultState.blend=!0}contextChange(e){this.gpu=e}getColorTargets(e,t){const s=qe[e.blendMode]||qe.normal,r=[],n={format:"bgra8unorm",writeMask:0,blend:s};for(let o=0;o<t;o++)r[o]=n;return r}destroy(){this.gpu=null}}K_.extension={type:[b.WebGPUSystem],name:"state"};const gP={type:"image",upload(i,e,t){const s=i.resource,r=(i.pixelWidth|0)*(i.pixelHeight|0),n=s.byteLength/r;t.device.queue.writeTexture({texture:e},s,{offset:0,rowsPerImage:i.pixelHeight,bytesPerRow:i.pixelWidth*n},{width:i.pixelWidth,height:i.pixelHeight,depthOrArrayLayers:1})}},j_={"bc1-rgba-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"bc2-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc3-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"bc7-rgba-unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"etc1-rgb-unorm":{blockBytes:8,blockWidth:4,blockHeight:4},"etc2-rgba8unorm":{blockBytes:16,blockWidth:4,blockHeight:4},"astc-4x4-unorm":{blockBytes:16,blockWidth:4,blockHeight:4}},_P={blockBytes:4,blockWidth:1,blockHeight:1},xP={type:"compressed",upload(i,e,t){let s=i.pixelWidth,r=i.pixelHeight;const n=j_[i.format]||_P;for(let o=0;o<i.resource.length;o++){const a=i.resource[o],l=Math.ceil(s/n.blockWidth)*n.blockBytes;t.device.queue.writeTexture({texture:e,mipLevel:o},a,{offset:0,bytesPerRow:l},{width:Math.ceil(s/n.blockWidth)*n.blockWidth,height:Math.ceil(r/n.blockHeight)*n.blockHeight,depthOrArrayLayers:1}),s=Math.max(s>>1,1),r=Math.max(r>>1,1)}}},Z_={type:"image",upload(i,e,t){const s=i.resource;if(!s)return;if(globalThis.HTMLImageElement&&s instanceof HTMLImageElement){const a=Y.get().createCanvas(s.width,s.height);a.getContext("2d").drawImage(s,0,0,s.width,s.height),i.resource=a,H("ImageSource: Image element passed, converting to canvas and replacing resource.")}const r=Math.min(e.width,i.resourceWidth||i.pixelWidth),n=Math.min(e.height,i.resourceHeight||i.pixelHeight),o=i.alphaMode==="premultiply-alpha-on-upload";t.device.queue.copyExternalImageToTexture({source:s},{texture:e,premultipliedAlpha:o},{width:r,height:n})}},vP={type:"video",upload(i,e,t){Z_.upload(i,e,t)}};class yP{constructor(e){this.device=e,this.sampler=e.createSampler({minFilter:"linear"}),this.pipelines={}}_getMipmapPipeline(e){let t=this.pipelines[e];return t||(this.mipmapShaderModule||(this.mipmapShaderModule=this.device.createShaderModule({code:`
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `})),t=this.device.createRenderPipeline({layout:"auto",vertex:{module:this.mipmapShaderModule,entryPoint:"vertexMain"},fragment:{module:this.mipmapShaderModule,entryPoint:"fragmentMain",targets:[{format:e}]}}),this.pipelines[e]=t),t}generateMipmap(e){const t=this._getMipmapPipeline(e.format);if(e.dimension==="3d"||e.dimension==="1d")throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");let s=e;const r=e.depthOrArrayLayers||1,n=e.usage&GPUTextureUsage.RENDER_ATTACHMENT;if(!n){const l={size:{width:Math.ceil(e.width/2),height:Math.ceil(e.height/2),depthOrArrayLayers:r},format:e.format,usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,mipLevelCount:e.mipLevelCount-1};s=this.device.createTexture(l)}const o=this.device.createCommandEncoder({}),a=t.getBindGroupLayout(0);for(let l=0;l<r;++l){let c=e.createView({baseMipLevel:0,mipLevelCount:1,dimension:"2d",baseArrayLayer:l,arrayLayerCount:1}),h=n?1:0;for(let u=1;u<e.mipLevelCount;++u){const d=s.createView({baseMipLevel:h++,mipLevelCount:1,dimension:"2d",baseArrayLayer:l,arrayLayerCount:1}),f=o.beginRenderPass({colorAttachments:[{view:d,storeOp:"store",loadOp:"clear",clearValue:{r:0,g:0,b:0,a:0}}]}),m=this.device.createBindGroup({layout:a,entries:[{binding:0,resource:this.sampler},{binding:1,resource:c}]});f.setPipeline(t),f.setBindGroup(0,m),f.draw(3,1,0,0),f.end(),c=d}}if(!n){const l={width:Math.ceil(e.width/2),height:Math.ceil(e.height/2),depthOrArrayLayers:r};for(let c=1;c<e.mipLevelCount;++c)o.copyTextureToTexture({texture:s,mipLevel:c-1},{texture:e,mipLevel:c},l),l.width=Math.ceil(l.width/2),l.height=Math.ceil(l.height/2)}return this.device.queue.submit([o.finish()]),n||s.destroy(),e}}class bP{constructor(e){this.textureView=null,this.gpuTexture=e}destroy(){this.gpuTexture.destroy(),this.textureView=null,this.gpuTexture=null}}class J_{constructor(e){this._gpuSamplers=Object.create(null),this._bindGroupHash=Object.create(null),this._uploads={image:Z_,buffer:gP,video:vP,compressed:xP},this._renderer=e,e.renderableGC.addManagedHash(this,"_bindGroupHash"),this._managedTextures=new st({renderer:e,type:"resource",onUnload:this.onSourceUnload.bind(this),name:"gpuTextureSource"})}get managedTextures(){return Object.values(this._managedTextures.items)}contextChange(e){this._gpu=e}initSource(e){return e._gpuData[this._renderer.uid]?.gpuTexture||this._initSource(e)}_initSource(e){if(e.autoGenerateMipmaps){const c=Math.max(e.pixelWidth,e.pixelHeight);e.mipLevelCount=Math.floor(Math.log2(c))+1}let t=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST;e.uploadMethodId!=="compressed"&&(t|=GPUTextureUsage.RENDER_ATTACHMENT,t|=GPUTextureUsage.COPY_SRC);const s=j_[e.format]||{blockWidth:1,blockHeight:1},r=Math.ceil(e.pixelWidth/s.blockWidth)*s.blockWidth,n=Math.ceil(e.pixelHeight/s.blockHeight)*s.blockHeight,o={label:e.label,size:{width:r,height:n},format:e.format,sampleCount:e.sampleCount,mipLevelCount:e.mipLevelCount,dimension:e.dimension,usage:t},a=this._gpu.device.createTexture(o);return e._gpuData[this._renderer.uid]=new bP(a),this._managedTextures.add(e)&&(e.on("update",this.onSourceUpdate,this),e.on("resize",this.onSourceResize,this),e.on("updateMipmaps",this.onUpdateMipmaps,this)),this.onSourceUpdate(e),a}onSourceUpdate(e){const t=this.getGpuSource(e);t&&(this._uploads[e.uploadMethodId]&&this._uploads[e.uploadMethodId].upload(e,t,this._gpu),e.autoGenerateMipmaps&&e.mipLevelCount>1&&this.onUpdateMipmaps(e))}onUpdateMipmaps(e){this._mipmapGenerator||(this._mipmapGenerator=new yP(this._gpu.device));const t=this.getGpuSource(e);this._mipmapGenerator.generateMipmap(t)}onSourceUnload(e){e.off("update",this.onSourceUpdate,this),e.off("resize",this.onSourceResize,this),e.off("updateMipmaps",this.onUpdateMipmaps,this)}onSourceResize(e){e._gcLastUsed=this._renderer.gc.now;const t=e._gpuData[this._renderer.uid],s=t?.gpuTexture;s?(s.width!==e.pixelWidth||s.height!==e.pixelHeight)&&(t.destroy(),this._bindGroupHash[e.uid]=null,e._gpuData[this._renderer.uid]=null,this.initSource(e)):this.initSource(e)}_initSampler(e){return this._gpuSamplers[e._resourceId]=this._gpu.device.createSampler(e),this._gpuSamplers[e._resourceId]}getGpuSampler(e){return this._gpuSamplers[e._resourceId]||this._initSampler(e)}getGpuSource(e){return e._gcLastUsed=this._renderer.gc.now,e._gpuData[this._renderer.uid]?.gpuTexture||this.initSource(e)}getTextureBindGroup(e){return this._bindGroupHash[e.uid]||this._createTextureBindGroup(e)}_createTextureBindGroup(e){const t=e.source;return this._bindGroupHash[e.uid]=new Gt({0:t,1:t.style,2:new We({uTextureMatrix:{type:"mat3x3<f32>",value:e.textureMatrix.mapCoord}})}),this._bindGroupHash[e.uid]}getTextureView(e){const t=e.source;t._gcLastUsed=this._renderer.gc.now;let s=t._gpuData[this._renderer.uid],r=null;return s||(this.initSource(t),s=t._gpuData[this._renderer.uid]),r=s.textureView||s.gpuTexture.createView(),r}generateCanvas(e){const t=this._renderer,s=t.gpu.device.createCommandEncoder(),r=Y.get().createCanvas();r.width=e.source.pixelWidth,r.height=e.source.pixelHeight;const n=r.getContext("webgpu");return n.configure({device:t.gpu.device,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC,format:Y.get().getNavigator().gpu.getPreferredCanvasFormat(),alphaMode:"premultiplied"}),s.copyTextureToTexture({texture:t.texture.getGpuSource(e.source),origin:{x:0,y:0}},{texture:n.getCurrentTexture()},{width:r.width,height:r.height}),t.gpu.device.queue.submit([s.finish()]),r}getPixels(e){const t=this.generateCanvas(e),s=Lt.getOptimalCanvasAndContext(t.width,t.height),r=s.context;r.drawImage(t,0,0);const{width:n,height:o}=t,a=r.getImageData(0,0,n,o),l=new Uint8ClampedArray(a.data.buffer);return Lt.returnCanvasAndContext(s),{pixels:l,width:n,height:o}}destroy(){this._managedTextures.destroy();for(const e of Object.keys(this._bindGroupHash)){const t=Number(e);this._bindGroupHash[t]?.destroy()}this._renderer=null,this._gpu=null,this._mipmapGenerator=null,this._gpuSamplers=null,this._bindGroupHash=null}}J_.extension={type:[b.WebGPUSystem],name:"texture"};class Q_{constructor(){this._maxTextures=0}contextChange(e){const t=new We({uTransformMatrix:{value:new O,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}});this._maxTextures=e.limits.maxBatchableTextures;const s=ks({name:"graphics",bits:[Zu,ed(this._maxTextures),zI,Fs]});this.shader=new lt({gpuProgram:s,resources:{localUniforms:t}})}execute(e,t){const s=t.context,r=s.customShader||this.shader,n=e.renderer,o=n.graphicsContext,{batcher:a,instructions:l}=o.getContextRenderData(s),c=n.encoder;c.setGeometry(a.geometry,r.gpuProgram);const h=n.globalUniforms.bindGroup;c.setBindGroup(0,h,r.gpuProgram);const u=n.renderPipes.uniformBatch.getUniformBindGroup(r.resources.localUniforms,!0);c.setBindGroup(2,u,r.gpuProgram);const d=l.instructions;let f=null;for(let m=0;m<l.instructionSize;m++){const g=d[m];if(g.topology!==f&&(f=g.topology,c.setPipelineFromGeometryProgramAndState(a.geometry,r.gpuProgram,e.state,g.topology)),r.groups[1]=g.bindGroup,!g.gpuBindGroup){const p=g.textures;g.bindGroup=qu(p.textures,p.count,this._maxTextures),g.gpuBindGroup=n.bindGroup.getBindGroup(g.bindGroup,r.gpuProgram,1)}c.setBindGroup(1,g.bindGroup,r.gpuProgram),c.renderPassEncoder.drawIndexed(g.size,1,g.start)}}destroy(){this.shader.destroy(!0),this.shader=null}}Q_.extension={type:[b.WebGPUPipesAdaptor],name:"graphics"};class ex{init(){const e=ks({name:"mesh",bits:[Ws,LI,Fs]});this._shader=new lt({gpuProgram:e,resources:{uTexture:k.EMPTY._source,uSampler:k.EMPTY._source.style,textureUniforms:{uTextureMatrix:{type:"mat3x3<f32>",value:new O}}}})}execute(e,t){const s=e.renderer;let r=t._shader;if(!r)r=this._shader,r.groups[2]=s.texture.getTextureBindGroup(t.texture);else if(!r.gpuProgram){H("Mesh shader has no gpuProgram",t.shader);return}const n=r.gpuProgram;if(n.autoAssignGlobalUniforms&&(r.groups[0]=s.globalUniforms.bindGroup),n.autoAssignLocalUniforms){const o=e.localUniforms;r.groups[1]=s.renderPipes.uniformBatch.getUniformBindGroup(o,!0)}s.encoder.draw({geometry:t._geometry,shader:r,state:t.state})}destroy(){this._shader.destroy(!0),this._shader=null}}ex.extension={type:[b.WebGPUPipesAdaptor],name:"mesh"};const TP=[...F_,V_,N_,Vd,H_,z_,J_,Y_,q_,K_,X_,L_,W_,G_],wP=[...U_,$_],SP=[D0,ex,Q_],tx=[],ix=[],sx=[];V.handleByNamedList(b.WebGPUSystem,tx),V.handleByNamedList(b.WebGPUPipes,ix),V.handleByNamedList(b.WebGPUPipesAdaptor,sx),V.add(...TP,...wP,...SP);class CP extends $r{constructor(){const e={name:"webgpu",type:et.WEBGPU,systems:tx,renderPipes:ix,renderPipeAdaptors:sx};super(e)}}const AP=Object.freeze(Object.defineProperty({__proto__:null,WebGPURenderer:CP},Symbol.toStringTag,{value:"Module"}));class EP{constructor(){this.batches=[],this.batched=!1}destroy(){this.batches.forEach(e=>{Se.return(e)}),this.batches.length=0}}class rx{constructor(e,t){this.state=mt.for2d(),this.renderer=e,this._adaptor=t,this.renderer.runners.contextChange.add(this),this._managedGraphics=new st({renderer:e,type:"renderable",priority:-1,name:"graphics"})}contextChange(){this._adaptor.contextChange(this.renderer)}validateRenderable(e){const t=e.context,s=!!e._gpuData,r=this.renderer.graphicsContext.updateGpuContext(t);return!!(r.isBatchable||s!==r.isBatchable)}addRenderable(e,t){const s=this.renderer.graphicsContext.updateGpuContext(e.context);e.didViewUpdate&&this._rebuild(e),s.isBatchable?this._addToBatcher(e,t):(this.renderer.renderPipes.batch.break(t),t.add(e))}updateRenderable(e){const s=this._getGpuDataForRenderable(e).batches;for(let r=0;r<s.length;r++){const n=s[r];n._batcher.updateElement(n)}}execute(e){if(!e.isRenderable)return;const t=this.renderer,s=e.context;if(!t.graphicsContext.getGpuContext(s).batches.length)return;const n=s.customShader||this._adaptor.shader;this.state.blendMode=e.groupBlendMode;const o=n.resources.localUniforms.uniforms;o.uTransformMatrix=e.groupTransform,o.uRound=t._roundPixels|e._roundPixels,$s(e.groupColorAlpha,o.uColor,0),this._adaptor.execute(this,e)}_rebuild(e){const t=this._getGpuDataForRenderable(e),s=this.renderer.graphicsContext.updateGpuContext(e.context);t.destroy(),s.isBatchable&&this._updateBatchesForRenderable(e,t)}_addToBatcher(e,t){const s=this.renderer.renderPipes.batch,r=this._getGpuDataForRenderable(e).batches;for(let n=0;n<r.length;n++){const o=r[n];s.addToBatch(o,t)}}_getGpuDataForRenderable(e){return e._gpuData[this.renderer.uid]||this._initGpuDataForRenderable(e)}_initGpuDataForRenderable(e){const t=new EP;return e._gpuData[this.renderer.uid]=t,this._managedGraphics.add(e),t}_updateBatchesForRenderable(e,t){const s=e.context,r=this.renderer.graphicsContext.getGpuContext(s),n=this.renderer._roundPixels|e._roundPixels;t.batches=r.batches.map(o=>{const a=Se.get(nd);return o.copyTo(a),a.renderable=e,a.roundPixels=n,a})}destroy(){this._managedGraphics.destroy(),this.renderer=null,this._adaptor.destroy(),this._adaptor=null,this.state=null}}rx.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"graphics"};const nx=class pv extends Sd{constructor(...e){super({});let t=e[0]??{};typeof t=="number"&&(L(J,"PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"),t={width:t,height:e[1],verticesX:e[2],verticesY:e[3]}),this.build(t)}build(e){e={...pv.defaultOptions,...e},this.verticesX=this.verticesX??e.verticesX,this.verticesY=this.verticesY??e.verticesY,this.width=this.width??e.width,this.height=this.height??e.height;const t=this.verticesX*this.verticesY,s=[],r=[],n=[],o=this.verticesX-1,a=this.verticesY-1,l=this.width/o,c=this.height/a;for(let u=0;u<t;u++){const d=u%this.verticesX,f=u/this.verticesX|0;s.push(d*l,f*c),r.push(d/o,f/a)}const h=o*a;for(let u=0;u<h;u++){const d=u%o,f=u/o|0,m=f*this.verticesX+d,g=f*this.verticesX+d+1,p=(f+1)*this.verticesX+d,_=(f+1)*this.verticesX+d+1;n.push(m,g,p,g,_,p)}this.buffers[0].data=new Float32Array(s),this.buffers[1].data=new Float32Array(r),this.indexBuffer.data=new Uint32Array(n),this.buffers[0].update(),this.buffers[1].update(),this.indexBuffer.update()}};nx.defaultOptions={width:100,height:100,verticesX:10,verticesY:10};let IP=nx;class $d{constructor(){this.batcherName="default",this.packAsQuad=!1,this.indexOffset=0,this.attributeOffset=0,this.roundPixels=0,this._batcher=null,this._batch=null,this._textureMatrixUpdateId=-1,this._uvUpdateId=-1}get blendMode(){return this.renderable.groupBlendMode}get topology(){return this._topology||this.geometry.topology}set topology(e){this._topology=e}reset(){this.renderable=null,this.texture=null,this._batcher=null,this._batch=null,this.geometry=null,this._uvUpdateId=-1,this._textureMatrixUpdateId=-1}setTexture(e){this.texture!==e&&(this.texture=e,this._textureMatrixUpdateId=-1)}get uvs(){const t=this.geometry.getBuffer("aUV"),s=t.data;let r=s;const n=this.texture.textureMatrix;return n.isSimple||(r=this._transformedUvs,(this._textureMatrixUpdateId!==n._updateID||this._uvUpdateId!==t._updateID)&&((!r||r.length<s.length)&&(r=this._transformedUvs=new Float32Array(s.length)),this._textureMatrixUpdateId=n._updateID,this._uvUpdateId=t._updateID,n.multiplyUvs(s,r))),r}get positions(){return this.geometry.positions}get indices(){return this.geometry.indices}get color(){return this.renderable.groupColorAlpha}get groupTransform(){return this.renderable.groupTransform}get attributeSize(){return this.geometry.positions.length/2}get indexSize(){return this.geometry.indices.length}}class ox{destroy(){}}class ax{constructor(e,t){this.localUniforms=new We({uTransformMatrix:{value:new O,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),this.localUniformsBindGroup=new Gt({0:this.localUniforms}),this.renderer=e,this._adaptor=t,this._adaptor.init()}validateRenderable(e){const t=this._getMeshData(e),s=t.batched,r=e.batched;if(t.batched=r,s!==r)return!0;if(r){const n=e._geometry;if(n.indices.length!==t.indexSize||n.positions.length!==t.vertexSize)return t.indexSize=n.indices.length,t.vertexSize=n.positions.length,!0;const o=this._getBatchableMesh(e);return o.texture.uid!==e._texture.uid&&(o._textureMatrixUpdateId=-1),!o._batcher.checkAndUpdateTexture(o,e._texture)}return!1}addRenderable(e,t){const s=this.renderer.renderPipes.batch,r=this._getMeshData(e);if(e.didViewUpdate&&(r.indexSize=e._geometry.indices?.length,r.vertexSize=e._geometry.positions?.length),r.batched){const n=this._getBatchableMesh(e);n.setTexture(e._texture),n.geometry=e._geometry,s.addToBatch(n,t)}else s.break(t),t.add(e)}updateRenderable(e){if(e.batched){const t=this._getBatchableMesh(e);t.setTexture(e._texture),t.geometry=e._geometry,t._batcher.updateElement(t)}}execute(e){if(!e.isRenderable)return;e.state.blendMode=Es(e.groupBlendMode,e.texture._source);const t=this.localUniforms;t.uniforms.uTransformMatrix=e.groupTransform,t.uniforms.uRound=this.renderer._roundPixels|e._roundPixels,t.update(),$s(e.groupColorAlpha,t.uniforms.uColor,0),this._adaptor.execute(this,e)}_getMeshData(e){var t,s;return(t=e._gpuData)[s=this.renderer.uid]||(t[s]=new ox),e._gpuData[this.renderer.uid].meshData||this._initMeshData(e)}_initMeshData(e){return e._gpuData[this.renderer.uid].meshData={batched:e.batched,indexSize:0,vertexSize:0},e._gpuData[this.renderer.uid].meshData}_getBatchableMesh(e){var t,s;return(t=e._gpuData)[s=this.renderer.uid]||(t[s]=new ox),e._gpuData[this.renderer.uid].batchableMesh||this._initBatchableMesh(e)}_initBatchableMesh(e){const t=new $d;return t.renderable=e,t.setTexture(e._texture),t.transform=e.groupTransform,t.roundPixels=this.renderer._roundPixels|e._roundPixels,e._gpuData[this.renderer.uid].batchableMesh=t,t}destroy(){this.localUniforms=null,this.localUniformsBindGroup=null,this._adaptor.destroy(),this._adaptor=null,this.renderer=null}}ax.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"mesh"};class PP{execute(e,t){const s=e.state,r=e.renderer,n=t.shader||e.defaultShader;n.resources.uTexture=t.texture._source,n.resources.uniforms=e.localUniforms;const o=r.gl,a=e.getBuffers(t);r.shader.bind(n),r.state.set(s),r.geometry.bind(a.geometry,n.glProgram);const c=a.geometry.indexBuffer.data.BYTES_PER_ELEMENT===2?o.UNSIGNED_SHORT:o.UNSIGNED_INT;o.drawElements(o.TRIANGLES,t.particleChildren.length*6,c,0)}}class RP{execute(e,t){const s=e.renderer,r=t.shader||e.defaultShader;r.groups[0]=s.renderPipes.uniformBatch.getUniformBindGroup(e.localUniforms,!0),r.groups[1]=s.texture.getTextureBindGroup(t.texture);const n=e.state,o=e.getBuffers(t);s.encoder.draw({geometry:o.geometry,shader:t.shader||e.defaultShader,state:n,size:t.particleChildren.length*6})}}function lx(i,e=null){const t=i*6;if(t>65535?e||(e=new Uint32Array(t)):e||(e=new Uint16Array(t)),e.length!==t)throw new Error(`Out buffer length is incorrect, got ${e.length} and expected ${t}`);for(let s=0,r=0;s<t;s+=6,r+=4)e[s+0]=r+0,e[s+1]=r+1,e[s+2]=r+2,e[s+3]=r+0,e[s+4]=r+2,e[s+5]=r+3;return e}function kP(i){return{dynamicUpdate:cx(i,!0),staticUpdate:cx(i,!1)}}function cx(i,e){const t=[];t.push(`

        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);let s=0;for(const n in i){const o=i[n];if(e!==o.dynamic)continue;t.push(`offset = index + ${s}`),t.push(o.code);const a=Zt(o.format);s+=a.stride/4}t.push(`
            index += stride * 4;
        }
    `),t.unshift(`
        var stride = ${s};
    `);const r=t.join(`
`);return new Function("ps","f32v","u32v",r)}class MP{constructor(e){this._size=0,this._generateParticleUpdateCache={};const t=this._size=e.size??1e3,s=e.properties;let r=0,n=0;for(const h in s){const u=s[h],d=Zt(u.format);u.dynamic?n+=d.stride:r+=d.stride}this._dynamicStride=n/4,this._staticStride=r/4,this.staticAttributeBuffer=new Li(t*4*r),this.dynamicAttributeBuffer=new Li(t*4*n),this.indexBuffer=lx(t);const o=new Rs;let a=0,l=0;this._staticBuffer=new it({data:new Float32Array(1),label:"static-particle-buffer",shrinkToFit:!1,usage:K.VERTEX|K.COPY_DST}),this._dynamicBuffer=new it({data:new Float32Array(1),label:"dynamic-particle-buffer",shrinkToFit:!1,usage:K.VERTEX|K.COPY_DST});for(const h in s){const u=s[h],d=Zt(u.format);u.dynamic?(o.addAttribute(u.attributeName,{buffer:this._dynamicBuffer,stride:this._dynamicStride*4,offset:a*4,format:u.format}),a+=d.size):(o.addAttribute(u.attributeName,{buffer:this._staticBuffer,stride:this._staticStride*4,offset:l*4,format:u.format}),l+=d.size)}o.addIndex(this.indexBuffer);const c=this.getParticleUpdate(s);this._dynamicUpload=c.dynamicUpdate,this._staticUpload=c.staticUpdate,this.geometry=o}getParticleUpdate(e){const t=FP(e);return this._generateParticleUpdateCache[t]?this._generateParticleUpdateCache[t]:(this._generateParticleUpdateCache[t]=this.generateParticleUpdate(e),this._generateParticleUpdateCache[t])}generateParticleUpdate(e){return kP(e)}update(e,t){e.length>this._size&&(t=!0,this._size=Math.max(e.length,this._size*1.5|0),this.staticAttributeBuffer=new Li(this._size*this._staticStride*4*4),this.dynamicAttributeBuffer=new Li(this._size*this._dynamicStride*4*4),this.indexBuffer=lx(this._size),this.geometry.indexBuffer.setDataWithSize(this.indexBuffer,this.indexBuffer.byteLength,!0));const s=this.dynamicAttributeBuffer;if(this._dynamicUpload(e,s.float32View,s.uint32View),this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View,e.length*this._dynamicStride*4,!0),t){const r=this.staticAttributeBuffer;this._staticUpload(e,r.float32View,r.uint32View),this._staticBuffer.setDataWithSize(r.float32View,e.length*this._staticStride*4,!0)}}destroy(){this._staticBuffer.destroy(),this._dynamicBuffer.destroy(),this.geometry.destroy()}}function FP(i){const e=[];for(const t in i){const s=i[t];e.push(t,s.code,s.dynamic?"d":"s")}return e.join("_")}var UP=`varying vec2 vUV;
varying vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color = texture2D(uTexture, vUV) * vColor;
    gl_FragColor = color;
}`,BP=`attribute vec2 aVertex;
attribute vec2 aUV;
attribute vec4 aColor;

attribute vec2 aPosition;
attribute float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

varying vec2 vUV;
varying vec4 vColor;

vec2 roundPixels(vec2 position, vec2 targetSize)
{       
    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

void main(void){
    float cosRotation = cos(aRotation);
    float sinRotation = sin(aRotation);
    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;
    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;

    vec2 v = vec2(x, y);
    v = v + aPosition;

    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    if(uRound == 1.0)
    {
        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
    }

    vUV = aUV;
    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;
}
`,hx=`
struct ParticleUniforms {
  uTranslationMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uRound:f32,
  uResolution:vec2<f32>,
};

fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
{
  return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   var position = vec4((uniforms.uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

   if(uniforms.uRound == 1.0) {
       position = vec4(roundPixels(position.xy, uniforms.uResolution), position.zw);
   }

    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;

  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {

    var sample = textureSample(uTexture, uSampler, uv) * color;
   
    return sample;
}`;class OP extends lt{constructor(){const e=It.from({vertex:BP,fragment:UP}),t=Dt.from({fragment:{source:hx,entryPoint:"mainFragment"},vertex:{source:hx,entryPoint:"mainVertex"}});super({glProgram:e,gpuProgram:t,resources:{uTexture:k.WHITE.source,uSampler:new Ct({}),uniforms:{uTranslationMatrix:{value:new O,type:"mat3x3<f32>"},uColor:{value:new ue(16777215),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}}})}}class ux{constructor(e,t){this.state=mt.for2d(),this.localUniforms=new We({uTranslationMatrix:{value:new O,type:"mat3x3<f32>"},uColor:{value:new Float32Array(4),type:"vec4<f32>"},uRound:{value:1,type:"f32"},uResolution:{value:[0,0],type:"vec2<f32>"}}),this.renderer=e,this.adaptor=t,this.defaultShader=new OP,this.state=mt.for2d(),this._managedContainers=new st({renderer:e,type:"renderable",name:"particleContainer"})}validateRenderable(e){return!1}addRenderable(e,t){this.renderer.renderPipes.batch.break(t),t.add(e)}getBuffers(e){return e._gpuData[this.renderer.uid]||this._initBuffer(e)}_initBuffer(e){return e._gpuData[this.renderer.uid]=new MP({size:e.particleChildren.length,properties:e._properties}),this._managedContainers.add(e),e._gpuData[this.renderer.uid]}updateRenderable(e){}execute(e){const t=e.particleChildren;if(t.length===0)return;const s=this.renderer,r=this.getBuffers(e);e.texture||(e.texture=t[0].texture);const n=this.state;r.update(t,e._childrenDirty),e._childrenDirty=!1,n.blendMode=Es(e.blendMode,e.texture._source);const o=this.localUniforms.uniforms,a=o.uTranslationMatrix;e.worldTransform.copyTo(a),a.prepend(s.globalUniforms.globalUniformData.projectionMatrix),o.uResolution=s.globalUniforms.globalUniformData.resolution,o.uRound=s._roundPixels|e._roundPixels,$s(e.groupColorAlpha,o.uColor,0),this.adaptor.execute(this,e)}destroy(){this._managedContainers.destroy(),this.renderer=null,this.defaultShader&&(this.defaultShader.destroy(),this.defaultShader=null)}}class dx extends ux{constructor(e){super(e,new PP)}}dx.extension={type:[b.WebGLPipes],name:"particle"};class fx extends ux{constructor(e){super(e,new RP)}}fx.extension={type:[b.WebGPUPipes],name:"particle"};const px=class mv extends IP{constructor(e={}){e={...mv.defaultOptions,...e},super({width:e.width,height:e.height,verticesX:4,verticesY:4}),this.update(e)}update(e){this.width=e.width??this.width,this.height=e.height??this.height,this._originalWidth=e.originalWidth??this._originalWidth,this._originalHeight=e.originalHeight??this._originalHeight,this._leftWidth=e.leftWidth??this._leftWidth,this._rightWidth=e.rightWidth??this._rightWidth,this._topHeight=e.topHeight??this._topHeight,this._bottomHeight=e.bottomHeight??this._bottomHeight,this._anchorX=e.anchor?.x,this._anchorY=e.anchor?.y,this.updateUvs(),this.updatePositions()}updatePositions(){const e=this.positions,{width:t,height:s,_leftWidth:r,_rightWidth:n,_topHeight:o,_bottomHeight:a,_anchorX:l,_anchorY:c}=this,h=r+n,u=t>h?1:t/h,d=o+a,f=s>d?1:s/d,m=Math.min(u,f),g=l*t,p=c*s;e[0]=e[8]=e[16]=e[24]=-g,e[2]=e[10]=e[18]=e[26]=r*m-g,e[4]=e[12]=e[20]=e[28]=t-n*m-g,e[6]=e[14]=e[22]=e[30]=t-g,e[1]=e[3]=e[5]=e[7]=-p,e[9]=e[11]=e[13]=e[15]=o*m-p,e[17]=e[19]=e[21]=e[23]=s-a*m-p,e[25]=e[27]=e[29]=e[31]=s-p,this.getBuffer("aPosition").update()}updateUvs(){const e=this.uvs;e[0]=e[8]=e[16]=e[24]=0,e[1]=e[3]=e[5]=e[7]=0,e[6]=e[14]=e[22]=e[30]=1,e[25]=e[27]=e[29]=e[31]=1;const t=1/this._originalWidth,s=1/this._originalHeight;e[2]=e[10]=e[18]=e[26]=t*this._leftWidth,e[9]=e[11]=e[13]=e[15]=s*this._topHeight,e[4]=e[12]=e[20]=e[28]=1-t*this._rightWidth,e[17]=e[19]=e[21]=e[23]=1-s*this._bottomHeight,this.getBuffer("aUV").update()}};px.defaultOptions={width:100,height:100,leftWidth:10,topHeight:10,rightWidth:10,bottomHeight:10,originalWidth:100,originalHeight:100};let DP=px;class GP extends $d{constructor(){super(),this.geometry=new DP}destroy(){this.geometry.destroy()}}class mx{constructor(e){this._renderer=e,this._managedSprites=new st({renderer:e,type:"renderable",name:"nineSliceSprite"})}addRenderable(e,t){const s=this._getGpuSprite(e);e.didViewUpdate&&this._updateBatchableSprite(e,s),this._renderer.renderPipes.batch.addToBatch(s,t)}updateRenderable(e){const t=this._getGpuSprite(e);e.didViewUpdate&&this._updateBatchableSprite(e,t),t._batcher.updateElement(t)}validateRenderable(e){const t=this._getGpuSprite(e);return!t._batcher.checkAndUpdateTexture(t,e._texture)}_updateBatchableSprite(e,t){t.geometry.update(e),t.setTexture(e._texture)}_getGpuSprite(e){return e._gpuData[this._renderer.uid]||this._initGPUSprite(e)}_initGPUSprite(e){const t=e._gpuData[this._renderer.uid]=new GP,s=t;return s.renderable=e,s.transform=e.groupTransform,s.texture=e._texture,s.roundPixels=this._renderer._roundPixels|e._roundPixels,this._managedSprites.add(e),e.didViewUpdate||this._updateBatchableSprite(e,s),t}destroy(){this._managedSprites.destroy(),this._renderer=null}}mx.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"nineSliceSprite"};const zP={name:"tiling-bit",vertex:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `},fragment:{header:`
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,main:`

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            }

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `}},LP={name:"tiling-bit",vertex:{header:`
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;

        `,main:`
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `},fragment:{header:`
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,main:`

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0

        `}};let Xd,Yd;class NP extends lt{constructor(){Xd??(Xd=ks({name:"tiling-sprite-shader",bits:[Ws,zP,Fs]})),Yd??(Yd=Ms({name:"tiling-sprite-shader",bits:[Ad,LP,Us]}));const e=new We({uMapCoord:{value:new O,type:"mat3x3<f32>"},uClampFrame:{value:new Float32Array([0,0,1,1]),type:"vec4<f32>"},uClampOffset:{value:new Float32Array([0,0]),type:"vec2<f32>"},uTextureTransform:{value:new O,type:"mat3x3<f32>"},uSizeAnchor:{value:new Float32Array([100,100,.5,.5]),type:"vec4<f32>"}});super({glProgram:Yd,gpuProgram:Xd,resources:{localUniforms:new We({uTransformMatrix:{value:new O,type:"mat3x3<f32>"},uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uRound:{value:0,type:"f32"}}),tilingUniforms:e,uTexture:k.EMPTY.source,uSampler:k.EMPTY.source.style}})}updateUniforms(e,t,s,r,n,o){const a=this.resources.tilingUniforms,l=o.width,c=o.height,h=o.textureMatrix,u=a.uniforms.uTextureTransform;u.set(s.a*l/e,s.b*l/t,s.c*c/e,s.d*c/t,s.tx/e,s.ty/t),u.invert(),a.uniforms.uMapCoord=h.mapCoord,a.uniforms.uClampFrame=h.uClampFrame,a.uniforms.uClampOffset=h.uClampOffset,a.uniforms.uTextureTransform=u,a.uniforms.uSizeAnchor[0]=e,a.uniforms.uSizeAnchor[1]=t,a.uniforms.uSizeAnchor[2]=r,a.uniforms.uSizeAnchor[3]=n,o&&(this.resources.uTexture=o.source,this.resources.uSampler=o.source.style)}}class HP extends Sd{constructor(){super({positions:new Float32Array([0,0,1,0,1,1,0,1]),uvs:new Float32Array([0,0,1,0,1,1,0,1]),indices:new Uint32Array([0,1,2,0,2,3])})}}function WP(i,e){const t=i.anchor.x,s=i.anchor.y;e[0]=-t*i.width,e[1]=-s*i.height,e[2]=(1-t)*i.width,e[3]=-s*i.height,e[4]=(1-t)*i.width,e[5]=(1-s)*i.height,e[6]=-t*i.width,e[7]=(1-s)*i.height}function VP(i,e,t,s){let r=0;const n=i.length/e,o=s.a,a=s.b,l=s.c,c=s.d,h=s.tx,u=s.ty;for(t*=e;r<n;){const d=i[t],f=i[t+1];i[t]=o*d+l*f+h,i[t+1]=a*d+c*f+u,t+=e,r++}}function $P(i,e){const t=i.texture,s=t.frame.width,r=t.frame.height;let n=0,o=0;i.applyAnchorToTexture&&(n=i.anchor.x,o=i.anchor.y),e[0]=e[6]=-n,e[2]=e[4]=1-n,e[1]=e[3]=-o,e[5]=e[7]=1-o;const a=O.shared;a.copyFrom(i._tileTransform.matrix),a.tx/=i.width,a.ty/=i.height,a.invert(),a.scale(i.width/s,i.height/r),VP(e,2,0,a)}const pn=new HP;class XP{constructor(){this.canBatch=!0,this.geometry=new Sd({indices:pn.indices.slice(),positions:pn.positions.slice(),uvs:pn.uvs.slice()})}destroy(){this.geometry.destroy(),this.shader?.destroy()}}class gx{constructor(e){this._state=mt.default2d,this._renderer=e,this._managedTilingSprites=new st({renderer:e,type:"renderable",name:"tilingSprite"})}validateRenderable(e){const t=this._getTilingSpriteData(e),s=t.canBatch;this._updateCanBatch(e);const r=t.canBatch;if(r&&r===s){const{batchableMesh:n}=t;return!n._batcher.checkAndUpdateTexture(n,e.texture)}return s!==r}addRenderable(e,t){const s=this._renderer.renderPipes.batch;this._updateCanBatch(e);const r=this._getTilingSpriteData(e),{geometry:n,canBatch:o}=r;if(o){r.batchableMesh||(r.batchableMesh=new $d);const a=r.batchableMesh;e.didViewUpdate&&(this._updateBatchableMesh(e),a.geometry=n,a.renderable=e,a.transform=e.groupTransform,a.setTexture(e._texture)),a.roundPixels=this._renderer._roundPixels|e._roundPixels,s.addToBatch(a,t)}else s.break(t),r.shader||(r.shader=new NP),this.updateRenderable(e),t.add(e)}execute(e){const{shader:t}=this._getTilingSpriteData(e);t.groups[0]=this._renderer.globalUniforms.bindGroup;const s=t.resources.localUniforms.uniforms;s.uTransformMatrix=e.groupTransform,s.uRound=this._renderer._roundPixels|e._roundPixels,$s(e.groupColorAlpha,s.uColor,0),this._state.blendMode=Es(e.groupBlendMode,e.texture._source),this._renderer.encoder.draw({geometry:pn,shader:t,state:this._state})}updateRenderable(e){const t=this._getTilingSpriteData(e),{canBatch:s}=t;if(s){const{batchableMesh:r}=t;e.didViewUpdate&&this._updateBatchableMesh(e),r._batcher.updateElement(r)}else if(e.didViewUpdate){const{shader:r}=t;r.updateUniforms(e.width,e.height,e._tileTransform.matrix,e.anchor.x,e.anchor.y,e.texture)}}_getTilingSpriteData(e){return e._gpuData[this._renderer.uid]||this._initTilingSpriteData(e)}_initTilingSpriteData(e){const t=new XP;return t.renderable=e,e._gpuData[this._renderer.uid]=t,this._managedTilingSprites.add(e),t}_updateBatchableMesh(e){const t=this._getTilingSpriteData(e),{geometry:s}=t,r=e.texture.source.style;r.addressMode!=="repeat"&&(r.addressMode="repeat",r.update()),$P(e,s.uvs),WP(e,s.positions)}destroy(){this._managedTilingSprites.destroy(),this._renderer=null}_updateCanBatch(e){const t=this._getTilingSpriteData(e),s=e.texture;let r=!0;return this._renderer.type===et.WEBGL&&(r=this._renderer.context.supports.nonPowOf2wrapping),t.canBatch=s.textureMatrix.isSimple&&(r||s.source.isPowerOfTwo),t.canBatch}}gx.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"tilingSprite"};const YP={name:"local-uniform-msdf-bit",vertex:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,main:`
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,end:`
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `},fragment:{header:`
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,main:`
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `}},qP={name:"local-uniform-msdf-bit",vertex:{header:`
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,main:`
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,end:`
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `},fragment:{header:`
            uniform float uDistance;
         `,main:`
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `}},KP={name:"msdf-bit",fragment:{header:`
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {

                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;

            }
        `}},jP={name:"msdf-bit",fragment:{header:`
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {

                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);

                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);

                return coverage;
            }
        `}};let qd,Kd;class ZP extends lt{constructor(e){const t=new We({uColor:{value:new Float32Array([1,1,1,1]),type:"vec4<f32>"},uTransformMatrix:{value:new O,type:"mat3x3<f32>"},uDistance:{value:4,type:"f32"},uRound:{value:0,type:"f32"}});qd??(qd=ks({name:"sdf-shader",bits:[Zu,ed(e),YP,KP,Fs]})),Kd??(Kd=Ms({name:"sdf-shader",bits:[Ju,id(e),qP,jP,Us]})),super({glProgram:Kd,gpuProgram:qd,resources:{localUniforms:t,batchSamplers:sd(e)}})}}class JP extends _e{destroy(){this.context.customShader&&this.context.customShader.destroy(),super.destroy()}}class _x{constructor(e){this._renderer=e,this._managedBitmapTexts=new st({renderer:e,type:"renderable",priority:-2,name:"bitmapText"})}validateRenderable(e){const t=this._getGpuBitmapText(e);return this._renderer.renderPipes.graphics.validateRenderable(t)}addRenderable(e,t){const s=this._getGpuBitmapText(e);xx(e,s),e._didTextUpdate&&(e._didTextUpdate=!1,this._updateContext(e,s)),this._renderer.renderPipes.graphics.addRenderable(s,t),s.context.customShader&&this._updateDistanceField(e)}updateRenderable(e){const t=this._getGpuBitmapText(e);xx(e,t),this._renderer.renderPipes.graphics.updateRenderable(t),t.context.customShader&&this._updateDistanceField(e)}_updateContext(e,t){const{context:s}=t,r=zs.getFont(e.text,e._style);s.clear(),r.distanceField.type!=="none"&&(s.customShader||(s.customShader=new ZP(this._renderer.limits.maxBatchableTextures)));const n=Xe.graphemeSegmenter(e.text),o=e._style;let a=r.baseLineOffset;const l=pd(n,o,r,!0),c=o.padding,h=l.scale;let u=l.width,d=l.height+l.offsetY;o._stroke&&(u+=o._stroke.width/h,d+=o._stroke.width/h),s.translate(-e._anchor._x*u-c,-e._anchor._y*d-c).scale(h,h);const f=r.applyFillAsTint?o._fill.color:16777215;let m=r.fontMetrics.fontSize,g=r.lineHeight;o.lineHeight&&(m=o.fontSize/h,g=o.lineHeight/h);let p=(g-m)/2;p-r.baseLineOffset<0&&(p=0);for(let _=0;_<l.lines.length;_++){const x=l.lines[_];for(let v=0;v<x.charPositions.length;v++){const y=x.chars[v],T=r.chars[y];if(T?.texture){const S=T.texture;s.texture(S,f||"black",Math.round(x.charPositions[v]+T.xOffset),Math.round(a+T.yOffset+p),S.orig.width,S.orig.height)}}a+=g}}_getGpuBitmapText(e){return e._gpuData[this._renderer.uid]||this.initGpuText(e)}initGpuText(e){const t=new JP;return e._gpuData[this._renderer.uid]=t,this._updateContext(e,t),this._managedBitmapTexts.add(e),t}_updateDistanceField(e){const t=this._getGpuBitmapText(e).context,s=e._style.fontFamily,r=ae.get(`${s}-bitmap`),{a:n,b:o,c:a,d:l}=e.groupTransform,c=Math.sqrt(n*n+o*o),h=Math.sqrt(a*a+l*l),u=(Math.abs(c)+Math.abs(h))/2,d=r.baseRenderedFontSize/e._style.fontSize,f=u*r.distanceField.range*(1/d);t.customShader.resources.localUniforms.uniforms.uDistance=f}destroy(){this._managedBitmapTexts.destroy(),this._renderer=null,this._managedBitmapTexts=null}}_x.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"bitmapText"};function xx(i,e){e.groupTransform=i.groupTransform,e.groupColorAlpha=i.groupColorAlpha,e.groupColor=i.groupColor,e.groupBlendMode=i.groupBlendMode,e.globalDisplayStatus=i.globalDisplayStatus,e.groupTransform=i.groupTransform,e.localDisplayStatus=i.localDisplayStatus,e.groupAlpha=i.groupAlpha,e._roundPixels=i._roundPixels}function QP(i){const{text:e,style:t,chars:s}=i,r=t,n=zs.getFont(e,r),o=Xe.graphemeSegmenter(e),a=pd(o,r,n,!0),l=a.scale,c=[],h=[],u=[],d=t.lineHeight?t.lineHeight:n.lineHeight*l;let f=0;for(const m of a.lines){if(m.chars.length===0)continue;const g=new se({label:"line"});g.y=f,u.push(g);let p=new se({label:"word"}),_=0;for(let x=0;x<m.chars.length;x++){const v=m.chars[x];if(!v||!n.chars[v])continue;const T=v===" ",S=x===m.chars.length-1;let w;s.length>0?(w=s.shift(),w.text=v,w.style=r,w.label=`char-${v}`,w.x=m.charPositions[x]*l-m.charPositions[_]*l):w=new DI({text:v,style:r,label:`char-${v}`,x:m.charPositions[x]*l-m.charPositions[_]*l}),T||(c.push(w),p.addChild(w)),(T||S)&&p.children.length>0&&(p.x=m.charPositions[_]*l,h.push(p),g.addChild(p),p=new se({label:"word"}),_=x+1)}f+=d}return{chars:c,lines:u,words:h}}class eR extends dn{constructor(){super(...arguments),this.generatingTexture=!1,this.currentKey="--"}destroy(){this.texturePromise=null,this.generatingTexture=!1,this.currentKey="--",super.destroy()}}function jd(i,e){const{texture:t,bounds:s}=i,r=e._style._getFinalPadding();Yp(s,e._anchor,t);const n=e._anchor._x*r*2,o=e._anchor._y*r*2;s.minX-=r-n,s.minY-=r-o,s.maxX-=r-n,s.maxY-=r-o}class vx{constructor(e){this._renderer=e,e.runners.resolutionChange.add(this),this._managedTexts=new st({renderer:e,type:"renderable",onUnload:this.onTextUnload.bind(this),name:"htmlText"})}resolutionChange(){for(const e in this._managedTexts.items){const t=this._managedTexts.items[e];t?._autoResolution&&t.onViewUpdate()}}validateRenderable(e){const t=this._getGpuText(e),s=e.styleKey;return t.currentKey!==s}addRenderable(e,t){const s=this._getGpuText(e);if(e._didTextUpdate){const r=e._autoResolution?this._renderer.resolution:e.resolution;(s.currentKey!==e.styleKey||e.resolution!==r)&&this._updateGpuText(e).catch(n=>{console.error(n)}),e._didTextUpdate=!1,jd(s,e)}this._renderer.renderPipes.batch.addToBatch(s,t)}updateRenderable(e){const t=this._getGpuText(e);t._batcher.updateElement(t)}async _updateGpuText(e){e._didTextUpdate=!1;const t=this._getGpuText(e);if(t.generatingTexture)return;const s=t.texturePromise;t.texturePromise=null,t.generatingTexture=!0,e._resolution=e._autoResolution?this._renderer.resolution:e.resolution;let r=this._renderer.htmlText.getTexturePromise(e);s&&(r=r.finally(()=>{this._renderer.htmlText.decreaseReferenceCount(t.currentKey),this._renderer.htmlText.returnTexturePromise(s)})),t.texturePromise=r,t.currentKey=e.styleKey,t.texture=await r;const n=e.renderGroup||e.parentRenderGroup;n&&(n.structureDidChange=!0),t.generatingTexture=!1,jd(t,e)}_getGpuText(e){return e._gpuData[this._renderer.uid]||this.initGpuText(e)}initGpuText(e){const t=new eR;return t.renderable=e,t.transform=e.groupTransform,t.texture=k.EMPTY,t.bounds={minX:0,maxX:1,minY:0,maxY:0},t.roundPixels=this._renderer._roundPixels|e._roundPixels,e._resolution=e._autoResolution?this._renderer.resolution:e.resolution,e._gpuData[this._renderer.uid]=t,this._managedTexts.add(e),t}onTextUnload(e){const t=e._gpuData[this._renderer.uid];if(!t)return;const{htmlText:s}=this._renderer;s.getReferenceCount(t.currentKey)===null?s.returnTexturePromise(t.texturePromise):s.decreaseReferenceCount(t.currentKey)}destroy(){this._managedTexts.destroy(),this._renderer=null}}vx.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"htmlText"};function tR(){const{userAgent:i}=Y.get().getNavigator();return/^((?!chrome|android).)*safari/i.test(i)}const iR=new De;function yx(i,e,t,s){const r=iR;r.minX=0,r.minY=0,r.maxX=i.width/s|0,r.maxY=i.height/s|0;const n=ye.getOptimalTexture(r.width,r.height,s,!1);return n.source.uploadMethodId="image",n.source.resource=i,n.source.alphaMode="premultiply-alpha-on-upload",n.frame.width=e/s,n.frame.height=t/s,n.source.emit("update",n.source),n.updateUvs(),n}function sR(i,e){const t=e.fontFamily,s=[],r={},n=/font-family:([^;"\s]+)/g,o=i.match(n);function a(l){r[l]||(s.push(l),r[l]=!0)}if(Array.isArray(t))for(let l=0;l<t.length;l++)a(t[l]);else a(t);o&&o.forEach(l=>{const c=l.split(":")[1].trim();a(c)});for(const l in e.tagStyles){const c=e.tagStyles[l].fontFamily;a(c)}return s}async function rR(i){const t=await(await Y.get().fetch(i)).blob(),s=new FileReader;return await new Promise((n,o)=>{s.onloadend=()=>n(s.result),s.onerror=o,s.readAsDataURL(t)})}async function nR(i,e){const t=await rR(e);return`@font-face {
        font-family: "${i.fontFamily}";
        font-weight: ${i.fontWeight};
        font-style: ${i.fontStyle};
        src: url('${t}');
    }`}const Zd=new Map;async function oR(i){const e=i.filter(t=>ae.has(`${t}-and-url`)).map(t=>{if(!Zd.has(t)){const{entries:s}=ae.get(`${t}-and-url`),r=[];s.forEach(n=>{const o=n.url,l=n.faces.map(c=>({weight:c.weight,style:c.style}));r.push(...l.map(c=>nR({fontWeight:c.weight,fontStyle:c.style,fontFamily:t},o)))}),Zd.set(t,Promise.all(r).then(n=>n.join(`
`)))}return Zd.get(t)});return(await Promise.all(e)).join(`
`)}function aR(i,e,t,s,r){const{domElement:n,styleElement:o,svgRoot:a}=r;n.innerHTML=`<style>${e.cssStyle}</style><div style='padding:0;'>${i}</div>`,n.setAttribute("style",`transform: scale(${t});transform-origin: top left; display: inline-block`),o.textContent=s;const{width:l,height:c}=r.image;return a.setAttribute("width",l.toString()),a.setAttribute("height",c.toString()),new XMLSerializer().serializeToString(a)}function lR(i,e){const t=Lt.getOptimalCanvasAndContext(i.width,i.height,e),{context:s}=t;return s.clearRect(0,0,i.width,i.height),s.drawImage(i,0,0),t}function cR(i,e,t){return new Promise(async s=>{t&&await new Promise(r=>setTimeout(r,100)),i.onload=()=>{s()},i.src=`data:image/svg+xml;charset=utf8,${encodeURIComponent(e)}`,i.crossOrigin="anonymous"})}class bx{constructor(e){this._activeTextures={},this._renderer=e,this._createCanvas=e.type===et.WEBGPU}getTexture(e){return this.getTexturePromise(e)}getManagedTexture(e){const t=e.styleKey;if(this._activeTextures[t])return this._increaseReferenceCount(t),this._activeTextures[t].promise;const s=this._buildTexturePromise(e).then(r=>(this._activeTextures[t].texture=r,r));return this._activeTextures[t]={texture:null,promise:s,usageCount:1},s}getReferenceCount(e){return this._activeTextures[e]?.usageCount??null}_increaseReferenceCount(e){this._activeTextures[e].usageCount++}decreaseReferenceCount(e){const t=this._activeTextures[e];t&&(t.usageCount--,t.usageCount===0&&(t.texture?this._cleanUp(t.texture):t.promise.then(s=>{t.texture=s,this._cleanUp(t.texture)}).catch(()=>{H("HTMLTextSystem: Failed to clean texture")}),this._activeTextures[e]=null))}getTexturePromise(e){return this._buildTexturePromise(e)}async _buildTexturePromise(e){const{text:t,style:s,resolution:r,textureStyle:n}=e,o=Se.get(U0),a=sR(t,s),l=await oR(a),c=GI(t,s,l,o),h=Math.ceil(Math.ceil(Math.max(1,c.width)+s.padding*2)*r),u=Math.ceil(Math.ceil(Math.max(1,c.height)+s.padding*2)*r),d=o.image,f=2;d.width=(h|0)+f,d.height=(u|0)+f;const m=aR(t,s,r,l,o);await cR(d,m,tR()&&a.length>0);const g=d;let p;this._createCanvas&&(p=lR(d,r));const _=yx(p?p.canvas:g,d.width-f,d.height-f,r);return n&&(_.source.style=n),this._createCanvas&&(this._renderer.texture.initSource(_.source),Lt.returnCanvasAndContext(p)),Se.return(o),_}returnTexturePromise(e){e.then(t=>{this._cleanUp(t)}).catch(()=>{H("HTMLTextSystem: Failed to clean texture")})}_cleanUp(e){ye.returnTexture(e,!0),e.source.resource=null,e.source.uploadMethodId="unknown"}destroy(){this._renderer=null;for(const e in this._activeTextures)this._activeTextures[e]&&this.returnTexturePromise(this._activeTextures[e].promise);this._activeTextures=null}}bx.extension={type:[b.WebGLSystem,b.WebGPUSystem,b.CanvasSystem],name:"htmlText"};class hR extends se{constructor(e){const{text:t,style:s,autoSplit:r,lineAnchor:n,wordAnchor:o,charAnchor:a,...l}=e;super(l),this._dirty=!1,this._canReuseChars=!1,this.chars=[],this.words=[],this.lines=[],this._originalText=t,this._autoSplit=r,this._lineAnchor=n,this._wordAnchor=o,this._charAnchor=a,this.style=s}split(){const e=this.splitFn();this.chars=e.chars,this.words=e.words,this.lines=e.lines,this.addChild(...this.lines),this.charAnchor=this._charAnchor,this.wordAnchor=this._wordAnchor,this.lineAnchor=this._lineAnchor,this._dirty=!1,this._canReuseChars=!0}get text(){return this._originalText}set text(e){this._originalText=e,this.lines.forEach(t=>t.destroy({children:!0})),this.lines.length=0,this.words.length=0,this.chars.length=0,this._canReuseChars=!1,this.onTextUpdate()}_setOrigin(e,t,s){let r;typeof e=="number"?r={x:e,y:e}:r={x:e.x,y:e.y},t.forEach(n=>{const o=n.getLocalBounds(),a=o.minX+o.width*r.x,l=o.minY+o.height*r.y;n.origin.set(a,l)}),this[s]=e}get lineAnchor(){return this._lineAnchor}set lineAnchor(e){this._setOrigin(e,this.lines,"_lineAnchor")}get wordAnchor(){return this._wordAnchor}set wordAnchor(e){this._setOrigin(e,this.words,"_wordAnchor")}get charAnchor(){return this._charAnchor}set charAnchor(e){this._setOrigin(e,this.chars,"_charAnchor")}get style(){return this._style}set style(e){e||(e={}),this._style=new Ye(e),this.words.forEach(t=>t.destroy()),this.words.length=0,this.lines.forEach(t=>t.destroy()),this.lines.length=0,this._canReuseChars=!0,this.onTextUpdate()}onTextUpdate(){this._dirty=!0,this._autoSplit&&this.split()}destroy(e){super.destroy(e),this.chars=[],this.words=[],this.lines=[],(typeof e=="boolean"?e:e?.style)&&this._style.destroy(e),this._style=null,this._originalText=""}}const Tx=class vn extends hR{constructor(e){const t={...vn.defaultOptions,...e};super(t)}static from(e,t){const s={...vn.defaultOptions,...t,text:e.text,style:new Ye(e.style)};return new vn({...s})}splitFn(){return QP({text:this._originalText,style:this._style,chars:this._canReuseChars?this.chars:[]})}};Tx.defaultOptions={autoSplit:!0,lineAnchor:0,wordAnchor:0,charAnchor:0};let uR=Tx;class dR extends dn{}class wx{constructor(e){this._renderer=e,e.runners.resolutionChange.add(this),this._managedTexts=new st({renderer:e,type:"renderable",onUnload:this.onTextUnload.bind(this),name:"canvasText"})}resolutionChange(){for(const e in this._managedTexts.items){const t=this._managedTexts.items[e];t?._autoResolution&&t.onViewUpdate()}}validateRenderable(e){const t=this._getGpuText(e),s=e.styleKey;return t.currentKey!==s?!0:e._didTextUpdate}addRenderable(e,t){const s=this._getGpuText(e);if(e._didTextUpdate){const r=e._autoResolution?this._renderer.resolution:e.resolution;(s.currentKey!==e.styleKey||e.resolution!==r)&&this._updateGpuText(e),e._didTextUpdate=!1,jd(s,e)}this._renderer.renderPipes.batch.addToBatch(s,t)}updateRenderable(e){const t=this._getGpuText(e);t._batcher.updateElement(t)}_updateGpuText(e){const t=this._getGpuText(e);t.texture&&this._renderer.canvasText.decreaseReferenceCount(t.currentKey),e._resolution=e._autoResolution?this._renderer.resolution:e.resolution,t.texture=this._renderer.canvasText.getManagedTexture(e),t.currentKey=e.styleKey}_getGpuText(e){return e._gpuData[this._renderer.uid]||this.initGpuText(e)}initGpuText(e){const t=new dR;return t.currentKey="--",t.renderable=e,t.transform=e.groupTransform,t.bounds={minX:0,maxX:1,minY:0,maxY:0},t.roundPixels=this._renderer._roundPixels|e._roundPixels,e._gpuData[this._renderer.uid]=t,this._managedTexts.add(e),t}onTextUnload(e){const t=e._gpuData[this._renderer.uid];if(!t)return;const{canvasText:s}=this._renderer;s.getReferenceCount(t.currentKey)>0?s.decreaseReferenceCount(t.currentKey):t.texture&&s.returnTexture(t.texture)}destroy(){this._managedTexts.destroy(),this._renderer=null}}wx.extension={type:[b.WebGLPipes,b.WebGPUPipes,b.CanvasPipes],name:"text"};class Sx{constructor(e){this._activeTextures={},this._renderer=e}getTexture(e,t,s,r){typeof e=="string"&&(L("8.0.0","CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"),e={text:e,style:s,resolution:t}),e.style instanceof Ye||(e.style=new Ye(e.style)),e.textureStyle instanceof Ct||(e.textureStyle=new Ct(e.textureStyle)),typeof e.text!="string"&&(e.text=e.text.toString());const{text:n,style:o,textureStyle:a}=e,l=e.resolution??this._renderer.resolution,{frame:c,canvasAndContext:h}=Hs.getCanvasAndContext({text:n,style:o,resolution:l}),u=yx(h.canvas,c.width,c.height,l);if(a&&(u.source.style=a),o.trim&&(c.pad(o.padding),u.frame.copyFrom(c),u.frame.scale(1/l),u.updateUvs()),o.filters){const d=this._applyFilters(u,o.filters);return this.returnTexture(u),Hs.returnCanvasAndContext(h),d}return this._renderer.texture.initSource(u._source),Hs.returnCanvasAndContext(h),u}returnTexture(e){const t=e.source;t.resource=null,t.uploadMethodId="unknown",t.alphaMode="no-premultiply-alpha",ye.returnTexture(e,!0)}renderTextToCanvas(){L("8.10.0","CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead")}getManagedTexture(e){e._resolution=e._autoResolution?this._renderer.resolution:e.resolution;const t=e.styleKey;if(this._activeTextures[t])return this._increaseReferenceCount(t),this._activeTextures[t].texture;const s=this.getTexture({text:e.text,style:e.style,resolution:e._resolution,textureStyle:e.textureStyle});return this._activeTextures[t]={texture:s,usageCount:1},s}decreaseReferenceCount(e){const t=this._activeTextures[e];t.usageCount--,t.usageCount===0&&(this.returnTexture(t.texture),this._activeTextures[e]=null)}getReferenceCount(e){return this._activeTextures[e]?.usageCount??0}_increaseReferenceCount(e){this._activeTextures[e].usageCount++}_applyFilters(e,t){const s=this._renderer.renderTarget.renderTarget,r=this._renderer.filter.generateFilteredTexture({texture:e,filters:t});return this._renderer.renderTarget.bind(s,!1),r}destroy(){this._renderer=null;for(const e in this._activeTextures)this._activeTextures[e]&&this.returnTexture(this._activeTextures[e].texture);this._activeTextures=null}}Sx.extension={type:[b.WebGLSystem,b.WebGPUSystem,b.CanvasSystem],name:"canvasText"},V.add(Bw,Ow);function Te(i){if(i!=null){if(typeof i=="number")return i;if(typeof i=="string"){if(i==="transparent")return;if(i.startsWith("#")){const t=parseInt(i.slice(1),16);if(!isNaN(t))return t}if(i.startsWith("0x")){const t=parseInt(i,16);if(!isNaN(t))return t}const e=parseInt(i,16);if(!isNaN(e))return e;try{return new ue(i).toNumber()}catch{return}}}}const Cx=i=>i==="transparent",_i=(i,e=16777215)=>Cx(i)?{color:e,alpha:0}:{color:Te(i)??e,alpha:1};class ti extends Kt{type="Caption";ready;_meta={duration:1/0,width:0,height:0};get meta(){return{...this._meta}}text;get style(){if(!this.originalOpts)return{};const e=this.originalOpts;return{fontSize:e.fontSize,fontFamily:e.fontFamily,fontWeight:e.fontWeight,fontStyle:e.fontStyle,color:e.fill,align:e.align,textCase:e.textCase,stroke:e.stroke?typeof e.stroke=="object"?{color:e.stroke.color,width:e.stroke.width}:{color:e.stroke,width:e.strokeWidth??0}:void 0,shadow:e.dropShadow?{color:e.dropShadow.color??"#000000",alpha:e.dropShadow.alpha??.5,blur:e.dropShadow.blur??4,distance:e.dropShadow.distance??0,angle:e.dropShadow.angle??0}:void 0}}set style(e){this.updateStyle(e)}get fontFamily(){return this.opts.fontFamily}set fontFamily(e){this.updateStyle({fontFamily:e})}get fontUrl(){return this.opts.fontUrl}set fontUrl(e){this.updateStyle({fontUrl:e})}get fontSize(){return this.opts.fontSize}set fontSize(e){this.updateStyle({fontSize:e})}get fontWeight(){return this.opts.fontWeight}set fontWeight(e){this.updateStyle({fontWeight:e})}get fontStyle(){return this.opts.fontStyle}set fontStyle(e){this.updateStyle({fontStyle:e})}get fill(){return this.opts.fill}set fill(e){this.updateStyle({fill:e})}get align(){return this.opts.align}set align(e){this.updateStyle({align:e})}get stroke(){return this.originalOpts?.stroke}set stroke(e){this.updateStyle({stroke:e})}get strokeWidth(){return this.opts.strokeWidth}set strokeWidth(e){this.updateStyle({strokeWidth:e})}get dropShadow(){return this.originalOpts?.dropShadow}set dropShadow(e){this.updateStyle({dropShadow:e})}get caption(){return this.originalOpts?.caption}set caption(e){this.updateStyle({caption:e})}bottomOffset;get textCase(){return this.originalOpts?.textCase||"none"}set textCase(e){this.updateStyle({textCase:e})}id=`clip_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;get mediaId(){return this.opts.mediaId}set mediaId(e){this.opts.mediaId=e,this.originalOpts&&(this.originalOpts.mediaId=e)}effects=[];get words(){return this.opts.words}set words(e){this.opts.words=e,this.originalOpts&&(this.originalOpts.caption?this.originalOpts.caption.words=e:this.originalOpts.words=e),this.text=e.map(t=>t.text).filter(t=>t&&t.trim()!=="").join(" "),this.refreshCaptions().then(()=>{this.emit("propsChange",{})})}opts;pixiTextContainer=null;renderTexture=null;wordTexts=[];extraPadding=0;textStyle;externalRenderer=null;pixiApp=null;originalOpts=null;constructor(e,t={},s){super(),this.text=e,this.originalOpts={...t},this.externalRenderer=s??null,this.opts={fontSize:t.fontSize??30,fontFamily:t.fontFamily??"Arial",fontUrl:t.fontUrl??"",fontWeight:t.fontWeight??"normal",fontStyle:t.fontStyle??"normal",fill:t.fill??"#ffffff",strokeWidth:t.strokeWidth??0,align:t.align??"center",wordWrapWidth:t.wordWrapWidth??0,wordWrap:t.wordWrap??!1,lineHeight:t.lineHeight??1,letterSpacing:t.letterSpacing??0,textCase:t.textCase??"none",videoWidth:t.caption?.positioning?.videoWidth??t.videoWidth??1280,videoHeight:t.caption?.positioning?.videoHeight??t.videoHeight??720,bottomOffset:t.caption?.positioning?.bottomOffset??t.bottomOffset??30,keyword:t.caption?.colors?.keyword??t.colors?.keyword??"#ffff00",background:t.caption?.colors?.background??t.colors?.background??"#000000",active:t.caption?.colors?.active??t.colors?.active??"#ffffff",activeFill:t.caption?.colors?.activeFill??t.colors?.activeFill??"#00ff00",appeared:t.caption?.colors?.appeared??t.colors?.appeared??"#ffffff",words:t.caption?.words??t.words??[],preserveKeywordColor:t.caption?.preserveKeywordColor??t.preserveKeywordColor??!1,mediaId:t.mediaId};const r={fontSize:this.opts.fontSize,fontFamily:this.opts.fontFamily,fontWeight:this.opts.fontWeight,fontStyle:this.opts.fontStyle,align:this.opts.align};if(t.fill&&typeof t.fill=="object"&&t.fill.type==="gradient"){const a=new ct(t.fill.x0,t.fill.y0,t.fill.x1,t.fill.y1);t.fill.colors.forEach(({ratio:l,color:c})=>{const h=typeof c=="number"?c:Te(c)??16777215;a.addColorStop(l,h)}),r.fill={fill:a}}else{let a;t.fill==="transparent"?a=16777215:(typeof t.fill=="string"||typeof t.fill=="number")&&(a=Te(t.fill)),r.fill=a??16777215}const n=a=>a==="transparent";if(t.stroke&&typeof t.stroke=="object"&&"color"in t.stroke){if(!n(t.stroke.color)){const a=Te(t.stroke.color);a!==void 0&&(r.stroke={color:a,width:t.stroke.width},t.stroke.join&&(r.stroke.join=t.stroke.join))}}else if(!n(t.stroke)){const a=Te(t.stroke);a!==void 0?r.stroke={color:a,width:this.opts.strokeWidth??0}:this.opts.strokeWidth&&this.opts.strokeWidth>0&&(r.stroke={color:0,width:this.opts.strokeWidth})}if(t.dropShadow){const a=Te(t.dropShadow.color);a!==void 0&&(r.dropShadow={color:a,alpha:t.dropShadow.alpha??.5,blur:t.dropShadow.blur??4,angle:t.dropShadow.angle??Math.PI/6,distance:t.dropShadow.distance??2})}const o=new Ye(r);this.textStyle=o,this.ready=(async()=>{await this.refreshCaptions();const a={...this._meta};return ee.info("CaptionClip ready:",a),a})()}async updateStyle(e){this.originalOpts||(this.originalOpts={}),this.originalOpts={...this.originalOpts,...e},e.fontSize!==void 0&&(this.opts.fontSize=e.fontSize),e.fontFamily!==void 0&&(this.opts.fontFamily=e.fontFamily),e.fontUrl!==void 0&&(this.opts.fontUrl=e.fontUrl),e.fontWeight!==void 0&&(this.opts.fontWeight=e.fontWeight),e.fontStyle!==void 0&&(this.opts.fontStyle=e.fontStyle),e.fill!==void 0&&(this.opts.fill=e.fill),e.align!==void 0&&(this.opts.align=e.align),e.letterSpacing!==void 0&&(this.opts.letterSpacing=e.letterSpacing),e.lineHeight!==void 0&&(this.opts.lineHeight=e.lineHeight),e.textCase!==void 0&&(this.opts.textCase=e.textCase),e.caption?.colors&&(e.caption.colors.appeared!==void 0&&(this.opts.appeared=e.caption.colors.appeared),e.caption.colors.active!==void 0&&(this.opts.active=e.caption.colors.active),e.caption.colors.activeFill!==void 0&&(this.opts.activeFill=e.caption.colors.activeFill),e.caption.colors.background!==void 0&&(this.opts.background=e.caption.colors.background),e.caption.colors.keyword!==void 0&&(this.opts.keyword=e.caption.colors.keyword)),e.caption?.preserveKeywordColor!==void 0&&(this.opts.preserveKeywordColor=e.caption.preserveKeywordColor);const t={fontSize:this.opts.fontSize,fontFamily:this.opts.fontFamily,fontWeight:this.opts.fontWeight,fontStyle:this.opts.fontStyle,align:this.opts.align};if(this.opts.fill&&typeof this.opts.fill=="object"&&this.opts.fill.type==="gradient"){const r=new ct(this.opts.fill.x0,this.opts.fill.y0,this.opts.fill.x1,this.opts.fill.y1);this.opts.fill.colors.forEach(({ratio:n,color:o})=>{const a=typeof o=="number"?o:Te(o)??16777215;r.addColorStop(n,a)}),t.fill={fill:r}}else{const r=typeof this.opts.fill=="string"||typeof this.opts.fill=="number"?Te(this.opts.fill):void 0;t.fill=r??16777215}if(e.stroke!==void 0||e.strokeWidth!==void 0)if(this.originalOpts.stroke&&typeof this.originalOpts.stroke=="object"&&"color"in this.originalOpts.stroke){const r=Te(this.originalOpts.stroke.color);r!==void 0&&(t.stroke={color:r,width:this.originalOpts.stroke.width},this.originalOpts.stroke.join&&(t.stroke.join=this.originalOpts.stroke.join))}else{const r=Te(this.originalOpts.stroke),n=e.strokeWidth??this.originalOpts.strokeWidth??0;r!==void 0?t.stroke={color:r,width:n}:n>0&&(t.stroke={color:0,width:n})}const s=e.dropShadow??this.originalOpts.dropShadow;if(s){const r=Te(s.color);r!==void 0&&(t.dropShadow={color:r,alpha:s.alpha??.5,blur:s.blur??4,angle:s.angle??Math.PI/6,distance:s.distance??2})}this.textStyle=new Ye(t),await this.refreshCaptions(),this.emit("propsChange",e)}async refreshCaptions(){this.pixiTextContainer?this.pixiTextContainer.removeChildren():this.pixiTextContainer=new se;const e=this.textStyle;let t=0,s=0,r=0;const n=this.opts.textCase,o=Xe.measureText(" ",this.textStyle);this.wordTexts=this.opts.words.map(S=>{let w=S.text;if(!w||w.trim()===""){const D=new se;return D.label="emptyWord",this.pixiTextContainer.addChild(D),D}n==="uppercase"?w=w.toUpperCase():n==="lowercase"?w=w.toLowerCase():n==="title"&&(w=w.replace(/\w\S*/g,D=>D.charAt(0).toUpperCase()+D.substring(1).toLowerCase()));const E=new uR({text:w,style:e});E.x=t,E.y=0;const P=E.getLocalBounds(),C=Math.ceil(P.width||E.width),A=Math.ceil(P.height||E.height);s=Math.max(s,A),t+=C+o.width,r=t-o.width,this.pixiTextContainer.addChild(E);const B=Te(this.opts.fill);return E.tint=B??16777215,E});const a=r,l=s,c=new _e;c.label="containerBackground";const h=this.opts.background==="transparent"||!this.opts.background,u=h?0:Te(this.opts.background),d=h?0:1,f=15;c.roundRect(0,0,a+f*2,l+f*2,10),c.fill({color:u,alpha:d}),this.wordTexts.forEach(S=>{this.extraPadding=0,S.pivot.y=0,S.pivot.x=0,S.y=f-this.extraPadding,S.x+=f}),this.pixiTextContainer.addChildAt(c,0);const g=a+f*2,p=l+f*2;this.renderTexture?this.renderTexture.resize(g,p):this.renderTexture=Ge.create({width:g,height:p});try{(await this.getRenderer()).render({container:this.pixiTextContainer,target:this.renderTexture})}catch(S){ee.warn("CaptionClip: Could not render captions during refresh",S)}this._meta.width=g,this._meta.height=p,this._meta.duration=1/0;const _=this.opts.videoWidth,x=this.opts.videoHeight,v=this.opts.bottomOffset,y=x-p-v,T=(_-g)/2;this.update({width:g,height:p,top:y,left:T})}lastLoggedTime=-1;updateState(e){const t=e/1e3,s=Math.floor(e/1e6);s!==this.lastLoggedTime&&(this.lastLoggedTime=s),this.opts.words.forEach((r,n)=>{const o=t>=r.from&&t<r.to,a=t>=r.to,l=r.isKeyWord&&!Cx(this.opts.keyword);let c=16777215,h=1;r.isKeyWord&&o&&l?{color:c,alpha:h}=_i(this.opts.keyword):o?{color:c,alpha:h}=_i(this.opts.active):a&&this.opts.preserveKeywordColor&&l?{color:c,alpha:h}=_i(this.opts.keyword):a?{color:c,alpha:h}=_i(this.opts.appeared):{color:c,alpha:h}=_i(this.opts.fill);const u=this.wordTexts[n];if(!u){console.warn(`WARNING: SplitBitmapText was not found for word "${r.text}"!`);return}u.children.forEach(f=>{f.label!=="bgRect"&&(f.tint=c,f.alpha=h)});const d=u.getChildByLabel("bgRect");if(o){const{color:f,alpha:m}=_i(this.opts.activeFill,16753920),g=10;d&&(d.visible=!1);const p=u.getLocalBounds();d&&(d.visible=!0);const _=16,x=d??new _e;x.label="bgRect",x.clear(),x.roundRect(p.x-g/2,p.y-g/2+this.extraPadding,p.width+g,p.height+g,_),x.fill({color:f,alpha:m}),x.tint=16777215,d||u.addChildAt(x,0)}else d&&(u.removeChild(d),d.destroy())})}async getTexture(){if(this.pixiTextContainer==null||this.renderTexture==null)return console.log("[CaptionClip] getTexture returning null - container or texture not ready"),null;try{return(await this.getRenderer()).render({container:this.pixiTextContainer,target:this.renderTexture}),this.renderTexture}catch(e){return console.error("[CaptionClip] Error in getTexture:",e),null}}setRenderer(e){this.externalRenderer=e}async getRenderer(){if(this.externalRenderer!=null)return this.externalRenderer;if(this.pixiApp?.renderer==null)throw new Error("CaptionClip: No renderer available. Provide a renderer via setRenderer().");return this.pixiApp.renderer}async tick(e){if(await this.ready,this.pixiTextContainer==null||this.renderTexture==null)throw new Error("CaptionClip not initialized");this.updateState(e);const t=await this.getRenderer();t.render({container:this.pixiTextContainer,target:this.renderTexture});const s=this.renderTexture.source?.resource?.source;let r;if(s instanceof HTMLCanvasElement)r=await createImageBitmap(s);else if(s instanceof OffscreenCanvas)r=await createImageBitmap(s);else{const o=t.extract.canvas(this.renderTexture);if(o instanceof HTMLCanvasElement||o instanceof OffscreenCanvas)r=await createImageBitmap(o);else throw new Error("Unable to extract canvas from render texture")}return{video:r,state:"success"}}async split(e){await this.ready;const t=await this.clone(),s=await this.clone();return[t,s]}addEffect(e){this.effects.push(e)}editEffect(e,t){const s=this.effects.find(r=>r.id===e);s&&Object.assign(s,t)}removeEffect(e){const t=this.effects.findIndex(s=>s.id===e);t!==-1&&this.effects.splice(t,1)}async clone(){await this.ready;const e=this.originalOpts||{},t=new ti(this.text,e);return this.copyStateTo(t),t.id=this.id,t.effects=[...this.effects],t}destroy(){if(!this.destroyed){ee.info("CaptionClip destroy");try{this.wordTexts.forEach(e=>{e!=null&&!e.destroyed&&e.destroy({children:!0})})}catch{}finally{this.wordTexts=[]}try{this.pixiTextContainer!=null&&this.pixiTextContainer.destroyed!==!0&&this.pixiTextContainer.destroy({children:!0})}catch{}finally{this.pixiTextContainer=null}try{this.renderTexture!=null&&this.renderTexture.destroyed!==!0&&this.renderTexture.destroy(!0)}catch{}finally{this.renderTexture=null}if(this.externalRenderer=null,this.pixiApp!=null)try{const e=this.pixiApp;e.destroyed!==!0&&e.renderer!=null&&this.pixiApp.destroy(!0,{children:!0,texture:!0})}catch{}finally{this.pixiApp=null}super.destroy()}}toJSON(e=!1){const t=super.toJSON(e),s={};if(this.originalOpts){const u=this.originalOpts;u.fontSize!==void 0&&(s.fontSize=u.fontSize),u.fontFamily!==void 0&&(s.fontFamily=u.fontFamily),u.fontWeight!==void 0&&(s.fontWeight=u.fontWeight),u.fontStyle!==void 0&&(s.fontStyle=u.fontStyle),u.fill!==void 0&&(s.color=u.fill),u.align!==void 0&&(s.align=u.align),u.textCase!==void 0&&(s.textCase=u.textCase),u.fontUrl!==void 0&&(s.fontUrl=u.fontUrl),u.stroke&&(typeof u.stroke=="object"?s.stroke={color:u.stroke.color,width:u.stroke.width}:s.stroke={color:u.stroke,width:u.strokeWidth??0}),u.dropShadow&&(s.shadow={color:u.dropShadow.color??"#000000",alpha:u.dropShadow.alpha??.5,blur:u.dropShadow.blur??4,distance:u.dropShadow.distance??0,angle:u.dropShadow.angle??0})}const r={};this.opts.words&&this.opts.words.length>0&&(r.words=this.opts.words);const n={},o=this.originalOpts?.caption?.colors??this.originalOpts?.colors;o?.appeared!==void 0&&(n.appeared=o.appeared),o?.active!==void 0&&(n.active=o.active),o?.activeFill!==void 0&&(n.activeFill=o.activeFill),o?.background!==void 0&&(n.background=o.background),o?.keyword!==void 0&&(n.keyword=o.keyword);let a;this.originalOpts?.caption?.preserveKeywordColor!==void 0?a=this.originalOpts.caption.preserveKeywordColor:this.originalOpts?.preserveKeywordColor!==void 0&&(a=this.originalOpts.preserveKeywordColor),Object.keys(n).length>0&&(r.colors=n),a!==void 0&&(r.preserveKeywordColor=a);const l={};this.bottomOffset!==void 0&&(l.bottomOffset=this.bottomOffset);const c=this.originalOpts?.caption?.positioning?.videoWidth??this.originalOpts?.videoWidth,h=this.originalOpts?.caption?.positioning?.videoHeight??this.originalOpts?.videoHeight;return c!==void 0&&(l.videoWidth=c),h!==void 0&&(l.videoHeight=h),Object.keys(l).length>0&&(r.positioning=l),{...t,type:"Caption",text:this.text,style:s,caption:Object.keys(r).length>0?r:void 0,id:this.id,effects:this.effects,mediaId:this.mediaId}}static async fromObject(e){if(e.type!=="Caption")throw new Error(`Expected Caption, got ${e.type}`);const t=e.text||"",s=e.style||{},r={};s.fontSize!==void 0&&(r.fontSize=s.fontSize),s.fontFamily!==void 0&&(r.fontFamily=s.fontFamily),s.fontWeight!==void 0&&(r.fontWeight=s.fontWeight),s.fontStyle!==void 0&&(r.fontStyle=s.fontStyle),s.color!==void 0&&(r.fill=s.color),s.align!==void 0&&(r.align=s.align),s.textCase!==void 0&&(r.textCase=s.textCase),s.fontUrl!==void 0?r.fontUrl=s.fontUrl:e.fontUrl!==void 0&&(r.fontUrl=e.fontUrl),e.mediaId&&(r.mediaId=e.mediaId),s.stroke&&(r.stroke=s.stroke.color,r.strokeWidth=s.stroke.width),s.shadow&&(r.dropShadow={color:s.shadow.color,alpha:s.shadow.alpha,blur:s.shadow.blur,distance:s.shadow.distance,angle:s.shadow.angle}),e.caption?r.caption=e.caption:(e.bottomOffset!==void 0&&(r.bottomOffset=e.bottomOffset),e.words!==void 0&&(r.words=e.words),(e.appearedColor!==void 0||e.activeColor!==void 0||e.activeFillColor!==void 0||e.backgroundColor!==void 0||e.isKeyWordColor!==void 0)&&(r.colors={},e.appearedColor!==void 0&&(r.colors.appeared=e.appearedColor),e.activeColor!==void 0&&(r.colors.active=e.activeColor),e.activeFillColor!==void 0&&(r.colors.activeFill=e.activeFillColor),e.backgroundColor!==void 0&&(r.colors.background=e.backgroundColor),e.isKeyWordColor!==void 0&&(r.colors.keyword=e.isKeyWordColor)),e.preservedColorKeyWord!==void 0&&(r.preserveKeywordColor=e.preservedColorKeyWord),e.videoWidth!==void 0&&(r.videoWidth=e.videoWidth),e.videoHeight!==void 0&&(r.videoHeight=e.videoHeight));const n=new ti(t,r);return n.left=e.left,n.top=e.top,n.width=e.width,n.height=e.height,n.angle=e.angle,n.display.from=e.display.from,n.display.to=e.display.to,n.duration=e.duration,n.playbackRate=e.playbackRate,n.zIndex=e.zIndex,n.opacity=e.opacity,n.flip=e.flip,e.animation&&n.setAnimation(e.animation.keyFrames,e.animation.opts),e.id&&(n.id=e.id),e.effects&&(n.effects=e.effects),await n.ready,n}}class ze extends Kt{type="Image";ready;_meta={duration:0,width:0,height:0};get meta(){return{...this._meta}}img=null;pixiTexture=null;frames=[];id=`clip_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;effects=[];static async fromUrl(e,t){const s=await Ls.load(e),r=s.source?.resource?.source;let n;try{if(r instanceof HTMLCanvasElement||r instanceof OffscreenCanvas)n=await createImageBitmap(r);else if(r instanceof HTMLImageElement){const a=new OffscreenCanvas(r.width,r.height),l=a.getContext("2d");if(l==null)throw new Error("Failed to create 2d context");l.drawImage(r,0,0),n=await createImageBitmap(a)}else if(r instanceof ImageBitmap)n=await createImageBitmap(r);else{const a=await fetch(e);if(!a.ok)throw new Error(`Failed to fetch image: ${a.status} ${a.statusText}`);const l=await a.blob();n=await createImageBitmap(l)}}catch{const l=await fetch(e);if(!l.ok)throw new Error(`Failed to fetch image: ${l.status} ${l.statusText}`);const c=await l.blob();n=await createImageBitmap(c)}const o=new ze(n,t||e);return o.pixiTexture=s,o}getTexture(){return this.pixiTexture}constructor(e,t){super(),this.src=t!==void 0?t:"";const s=r=>{this.img=r,this._meta.width=r.width,this._meta.height=r.height,this._meta.duration=1/0;const n={...this._meta};return this.width=this.width===0?n.width:this.width,this.height=this.height===0?n.height:this.height,this.duration===0&&n.duration!==1/0&&(this.duration=n.duration,this.display.to=this.display.from+this.duration),n};if(e instanceof ReadableStream)this.ready=new Response(e).blob().then(r=>createImageBitmap(r)).then(s);else if(e instanceof ImageBitmap)this.ready=Promise.resolve(s(e));else if(Array.isArray(e)&&e.every(r=>r instanceof VideoFrame)){this.frames=e;const r=this.frames[0];if(r==null)throw Error("The frame count must be greater than 0");this._meta={width:r.displayWidth,height:r.displayHeight,duration:this.frames.reduce((o,a)=>o+(a.duration??0),0)};const n={...this._meta,duration:1/0};this.width=this.width===0?n.width:this.width,this.height=this.height===0?n.height:this.height,this.duration===0&&n.duration!==1/0&&(this.duration=n.duration,this.display.to=this.display.from+this.duration),this.ready=Promise.resolve(n)}else if("type"in e)this.ready=this.initAnimateImg(e.stream,e.type).then(()=>{const r={width:this._meta.width,height:this._meta.height,duration:1/0};return this.width=this.width===0?r.width:this.width,this.height=this.height===0?r.height:this.height,this.duration===0&&r.duration!==1/0&&(this.duration=r.duration,this.display.to=this.display.from+this.duration),r});else throw Error("Illegal arguments")}async initAnimateImg(e,t){this.frames=await Rw(e,t);const s=this.frames[0];if(s==null)throw Error("No frame available in gif");this._meta={duration:this.frames.reduce((r,n)=>r+(n.duration??0),0),width:s.codedWidth,height:s.codedHeight},ee.info("ImageClip ready:",this._meta)}tickInterceptor=async(e,t)=>t;async tick(e){if(this.img!=null)return await this.tickInterceptor(e,{video:await createImageBitmap(this.img),state:"success"});const t=e%this._meta.duration;return await this.tickInterceptor(e,{video:(this.frames.find(s=>t>=s.timestamp&&t<=s.timestamp+(s.duration??0))??this.frames[0]).clone(),state:"success"})}async split(e){if(await this.ready,this.img!=null)return[new ze(await createImageBitmap(this.img),this.src),new ze(await createImageBitmap(this.img),this.src)];let t=-1;for(let n=0;n<this.frames.length;n++){const o=this.frames[n];if(!(e>o.timestamp)){t=n;break}}if(t===-1)throw Error("Not found frame by time");const s=this.frames.slice(0,t).map(n=>new VideoFrame(n)),r=this.frames.slice(t).map(n=>new VideoFrame(n,{timestamp:n.timestamp-e}));return[new ze(s,this.src),new ze(r,this.src)]}async clone(){await this.ready;const e=this.img==null?this.frames.map(s=>s.clone()):await createImageBitmap(this.img),t=new ze(e,this.src);return t.tickInterceptor=this.tickInterceptor,this.copyStateTo(t),t.id=this.id,t.effects=[...this.effects],t.transition=this.transition,t}addEffect(e){this.effects.push(e)}editEffect(e,t){const s=this.effects.find(r=>r.id===e);s&&Object.assign(s,t)}removeEffect(e){const t=this.effects.findIndex(s=>s.id===e);t!==-1&&this.effects.splice(t,1)}destroy(){ee.info("ImageClip destroy"),this.img?.close(),this.frames.forEach(e=>e.close()),this.pixiTexture=null,super.destroy()}toJSON(e=!1){return{...super.toJSON(e),type:"Image",id:this.id,effects:this.effects}}static async fromObject(e){if(e.type!=="Image")throw new Error(`Expected Image, got ${e.type}`);if(!e.src||e.src.trim()==="")throw new Error("ImageClip requires a valid source URL. Generated clips (like text-to-image) cannot be loaded from JSON without their source data.");let t;try{const s=await fetch(e.src);if(!s.ok)throw new Error(`Failed to fetch image from ${e.src}: ${s.status} ${s.statusText}. Make sure the file exists in the public directory.`);const r=await s.blob();if(!r.type.startsWith("image/"))throw new Error(`Invalid image format: ${r.type}. Expected an image file.`);t=new ze(await createImageBitmap(r),e.src)}catch(s){throw s instanceof Error&&s.message.includes("could not be decoded")?new Error(`Failed to decode image from ${e.src}. The image may be corrupted, in an unsupported format, or there may be CORS issues.`):s}return await t.ready,t.left=e.left,t.top=e.top,t.width=e.width,t.height=e.height,t.angle=e.angle,t.display.from=e.display.from,t.display.to=e.display.to,t.duration=e.duration,t.playbackRate=e.playbackRate,t.zIndex=e.zIndex,t.opacity=e.opacity,t.flip=e.flip,e.style&&(t.style={...t.style,...e.style}),e.animation&&t.setAnimation(e.animation.keyFrames,e.animation.opts),e.id&&(t.id=e.id),e.effects&&(t.effects=e.effects),e.transition&&(t.transition=e.transition),t}}function Jd(i,e){const t={},s=e.videoTracks[0];if(s!=null){const n=pR(i.getTrackById(s.id))?.buffer,o=fR(s.codec);o&&(t.videoTrackConf={timescale:s.timescale,duration:s.duration,width:s.video.width,height:s.video.height,brands:e.brands,type:o.type,[o.descKey]:n}),t.videoDecoderConf={codec:s.codec,codedHeight:s.video.height,codedWidth:s.video.width,description:n}}const r=e.audioTracks[0];if(r!=null){const n=mR(i),o=n?gR(n):{};t.audioTrackConf={timescale:r.timescale,samplerate:o.sampleRate??r.audio.sample_rate,channel_count:o.numberOfChannels??r.audio.channel_count,hdlr:"soun",type:r.codec.startsWith("mp4a")?"mp4a":r.codec,description:n},t.audioDecoderConf={codec:o.codec??he.codec,numberOfChannels:o.numberOfChannels??r.audio.channel_count,sampleRate:o.sampleRate??r.audio.sample_rate}}return t}function fR(i){return i.startsWith("avc1")?{descKey:"avcDecoderConfigRecord",type:"avc1"}:i.startsWith("hvc1")?{descKey:"hevcDecoderConfigRecord",type:"hvc1"}:null}function pR(i){for(const e of i.mdia.minf.stbl.stsd.entries){const t=e.avcC??e.hvcC??e.av1C??e.vpcC;if(t!=null){const s=new oi.DataStream(void 0,0,void 0);return t.write(s),new Uint8Array(s.buffer.slice(8))}}}function mR(i,e="mp4a"){return i.moov?.traks.flatMap(t=>t.mdia.minf.stbl.stsd.entries).find(t=>t.type===e)}function gR(i){const e=i.esd?.descs?.[0];if(!e)return{};let t=`mp4a.${e.oti.toString(16)}`;const s=e.descs?.[0];if(!s)return t.endsWith(".40")&&(t+=".2"),{codec:t};const r=s.data;if(!r)return{codec:t};const n=(r[0]&248)>>3;t+=`.${n}`;const o=(r[0]&7)<<1|r[1]>>7,a=(r[1]&120)>>3;return{codec:t,sampleRate:[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350][o],numberOfChannels:a}}async function _R(i,e,t){const s=oi.createFile(!1);s.onReady=o=>{e({mp4boxFile:s,info:o}),[o.videoTracks[0],o.audioTracks[0]].forEach(a=>{if(a){const l=a.video?"video":"audio";s.setExtractionOptions(a.id,l,{nbSamples:100})}}),s.start()},s.onSamples=t;let r=0;const n=30*1024*1024;for(;;){const o=await i.read(n,{at:r});if(o.byteLength===0)break;o.fileStart=r;const a=s.appendBuffer(o);if(a==null)break;r=a}s.stop()}function xR(i){if(i?.length!==9)return{};const e=new Int32Array(i.buffer),t=h=>h/65536,s=t(e[0]),r=t(e[1]),n=t(e[3]),o=t(e[4]),a=t(e[6]),l=t(e[7]),c=e[8]/(1<<30);return{scaleX:Math.sqrt(s*s+n*n),scaleY:Math.sqrt(r*r+o*o),rotationRad:Math.atan2(n,s),rotationDeg:Math.atan2(n,s)*180/Math.PI,translateX:a,translateY:l,perspective:c}}function vR(i,e,t){const s=(Math.round(t/90)*90+360)%360;if(s===0)return c=>c;const r=s===90||s===270,n=r?e:i,o=r?i:e,a=new OffscreenCanvas(n,o),l=a.getContext("2d");return l.translate(n/2,o/2),l.rotate(-s*Math.PI/180),l.translate(-i/2,-e/2),c=>{if(!c)return null;l.drawImage(c,0,0);const h=new VideoFrame(a,{timestamp:c.timestamp,duration:c.duration??void 0});return c.close(),h}}class Ax{static async getCacheKey(e){const s=new TextEncoder().encode(e),r=await crypto.subtle.digest("SHA-1",s);return Array.from(new Uint8Array(r)).map(o=>o.toString(16).padStart(2,"0")).join("")}static getPath(e){return`assets/${e}`}static async get(e){const t=await this.getCacheKey(e),s=this.getPath(t),r=ai(s);return await r.exists()?r:null}static async put(e,t){const s=await this.getCacheKey(e),r=this.getPath(s),n=ai(r);return await Ei(n,t),n}}let Qd=0;function ef(i){return i.kind==="file"&&i.createReader instanceof Function}class ke extends Kt{type="Video";insId=Qd++;logger=ee.create(`VideoClip id:${this.insId},`);ready;_meta={duration:0,width:0,height:0,audioSampleRate:0,audioChanCount:0};get meta(){return{...this._meta}}localFile;headerBoxPos=[];async getFileHeaderBinData(){await this.ready;const e=await this.localFile.getOriginFile();if(e==null)throw Error("VideoClip localFile is not origin file");return await new Blob(this.headerBoxPos.map(({start:t,size:s})=>e.slice(t,t+s))).arrayBuffer()}parsedMatrix={perspective:1,rotationRad:0,rotationDeg:0,scaleX:1,scaleY:1,translateX:0,translateY:0};vfRotater=e=>e;videoSamples=[];audioSamples=[];videoFrameFinder=null;audioFrameFinder=null;decoderConf={video:null,audio:null};opts={audio:!0};audio=!0;id=`clip_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;effects=[];static async fromUrl(e,t={}){const s=await Ax.get(e);if(s){const u=new ke(s,{},e);return await u.ready,t.x!==void 0&&(u.left=t.x),t.y!==void 0&&(u.top=t.y),t.width!==void 0&&(u.width=t.width),t.height!==void 0&&(u.height=t.height),u}const r=await fetch(e);if(!r.ok)throw new Error(`Failed to fetch video from ${e}: ${r.status} ${r.statusText}`);const n=r.body,[o,a]=n.tee(),l=(async()=>{const u=new ke(o,{},e);return await u.ready,u})(),c=Ax.put(e,a),[h]=await Promise.all([l,c]);return t.x!==void 0&&(h.left=t.x),t.y!==void 0&&(h.top=t.y),t.width!==void 0&&(h.width=t.width),t.height!==void 0&&(h.height=t.height),h}constructor(e,t={},s){if(super(),this.src=s!==void 0?s:"",!(e instanceof ReadableStream)&&!ef(e)&&!Array.isArray(e.videoSamples))throw Error("Illegal argument");this.opts={audio:!0,...t},this.audio=typeof this.opts.audio=="boolean"?this.opts.audio:!0,this.volume=typeof t.audio=="object"&&"volume"in t.audio?t.audio.volume:t.volume??1;const r=async n=>(await Ei(this.localFile,n),this.localFile);this.localFile=ef(e)?e:"localFile"in e?e.localFile:Yh(),this.ready=(e instanceof ReadableStream?r(e).then(n=>Ex(n,this.opts)):ef(e)?Ex(e,this.opts):Promise.resolve(e)).then(async({videoSamples:n,audioSamples:o,decoderConf:a,headerBoxPos:l,parsedMatrix:c})=>{this.videoSamples=n,this.audioSamples=o,this.decoderConf=a,this.headerBoxPos=l,this.parsedMatrix=c;const{videoFrameFinder:h,audioFrameFinder:u}=bR({video:a.video==null?null:{...a.video,hardwareAcceleration:this.opts.__unsafe_hardwareAcceleration__},audio:a.audio},await this.localFile.createReader(),n,o,this.opts.audio!==!1?this.volume:0);this.videoFrameFinder=h,this.audioFrameFinder=u;const{codedWidth:d,codedHeight:f}=a.video??{};d&&f&&(this.vfRotater=vR(d,f,c.rotationDeg)),this._meta=yR(a,n,o,c.rotationDeg),this.logger.info("VideoClip meta:",this._meta);const m={...this._meta};this.width=this.width===0?m.width:this.width,this.height=this.height===0?m.height:this.height,this.trim.to=this.trim.to===0?m.duration:this.trim.to;const g=(this.trim.to-this.trim.from)/this.playbackRate;return this.duration=this.duration===0?g:this.duration,this.display.to=this.display.from+this.duration,this.on("propsChange",p=>{p.volume!==void 0&&this.audioFrameFinder&&this.audioFrameFinder.setVolume(p.volume)}),m})}tickInterceptor=async(e,t)=>t;async tick(e){const t=e+this.trim.from;if(t>=this.trim.to||t>=this._meta.duration)return await this.tickInterceptor(e,{audio:await this.audioFrameFinder?.find(t)??[],state:"done"});const[s,r]=await Promise.all([this.audioFrameFinder?.find(t)??[],this.videoFrameFinder?.find(t).then(this.vfRotater)]);return r==null?await this.tickInterceptor(e,{audio:s,state:"success"}):await this.tickInterceptor(e,{video:r,audio:s,state:"success"})}async split(e){if(await this.ready,e<=0||e>=this._meta.duration)throw Error("time out of bounds");const[t,s]=IR(this.videoSamples,e),[r,n]=PR(this.audioSamples,e),o=new ke({localFile:this.localFile,videoSamples:t??[],audioSamples:r??[],decoderConf:this.decoderConf,headerBoxPos:this.headerBoxPos,parsedMatrix:this.parsedMatrix},this.opts,this.src),a=new ke({localFile:this.localFile,videoSamples:s??[],audioSamples:n??[],decoderConf:this.decoderConf,headerBoxPos:this.headerBoxPos,parsedMatrix:this.parsedMatrix},this.opts,this.src);return await Promise.all([o.ready,a.ready]),[o,a]}addEffect(e){this.effects.push(e)}editEffect(e,t){const s=this.effects.find(r=>r.id===e);s&&Object.assign(s,t)}removeEffect(e){const t=this.effects.findIndex(s=>s.id===e);t!==-1&&this.effects.splice(t,1)}async clone(){await this.ready;const e=new ke({localFile:this.localFile,videoSamples:[...this.videoSamples],audioSamples:[...this.audioSamples],decoderConf:this.decoderConf,headerBoxPos:this.headerBoxPos,parsedMatrix:this.parsedMatrix},this.opts,this.src);return await e.ready,e.tickInterceptor=this.tickInterceptor,this.copyStateTo(e),e.id=this.id,e.effects=[...this.effects],e}async splitTrack(){await this.ready;const e=[];if(this.videoSamples.length>0){const t=new ke({localFile:this.localFile,videoSamples:[...this.videoSamples],audioSamples:[],decoderConf:{video:this.decoderConf.video,audio:null},headerBoxPos:this.headerBoxPos,parsedMatrix:this.parsedMatrix},this.opts,this.src);await t.ready,t.tickInterceptor=this.tickInterceptor,e.push(t)}if(this.audioSamples.length>0){const t=new ke({localFile:this.localFile,videoSamples:[],audioSamples:[...this.audioSamples],decoderConf:{audio:this.decoderConf.audio,video:null},headerBoxPos:this.headerBoxPos,parsedMatrix:this.parsedMatrix},this.opts,this.src);await t.ready,t.tickInterceptor=this.tickInterceptor,e.push(t)}return e}destroy(){this.destroyed||(this.destroyed=!0,this.logger.info("VideoClip destroy"),super.destroy(),this.videoFrameFinder?.destroy(),this.audioFrameFinder?.destroy())}toJSON(e=!1){return{...super.toJSON(e),type:"Video",audio:this.audio,volume:this.volume,id:this.id,effects:this.effects}}static async fromObject(e){if(e.type!=="Video")throw new Error(`Expected Video, got ${e.type}`);const t=await fetch(e.src);if(!t.ok)throw new Error(`Failed to fetch video from ${e.src}: ${t.status} ${t.statusText}. Make sure the file exists in the public directory.`);const s=e.audio!==void 0?{audio:e.audio,volume:e.volume}:{volume:e.volume},r=new ke(t.body,s,e.src);return await r.ready,r.left=e.left,r.top=e.top,r.width=e.width,r.height=e.height,r.angle=e.angle,r.display.from=e.display.from,r.display.to=e.display.to,r.duration=e.duration,r.playbackRate=e.playbackRate,r.zIndex=e.zIndex,r.opacity=e.opacity,r.flip=e.flip,e.style&&(r.style={...r.style,...e.style}),e.animation&&r.setAnimation(e.animation.keyFrames,e.animation.opts),e.id&&(r.id=e.id),e.effects&&(r.effects=e.effects),e.transition&&(r.transition=e.transition),e.trim&&(r.trim.from=e.trim.from<1e6?e.trim.from*1e6:e.trim.from,r.trim.to=e.trim.to<1e6?e.trim.to*1e6:e.trim.to),e.volume!==void 0&&(r.volume=e.volume),r}async createPlaybackElement(){await this.ready;const t=this.localFile;if(!t||typeof t.getOriginFile!="function")throw new Error("VideoClip does not have a local file for playback");const s=await t.getOriginFile();if(!s)throw new Error("Failed to get origin file from VideoClip");const r=URL.createObjectURL(s),n=document.createElement("video");return n.crossOrigin="anonymous",n.muted=!0,n.autoplay=!1,n.playsInline=!0,n.preload="auto",n.loop=!1,n.src=r,await new Promise((o,a)=>{const l=()=>{n.removeEventListener("loadeddata",l),n.removeEventListener("error",c),n.pause(),n.currentTime=0,o()},c=()=>{n.removeEventListener("loadeddata",l),n.removeEventListener("error",c),a(new Error("Failed to load video"))};n.addEventListener("loadeddata",l,{once:!0}),n.addEventListener("error",c,{once:!0}),n.load()}),{element:n,objectUrl:r}}async play(e,t){const s=e,r=t+this.trim.from/1e6;if(Math.abs(s.currentTime-r)>.1&&(s.currentTime=r),s.muted=!1,s.paused)try{await s.play()}catch{try{await s.play()}catch(o){console.warn("Failed to play video:",o)}}}pause(e){const t=e;t.pause(),t.muted=!0}async seek(e,t){const s=e,r=t+this.trim.from/1e6;return s.pause(),s.currentTime=r,new Promise(n=>{if(Math.abs(s.currentTime-t)<.01){n();return}const o=()=>{s.removeEventListener("seeked",o),n()};s.addEventListener("seeked",o,{once:!0}),setTimeout(()=>{s.removeEventListener("seeked",o),n()},500)})}syncPlayback(e,t,s){const r=e,n=(this.trim.to-this.trim.from)/1e6,o=s>=0&&s<n,a=s+this.trim.from/1e6;r.volume=this.volume,t&&o?r.paused?this.play(r,s).catch(console.warn):(r.muted&&(r.muted=!1),(r.ended||r.currentTime>=this.trim.to/1e6)&&(r.currentTime=a,r.play().catch(console.warn))):(r.paused||r.pause(),r.muted=!0,o&&Math.abs(r.currentTime-a)>.1&&(r.currentTime=a))}cleanupPlayback(e,t){const s=e;s.pause(),s.removeAttribute("src"),s.load(),t&&URL.revokeObjectURL(t)}async scaleToFit(e,t){await this.ready;const{width:s,height:r}=this.meta;if(s===0||r===0)return;const n=Math.min(e/s,t/r);this.width=s*n,this.height=r*n}async scaleToFill(e,t){await this.ready;const{width:s,height:r}=this.meta;if(s===0||r===0)return;const n=Math.max(e/s,t/r);this.width=s*n,this.height=r*n}centerInScene(e,t){this.left=(e-this.width)/2,this.top=(t-this.height)/2}}function yR(i,e,t,s){const r={duration:0,width:0,height:0,audioSampleRate:0,audioChanCount:0};if(i.video!=null&&e.length>0){r.width=i.video.codedWidth??0,r.height=i.video.codedHeight??0;const a=(Math.round(s/90)*90+360)%360;(a===90||a===270)&&([r.width,r.height]=[r.height,r.width])}i.audio!=null&&t.length>0&&(r.audioSampleRate=he.sampleRate,r.audioChanCount=he.channelCount);let n=0,o=0;if(e.length>0)for(let a=e.length-1;a>=0;a--){const l=e[a];if(!l.deleted){n=l.cts+l.duration;break}}if(t.length>0){const a=t.at(-1);o=a.cts+a.duration}return r.duration=Math.max(n,o),r}function bR(i,e,t,s,r){return{audioFrameFinder:r===0||i.audio==null||s.length===0?null:new SR(e,s,i.audio,{volume:r,targetSampleRate:he.sampleRate}),videoFrameFinder:i.video==null||t.length===0?null:new TR(e,t,i.video)}}async function Ex(i,e={}){let t=null;const s={video:null,audio:null};let r=[],n=[],o=[];const a={perspective:1,rotationRad:0,rotationDeg:0,scaleX:1,scaleY:1,translateX:0,translateY:0};let l=-1,c=-1;const h=await i.createReader();await _R(h,async d=>{t=d.info;const f=d.mp4boxFile.ftyp;o.push({start:f.start,size:f.size});const m=d.mp4boxFile.moov;o.push({start:m.start,size:m.size}),Object.assign(a,xR(t.videoTracks[0]?.matrix));let{videoDecoderConf:g,audioDecoderConf:p}=Jd(d.mp4boxFile,d.info);if(s.video=g??null,s.audio=p??null,g==null&&p==null&&ee.error("VideoClip no video and audio track"),p!=null){const{supported:_}=await AudioDecoder.isConfigSupported(p);_||ee.error(`VideoClip audio codec is not supported: ${p.codec}`)}if(g!=null){const{supported:_}=await VideoDecoder.isConfigSupported(g);_||ee.error(`VideoClip video codec is not supported: ${g.codec}`)}ee.info("mp4BoxFile moov ready",{...d.info,tracks:null,videoTracks:null,audioTracks:null},s)},(d,f,m)=>{if(f==="video"){l===-1&&(l=m[0].dts);for(const g of m)r.push(Ix(g,l,"video"))}else if(f==="audio"&&e.audio){c===-1&&(c=m[0].dts);for(const g of m)n.push(Ix(g,c,"audio"))}}),await h.close();const u=r.at(-1)??n.at(-1);if(t==null)throw Error("VideoClip stream is done, but not emit ready");if(u==null)throw Error("VideoClip stream not contain any sample");return tf(r),ee.info("mp4 stream parsed"),{videoSamples:r,audioSamples:n,decoderConf:s,headerBoxPos:o,parsedMatrix:a}}function Ix(i,e=0,t){let s=i.offset;const r=t==="video"&&i.is_sync?kR(i.data,i.description.type):-1;let n=i.size;return r>0&&(s+=r,n-=r),{...i,is_idr:r>=0,offset:s,size:n,cts:(i.cts-e)/i.timescale*1e6,dts:(i.dts-e)/i.timescale*1e6,duration:i.duration/i.timescale*1e6,timescale:1e6,data:t==="video"?null:i.data}}class TR{constructor(e,t,s){this.localFileReader=e,this.samples=t,this.conf=s}decoder=null;timestamp=0;curAborter={abort:!1,st:performance.now()};find=async e=>{(this.decoder==null||this.decoder.state==="closed"||e<=this.timestamp||e-this.timestamp>3e6)&&this.reset(e),this.curAborter.abort=!0,this.timestamp=e,this.curAborter={abort:!1,st:performance.now()};const t=await this.parseFrame(e,this.decoder,this.curAborter);return this.sleepCnt=0,t};lastVfDur=0;downgradeSoftDecode=!1;videoDecCursorIdx=0;videoFrames=[];outputFrameCnt=0;inputChunkCnt=0;sleepCnt=0;predecodeErr=!1;parseFrame=async(e,t,s)=>{if(t==null||t.state==="closed"||s.abort)return null;if(this.videoFrames.length>0){const r=this.videoFrames[0];return e<r.timestamp?null:(this.videoFrames.shift(),e>r.timestamp+(r.duration??0)?(r.close(),await this.parseFrame(e,t,s)):(!this.predecodeErr&&this.videoFrames.length<10&&this.startDecode(t).catch(n=>{throw this.predecodeErr=!0,this.reset(e),n}),r))}if(this.decoding||this.outputFrameCnt<this.inputChunkCnt&&t.decodeQueueSize>0){if(performance.now()-s.st>6e3)throw Error(`VideoClip.tick video timeout, ${JSON.stringify(this.getState())}`);this.sleepCnt+=1,await Zh(15)}else{if(this.videoDecCursorIdx>=this.samples.length)return null;try{await this.startDecode(t)}catch(r){throw this.reset(e),r}}return await this.parseFrame(e,t,s)};decoding=!1;startDecode=async e=>{if(this.decoding||e.decodeQueueSize>600)return;let t=this.videoDecCursorIdx+1;if(t>this.samples.length)return;this.decoding=!0;let s=!1;for(;t<this.samples.length;t++){const r=this.samples[t];if(!s&&!r.deleted&&(s=!0),r.is_idr)break}if(s){const r=this.samples.slice(this.videoDecCursorIdx,t);if(r[0]?.is_idr!==!0)ee.warn("First sample not idr frame");else{const n=performance.now(),o=await ER(r,this.localFileReader),a=performance.now()-n;if(a>1e3){const l=r[0],c=r.at(-1),h=c.offset+c.size-l.offset;ee.warn(`Read video samples time cost: ${Math.round(a)}ms, file chunk size: ${h}`)}if(e.state==="closed")return;this.lastVfDur=o[0]?.duration??0,RR(e,o,{onDecodingError:l=>{if(this.downgradeSoftDecode)throw l;this.outputFrameCnt===0&&(this.downgradeSoftDecode=!0,ee.warn("Downgrade to software decode"),this.reset())}}),this.inputChunkCnt+=o.length}}this.videoDecCursorIdx=t,this.decoding=!1};reset=e=>{if(this.decoding=!1,this.videoFrames.forEach(s=>s.close()),this.videoFrames=[],e==null||e===0)this.videoDecCursorIdx=0;else{let s=0;for(let r=0;r<this.samples.length;r++){const n=this.samples[r];if(n.is_idr&&(s=r),!(n.cts<e)){this.videoDecCursorIdx=s;break}}}this.inputChunkCnt=0,this.outputFrameCnt=0,this.decoder?.state!=="closed"&&this.decoder?.close();const t={...this.conf,...this.downgradeSoftDecode?{hardwareAcceleration:"prefer-software"}:{}};this.decoder=new VideoDecoder({output:s=>{if(this.outputFrameCnt+=1,s.timestamp===-1){s.close();return}let r=s;s.duration==null&&(r=new VideoFrame(s,{duration:this.lastVfDur}),s.close()),this.videoFrames.push(r)},error:s=>{if(s.message.includes("Codec reclaimed due to inactivity")){this.decoder=null,ee.warn(s.message);return}const r=`VideoFinder VideoDecoder err: ${s.message}, config: ${JSON.stringify(t)}, state: ${JSON.stringify(this.getState())}`;throw ee.error(r),Error(r)}}),this.decoder.configure(t)};getState=()=>({time:this.timestamp,decState:this.decoder?.state,decQSize:this.decoder?.decodeQueueSize,decCursorIdx:this.videoDecCursorIdx,sampleLen:this.samples.length,inputCnt:this.inputChunkCnt,outputCnt:this.outputFrameCnt,cacheFrameLen:this.videoFrames.length,softDecode:this.downgradeSoftDecode,clipIdCnt:Qd,sleepCnt:this.sleepCnt,memInfo:Rx()});destroy=()=>{this.decoder?.state!=="closed"&&this.decoder?.close(),this.decoder=null,this.curAborter.abort=!0,this.videoFrames.forEach(e=>e.close()),this.videoFrames=[],this.localFileReader.close()}}function wR(i,e){for(let t=0;t<e.length;t++){const s=e[t];if(i>=s.cts&&i<s.cts+s.duration)return t;if(s.cts>i)break}return 0}class SR{constructor(e,t,s,r){this.localFileReader=e,this.samples=t,this.conf=s,this.volume=r.volume,this.sampleRate=r.targetSampleRate}volume=1;sampleRate;setVolume(e){this.volume=e,this.reset()}decoder=null;curAborter={abort:!1,st:performance.now()};find=async e=>{const t=e<=this.timestamp||e-this.timestamp>1e5;(this.decoder==null||this.decoder.state==="closed"||t)&&this.reset(),t&&(this.timestamp=e,this.decCursorIdx=wR(e,this.samples)),this.curAborter.abort=!0;const s=e-this.timestamp;this.timestamp=e,this.curAborter={abort:!1,st:performance.now()};const r=await this.parseFrame(Math.ceil(s*(this.sampleRate/1e6)),this.decoder,this.curAborter);return this.sleepCnt=0,r};timestamp=0;decCursorIdx=0;pcmData={frameCnt:0,data:[]};sleepCnt=0;parseFrame=async(e,t=null,s)=>{if(t==null||s.abort||t.state==="closed"||e===0)return[];const r=this.pcmData.frameCnt-e;if(r>0)return r<he.sampleRate/10&&this.startDecode(t),Px(this.pcmData,e);if(t.decoding){if(performance.now()-s.st>3e3)throw s.abort=!0,Error(`VideoClip.tick audio timeout, ${JSON.stringify(this.getState())}`);this.sleepCnt+=1,await Zh(15)}else{if(this.decCursorIdx>=this.samples.length-1)return Px(this.pcmData,this.pcmData.frameCnt);this.startDecode(t)}return this.parseFrame(e,t,s)};startDecode=e=>{if(e.decodeQueueSize>10)return;const s=[];let r=this.decCursorIdx;for(;r<this.samples.length;){const n=this.samples[r];if(r+=1,!n.deleted&&(s.push(n),s.length>=10))break}this.decCursorIdx=r,e.decode(s.map(n=>new EncodedAudioChunk({type:"key",timestamp:n.cts,duration:n.duration,data:n.data})))};reset=()=>{this.timestamp=0,this.decCursorIdx=0,this.pcmData={frameCnt:0,data:[]},this.decoder?.close(),this.decoder=CR(this.conf,{resampleRate:he.sampleRate,volume:this.volume},e=>{this.pcmData.data.push(e),this.pcmData.frameCnt+=e[0].length})};getState=()=>({time:this.timestamp,decState:this.decoder?.state,decQSize:this.decoder?.decodeQueueSize,decCursorIdx:this.decCursorIdx,sampleLen:this.samples.length,pcmLen:this.pcmData.frameCnt,clipIdCnt:Qd,sleepCnt:this.sleepCnt,memInfo:Rx()});destroy=()=>{this.decoder=null,this.curAborter.abort=!0,this.pcmData={frameCnt:0,data:[]},this.localFileReader.close()}}function CR(i,e,t){let s=0,r=0;const n=h=>{if(r+=1,h.length!==0){if(e.volume!==1)for(const u of h)for(let d=0;d<u.length;d++)u[d]*=e.volume;h.length===1&&(h=[h[0],h[0]]),t(h)}},o=AR(n),a=e.resampleRate!==i.sampleRate;let l=new AudioDecoder({output:h=>{const u=kp(h);a?o(()=>aw(u,h.sampleRate,{rate:e.resampleRate,chanCount:h.numberOfChannels})):n(u),h.close()},error:h=>{h.message.includes("Codec reclaimed due to inactivity")||c("VideoClip AudioDecoder err",h)}});l.configure(i);function c(h,u){const d=`${h}: ${u.message}, state: ${JSON.stringify({qSize:l.decodeQueueSize,state:l.state,inputCnt:s,outputCnt:r})}`;throw ee.error(d),Error(d)}return{decode(h){s+=h.length;try{for(const u of h)l.decode(u)}catch(u){c("decode audio chunk error",u)}},close(){l.state!=="closed"&&l.close()},get decoding(){return s>r&&l.decodeQueueSize>0},get state(){return l.state},get decodeQueueSize(){return l.decodeQueueSize}}}function AR(i){const e=[];let t=0;function s(o,a){e[a]=o,r()}function r(){const o=e[t];o!=null&&(i(o),t+=1,r())}let n=0;return o=>{const a=n;n+=1,o().then(l=>s(l,a)).catch(l=>s(l,a))}}function Px(i,e){const t=[new Float32Array(e),new Float32Array(e)];let s=0,r=0;for(;r<i.data.length;){const[n,o]=i.data[r];if(s+n.length>e){const a=e-s;t[0].set(n.subarray(0,a),s),t[1].set(o.subarray(0,a),s),i.data[r][0]=n.subarray(a,n.length),i.data[r][1]=o.subarray(a,o.length);break}else t[0].set(n,s),t[1].set(o,s),s+=n.length,r++}return i.data=i.data.slice(r),i.frameCnt-=e,t}async function ER(i,e){const t=i[0],s=i.at(-1);if(s==null)return[];const r=s.offset+s.size-t.offset;if(r<3e7){const n=new Uint8Array(await e.read(r,{at:t.offset}));return i.map(o=>{const a=o.offset-t.offset;return new EncodedVideoChunk({type:o.is_sync?"key":"delta",timestamp:o.cts,duration:o.duration,data:n.subarray(a,a+o.size)})})}return await Promise.all(i.map(async n=>new EncodedVideoChunk({type:n.is_sync?"key":"delta",timestamp:n.cts,duration:n.duration,data:await e.read(n.size,{at:n.offset})})))}function IR(i,e){if(i.length===0)return[];let t=0,s=0,r=-1;for(let l=0;l<i.length;l++){const c=i[l];if(r===-1&&e<c.cts&&(r=l-1),c.is_idr)if(r===-1)t=l;else{s=l;break}}const n=i[r];if(n==null)throw Error("Not found video sample by time");const o=i.slice(0,s===0?i.length:s).map(l=>({...l}));for(let l=t;l<o.length;l++){const c=o[l];e<c.cts&&(c.deleted=!0,c.cts=-1)}tf(o);const a=i.slice(n.is_idr?r:t).map(l=>({...l,cts:l.cts-e}));for(const l of a)l.cts<0&&(l.deleted=!0,l.cts=-1);return tf(a),[o,a]}function PR(i,e){if(i.length===0)return[];let t=-1;for(let n=0;n<i.length;n++){const o=i[n];if(!(e>o.cts)){t=n;break}}if(t===-1)throw Error("Not found audio sample by time");const s=i.slice(0,t).map(n=>({...n})),r=i.slice(t).map(n=>({...n,cts:n.cts-e}));return[s,r]}function RR(i,e,t){if(i.state==="configured"){for(let s=0;s<e.length;s++)i.decode(e[s]);i.flush().catch(s=>{if(!(s instanceof Error))throw s;if(s.message.includes("Decoding error")&&t.onDecodingError!=null){t.onDecodingError(s);return}if(!s.message.includes("Aborted due to close"))throw s})}}function kR(i,e){if(e!=="avc1"&&e!=="hvc1")return 0;const t=new DataView(i.buffer);for(let s=0;s<i.byteLength-4;){if(e==="avc1"){const r=t.getUint8(s+4)&31;if(r===5||r===7||r===8)return s}else if(e==="hvc1"){const r=t.getUint8(s+4)>>1&63;if(r===19||r===20||r===32||r===33||r===34)return s}s+=t.getUint32(s)+4}return-1}function tf(i){let e=0,t=null;for(const s of i)if(!s.deleted){if(s.is_sync&&(e+=1),e>=2)break;(t==null||s.cts<t.cts)&&(t=s)}t!=null&&t.cts<2e5&&(t.duration+=t.cts,t.cts=0)}function Rx(){try{const i=performance.memory;return{jsHeapSizeLimit:i.jsHeapSizeLimit,totalJSHeapSize:i.totalJSHeapSize,usedJSHeapSize:i.usedJSHeapSize,percentUsed:(i.usedJSHeapSize/i.jsHeapSizeLimit).toFixed(3),percentTotal:(i.totalJSHeapSize/i.jsHeapSizeLimit).toFixed(3)}}catch{return{}}}class xt extends Kt{type="Text";ready;_meta={duration:1/0,width:0,height:0};get meta(){return{...this._meta}}get width(){return this._width}set width(e){this.width!==e&&(this._width=e,this.refreshText(),this.emit("propsChange",{width:e}))}get height(){return this._height}set height(e){this.height!==e&&(this._height=e,this.refreshText(),this.emit("propsChange",{height:e}))}_lastContentWidth=0;_lastContentHeight=0;_text="";get text(){return this._text}set text(e){this._text!==e&&(this._text=e,this.originalOpts&&this.textStyle&&this.refreshText())}get style(){return{fontSize:this.originalOpts.fontSize,fontFamily:this.originalOpts.fontFamily,fontWeight:this.originalOpts.fontWeight,fontStyle:this.originalOpts.fontStyle,fill:this.originalOpts.fill,align:this.originalOpts.align,stroke:this.originalOpts.stroke?typeof this.originalOpts.stroke=="object"?{color:this.originalOpts.stroke.color,width:this.originalOpts.stroke.width,join:this.originalOpts.stroke.join,cap:this.originalOpts.stroke.cap,miterLimit:this.originalOpts.stroke.miterLimit}:{color:this.originalOpts.stroke,width:this.originalOpts.strokeWidth??0}:void 0,dropShadow:this.originalOpts.dropShadow?{color:this.originalOpts.dropShadow.color??"#000000",alpha:this.originalOpts.dropShadow.alpha??.5,blur:this.originalOpts.dropShadow.blur??4,distance:this.originalOpts.dropShadow.distance??0,angle:this.originalOpts.dropShadow.angle??0}:void 0,wordWrap:this.originalOpts.wordWrap,wordWrapWidth:this.originalOpts.wordWrapWidth,lineHeight:this.originalOpts.lineHeight,letterSpacing:this.originalOpts.letterSpacing,textCase:this.originalOpts.textCase,textDecoration:this.originalOpts.textDecoration}}set style(e){this.updateStyle(e)}get textAlign(){return this.originalOpts.align||this.originalOpts.textAlign||"left"}set textAlign(e){this.updateStyle({align:e})}get verticalAlign(){return this.originalOpts.verticalAlign||this.originalOpts.textDecoration||"top"}set verticalAlign(e){["underline","overline","strikethrough","line-through"].includes(e)?(this.updateStyle({textDecoration:e==="strikethrough"?"line-through":e}),this.originalOpts.verticalAlign=e):this.updateStyle({verticalAlign:e})}get textCase(){return this.originalOpts.textCase||"none"}set textCase(e){this.updateStyle({textCase:e})}pixiText=null;textStyle;renderTexture=null;externalRenderer=null;pixiApp=null;originalOpts;id=`clip_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;effects=[];constructor(e,t={},s){super(),this.originalOpts={...t},this.text=e,this.externalRenderer=s??null;const r=this.createStyleFromOpts(t),n=new Ye(r);this.textStyle=n,this.ready=(async()=>{await this.refreshText();const o={...this._meta};return ee.info("TextClip ready:",o),o})()}setRenderer(e){this.externalRenderer=e}async getRenderer(){if(this.externalRenderer!=null)return this.externalRenderer;if(this.pixiApp?.renderer==null)throw new Error("TextClip: Failed to create renderer. Please provide a renderer via constructor or setRenderer() method.");return this.pixiApp.renderer}async getTexture(){return this.pixiText==null||this.renderTexture==null?null:((await this.getRenderer()).render({container:this.pixiText,target:this.renderTexture}),this.renderTexture)}async tick(e){if(await this.ready,this.pixiText==null||this.renderTexture==null)throw new Error("TextClip not initialized");if(this.renderTexture.width<=0||this.renderTexture.height<=0)throw new Error(`Invalid RenderTexture dimensions: ${this.renderTexture.width}x${this.renderTexture.height}`);(await this.getRenderer()).render({container:this.pixiText,target:this.renderTexture});const s=this.renderTexture.source?.resource?.source;let r;if(s instanceof HTMLCanvasElement)r=await createImageBitmap(s);else if(s instanceof OffscreenCanvas)r=await createImageBitmap(s);else{const a=(await this.getRenderer()).extract.canvas(this.renderTexture);if(a instanceof HTMLCanvasElement||a instanceof OffscreenCanvas)r=await createImageBitmap(a);else{const l=this.renderTexture.width,c=this.renderTexture.height;throw new OffscreenCanvas(l,c).getContext("2d")==null?new Error("Failed to create 2d context for fallback rendering"):new Error("Unable to extract canvas from render texture")}}return{video:r,state:"success"}}async split(e){await this.ready;const t=await this.clone(),s=await this.clone();return[t,s]}addEffect(e){this.effects.push(e)}editEffect(e,t){const s=this.effects.find(r=>r.id===e);s&&Object.assign(s,t)}removeEffect(e){const t=this.effects.findIndex(s=>s.id===e);t!==-1&&this.effects.splice(t,1)}async clone(){await this.ready;const e=this.textStyle,t=this.originalOpts||{},s=o=>{if(o!=null){if(typeof o=="number")return o;if(o instanceof ue)return o.toNumber()}},r={fontSize:t.fontSize??e.fontSize,fontFamily:t.fontFamily??(Array.isArray(e.fontFamily)?e.fontFamily[0]:typeof e.fontFamily=="string"?e.fontFamily:"Roboto"),fontWeight:t.fontWeight??e.fontWeight,fontStyle:t.fontStyle??e.fontStyle,align:t.align??(e.align==="justify"?"left":e.align),textCase:t.textCase,textDecoration:t.textDecoration};if(t.fill&&typeof t.fill=="object"&&"type"in t.fill&&t.fill.type==="gradient")r.fill=t.fill;else{const o=s(e.fill);r.fill=o??16777215}if(t.stroke&&typeof t.stroke=="object"&&"color"in t.stroke)r.stroke=t.stroke;else{const o=s(e.stroke);o!==void 0&&(r.stroke=o),r.strokeWidth=t.strokeWidth??e.strokeThickness??0}if(t.dropShadow)r.dropShadow=t.dropShadow;else if(e.dropShadow){const o=e.dropShadow,a=s(o.color);a!==void 0&&(r.dropShadow={color:a,alpha:o.alpha,blur:o.blur,angle:o.angle,distance:o.distance})}if(t.wordWrap!==void 0?(r.wordWrap=t.wordWrap,r.wordWrapWidth=t.wordWrapWidth):e.wordWrap&&(r.wordWrap=e.wordWrap,r.wordWrapWidth=e.wordWrapWidth),t.lineHeight!==void 0)r.lineHeight=t.lineHeight;else if(e.lineHeight!==void 0){const o=r.fontSize??e.fontSize??40;r.lineHeight=e.lineHeight/o}t.letterSpacing!==void 0?r.letterSpacing=t.letterSpacing:e.letterSpacing!==void 0&&(r.letterSpacing=e.letterSpacing);const n=new xt(this.text,r);return await n.ready,this.copyStateTo(n),n.id=this.id,n.effects=[...this.effects],n}async updateStyle(e){this.originalOpts={...this.originalOpts,...e};const t=this.createStyleFromOpts(this.originalOpts),s=new Ye(t);this.textStyle=s,await this.refreshText()}async refreshText(){const e=this.textStyle;let t=this.text;const s=this.originalOpts.textCase;s==="uppercase"?t=t.toUpperCase():s==="lowercase"?t=t.toLowerCase():s==="title"&&(t=t.replace(/\w\S*/g,p=>p.charAt(0).toUpperCase()+p.substring(1).toLowerCase())),this.pixiText?(this.pixiText.text=t,this.pixiText.style=e,this.pixiText.children.forEach(p=>{p instanceof _e&&p.destroy()}),this.pixiText.removeChildren()):this.pixiText=new OI({text:t,style:e});const r=this.originalOpts.textDecoration||this.originalOpts.verticalAlign;if(r&&r!=="none"&&["underline","overline","strikethrough","line-through"].includes(r)){const p=r==="strikethrough"?"line-through":r,_=Xe.measureText(t,e),x=e.fontSize??40,v=Math.max(1,x/12);let y=16777215;typeof e.fill=="number"?y=e.fill:e.fill&&typeof e.fill=="object"&&"fill"in e.fill&&(y=16777215);const T=new _e,S=e.lineHeight??_.lineHeight;for(let w=0;w<_.lines.length;w++){const E=_.lineWidths[w];let P=0;e.align==="center"?P=(_.maxLineWidth-E)/2:e.align==="right"&&(P=_.maxLineWidth-E);const C=w*S;let A=0;p==="underline"?A=S:p==="line-through"?A=S/2:p==="overline"&&(A=0);const B=C+A;T.rect(P,B,E,v),T.fill(y)}this.pixiText.addChild(T)}const n=this.pixiText.getLocalBounds(),o=Math.ceil(n.width||this.pixiText.width||1),a=Math.ceil(n.height||this.pixiText.height||1);let l=o;e.wordWrap&&e.wordWrapWidth>0&&(l=Math.max(l,e.wordWrapWidth));const c=a,h=this.width===0||Math.abs(this.width-this._lastContentWidth)<.1,u=this.height===0||Math.abs(this.height-this._lastContentHeight)<.1,d=h?l:Math.max(l,this.width||0),f=u?c:Math.max(c,this.height||0);this._lastContentWidth=l,this._lastContentHeight=c;const m=this.textAlign;m==="center"?this.pixiText.x=(d-o)/2:m==="right"?this.pixiText.x=d-o:this.pixiText.x=0;const g=this.originalOpts.verticalAlign||"top";g==="center"?this.pixiText.y=(f-a)/2:g==="bottom"?this.pixiText.y=f-a:this.pixiText.y=0,this.renderTexture&&this.renderTexture.destroy(),this.renderTexture=Ge.create({width:d,height:f}),this._meta.width=d,this._meta.height=f,this._width=d,this._height=f,this.duration===0&&this._meta.duration!==1/0&&(this.duration=this._meta.duration,this.display.to=this.display.from+this.duration)}createStyleFromOpts(e){const t=e.fontSize??40,s=e.lineHeight??1,r={fontSize:t,fontFamily:e.fontFamily??"Roboto",fontWeight:e.fontWeight??"normal",fontStyle:e.fontStyle??"normal",align:e.align??"left",wordWrap:e.wordWrap??!1,wordWrapWidth:e.wordWrapWidth??100,lineHeight:t*s,letterSpacing:e.letterSpacing??0};if(e.fill&&typeof e.fill=="object"&&e.fill.type==="gradient"){const n=new ct(e.fill.x0,e.fill.y0,e.fill.x1,e.fill.y1);e.fill.colors.forEach(({ratio:o,color:a})=>{const l=typeof a=="number"?a:Te(a)??16777215;n.addColorStop(o,l)}),r.fill={fill:n}}else{const{color:n,alpha:o}=_i(e.fill);r.fill=n,o<1&&(r.fillAlpha=o)}if(e.stroke&&typeof e.stroke=="object"&&"color"in e.stroke){const n=Te(e.stroke.color);n!==void 0&&(r.stroke={color:n,width:e.stroke.width},e.stroke.join&&(r.stroke.join=e.stroke.join),e.stroke.cap&&(r.stroke.cap=e.stroke.cap),e.stroke.miterLimit&&(r.stroke.miterLimit=e.stroke.miterLimit))}else{const n=Te(e.stroke),o=e.strokeWidth??0;n!==void 0&&o>0?r.stroke={color:n,width:o}:e.strokeWidth&&e.strokeWidth>0&&(r.stroke={color:0,width:e.strokeWidth})}if(e.dropShadow){const n=Te(e.dropShadow.color);n!==void 0&&(r.dropShadow={color:n,alpha:e.dropShadow.alpha??.5,blur:e.dropShadow.blur??4,angle:e.dropShadow.angle??Math.PI/6,distance:e.dropShadow.distance??2})}return r}destroy(){if(!this.destroyed){ee.info("TextClip destroy");try{this.pixiText!=null&&this.pixiText.destroyed!==!0&&this.pixiText.destroy({children:!0})}catch{}finally{this.pixiText=null}try{this.renderTexture!=null&&this.renderTexture.destroyed!==!0&&this.renderTexture.destroy(!0)}catch{}finally{this.renderTexture=null}if(this.externalRenderer=null,this.pixiApp!=null)try{const e=this.pixiApp;e.destroyed!==!0&&e.renderer!=null&&this.pixiApp.destroy(!0,{children:!0,texture:!0})}catch{}finally{this.pixiApp=null}super.destroy()}}toJSON(e=!1){const t=super.toJSON(e),s={};return this.originalOpts.fontSize!==void 0&&(s.fontSize=this.originalOpts.fontSize),this.originalOpts.fontFamily!==void 0&&(s.fontFamily=this.originalOpts.fontFamily),this.originalOpts.fontWeight!==void 0&&(s.fontWeight=this.originalOpts.fontWeight),this.originalOpts.fontStyle!==void 0&&(s.fontStyle=this.originalOpts.fontStyle),this.originalOpts.fill!==void 0&&(s.color=this.originalOpts.fill),this.originalOpts.align!==void 0&&(s.align=this.originalOpts.align),this.originalOpts.wordWrap!==void 0&&(s.wordWrap=this.originalOpts.wordWrap),this.originalOpts.wordWrapWidth!==void 0&&(s.wordWrapWidth=this.originalOpts.wordWrapWidth),this.originalOpts.lineHeight!==void 0&&(s.lineHeight=this.originalOpts.lineHeight),this.originalOpts.letterSpacing!==void 0&&(s.letterSpacing=this.originalOpts.letterSpacing),this.originalOpts.stroke&&(typeof this.originalOpts.stroke=="object"?s.stroke={color:this.originalOpts.stroke.color,width:this.originalOpts.stroke.width,join:this.originalOpts.stroke.join,cap:this.originalOpts.stroke.cap,miterLimit:this.originalOpts.stroke.miterLimit}:s.stroke={color:this.originalOpts.stroke,width:this.originalOpts.strokeWidth??0}),this.originalOpts.dropShadow&&(s.shadow={color:this.originalOpts.dropShadow.color??"#000000",alpha:this.originalOpts.dropShadow.alpha??.5,blur:this.originalOpts.dropShadow.blur??4,distance:this.originalOpts.dropShadow.distance??0,angle:this.originalOpts.dropShadow.angle??0}),{...t,type:"Text",text:this.text,style:s,id:this.id,effects:this.effects}}static async fromObject(e){if(e.type!=="Text")throw new Error(`Expected Text, got ${e.type}`);const t=e.text||"",s=e.style||{},r={};s.fontSize!==void 0&&(r.fontSize=s.fontSize),s.fontFamily!==void 0&&(r.fontFamily=s.fontFamily),s.fontWeight!==void 0&&(r.fontWeight=s.fontWeight),s.fontStyle!==void 0&&(r.fontStyle=s.fontStyle),s.color!==void 0&&(r.fill=s.color),s.align!==void 0&&(r.align=s.align),s.wordWrap!==void 0&&(r.wordWrap=s.wordWrap),s.wordWrapWidth!==void 0&&(r.wordWrapWidth=s.wordWrapWidth),s.lineHeight!==void 0&&(r.lineHeight=s.lineHeight),s.letterSpacing!==void 0&&(r.letterSpacing=s.letterSpacing),s.stroke&&(s.stroke.join||s.stroke.cap||s.stroke.miterLimit!==void 0?r.stroke={color:s.stroke.color,width:s.stroke.width,join:s.stroke.join,cap:s.stroke.cap,miterLimit:s.stroke.miterLimit}:(r.stroke=s.stroke.color,r.strokeWidth=s.stroke.width)),s.shadow&&(r.dropShadow={color:s.shadow.color,alpha:s.shadow.alpha,blur:s.shadow.blur,distance:s.shadow.distance,angle:s.shadow.angle});const n=new xt(t,r);return n.left=e.left,n.top=e.top,n.width=e.width,n.height=e.height,n.angle=e.angle,n.display.from=e.display.from,n.display.to=e.display.to,n.duration=e.duration,n.playbackRate=e.playbackRate,n.zIndex=e.zIndex,n.opacity=e.opacity,n.flip=e.flip,e.animation&&n.setAnimation(e.animation.keyFrames,e.animation.opts),e.id&&(n.id=e.id),e.effects&&(n.effects=e.effects),await n.ready,n}getVisibleHandles(){return["mr","mb","br","rot"]}}class ut extends Kt{type="Effect";ready;_meta={duration:5e6,width:0,height:0};get meta(){return{...this._meta}}id=`clip_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;effect;constructor(e){super(),this.effect={id:`eff_${Date.now()}`,key:e,name:e},this.ready=Promise.resolve(this._meta),this.duration=this._meta.duration}async clone(){const e=new ut(this.effect.key);return this.copyStateTo(e),e.id=this.id,e}async tick(e){return{video:void 0,state:"success"}}async split(e){const t=await this.clone(),s=await this.clone();return[t,s]}toJSON(e=!1){return{...super.toJSON(e),type:"Effect",effect:this.effect,id:this.id,effects:this.effects}}static async fromObject(e){if(e.type!=="Effect")throw new Error(`Expected Effect, got ${e.type}`);const t=new ut(e.effect.key);return t.effect=e.effect,t.left=e.left,t.top=e.top,t.width=e.width,t.height=e.height,t.angle=e.angle,t.display.from=e.display.from,t.display.to=e.display.to,t.duration=e.duration,t.playbackRate=e.playbackRate,t.zIndex=e.zIndex,t.opacity=e.opacity,t.flip=e.flip,e.animation&&t.setAnimation(e.animation.keyFrames,e.animation.opts),e.id&&(t.id=e.id),await t.ready,t}}class mn extends Kt{type="Placeholder";meta={width:0,height:0,duration:0};constructor(e,t={},s="Placeholder"){super(),this.type=s,this.src=e,this.meta={width:t.width||1280,height:t.height||720,duration:t.duration||5e6},this.width=this.meta.width,this.height=this.meta.height,this.duration=this.meta.duration,this.trim.to=this.duration,this.display.to=this.display.from+this.duration,this.ready=Promise.resolve(this.meta)}placeholderFrame=null;async tick(e){if(!this.placeholderFrame){const t=document.createElement("canvas");t.width=this.meta.width,t.height=this.meta.height;const s=t.getContext("2d");s&&(s.fillStyle="#1e1e1e",s.fillRect(0,0,t.width,t.height),s.fillStyle="#ffffff",s.font=`${Math.floor(t.height/10)}px sans-serif`,s.textAlign="center",s.textBaseline="middle",s.fillText("Loading...",t.width/2,t.height/2),s.strokeStyle="#333333",s.lineWidth=10,s.strokeRect(0,0,t.width,t.height)),this.placeholderFrame=await createImageBitmap(t)}return{video:this.placeholderFrame,state:e>=this.duration?"done":"success",audio:[]}}async clone(){const e=new mn(this.src,this.meta);return this.copyStateTo(e),e.id=this.id,e}async split(e){const t=await this.clone(),s=await this.clone();return t.trim.to=e+this.trim.from,s.trim.from=e+this.trim.from,t.duration=t.trim.to-t.trim.from,s.duration=s.trim.to-s.trim.from,t.display.to=t.display.from+t.duration,s.display.from=t.display.to,s.display.to=s.display.from+s.duration,[t,s]}}class xi extends Kt{type="Transition";ready;_meta={duration:2e6,width:0,height:0};get meta(){return{...this._meta}}id=`clip_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;transitionEffect;fromClipId=null;toClipId=null;constructor(e){super(),this.transitionEffect={id:`trans_${Date.now()}`,key:e,name:e},this.ready=Promise.resolve(this._meta),this.duration=this._meta.duration}async clone(){const e=new xi(this.transitionEffect.key);return this.copyStateTo(e),e.fromClipId=this.fromClipId,e.toClipId=this.toClipId,e}async tick(e){return{video:void 0,state:"success"}}async split(e){const t=await this.clone(),s=await this.clone();return[t,s]}toJSON(e=!1){return{...super.toJSON(e),type:"Transition",transitionEffect:this.transitionEffect,fromClipId:this.fromClipId,toClipId:this.toClipId,id:this.id,effects:this.effects}}static async fromObject(e){if(e.type!=="Transition")throw new Error(`Expected Transition, got ${e.type}`);const t=new xi(e.transitionEffect.key);return t.transitionEffect=e.transitionEffect,t.fromClipId=e.fromClipId||null,t.toClipId=e.toClipId||null,t.left=e.left,t.top=e.top,t.width=e.width,t.height=e.height,t.angle=e.angle,t.display.from=e.display.from,t.display.to=e.display.to,t.duration=e.duration,t.playbackRate=e.playbackRate,t.zIndex=e.zIndex,t.opacity=e.opacity,t.flip=e.flip,e.animation&&t.setAnimation(e.animation.keyFrames,e.animation.opts),e.id&&(t.id=e.id),await t.ready,t}}function kx(i,e){let t=!1;async function s(){const r=i.getReader();for(;!t;){const{value:n,done:o}=await r.read();if(o){e.onDone();return}await e.onChunk(n)}r.releaseLock(),await i.cancel()}return s().catch(console.error),()=>{t=!0}}function Mx(i,e,t){let s=0,r=0;const n=i.boxes;let o=!1;const a=()=>{if(!o)if(n.find(m=>m.type==="moof")!=null)o=!0;else return null;if(r>=n.length)return null;const d=new oi.DataStream;let f=r;try{for(;f<n.length;)n[f].write(d),delete n[f],f+=1}catch(m){const g=n[f];throw m instanceof Error&&g!=null?Error(`${m.message} | deltaBuf( boxType: ${g.type}, boxSize: ${g.size}, boxDataLen: ${g.data?.length??-1})`):m}return MR(i),r=n.length,new Uint8Array(d.buffer)};let l=!1,c=!1,h=null;return{stream:new ReadableStream({start(d){s=self.setInterval(()=>{const f=a();f!=null&&!c&&d.enqueue(f)},e),h=f=>{if(clearInterval(s),i.flush(),f!=null){d.error(f);return}const m=a();m!=null&&!c&&d.enqueue(m),c||d.close()},l&&h()},cancel(){c=!0,clearInterval(s),t?.()}}),stop:d=>{l||(l=!0,h?.(d))}}}function MR(i){if(i.moov!=null){for(var e=0;e<i.moov.traks.length;e++)i.moov.traks[e].samples=[];i.mdats=[],i.moofs=[]}}class Fx{readable;writable;inputBufOffset=0;isStreamCancelled=!1;constructor(){const e=oi.createFile();this.readable=new ReadableStream({start:t=>this.initMP4Box(e,t),cancel:()=>{this.isStreamCancelled=!0,e.stop()}},{highWaterMark:50}),this.writable=new WritableStream({write:async t=>{if(this.isStreamCancelled)throw new Error("Stream cancelled");const s=t.buffer;s.fileStart=this.inputBufOffset,this.inputBufOffset+=s.byteLength,e.appendBuffer(s)},close:()=>{e.flush(),e.stop(),e.onFlush?.()},abort:t=>{FR.error("SampleTransform writable aborted:",t),e.stop()}})}initMP4Box(e,t){e.onReady=r=>{[r.videoTracks[0],r.audioTracks[0]].forEach(n=>{n&&e.setExtractionOptions(n.id,n.video?"video":"audio",{nbSamples:100})}),t.enqueue({chunkType:"ready",data:{info:r,file:e}}),e.start()};const s={};e.onSamples=(r,n,o)=>{const a=o.map(l=>({...l}));t.enqueue({chunkType:"samples",data:{id:r,type:n,samples:a}}),s[r]=(s[r]??0)+o.length,e.releaseUsedSamples(r,s[r])},e.onFlush=()=>{t.close()},e.onError=r=>{t.error(new Error(`mp4box error: ${r}`))}}}const FR={error:(...i)=>console.error("[SampleTransform]",...i)};function UR(i){let e=0;const t=i.boxes,s=[];let r=0;async function n(){const m=f(t,e);e=t.length,s.forEach(({track:g,id:p})=>{const _=g.samples.at(-1);_!=null&&(r=Math.max(r,_.cts+_.duration)),i.releaseUsedSamples(p,g.samples.length),g.samples=[]}),i.mdats=[],i.moofs=[],m!=null&&await h?.write(m)}let o=[];function a(){if(o.length>0)return!0;const m=t.findIndex(g=>g.type==="moov");if(m===-1)return!1;if(o=t.slice(0,m+1),e=m+1,s.length===0)for(let g=1;;g+=1){const p=i.getTrackById(g);if(p==null)break;s.push({track:p,id:g})}return!0}let l=0;const c=Yh();let h=null;const u=(async()=>{h=await c.createWriter(),l=self.setInterval(()=>{a()&&n()},100)})();let d=!1;return async()=>{if(d)throw Error("File exported");if(d=!0,await u,clearInterval(l),!a()||h==null)return null;i.flush(),await n(),await h?.close();const m=o.find(_=>_.type==="moov");if(m==null)return null;m.mvhd.duration=r;const g=Yh(),p=f(o,0);return await Ei(g,p.slice()),await Ei(g,c,{overwrite:!1}),await g.stream()};function f(m,g){if(g>=m.length)return null;const p=new oi.DataStream;for(let _=g;_<m.length;_++)m[_]!==null&&(m[_].write(p),delete m[_]);return new Uint8Array(p.buffer).slice()}}function BR(i){const e=new ArrayBuffer(i.byteLength);i.copyTo(e);const t=i.timestamp;return{duration:i.duration??0,dts:t,cts:t,is_sync:i.type==="key",data:e}}async function Ux(i){const e=oi.createFile(),t=UR(e);await OR(i,e);const s=await t();if(s==null)throw Error("Can not generate file from streams");return s}async function OR(i,e){let t=0,s=0,r=0,n=0,o=0,a=0,l=null,c=null;for(const h of i){let u=null,d=null,f=null,m=null;if(await new Promise(async g=>{kx(h.pipeThrough(new Fx),{onDone:g,onChunk:async({chunkType:p,data:_})=>{if(p==="ready"){const{videoTrackConf:x,audioTrackConf:v}=Jd(_.file,_.info);t===0&&x!=null&&(t=e.addTrack(x)),n===0&&v!=null&&(n=e.addTrack(v))}else if(p==="samples"){const{type:x,samples:v}=_,y=x==="video"?t:n,T=x==="video"?s:o,S=x==="video"?r:a;v.forEach(E=>{let P,C;x==="video"?(u===null&&(u=E.dts,d=E.cts),P=E.dts-u,C=E.cts-(d??0)):(f===null&&(f=E.dts,m=E.cts),P=E.dts-f,C=E.cts-(m??0)),e.addSample(y,new Uint8Array(E.data),{duration:E.duration,dts:P+T,cts:C+S,is_sync:E.is_sync})});const w=v.at(-1);if(w==null)return;x==="video"?l=w:x==="audio"&&(c=w)}}})}),l!=null&&u!==null&&d!==null){const g=l.dts-u+l.duration,p=l.cts-d+l.duration;s+=g,r+=p}if(c!=null&&l!=null){const g=c.timescale/l.timescale;o=Math.round(s*g),a=Math.round(r*g)}}}async function DR(i){return await Ux([i])}function GR(i){let e=[];const t=new AudioDecoder({output:s=>{e.push(s)},error:ee.error});return t.configure(i),{decode:async s=>{s.forEach(n=>{t.decode(new EncodedAudioChunk({type:n.is_sync?"key":"delta",timestamp:1e6*n.cts/n.timescale,duration:1e6*n.duration/n.timescale,data:n.data}))}),await t.flush();const r=e;return e=[],r},close:()=>{t.close()}}}function zR(i,e){const t={codec:i.codec,sampleRate:i.sampleRate,numberOfChannels:i.numberOfChannels},s=new AudioEncoder({output:o=>{e(BR(o))},error:o=>{ee.error("AudioEncoder error:",o,", config:",t)}});s.configure(t);let r=null;function n(o,a){return new AudioData({timestamp:a,numberOfChannels:i.numberOfChannels,numberOfFrames:o.length/i.numberOfChannels,sampleRate:i.sampleRate,format:"f32-planar",data:new Float32Array(o)})}return{encode:async(o,a)=>{r!=null&&s.encode(n(r.data,r.ts)),r={data:o,ts:a}},stop:async()=>{r!=null&&(LR(r.data,i.numberOfChannels,i.sampleRate),s.encode(n(r.data,r.ts)),r=null),await s.flush(),s.close()}}}function LR(i,e,t){const s=i.length-1,r=Math.min(t/2,s);for(let n=0;n<r;n++)for(let o=1;o<=e;o++)i[Math.floor(s/o)-n]*=n/r}function NR(i,e){ee.info("mixinMP4AndAudio, opts:",{volume:e.volume,loop:e.loop});const t=oi.createFile(),{stream:s,stop:r}=Mx(t,500);let n=null,o=null,a=[],l=0,c=0,h=0,u=!0,d=he.sampleRate;kx(i.pipeThrough(new Fx),{onDone:async()=>{await o?.stop(),n?.close(),r()},onChunk:async({chunkType:p,data:_})=>{if(p==="ready"){const{videoTrackConf:x,audioTrackConf:v,audioDecoderConf:y}=Jd(_.file,_.info);l===0&&x!=null&&(l=t.addTrack(x));const T=v??{timescale:1e6,samplerate:d,channel_count:he.channelCount,hdlr:"soun",name:"SoundHandler",type:"mp4a"};c===0&&(c=t.addTrack(T),d=v?.samplerate??d,u=v!=null);const S=new AudioContext({sampleRate:d});a=qh(await S.decodeAudioData(await new Response(e.stream).arrayBuffer())),y!=null&&(n=GR(y)),o=zR(y??{codec:T.type==="mp4a"?he.codec:T.type,numberOfChannels:T.channel_count,sampleRate:T.samplerate},w=>t.addSample(c,new Uint8Array(w.data),w))}else if(p==="samples"){const{id:x,type:v,samples:y}=_;if(v==="video"){y.forEach(T=>t.addSample(x,new Uint8Array(T.data),T)),u||await m(y);return}v==="audio"&&await g(y)}}});function f(p){const _=a.map(x=>e.loop?Kh(x,h,h+p):x.slice(h,h+p));if(h+=p,e.volume!==1)for(const x of _)for(let v=0;v<x.length;v++)x[v]*=e.volume;return _}async function m(p){const _=p[0],x=p[p.length-1],v=Math.floor((x.cts+x.duration-_.cts)/_.timescale*d),y=Mp([f(v)]);y.length!==0&&o?.encode(y,_.cts/_.timescale*1e6)}async function g(p){if(n==null)return;const _=(await n.decode(p)).map(kp),x=Rp(_),v=f(x[0].length),y=p[0];o?.encode(Mp([x,v]),y.cts/y.timescale*1e6)}return s}const HR=`
in vec2 aPosition;
out vec2 vTextureCoord;

uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;

vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;

    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`,WR=`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;
uniform float rotationCount; 

void main(void)
{
    vec2 center = vec2(0.35, 0.35);
    vec2 uvs = vTextureCoord.xy - center;
    
    // Rotacin en funcin de la cantidad de vueltas
    float angle = uTime * rotationCount * 6.28318530718;
    
    float cosAngle = cos(angle);
    float sinAngle = sin(angle);
    mat2 rotation = mat2(cosAngle, -sinAngle, sinAngle, cosAngle);
    
    uvs = rotation * uvs;
    uvs += center;
    
    if (uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0) {
        discard;
    }
    
    vec4 fg = texture2D(uTexture, uvs);
    gl_FragColor = fg;
}
`,VR={uTime:{value:0,type:"f32"},rotationCount:{value:4,type:"f32"}},$R=`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;

void main(void)
{
    vec2 uvs = vTextureCoord.xy;

    vec4 fg = texture2D(uTexture, vTextureCoord);

    fg.r = uvs.y + sin(uTime);

    gl_FragColor = fg;

}
`,XR={uTime:{value:0,type:"f32"}},YR=`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;
uniform vec3 bubbleColor;
uniform float bubbleCount;

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float softCircle(vec2 uv, vec2 c, float r, float g) {
    float d = distance(uv, c);
    float base = 1.0 - smoothstep(r * 0.9, r, d);
    float halo = (1.0 - smoothstep(r, r * (1.0 + g), d));
    return base + halo * 0.5;
}

vec2 bubblePos(float id) {
    float fx = rand(vec2(id, 1.234));
    float fy = rand(vec2(id, 9.345));
    return vec2(fx, fy);
}

float bubbleRadius(float id) {
    return mix(0.015, 0.025, rand(vec2(id, 44.123)));
}

void main(void)
{
    vec2 uvs = vTextureCoord.xy;
    vec4 fg = texture2D(uTexture, uvs);

    float bubbles = 0.0;

    for(float i = 0.0; i < 200.0; i++) {

        if(i >= bubbleCount) break;
        float spawnSpeed = 8.0; 
        float spawnTime = (i / bubbleCount) / spawnSpeed;
        float t = uTime - spawnTime;

        if(t < 0.0) continue;

        float grow = pow(clamp(t, 0.0, 1.0), 0.35);

        vec2 pos = bubblePos(i);
        vec2 bubbleCenter = pos;

        float baseR = bubbleRadius(i);

        float r = baseR * grow;

        float phase = rand(vec2(i, 999.0)) * 6.28318;
        float pulse = sin(t * 1.6 + phase) * 0.5 + 0.5;
        float opacity = mix(0.2, 1.0, pulse);

        bubbles += softCircle(uvs, bubbleCenter, r, 0.8) * opacity;
    }

    fg.rgb += bubbleColor * bubbles;
    gl_FragColor = fg;
}
`,qR={uTime:{value:0,type:"f32"},bubbleColor:{value:[1,.85,.4],type:"vec3<f32>"},bubbleCount:{value:150,type:"f32"}},KR=`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;      
uniform float maxIntensity; 

void main(void)
{
    vec2 uvs = vTextureCoord.xy;
    vec4 color = texture2D(uTexture, uvs);

    float intensity = (sin(uTime) * 0.5 + 0.5) * maxIntensity;

    vec3 sepiaColor;
    sepiaColor.r = dot(color.rgb, vec3(0.393, 0.769, 0.189));
    sepiaColor.g = dot(color.rgb, vec3(0.349, 0.686, 0.168));
    sepiaColor.b = dot(color.rgb, vec3(0.272, 0.534, 0.131));

    color.rgb = mix(color.rgb, sepiaColor, intensity);

    gl_FragColor = color;
}
`,jR={uTime:{value:0,type:"f32"},maxIntensity:{value:1,type:"f32"}},ZR=`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform vec3 colorStart;  
uniform vec3 colorEnd;    
uniform int direction;  

void main(void)
{
    vec2 uvs = vTextureCoord.xy;
    vec4 fg = texture2D(uTexture, uvs);

    float t = 0.0;
    if(direction == 0) {
        t = uvs.x; 
    } else if(direction == 1) {
        t = uvs.y;
    } else {
        t = (uvs.x + uvs.y) * 0.5;
    }

    vec3 gradientColor = mix(colorStart, colorEnd, t);

    fg.rgb = fg.rgb * gradientColor; 

    gl_FragColor = fg;
}
`,JR={colorStart:{value:[1,0,0],type:"vec3<f32>"},colorEnd:{value:[0,0,1],type:"vec3<f32>"},direction:{value:0,type:"i32"}},QR=`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float intensity;
uniform int direction;   

vec3 rainbow(float t) {
    float r = 0.5 + 0.5 * sin(6.28318 * (t + 0.0));
    float g = 0.5 + 0.5 * sin(6.28318 * (t + 0.33));
    float b = 0.5 + 0.5 * sin(6.28318 * (t + 0.66));
    return vec3(r, g, b);
}

void main(void)
{
    vec2 uvs = vTextureCoord.xy;
    vec4 fg = texture2D(uTexture, uvs);

    float t = 0.0;
    if(direction == 0) {
        t = uvs.x; 
    } else if(direction == 1) {
        t = uvs.y; 
    } else {
        t = (uvs.x + uvs.y) * 0.5; 
    }

    vec3 rainbowColor = rainbow(t);

    fg.rgb = fg.rgb * rainbowColor*intensity;

    gl_FragColor = fg;
}
`,ek={intensity:{value:1,type:"f32"},direction:{value:0,type:"i32"}},tk=`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;     
uniform float intensity;  
uniform float sliceCount;   
uniform float rgbShift;     

float rand(float n) { return fract(sin(n) * 43758.5453123); }
float rand2(vec2 p) { return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453); }

void main(void)
{
    vec2 uv = vTextureCoord.xy;

    float sliceId = floor(uv.y * sliceCount);
    float sliceShift = (rand(sliceId + uTime * 10.0) - 0.5) * 0.2 * intensity;

    uv.x += sliceShift;

    float rShift = rgbShift * intensity;
    float gShift = -rgbShift * 0.5 * intensity;
    float bShift = rgbShift * 0.75 * intensity;

    vec3 col;
    col.r = texture2D(uTexture, uv + vec2(rShift, 0.0)).r;
    col.g = texture2D(uTexture, uv + vec2(gShift, 0.0)).g;
    col.b = texture2D(uTexture, uv + vec2(bShift, 0.0)).b;

    float noise = rand2(vec2(uTime * 50.0, uv.y * 100.0));
    float noiseIntensity = noise * 0.15 * intensity;

    col += noiseIntensity;

    gl_FragColor = vec4(col, 1.0);
}
`,ik={uTime:{value:0,type:"f32"},intensity:{value:.5,type:"f32"},sliceCount:{value:12,type:"f32"},rgbShift:{value:.01,type:"f32"}},Bx=`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float pixelSize;
uniform float uTime;
uniform float jitterStrength;

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

void main(void)
{
    vec2 uv = vTextureCoord.xy;

    vec2 pixelUV = floor(uv / pixelSize) * pixelSize;

    float n1 = hash(pixelUV + uTime * 1.5);
    float n2 = hash(pixelUV * 2.3 + uTime * 1.7);

    vec2 jitter = (vec2(n1, n2) - 0.5) * jitterStrength * pixelSize;

    vec2 finalUV = pixelUV + jitter;

    finalUV = clamp(finalUV, 0.0, 1.0);
    vec4 color = texture2D(uTexture, finalUV);

    gl_FragColor = color;
}
`,Ox={pixelSize:{value:.02,type:"f32"},uTime:{value:0,type:"f32"},jitterStrength:{value:.8,type:"f32"}},sf={...{rotationMovement:{label:"Rotation Movement",fragment:WR,uniforms:VR},redGradient:{label:"Red Gradient",fragment:$R,uniforms:XR},bubbleSparkles:{label:"Bubble Sparkles",fragment:YR,uniforms:qR},sepia:{label:"Sepia",fragment:KR,uniforms:jR},uvGradient:{label:"UV Gradient",fragment:ZR,uniforms:JR},rainbow:{label:"Rainbow",fragment:QR,uniforms:ek},glitch:{label:"Glitch",fragment:tk,uniforms:ik},pixelate:{label:"Pixelate",fragment:Bx,uniforms:Ox},rgbGlitch:{label:"RGB Glitch",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float glitchStrength;
uniform float glitchSpeed;

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
}

float rand2(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

void main(void)
{
    vec2 uv = vTextureCoord;

    vec4 base = texture2D(uTexture, uv);
    if (base.a < 0.01) {
        gl_FragColor = base;
        return;
    }

    float lineNoise =
        hash(vec2(floor(uv.y * 300.0), uTime * glitchSpeed));

    float rOffset =
        (hash(vec2(uTime, 1.0)) - 0.5) * glitchStrength;

    float gOffset =
        (hash(vec2(uTime, 2.0)) - 0.5) * glitchStrength * 0.5;

    float bOffset =
        (hash(vec2(uTime, 3.0)) - 0.5) * glitchStrength;

    float rShift = rOffset * lineNoise;
    float gShift = gOffset * lineNoise;
    float bShift = bOffset * lineNoise;

    vec2 uvR = clamp(uv + vec2(rShift, 0.0), 0.0, 1.0);
    vec2 uvG = clamp(uv + vec2(gShift, 0.0), 0.0, 1.0);
    vec2 uvB = clamp(uv + vec2(bShift, 0.0), 0.0, 1.0);

    vec3 col;
    col.r = texture2D(uTexture, uvR).r;
    col.g = texture2D(uTexture, uvG).g;
    col.b = texture2D(uTexture, uvB).b;

    float noise =
        (rand2(vec2(uTime * 50.0, uv.y * 100.0)) - 0.5) * 0.15;

    col += noise;

    gl_FragColor = vec4(col, base.a);
}
`,uniforms:{uTime:{value:0,type:"f32"},glitchStrength:{value:.02,type:"f32"},glitchSpeed:{value:2,type:"f32"}}},rgbShift:{label:"RGB Shift",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float shiftAmount;
uniform float angle;
uniform float uTime;
uniform float wobbleAmount;
uniform float wobbleSpeed;

void main(void)
{
    vec2 uv = vTextureCoord;

    vec4 base = texture2D(uTexture, uv);

    if (base.a < 0.01) {
        gl_FragColor = base;
        return;
    }

    vec2 dir = vec2(cos(angle), sin(angle));
    float wobble = sin(uTime * wobbleSpeed) * wobbleAmount;

    vec2 rUV = uv + dir * shiftAmount + vec2(wobble, 0.0);
    vec2 gUV = uv;
    vec2 bUV = uv - dir * shiftAmount - vec2(wobble, 0.0);

    rUV = clamp(rUV, 0.0, 1.0);
    gUV = clamp(gUV, 0.0, 1.0);
    bUV = clamp(bUV, 0.0, 1.0);

    float r = texture2D(uTexture, rUV).r;
    float g = texture2D(uTexture, gUV).g;
    float b = texture2D(uTexture, bUV).b;

    gl_FragColor = vec4(r, g, b, base.a);
}
`,uniforms:{shiftAmount:{value:.01,type:"f32"},angle:{value:0,type:"f32"},uTime:{value:0,type:"f32"},wobbleAmount:{value:.003,type:"f32"},wobbleSpeed:{value:20,type:"f32"}}},halftone:{label:"Halftone",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float dotSize;       
uniform float intensity;     
uniform float angle;         
uniform float uTime;        
uniform float vibrateStrength;

float luminance(vec3 c) {
    return dot(c, vec3(0.299, 0.587, 0.114));
}

void main(void)
{
    vec2 uv = vTextureCoord.xy;

    float ca = cos(angle);
    float sa = sin(angle);
    mat2 rot = mat2(ca, -sa, sa, ca);
    vec2 rotatedUV = rot * (uv - 0.5) + 0.5;
    vec2 grid = rotatedUV / dotSize;
    vec2 cell = floor(grid) + 0.5;

    vec2 cellCenter = cell * dotSize;

    float jitter = sin(uTime * 10.0 + cell.x * 12.989 + cell.y * 78.233) * 0.5;
    float dist = distance(rotatedUV, cellCenter + jitter * vibrateStrength * dotSize);
    vec4 texColor = texture2D(uTexture, uv);
    float lum = luminance(texColor.rgb);
    float radius = (1.0 - lum) * dotSize * 0.5;
    float mask = smoothstep(radius, radius * 0.8, dist);

    vec3 halftone = texColor.rgb * mask;
    texColor.rgb = mix(texColor.rgb, halftone, intensity);

    gl_FragColor = texColor;
}
`,uniforms:{dotSize:{value:.03,type:"f32"},intensity:{value:1,type:"f32"},angle:{value:0,type:"f32"},uTime:{value:0,type:"f32"},vibrateStrength:{value:.2,type:"f32"}}},sinewave:{label:"Sinewave",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;     
uniform float amplitude; 
uniform float frequency;  
uniform float speed;    
uniform int direction;    

void main(void)
{
    vec2 uv = vTextureCoord.xy;

    vec2 offset = vec2(0.0);

    if(direction == 0) {
        offset.y = sin((uv.x + uTime * speed) * frequency * 6.2831853) * amplitude;
    } else {
        offset.x = sin((uv.y + uTime * speed) * frequency * 6.2831853) * amplitude;
    }

    vec4 color = texture2D(uTexture, uv + offset);
    gl_FragColor = color;
}
`,uniforms:{uTime:{value:0,type:"f32"},amplitude:{value:.02,type:"f32"},frequency:{value:3,type:"f32"},speed:{value:.5,type:"f32"},direction:{value:0,type:"i32"}}},shine:{label:"Shine",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;          // tiempo para animacin
uniform vec3 shineColor;      // color de los rayos
uniform float rayWidth;       // grosor del rayo
uniform float rayCount;       // cantidad de rayos
uniform float rotationSpeed;  // velocidad de rotacin

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    vec2 center = vec2(0.3, 0.35);

    vec2 dir = uv - center;

    float angle = atan(dir.y, dir.x);

    angle += uTime * rotationSpeed;

    float normAngle = fract(angle / 6.28318530718); // 2

    float rays = sin(normAngle * rayCount * 6.28318530718);

    float intensity = smoothstep(0.0, rayWidth, rays) - smoothstep(rayWidth, rayWidth*1.5, rays);

    vec4 color = texture2D(uTexture, uv);

    color.rgb += shineColor * intensity;

    gl_FragColor = color;
}
`,uniforms:{uTime:{value:0,type:"f32"},shineColor:{value:[1,1,1],type:"vec3<f32>"},rayWidth:{value:.05,type:"f32"},rayCount:{value:12,type:"f32"},rotationSpeed:{value:.5,type:"f32"}}},blink:{label:"Blink",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;    
uniform float blinkSpeed;  
uniform float minIntensity; 
uniform float maxIntensity; 

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    vec4 color = texture2D(uTexture, uv);
    float t = sin(uTime * blinkSpeed * 6.2831853) * 0.5 + 0.5;
    float intensity = mix(minIntensity, maxIntensity, t);

    color.rgb *= intensity;

    gl_FragColor = color;
}
`,uniforms:{uTime:{value:0,type:"f32"},blinkSpeed:{value:2,type:"f32"},minIntensity:{value:.3,type:"f32"},maxIntensity:{value:1,type:"f32"}}},spring:{label:"Spring",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;         
uniform float frequency;      
uniform float damping;      
uniform float strength;      

void main(void)
{
    vec2 uv = vTextureCoord.xy;

    float spring = exp(-damping * uTime) *
                   sin(uTime * frequency * 6.2831853);

    uv.x += spring * strength;
    uv.y += spring * strength * 0.5; 

    vec4 color = texture2D(uTexture, uv);

    gl_FragColor = color;
}
`,uniforms:{uTime:{value:0,type:"f32"},frequency:{value:2,type:"f32"},damping:{value:.8,type:"f32"},strength:{value:.04,type:"f32"}}},duotone:{label:"Duotone",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform vec3 colorA;     
uniform vec3 colorB;    
uniform float intensity; 

void main(void)
{
    vec2 uv = vTextureCoord.xy;

    vec4 tex = texture2D(uTexture, uv);
    float gray = dot(tex.rgb, vec3(0.299, 0.587, 0.114));
    vec3 duo = mix(colorA, colorB, gray);
    tex.rgb = mix(tex.rgb, duo, intensity);
    gl_FragColor = tex;
}
`,uniforms:{colorA:{value:[.1,.1,.5],type:"vec3<f32>"},colorB:{value:[1,.8,.2],type:"vec3<f32>"},intensity:{value:1,type:"f32"}}},tritone:{label:"Tritone",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform vec3 colorShadow;   
uniform vec3 colorMid;       
uniform vec3 colorHighlight;

uniform float intensity;    

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    vec4 tex = texture2D(uTexture, uv);
    float gray = dot(tex.rgb, vec3(0.299, 0.587, 0.114));


    vec3 duoA = mix(colorShadow, colorMid, smoothstep(0.0, 0.5, gray));
    vec3 duoB = mix(colorMid, colorHighlight, smoothstep(0.5, 1.0, gray));
    vec3 tritone = mix(duoA, duoB, smoothstep(0.33, 0.66, gray));
    tex.rgb = mix(tex.rgb, tritone, intensity);

    gl_FragColor = tex;
}
`,uniforms:{colorShadow:{value:[.1,0,.3],type:"vec3<f32>"},colorMid:{value:[.2,.8,.8],type:"vec3<f32>"},colorHighlight:{value:[1,.9,.4],type:"vec3<f32>"},intensity:{value:1,type:"f32"}}},hueShift:{label:"Hue Shift",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;    
uniform float amount;    

vec3 hueShift(vec3 color, float angle) {
    float cosA = cos(angle);
    float sinA = sin(angle);
    mat3 rot = mat3(
        0.299 + 0.701 * cosA + 0.168 * sinA,
        0.587 - 0.587 * cosA + 0.330 * sinA,
        0.114 - 0.114 * cosA - 0.497 * sinA,

        0.299 - 0.299 * cosA - 0.328 * sinA,
        0.587 + 0.413 * cosA + 0.035 * sinA,
        0.114 - 0.114 * cosA + 0.292 * sinA,

        0.299 - 0.300 * cosA + 1.250 * sinA,
        0.587 - 0.588 * cosA - 1.050 * sinA,
        0.114 + 0.886 * cosA - 0.203 * sinA
    );

    return color * rot;
}

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    vec4 tex = texture2D(uTexture, uv);

    vec3 shifted = hueShift(tex.rgb, uTime*2.5);

    tex.rgb = mix(tex.rgb, shifted, amount);

    gl_FragColor = tex;
}
`,uniforms:{uTime:{value:0,type:"f32"},amount:{value:1,type:"f32"}}},warpTransition:{label:"Warp Transition",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;       
uniform float uStrength;  
uniform float swirl;      

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    vec2 center = vec2(0.5, 0.5);
    vec2 dir = uv - center;
    float dist = length(dir);
    float warpAmount = pow(dist, 2.0) * uStrength * uTime;
    float angle = swirl * uTime * 6.283185; 

    float s = sin(angle * dist);
    float c = cos(angle * dist);

    mat2 rot = mat2(c, -s, s, c);
    vec2 warpedUV = center + rot * dir * (1.0 - warpAmount);
    vec4 color = texture2D(uTexture, warpedUV);

    gl_FragColor = color;
}
`,uniforms:{uTime:{value:0,type:"f32"},uStrength:{value:.8,type:"f32"},swirl:{value:.3,type:"f32"}}},slitScan:{label:"Slit Scan",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;      
uniform float uStrength;  
uniform int direction;     

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    float offset;
    if(direction == 0) {
        offset = (uv.y - 0.5) * uStrength * uTime;
        uv.x += offset;
    } else {
        offset = (uv.x - 0.5) * uStrength * uTime;
        uv.y += offset;
    }

    vec4 color = texture2D(uTexture, uv);

    gl_FragColor = color;
}
`,uniforms:{uTime:{value:0,type:"f32"},uStrength:{value:.2,type:"f32"},direction:{value:0,type:"i32"}}},slitScanGlitch:{label:"Slit Scan Glitch",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uStrength;
uniform float uNoise;
uniform int direction;

float hash(float n) {
    return fract(sin(n) * 43758.5453);
}

float hash(vec2 p) {
    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);
}

void main(void)
{
    vec2 uv = vTextureCoord.xy;

    float offset;
    if(direction == 0) {
        offset = (uv.y - 0.5) * uStrength * uTime;
        uv.x += offset;
    } else {
        offset = (uv.x - 0.5) * uStrength * uTime;
        uv.y += offset;
    }

    float jitter = (hash(floor(uv * 100.0) + uTime) - 0.5) * uNoise;
    if(direction == 0) {
        uv.x += jitter;
    } else {
        uv.y += jitter;
    }

    float rOffset = (hash(uv + 1.0) - 0.5) * uNoise * 0.5;
    float gOffset = (hash(uv + 2.0) - 0.5) * uNoise * 0.5;
    float bOffset = (hash(uv + 3.0) - 0.5) * uNoise * 0.5;

    vec4 texR = texture2D(uTexture, uv + vec2(rOffset, 0.0));
    vec4 texG = texture2D(uTexture, uv + vec2(gOffset, 0.0));
    vec4 texB = texture2D(uTexture, uv + vec2(bOffset, 0.0));

    gl_FragColor = vec4(texR.r, texG.g, texB.b, 1.0);
}
`,uniforms:{uTime:{value:0,type:"f32"},uStrength:{value:.2,type:"f32"},uNoise:{value:.05,type:"f32"},direction:{value:0,type:"i32"}}},pixelateTransition:{label:"Pixelate Transition",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;       
uniform float maxPixelSize; 

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    float pixelSize = maxPixelSize * uTime;
    pixelSize = max(pixelSize, 0.001);
    vec2 pixelUV = floor(uv / pixelSize) * pixelSize;

    vec4 color = texture2D(uTexture, pixelUV);

    gl_FragColor = color;
}
`,uniforms:{uTime:{value:0,type:"f32"},maxPixelSize:{value:.05,type:"f32"}}},focusTransition:{label:"Focus Transition",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;       
uniform float maxBlur;    

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    vec4 color = vec4(0.0);
    float blur = maxBlur * (1.0 - uTime);

    if(blur < 0.001) {
        color = texture2D(uTexture, uv);
    } else {
        vec2 offsets[9];
        offsets[0] = vec2(-blur, -blur);
        offsets[1] = vec2(0.0, -blur);
        offsets[2] = vec2(blur, -blur);
        offsets[3] = vec2(-blur, 0.0);
        offsets[4] = vec2(0.0, 0.0);
        offsets[5] = vec2(blur, 0.0);
        offsets[6] = vec2(-blur, blur);
        offsets[7] = vec2(0.0, blur);
        offsets[8] = vec2(blur, blur);

        for(int i = 0; i < 9; i++) {
            color += texture2D(uTexture, uv + offsets[i]);
        }

        color /= 9.0;
    }

    gl_FragColor = color;
}
`,uniforms:{uTime:{value:0,type:"f32"},maxBlur:{value:.01,type:"f32"}}},invert:{label:"Invert",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float amount;

void main(void)
{
    vec2 uv = vTextureCoord;
    vec4 tex = texture2D(uTexture, uv);

    vec3 inverted = vec3(1.0) - tex.rgb;

    float strength = amount * tex.a;

    tex.rgb = mix(tex.rgb, inverted, strength);

    gl_FragColor = tex;
}
`,uniforms:{amount:{value:1,type:"f32"}}},grayscale:{label:"Grayscale",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float amount; 

void main(void)
{
    vec2 uv = vTextureCoord.xy;
    vec4 tex = texture2D(uTexture, uv);
    float gray = dot(tex.rgb, vec3(0.299, 0.587, 0.114));
    vec3 grayscale = vec3(gray);

    tex.rgb = mix(tex.rgb, grayscale, amount);

    gl_FragColor = tex;
}
`,uniforms:{amount:{value:1,type:"f32"}}},vignette:{label:"Vignette",fragment:`
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uIntensity;  
uniform float uSoftness;  

void main(void)
{
    vec2 uv = vTextureCoord.xy;

    vec2 centered = uv - vec2(0.5);
    float dist = length(centered);
    float vignette = smoothstep(0.5, 0.5 - uSoftness, dist);
    vec4 color = texture(uTexture, uv);
    color.rgb *= 1.0 - (vignette * uIntensity);

    gl_FragColor = color;
}
`,uniforms:{uIntensity:{value:.5,type:"f32"},uSoftness:{value:.2,type:"f32"}}},chromatic:{label:"Chromatic",fragment:`
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uIntensity; 
uniform vec2 uDirection;  

void main(void)
{
    vec2 uv = vTextureCoord;
    vec2 offset = uDirection * uIntensity;
    float r = texture(uTexture, uv + offset).r;
    float g = texture(uTexture, uv).g;
    float b = texture(uTexture, uv - offset).b;
    vec4 color = vec4(r, g, b, 1.0);

    gl_FragColor = color;
}
`,uniforms:{uIntensity:{value:.005,type:"f32"},uDirection:{value:[1,0],type:"vec2<f32>"}}},swirlMovement:{label:"Swirl Movement",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;
uniform float rotationCount;

uniform float swirlStrength; 
uniform float swirlRadius;   
uniform float rainbowIntensity;

vec3 hsv2rgb(vec3 c)
{
    vec3 rgb = clamp( abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0,
                      0.0,
                      1.0 );
    return c.z * mix(vec3(1.0), rgb, c.y);
}

float flamePattern(float dist, float angle, float time) {
    return pow(sin(dist * 10.0 - time * 5.0 + angle * 5.0) * 0.5 + 0.5, 2.0);
}

void main(void)
{
    vec2 center = vec2(0.3, 0.45);
    vec2 uvs = vTextureCoord - center;

    // fade del rainbow (0 cuando uTime >= 0.75)
    float fadeRainbow = clamp(1.0 - smoothstep(0.7, 0.75, uTime), 0.0, 1.0);

    // fade de swirl, wave y blur (disminuye entre 0.8 y 1.0)
    float fadeMotion = clamp(1.0 - smoothstep(0.8, 1.0, uTime), 0.0, 1.0);

    // ngulo total acumulado para mantener la direccin del giro
    float angleTotal = uTime * rotationCount * 6.2831853; 

    float cosA = cos(angleTotal);
    float sinA = sin(angleTotal);
    mat2 rotation = mat2(cosA, -sinA, sinA, cosA);
    vec2 rotatedUV = rotation * uvs + center;

    float dist = distance(rotatedUV, center);
    float d = clamp(dist / swirlRadius, 0.0, 1.0);

    // swirl disminuye suavemente sin invertir la direccin
    float swirlAngle = swirlStrength * d * d * 6.2831853 * fadeMotion;
    float cosS = cos(swirlAngle);
    float sinS = sin(swirlAngle);

    vec2 dir = rotatedUV - center;
    rotatedUV = vec2(
        dir.x * cosS - dir.y * sinS,
        dir.x * sinS + dir.y * cosS
    ) + center;

    float wave = sin(dist * 12.0 - uTime * 4.0) * 0.015 * fadeMotion; 
    rotatedUV += wave * normalize(dir);

    // blur de la textura
    vec4 color = vec4(0.0);
    float blurAmount = (0.004 + rotationCount * 0.001) * fadeMotion; 

    for (int i = -3; i <= 3; i++) {
        float offset = float(i) * blurAmount;
        vec2 blurUV = rotatedUV + vec2(offset * cosA, offset * sinA);
        color += texture2D(uTexture, blurUV);
    }
    color /= 7.0;

    // rainbow
    float rainbowScale = 0.05;
    float ang = atan(dir.y, dir.x);
    float hue = (ang / 6.2831853) + 0.5 + dist * rainbowScale;
    hue += uTime * 0.2 + rotationCount * 0.05;

    vec3 rainbow = hsv2rgb(vec3(hue, 0.35, 1.0));
    color.rgb = mix(color.rgb, rainbow, rainbowIntensity * fadeRainbow);

    // Flame disminuye con fadeMotion
    float flame = flamePattern(dist, ang, uTime) * fadeMotion;
    vec3 flameColor = vec3(1.0, 0.5, 0.0) * flame;
    flameColor = mix(flameColor, vec3(1.0,1.0,0.2), flame * 0.5);
    color.rgb += flameColor * 0.3;

    if (rotatedUV.x < 0.0 || rotatedUV.x > 1.0 || rotatedUV.y < 0.0 || rotatedUV.y > 1.0) {
        discard;
    }

    gl_FragColor = color;
}

`,uniforms:{uTime:{value:0,type:"f32"},rotationCount:{value:4,type:"f32"},swirlStrength:{value:.9,type:"f32"},swirlRadius:{value:1,type:"f32"},rainbowIntensity:{value:.25,type:"f32"}}},heartSparkles:{label:"Heart Sparkles",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;
uniform vec3 heartColor;
uniform float heartCount;

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float heartShape(vec2 p) {
    p = (p - 0.5) * 2.0;   
    p.y = -p.y;           
    p.y += 0.25;          
    float x = p.x;
    float y = p.y;
    float val = pow(x*x + y*y - 1.0, 3.0) - x*x * y*y*y;
    return smoothstep(0.0, 0.02, -val);
}

vec2 heartPos(float id) {
    float fx = rand(vec2(id, 1.234)) * 0.85 - 0.025; 
    float fy = rand(vec2(id, 1.345)) * 0.85 + 0.025;
    return vec2(fx, fy);
}

float heartSize(float id) {
    return mix(0.02, 0.05, rand(vec2(id, 44.123))); 
}

void main() {
    vec2 uv = vTextureCoord.xy;
    vec4 base = texture2D(uTexture, uv);

    float hearts = 0.0;

    for(float i = 0.0; i < 200.0; i++) {
        if(i >= heartCount) break;

        vec2 pos = heartPos(i);
        float size = heartSize(i);

        float vibX = (rand(vec2(i, uTime)) - 0.5) * 0.02;
        float vibY = (rand(vec2(i+1.0, uTime)) - 0.5) * 0.02;

        vec2 heartUV = (uv - (pos + vec2(vibX, vibY))) / size + 0.5;

        float h = heartShape(heartUV);

        float pulse = sin(uTime * 4.0 + i) * 0.2 + 1.0;
        h *= pulse;

        hearts += h;
    }

    base.rgb += heartColor * hearts;
    gl_FragColor = base;
}
`,uniforms:{uTime:{value:0,type:"f32"},heartColor:{value:[1,.2,.5],type:"vec3<f32>"},heartCount:{value:150,type:"f32"}}},butterflySparkles:{label:"Butterfly Sparkles",fragment:`
in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;
uniform vec3 butterflyColor;
uniform float butterflyCount;

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float wing(vec2 p) {
    float d = pow(p.x, 2.0) + pow(p.y * 1.2, 2.0);
    return smoothstep(0.3, 0.0, d);
}

float butterflyShape(vec2 uv) {
    vec2 p = (uv - 0.5) * 2.0;

    float body = smoothstep(0.12, 0.05, abs(p.x)) 
               * smoothstep(0.4, 0.0, abs(p.y));

    float wL = wing(vec2(p.x * 1.2 + 0.6, p.y));
    float wR = wing(vec2(p.x * 1.2 - 0.6, p.y));

    return clamp(wL + wR + body, 0.0, 1.0);
}
vec2 butterflyPos(float id) {
    float fx = rand(vec2(id, 1.234)) * 0.85 - 0.025;
    float fy = rand(vec2(id, 1.345)) * 0.85 + 0.025;
    return vec2(fx, fy);
}

float butterflySize(float id) {
    return mix(0.03, 0.08, rand(vec2(id, 44.123)));
}

void main() {
    vec2 uv = vTextureCoord.xy;
    vec4 base = texture2D(uTexture, uv);

    float butterflies = 0.0;

    for(float i = 0.0; i < 200.0; i++) {
        if(i >= butterflyCount) break;

        vec2 pos = butterflyPos(i);
        float size = butterflySize(i);

        float vibX = (rand(vec2(i, uTime)) - 0.5) * 0.02;
        float vibY = (rand(vec2(i+1.0, uTime)) - 0.5) * 0.02;

        vec2 bUV = (uv - (pos + vec2(vibX, vibY))) / size + 0.5;

        float b = butterflyShape(bUV);

        float pulse = sin(uTime * 3.0 + i) * 0.25 + 1.0;
        b *= pulse;

        butterflies += b;
    }

    base.rgb += butterflyColor * butterflies;
    gl_FragColor = base;
}
`,uniforms:{uTime:{value:0,type:"f32"},butterflyColor:{value:[.5,.6,1],type:"vec3<f32>"},butterflyCount:{value:120,type:"f32"}}},distort:{label:"Distort",fragment:`
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float amplitude; 
uniform float speed;     
uniform float uTime;  

void main() {
    vec2 p = vTextureCoord;
    vec2 center = vec2(0.28, 0.45);

    vec2 dir = p - center;
    float dist = length(dir);

    vec2 offset = vec2(0.0);

    if (dist <= uTime) {
        offset = dir * sin(dist * amplitude - uTime * speed);
    }

    gl_FragColor = texture2D(uTexture, p + offset);
}
`,uniforms:{uTime:{value:0,type:"f32"},amplitude:{value:30,type:"f32"},speed:{value:30,type:"f32"}}},perspectiveSingle:{label:"Perspective Single",fragment:`
precision mediump float;

uniform sampler2D uTexture;
uniform float persp;      
uniform float unzoom;     
uniform float reflection; 
uniform float floating;   
uniform float uTime;

varying vec2 vTextureCoord;

bool inBounds(vec2 p) {
    return all(greaterThanEqual(p, vec2(0.0))) &&
           all(lessThanEqual(p, vec2(1.0)));
}

vec2 project(vec2 p) {
    return p * vec2(1.0, -1.2) + vec2(0.0, -floating / 100.0);
}

vec2 xskew(vec2 p, float persp, float center) {
    float x = mix(p.x, 1.0 - p.x, center);

    return (
        (
            vec2(
                x,
                (p.y - 0.5*(1.0-persp) * x) /
                (1.0+(persp-1.0)*x)
            )
            - vec2(0.5 - abs(center - 0.5), 0.0)
        )
        * vec2(
            0.5 / abs(center - 0.5) * (center < 0.5 ? 1.0 : -1.0),
            1.0
        )
        + vec2(center < 0.5 ? 0.0 : 1.0, 0.0)
    );
}

void main() {
    vec2 p = vTextureCoord;

    float uz = unzoom * sin(uTime * 0.5);
    p = -uz * 0.5 + (1.0 + uz) * p;

    vec2 warped = xskew(p, persp, 0.0);

    vec4 baseColor = vec4(0.0);

    if (inBounds(warped)) {
        baseColor = texture2D(uTexture, warped);
    }

    vec2 proj = project(warped);
    if (inBounds(proj)) {
        vec4 refl = texture2D(uTexture, proj);
        refl.rgb *= reflection * (1.0 - proj.y);
        baseColor += refl;
    }

    gl_FragColor = baseColor;
}

`,uniforms:{uTime:{value:0,type:"f32"},persp:{value:.7,type:"f32"},unzoom:{value:.3,type:"f32"},reflection:{value:0,type:"f32"},floating:{value:3,type:"f32"}}},distortSpin:{label:"Distort Spin",fragment:`
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;        
uniform float radius;       
uniform float spinPower;    
uniform float speed;       

void main() {
    vec2 uv = vTextureCoord;
    vec2 center = vec2(0.28, 0.45);

    vec2 pos = uv - center;

    float dist = length(pos);

    if (dist < radius) {
        float percent = (radius - dist) / radius;

        float theta = percent * percent * spinPower * sin(uTime * speed);

        float s = sin(theta);
        float c = cos(theta);

        pos = vec2(
            pos.x * c - pos.y * s,
            pos.x * s + pos.y * c
        );
    }

    uv = pos + center;

    gl_FragColor = texture2D(uTexture, uv);
}
`,uniforms:{uTime:{value:0,type:"f32"},radius:{value:1,type:"f32"},spinPower:{value:18,type:"f32"},speed:{value:4,type:"f32"}}},distortGrid:{label:"Distort Grid",fragment:`
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;

uniform float speed;        
uniform float intensity;    
uniform int endx;
uniform int endy;

#define PI 3.14159265358979323

float rand(vec2 v) {
    return fract(sin(dot(v.xy , vec2(12.9898,78.233))) * 43758.5453);
}

vec2 rotate2d(vec2 v, float a) {
    mat2 rm = mat2(cos(a), -sin(a),
                   sin(a),  cos(a));
    return rm * v;
}

void main() {
    vec2 uv = vTextureCoord;

    vec2 p = uv - 0.5;

    float t = sin(uTime * speed) * 0.5 + 0.5;

    float warp = 1.0 + intensity * abs(t - 0.5);

    vec2 rp = p * warp;
    float tx = float(endx) + 0.5;
    float ty = float(endy) + 0.5;

    vec2 shifted = mix(vec2(0.5, 0.5), vec2(tx, ty), t*t);

    vec2 tiled = fract(rp + shifted);

    vec2 cell = floor(rp + shifted);

    bool isEnd = int(cell.x) == endx && int(cell.y) == endy;

    if (!isEnd) {
        float rnd = rand(cell);
        float angle = float(int(rnd * 4.0)) * 0.5 * PI;
        tiled = vec2(0.5) + rotate2d(tiled - vec2(0.5), angle);
    }
    gl_FragColor = texture2D(uTexture, tiled);
}
`,uniforms:{uTime:{value:0,type:"f32"},speed:{value:2,type:"f32"},intensity:{value:1.5,type:"f32"},endx:{value:2,type:"i32"},endy:{value:-1,type:"i32"}}},distortRip:{label:"Distort Rip",fragment:`
precision highp float;

in vec2 vTextureCoord;
uniform sampler2D uTexture;
uniform float uTime;

uniform float intensity;    
uniform float speed;        
uniform int slices;         
uniform float randomness;   

#define PI 3.141592653589793
float rand(float x) {
    return fract(sin(x * 12.9898) * 43758.5453);
}

void main() {
    vec2 uv = vTextureCoord;

    float sliceHeight = 1.0 / float(slices);
    float sliceIndex = floor(uv.y / sliceHeight);

    float offsetX = (rand(sliceIndex + uTime * speed) - 0.5) * intensity;

    float offsetY = sin(uTime * speed + sliceIndex * 1.5) * 0.01 * randomness;

    uv.x += offsetX;
    uv.y += offsetY;
    vec4 color = texture(uTexture, uv);

    gl_FragColor = color;
}

`,uniforms:{uTime:{value:0,type:"f32"},intensity:{value:.05,type:"f32"},speed:{value:2,type:"f32"},slices:{value:10,type:"i32"},randomness:{value:1,type:"f32"}}},twoCurtain:{label:"Two Curtain",fragment:`
precision highp float;

in vec2 vTextureCoord;
uniform sampler2D uTexture;
uniform float uTime;      
uniform float softness;   

void main() {
    vec2 uv = vTextureCoord;

    float t_raw = clamp(uTime, 0.0, 1.0);
    float t = pow(t_raw, 0.55);

    float mid = 0.5;

    float leftEdge = mid - t * mid;
    float rightEdge = mid + t * mid;

    float mask = smoothstep(leftEdge, leftEdge + softness, uv.x) *
                 (1.0 - smoothstep(rightEdge - softness, rightEdge, uv.x));

    vec4 color = texture(uTexture, uv);

    gl_FragColor = vec4(color.rgb * mask, color.a * mask);
}
`,uniforms:{uTime:{value:0,type:"f32"},softness:{value:.2,type:"f32"}}},trianglePattern:{label:"Triangle Pattern",fragment:`
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float softness;
uniform float zoom;

#define PI 3.141592653589793

vec2 rotate2D(vec2 st, float angle) {
    st -= 0.5;
    st = mat2(cos(angle), -sin(angle),
              sin(angle),  cos(angle)) * st;
    st += 0.5;
    return st;
}

vec2 tile(vec2 st, float zoom) {
    st *= zoom;
    return fract(st);
}

vec2 rotateTile(vec2 st) {
    st *= 2.0;

    float index = 0.0;
    if (fract(st.x * 0.5) > 0.5) index += 1.0;
    if (fract(st.y * 0.5) > 0.5) index += 2.0;

    st = fract(st);

    if (index == 1.0)      st = rotate2D(st, PI * 0.5);
    else if (index == 2.0) st = rotate2D(st, PI * -0.5);
    else if (index == 3.0) st = rotate2D(st, PI);

    return st;
}

float triangleShape(vec2 st, float smoothness) {
    vec2 p0 = vec2(0.3, -0.5);
    vec2 p1 = vec2(0.7, -0.5);
    vec2 p2 = vec2(0.5, 1.0);

    vec3 e0, e1, e2;

    e0.xy = normalize(p1 - p0).yx * vec2(+1.0, -1.0);
    e1.xy = normalize(p2 - p1).yx * vec2(+1.0, -1.0);
    e2.xy = normalize(p0 - p2).yx * vec2(+1.0, -1.0);

    e0.z = dot(e0.xy, p0) - smoothness;
    e1.z = dot(e1.xy, p1) - smoothness;
    e2.z = dot(e2.xy, p2) - smoothness;

    float a = max(0.0, dot(e0.xy, st) - e0.z);
    float b = max(0.0, dot(e1.xy, st) - e1.z);
    float c = max(0.0, dot(e2.xy, st) - e2.z);

    return smoothstep(smoothness * 2.0, 1e-7, length(vec3(a, b, c)));
}

void main() {
    vec2 uv = vTextureCoord;
    vec2 st = uv;
    st = tile(st, zoom);
    st = rotateTile(st);
    st = rotate2D(st, -PI * 0.25 * uTime);

    float mask = triangleShape(st, softness);

    vec4 tex = texture(uTexture, uv);
    gl_FragColor = vec4(tex.rgb * mask, tex.a * mask);
}
`,uniforms:{uTime:{value:0,type:"f32"},softness:{value:.2,type:"f32"},zoom:{value:8,type:"f32"}}},mirrorTile:{label:"Mirror Tile",fragment:`
precision highp float;

in vec2 vTextureCoord;
uniform sampler2D uTexture;
uniform float uTime;

vec2 mirrorTile(vec2 st, float zoom) {
    st *= zoom;

    if (fract(st.y * 0.5) > 0.5) {
        st.x = st.x + 0.5;
        st.y = 1.0 - st.y;
    }

    return fract(st);
}

float zigzag(vec2 st) {
    float x = st.x * 2.0;
    float a = floor(1.0 + sin(x * 3.14159));
    float b = floor(1.0 + sin((x + 1.0) * 3.14159));
    float f = fract(x);
    return mix(a, b, f);
}

void main() {
    vec2 st = vTextureCoord;

    st = mirrorTile(st * vec2(1.0, 2.0), 5.0);

    float zz = zigzag(st);

    st.y += zz * 0.03;

    vec4 tex = texture(uTexture, st);

    gl_FragColor = tex;
}
`,uniforms:{uTime:{value:0,type:"f32"}}},flashLoop:{label:"Flash Loop",fragment:`
precision highp float;

in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;
uniform float speed;      
uniform float intensity;  

void main(void)
{
    vec4 tex = texture2D(uTexture, vTextureCoord);
    float t = fract(uTime * speed);
    float wave = sin(t * 3.141592);
    float base = 0.6;
    float brightness = mix(base, 1.0, wave);
    float flash = 1.0 + brightness * intensity;

    vec3 color = tex.rgb * flash;

    gl_FragColor = vec4(color, tex.a);
}
`,uniforms:{uTime:{value:0,type:"f32"},speed:{value:10.2,type:"f32"},intensity:{value:1.5,type:"f32"}}},filmStripPro:{label:"Film Strip Pro",fragment:`
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;

uniform float framesPerScreen;
uniform float scrollSpeed;
uniform float gateWeave;

void main() {
    vec2 uv = vTextureCoord;

    vec3 color = vec3(0.0);

    uv.y += uTime * scrollSpeed;
    uv.y += sin(uTime * 2.0) * 0.003 * gateWeave;

    float stripLeft  = 0.025;
    float stripRight = 0.5;

    if (uv.x < stripLeft || uv.x > stripRight) {
        gl_FragColor = vec4(color, 1.0);
        return;
    }

    vec2 stripUV;
    stripUV.x = (uv.x - stripLeft) / (stripRight - stripLeft);
    stripUV.y = fract(uv.y);

    float holeZone = 0.06; 
    float frameZone = 1.0 - holeZone * 2.0;

    float frameH = 1.0 / framesPerScreen;
    float localY = fract(stripUV.y / frameH);

    bool inFrameX =
        stripUV.x > holeZone &&
        stripUV.x < holeZone + frameZone;

    float marginX = 0.08;
    float marginY = 0.10;


    bool insideFrame =
        inFrameX &&
        stripUV.x > holeZone + marginX &&
        stripUV.x < holeZone + frameZone - marginX &&
        localY > marginY &&
        localY < 1.0 - marginY;

    float frameZoneX = frameZone - marginX * 4.0;
    float centerOffset = (1.0 - frameZoneX - holeZone * 2.0) * 0.5;

    vec2 frameUV;
    frameUV.x = (stripUV.x - (holeZone + marginX * 2.0) - centerOffset) / frameZoneX;
    frameUV.y = (localY - marginY) / (1.0 - marginY * 2.0);

    float holeH = 0.01;
    float holeSpacing = frameH * 0.1;

    float holeRow = step(mod(stripUV.y, holeSpacing), holeH);

    bool leftHole  = stripUV.x < holeZone * 0.8;
    bool rightHole = stripUV.x > 1.0 - holeZone * 0.8;

    bool isHole = holeRow > 0.5 && (leftHole || rightHole);
    if (isHole) {
        color = vec3(1.0);
    }
    else if (insideFrame) {
        color = texture2D(uTexture, frameUV).rgb;
    }
    else {
        color = vec3(0.0);
    }

    gl_FragColor = vec4(color, 1.0);
}
`,uniforms:{uTime:{value:0,type:"f32"},framesPerScreen:{value:2,type:"f32"},scrollSpeed:{value:.35,type:"f32"},gateWeave:{value:.6,type:"f32"}}},badSignal:{label:"Bad Signal",fragment:`
precision highp float;

in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;
float rand(vec2 co) {
    return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453);
}

float noise(float y) {
    return rand(vec2(y, uTime));
}

void main(void)
{
    vec2 uv = vTextureCoord;
    float flicker = 0.9 + 0.1 * sin(uTime * 30.0);
    float lineNoise = noise(floor(uv.y * 200.0));
    uv.x += (lineNoise - 0.5) * 0.03;
    uv.x += sin(uv.y * 40.0 + uTime * 10.0) * 0.005;
    float rgbShift = 0.004 * sin(uTime * 5.0);

    vec4 colR = texture2D(uTexture, uv + vec2(rgbShift, 0.0));
    vec4 colG = texture2D(uTexture, uv);
    vec4 colB = texture2D(uTexture, uv - vec2(rgbShift, 0.0));

    vec4 color;
    color.r = colR.r;
    color.g = colG.g;
    color.b = colB.b;
    color.a = colG.a;
    float staticNoise = rand(uv * uTime) * 0.08;
    color.rgb += staticNoise;
    float scanline = sin(uv.y * 800.0) * 0.04;
    color.rgb -= scanline;
    color.rgb *= flicker;

    gl_FragColor = color;
}

`,uniforms:{uTime:{value:0,type:"f32"}}},omniflexion:{label:"Omniflexion",fragment:`
precision highp float;

in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;

/* Configuracin */
uniform float strength;   // fuerza de la omniflexin
uniform float frequency;  // frecuencia de ondas
uniform float speed;      // velocidad animacin

void main(void)
{
    vec2 uv = vTextureCoord;
    vec2 center = vec2(0.5);

    vec2 dir = uv - center;
    float dist = length(dir);
    float wave =
        sin(dist * frequency - uTime * speed) *
        strength;

    float lens = dist * dist;

    vec2 flexUV = uv + normalize(dir) * wave * lens;
    vec4 color = texture2D(uTexture, flexUV);

    gl_FragColor = color;
}

`,uniforms:{uTime:{value:0,type:"f32"},strength:{value:.08,type:"f32"},frequency:{value:18,type:"f32"},speed:{value:3.5,type:"f32"}}},inverseAperture:{label:"Inverse Aperture",fragment:`
precision highp float;

in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;

uniform float feather;

void main(void)
{
    vec2 uv = vTextureCoord;

    vec2 center = vec2(0.28, 0.48);

    float dist = distance(uv, center);

    float maxRadius = 0.8;

    float radius = mix(maxRadius, 0.0, uTime);

    float mask = smoothstep(
        radius - feather,
        radius + feather,
        dist
    );

    vec4 color = texture2D(uTexture, uv);

    gl_FragColor = vec4(color.rgb * mask, color.a);
}

`,uniforms:{uTime:{value:0,type:"f32"},feather:{value:.03,type:"f32"}}},curtainOpen:{label:"Curtain Open",fragment:`
precision highp float;

in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;

void main(void)
{
    vec2 uv = vTextureCoord;

    float openPhase = smoothstep(0.0, 0.6, uTime);
    float zoomPhase = smoothstep(0.6, 1.0, uTime);

    float zoom =
        1.0 +
        sin(zoomPhase * 3.141592) * 0.2;

    vec2 center = vec2(0.28, 0.35);
    vec2 zoomUV = (uv - center) / zoom + center;

    vec4 tex = texture2D(uTexture, zoomUV);

    float centerY = 0.48;
    float halfOpen = openPhase * 0.5;

    float mask = step(abs(zoomUV.y - centerY), halfOpen);

    gl_FragColor = vec4(tex.rgb * mask, tex.a);
}

`,uniforms:{uTime:{value:0,type:"f32"}}},curtainBlur:{label:"Curtain Blur",fragment:`
precision highp float;

in vec2 vTextureCoord;
in vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;

vec4 blur9(sampler2D tex, vec2 uv, vec2 resolution, float radius)
{
    vec4 color = vec4(0.0);
    vec2 off = radius / resolution;

    color += texture2D(tex, uv + off * vec2(-1.0, -1.0)) * 0.0625;
    color += texture2D(tex, uv + off * vec2( 0.0, -1.0)) * 0.125;
    color += texture2D(tex, uv + off * vec2( 1.0, -1.0)) * 0.0625;

    color += texture2D(tex, uv + off * vec2(-1.0,  0.0)) * 0.125;
    color += texture2D(tex, uv)                             * 0.25;
    color += texture2D(tex, uv + off * vec2( 1.0,  0.0)) * 0.125;

    color += texture2D(tex, uv + off * vec2(-1.0,  1.0)) * 0.0625;
    color += texture2D(tex, uv + off * vec2( 0.0,  1.0)) * 0.125;
    color += texture2D(tex, uv + off * vec2( 1.0,  1.0)) * 0.0625;

    return color;
}

void main(void)
{
    vec2 uv = vTextureCoord;

    float openPhase = smoothstep(0.0, 0.3, uTime);
    float zoomPhase = smoothstep(0.3, 1.0, uTime);

    float zoom =
        1.0 +
        sin(zoomPhase * 3.141592) * 0.2;

    vec2 center = vec2(0.28, 0.35);
    vec2 zoomUV = (uv - center) / zoom + center;

    float blurAmount = mix(10.0, 0.0, openPhase);

    vec4 blurred =
        blur9(uTexture, zoomUV, vec2(1024.0, 1024.0), blurAmount);

    float pulse =
    (sin(uTime * 2.0) * 0.5 + 0.5) * 0.8;
    blurred.rgb *= (1.0 + pulse);
    float centerY = 0.48;
    float halfOpen = openPhase * 0.5;

    float mask = step(abs(zoomUV.y - centerY), halfOpen);

    gl_FragColor = vec4(blurred.rgb * mask, blurred.a);
}

`,uniforms:{uTime:{value:0,type:"f32"}}},distortV2:{label:"Distort V2",fragment:`
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;

uniform float strength;

uniform float frequency;

void main(void)
{
    vec2 uv = vTextureCoord;

    float waveX = sin((uv.y + uTime * 0.6) * frequency) * strength;
    float waveY = cos((uv.x + uTime * 0.4) * frequency) * strength;

    vec2 distortedUV = uv + vec2(waveX, waveY);

    distortedUV = clamp(distortedUV, 0.0, 1.0);

    vec4 color = texture2D(uTexture, distortedUV);

    gl_FragColor = color;
}
`,uniforms:{uTime:{value:0,type:"f32"},strength:{value:.015,type:"f32"},frequency:{value:10,type:"f32"}}},lightning:{label:"Lightning",fragment:`
precision mediump float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;

void main(void)
{
    vec2 uv = vTextureCoord;
    vec2 center = vec2(0.28, 0.45);

    float dist = distance(uv, center);

    float speed = 0.7;
    float progress = mod(uTime * speed, 1.0);

    float width = mix(0.01, 0.07, progress);

    float lightning = smoothstep(progress + width, progress, dist);

    float noise = sin((uv.x + uv.y) * 30.0 + uTime * 12.0);
    lightning *= noise * 0.5 + 0.5;

    float explosion = smoothstep(0.85, 1.0, progress);
    float burst = explosion * smoothstep(0.25, 0.0, dist);

    vec3 lightningColor = vec3(1.0, 0.9, 0.6) * lightning * 2.5;
    vec3 explosionColor = vec3(1.0, 0.4, 0.2) * burst * 4.0;

    vec4 base = texture2D(uTexture, uv);

    gl_FragColor = vec4(base.rgb + lightningColor + explosionColor, base.a);
}
`,uniforms:{uTime:{value:0,type:"f32"}}},lightningVeins:{label:"Lightning Veins",fragment:`
precision mediump float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uTexture;
uniform float uTime;

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);

    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
           (c - a) * u.y * (1.0 - u.x) +
           (d - b) * u.x * u.y;
}

void main(void)
{
    vec2 uv = vTextureCoord;
    vec2 center = vec2(0.5);

    vec2 dir = uv - center;
    float dist = length(dir);
    float t = uTime * 1.5;

    float veinNoise =
        noise(dir * 6.0 + t) * 0.6 +
        noise(dir * 12.0 - t * 1.3) * 0.3;

    float warpedDist = dist + veinNoise * 0.08;

    float thickness = 0.04 + veinNoise * 0.02;

    float lightning =
        smoothstep(thickness, 0.0, warpedDist);

    float branches =
        smoothstep(0.02, 0.0,
            abs(noise(dir * 20.0 + t) - 0.5));

    lightning += branches * 0.35;

    float pulse = sin(uTime * 10.0) * 0.3 + 0.7;
    lightning *= pulse;

    vec3 veinColor =
        vec3(0.6, 0.85, 1.0) * lightning * 2.5;

    vec4 base = texture2D(uTexture, uv);

    gl_FragColor =
        vec4(base.rgb + veinColor, base.a);
}
`,uniforms:{uTime:{value:0,type:"f32"}}},pixelError:{label:"Pixel Error",fragment:`
precision mediump float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;

float rand(float x)
{
    return fract(sin(x) * 43758.5453123);
}

void main(void)
{
    vec2 uv = vTextureCoord;

    float pixelRows = 120.0;
    float row = floor(uv.y * pixelRows) / pixelRows;

    float offset =
        sin(row * 40.0 + uTime * 3.0) *
        0.015;

    offset += (rand(row * 10.0) - 0.5) * 0.01;

    vec2 distortedUV = vec2(uv.x + offset, uv.y);

    distortedUV = clamp(distortedUV, 0.0, 1.0);

    vec4 color = texture2D(uTexture, distortedUV);

    gl_FragColor = color;
}
`,uniforms:{uTime:{value:0,type:"f32"}}},neonFlash:{label:"Neon Flash",fragment:`
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uIntensity;

uniform float neonR;
uniform float neonG;
uniform float neonB;

void main(void)
{
    vec4 base = texture2D(uTexture, vTextureCoord);

    float speed = 4.2;                 
    float t = fract(uTime * speed);    

    float rise = smoothstep(0.0, 0.25, t);
    float fall = smoothstep(0.85, 0.55, t);
    float flash = rise * fall;

    flash = mix(0.25, 1.0, flash);

    flash *= uIntensity;

    base.r += base.r * neonR * flash;
    base.g += base.g * neonG * flash;
    base.b += base.b * neonB * flash;

    gl_FragColor = base;
}
`,uniforms:{uTime:{value:0,type:"f32"},uIntensity:{value:1.8,type:"f32"},neonR:{value:.1,type:"f32"},neonG:{value:.9,type:"f32"},neonB:{value:1,type:"f32"}}},waveDistort:{label:"Wave Distort",fragment:`
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uStrength;
uniform float uSpeed;

void main(void)
{
    vec2 uv = vTextureCoord;
    float time = uTime * uSpeed;

    float wave = sin((uv.y * 18.0) - time);

    float offsetX = wave * uStrength;

    vec2 distortedUV = uv + vec2(offsetX, 0.0);

    distortedUV = clamp(distortedUV, 0.0, 1.0);

    vec4 color = texture2D(uTexture, distortedUV);

    gl_FragColor = color;
}
`,uniforms:{uTime:{value:0,type:"f32"},uStrength:{value:.02,type:"f32"},uSpeed:{value:20,type:"f32"}}},bouncingBalls:{label:"Bouncing Balls",fragment:`
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;

const int BALL_COUNT = 10;
float radius = 0.05;
float border = 0.006;

vec2 bounce(vec2 p)
{
    return abs(fract(p) * 2.0 - 1.0);
}

void main(void)
{
    vec2 uv = vTextureCoord;

    /* Textura base */
    vec4 color = texture2D(uTexture, uv);

    float ballsAlpha = 0.0;

    for (int i = 0; i < BALL_COUNT; i++)
    {
        float id = float(i) + 1.0;

        vec2 speed = vec2(
            0.3 + id * 0.12,
            0.25 + id * 0.15
        );

        vec2 pos = bounce(vec2(
            uTime * speed.x + id * 0.17,
            uTime * speed.y + id * 0.29
        ));

        float d = distance(uv, pos);

        float edge =
            smoothstep(radius, radius - border, d) -
            smoothstep(radius - border, radius - border - 0.01, d);

        ballsAlpha += edge;
    }

    ballsAlpha = clamp(ballsAlpha, 0.0, 1.0);
    color.rgb = mix(color.rgb, vec3(1.0), ballsAlpha);

    gl_FragColor = color;
}
`,uniforms:{uTime:{value:0,type:"f32"}}},waterReflection:{label:"Water Reflection",fragment:`
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uWaveStrength;
uniform float uWaveSpeed;

void main(void)
{
    vec2 uv = vTextureCoord;

    if (uv.y < 0.5)
    {
        gl_FragColor = texture2D(uTexture, uv);
        return;
    }

    vec2 reflectUV = uv;
    reflectUV.y = 1.0 - uv.y;

    float wave =
        sin(reflectUV.y * 30.0 + uTime * uWaveSpeed) *
        uWaveStrength;

    reflectUV.x += wave;
    reflectUV = clamp(reflectUV, 0.0, 1.0);

    vec4 reflectColor = texture2D(uTexture, reflectUV);

    float fade = smoothstep(0.5, 1.0, uv.y);

    reflectColor.rgb *= (1.0 - fade) * 0.85;
    reflectColor.a *= (1.0 - fade);

    gl_FragColor = reflectColor;
}
`,uniforms:{uTime:{value:0,type:"f32"},uWaveStrength:{value:.02,type:"f32"},uWaveSpeed:{value:2.5,type:"f32"}}},darkError:{label:"Dark Error",fragment:`
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uStrength;

float rand(vec2 co)
{
    return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453);
}

void main(void)
{
    vec2 uv = vTextureCoord;

    float t = floor(uTime * 6.0);

    float blockSize = 0.08;
    float blockY = floor(uv.y / blockSize) * blockSize;

    float noise = rand(vec2(blockY, t));

    float shift =
        step(0.65, noise) *
        (rand(vec2(blockY, t + 1.0)) - 0.5) *
        uStrength;

    vec2 glitchUV = uv + vec2(shift, 0.0);
    glitchUV = clamp(glitchUV, 0.0, 1.0);

    vec4 color = texture2D(uTexture, glitchUV);
    float darkPulse =
        step(0.75, noise) *
        (0.4 + rand(vec2(uv.x, t)) * 0.6);

    color.rgb *= 1.0 - darkPulse;
    float pixelNoise = rand(uv * t);
    color.rgb *= 1.0 - step(0.96, pixelNoise) * 0.8;

    gl_FragColor = color;
}
`,uniforms:{uTime:{value:0,type:"f32"},uStrength:{value:.08,type:"f32"}}},scaleMoveBlur:{label:"Scale Move Blur",fragment:`
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;

vec4 blur5(sampler2D tex, vec2 uv, float strength)
{
    vec4 col = vec4(0.0);
    float s = strength;

    col += texture2D(tex, uv + vec2(-s, -s)) * 0.05;
    col += texture2D(tex, uv + vec2( 0.0, -s)) * 0.10;
    col += texture2D(tex, uv + vec2( s, -s)) * 0.05;

    col += texture2D(tex, uv + vec2(-s,  0.0)) * 0.10;
    col += texture2D(tex, uv)                * 0.40;
    col += texture2D(tex, uv + vec2( s,  0.0)) * 0.10;

    col += texture2D(tex, uv + vec2(-s,  s)) * 0.05;
    col += texture2D(tex, uv + vec2( 0.0,  s)) * 0.10;
    col += texture2D(tex, uv + vec2( s,  s)) * 0.05;

    return col;
}

void main(void)
{
    vec2 uv = vTextureCoord;
    vec2 center = vec2(0.5, 0.5);

    float t = clamp(uTime, 0.0, 1.0);
    float zoomPhase = smoothstep(0.0, 0.5, t) *
                      (1.0 - smoothstep(0.5, 1.0, t));

    float scale = 1.0 + zoomPhase * 0.5;

    vec2 offset = vec2(0.0);

    if (t < 0.33)
    {
        offset = vec2(0.12 * (t / 0.33), 0.0);
    }
    else if (t < 0.66)
    {
        offset = vec2(
            0.12 * (1.0 - (t - 0.33) / 0.33),
            0.0
        );
    }
    else
    {
        offset = vec2(
            0.08 * ((t - 0.66) / 0.34),
           -0.08 * ((t - 0.66) / 0.34)
        );
    }

    offset *= zoomPhase;
    vec2 transformedUV =
        (uv - center) / scale +
        center -
        offset;

    transformedUV = clamp(transformedUV, 0.0, 1.0);
    float blurStrength = zoomPhase * 0.015;

    vec4 color = blur5(uTexture, transformedUV, blurStrength);

    gl_FragColor = color;
}
`,uniforms:{uTime:{value:0,type:"f32"}}},paperBreakReveal:{label:"Paper Break Reveal",fragment:`
precision highp float;

in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uCutPos;


float noise(float x)
{
    return sin(x * 28.0) * 0.035;
}

vec4 blur5(sampler2D tex, vec2 uv, float s)
{
    vec4 c = vec4(0.0);
    c += texture2D(tex, uv + vec2(-s, -s)) * 0.05;
    c += texture2D(tex, uv + vec2( 0.0, -s)) * 0.10;
    c += texture2D(tex, uv + vec2( s, -s)) * 0.05;
    c += texture2D(tex, uv + vec2(-s,  0.0)) * 0.10;
    c += texture2D(tex, uv)                * 0.40;
    c += texture2D(tex, uv + vec2( s,  0.0)) * 0.10;
    c += texture2D(tex, uv + vec2(-s,  s)) * 0.05;
    c += texture2D(tex, uv + vec2( 0.0,  s)) * 0.10;
    c += texture2D(tex, uv + vec2( s,  s)) * 0.05;
    return c;
}

void main(void)
{
    vec2 uv = vTextureCoord;
    vec2 center = vec2(0.5);
    float movePhase  = smoothstep(0.0, 0.45, uTime);
    float settle     = smoothstep(0.45, 0.6, uTime);
    float cutPhase   = smoothstep(0.7, 0.9, uTime);
    float cleanPhase = smoothstep(0.9, 1.0, uTime);
    float scale = mix(1.5, 1.0, settle);

    float moveAlive = 1.0 - settle;

    vec2 movement = vec2(
        sin(uTime * 6.0) * 0.18 * moveAlive,
        0.0
    );

    vec2 uvScaled =
        (uv - center) / scale +
        center -
        movement;

    uvScaled = clamp(uvScaled, 0.0, 1.0);

    float blurStrength = (1.0 - cleanPhase) * 0.025;
    vec4 blurred = blur5(uTexture, uvScaled, blurStrength);
    vec4 clean = texture2D(uTexture, uv);

    float tearLine =
        mix(
            uCutPos,
            uCutPos + noise(uv.y + uTime * 3.0),
            cutPhase
        );

    tearLine = clamp(tearLine, uCutPos - 0.05, uCutPos + 0.05);

    float split = cutPhase * 0.35;

    vec2 leftUV  = uv;
    vec2 rightUV = uv;

    leftUV.x  -= split * step(uv.x, tearLine);
    rightUV.x += split * step(tearLine, uv.x);

    leftUV  = clamp(leftUV,  0.0, 1.0);
    rightUV = clamp(rightUV, 0.0, 1.0);

    vec4 left  = texture2D(uTexture, leftUV);
    vec4 right = texture2D(uTexture, rightUV);

    float cutMask =
        smoothstep(tearLine - 0.02, tearLine + 0.02, uv.x);

    vec4 broken = mix(left, right, cutMask);

    float edge =
        smoothstep(0.0, 0.02, abs(uv.x - tearLine)) *
        (1.0 - smoothstep(0.02, 0.05, abs(uv.x - tearLine)));

    vec3 edgeColor = vec3(1.0) * edge * cutPhase;

    broken.rgb += edgeColor;

    vec4 result = mix(blurred, broken, cutPhase);
    result = mix(result, clean, cleanPhase);

    gl_FragColor = result;
}
`,uniforms:{uTime:{value:0,type:"f32"},uCutPos:{value:.28,type:"f32"}}},graffiti:{label:"Graffiti",fragment:`
#ifdef GL_ES
precision mediump float;
#endif

varying vec2 vTextureCoord;

uniform float uTime;
uniform sampler2D uTexture;

float rand(vec2 st)
{
    return fract(sin(dot(st, vec2(12.9898,78.233))) * 43758.5453123);
}

float noise(vec2 st)
{
    vec2 i = floor(st);
    vec2 f = fract(st);

    float a = rand(i);
    float b = rand(i + vec2(1.0, 0.0));
    float c = rand(i + vec2(0.0, 1.0));
    float d = rand(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
           (c - a) * u.y * (1.0 - u.x) +
           (d - b) * u.x * u.y;
}

float spray(vec2 st, float radius)
{
    float dist = length(st - vec2(0.28, 0.5));
    float base = smoothstep(radius, radius - 0.06, dist);

    float speckle =
        noise(st * 45.0 + uTime * 3.0) *
        noise(st * 90.0);

    return clamp(base + speckle * 0.7, 0.0, 1.0);
}

float drips(vec2 st, float mask)
{
    float column = noise(vec2(st.x * 25.0, 0.0));

    float drip =
        smoothstep(0.3, 0.7, column) *
        smoothstep(0.1, 1.0, 1.0 - st.y);

    float flow =
        noise(vec2(st.x * 35.0, st.y * 6.0 + uTime * 2.5));

    return drip * flow * mask;
}

void main(void)
{
    vec2 uv = vTextureCoord;

    vec4 base = texture2D(uTexture, uv);

    vec3 graffitiColor = vec3(1.0, 0.0, 0.5);

    float reveal = smoothstep(0.0, 1.0, uTime);

    float sprayMask =
        spray(uv, 0.35 * reveal);

    float dripMask =
        drips(uv, sprayMask) * reveal;

    float graffitiMask =
        clamp(sprayMask + dripMask * 1.3, 0.0, 1.0);

    vec3 graffiti =
        graffitiColor * graffitiMask;

    vec3 Color =
        base.rgb + graffiti;

    gl_FragColor = vec4(Color, base.a);
}
`,uniforms:{uTime:{value:0,type:"f32"}}},laser:{label:"Laser",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform vec3 uColor;
uniform float uThickness;
uniform float uIntensity;

float noise(float x) {
    return sin(x * 40.0) * 0.005;
}

void main() {
    vec2 uv = vTextureCoord;

    vec4 baseColor = texture2D(uTexture, uv);

    float beamY = 0.48 + noise(uv.x + uTime * 5.0);

    float dist = abs(uv.y - beamY);

    float core = smoothstep(uThickness, 0.0, dist);

    float glow = smoothstep(uThickness * 4.0, uThickness, dist);

    float pulse = 0.6 + 0.4 * sin(uTime * 10.0);

    float laserMask = (core + glow * uIntensity) * pulse;

    vec3 laserColor = uColor * laserMask;

    vec3 color = baseColor.rgb + laserColor;

    gl_FragColor = vec4(color, baseColor.a);
}
`,uniforms:{uTime:{value:0,type:"f32"},uColor:{value:[1,0,.2],type:"vec3<f32>"},uThickness:{value:.02,type:"f32"},uIntensity:{value:1.5,type:"f32"}}},wave:{label:"Wave",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uStrength;
uniform float uFrequency;
uniform float uSpeed;

void main() {
    vec2 uv = vTextureCoord;

    vec2 center = vec2(0.5, 0.5);

    float dist = distance(uv, center);

    float wave =
        sin(dist * uFrequency - uTime * uSpeed) *
        uStrength *
        smoothstep(1.0, 0.0, dist);

    vec2 dir = normalize(uv - center);

    vec2 distortedUV = uv + dir * wave;

    vec4 color = texture2D(uTexture, distortedUV);

    gl_FragColor = color;
}
`,uniforms:{uTime:{value:0,type:"f32"},uStrength:{value:.02,type:"f32"},uFrequency:{value:20,type:"f32"},uSpeed:{value:4,type:"f32"}}},sparks:{label:"Sparks",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uDensity;
uniform float uSpeed;
uniform float uSize;

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}
vec3 randomColor(float h) {
    return vec3(
        0.5 + 0.5 * sin(h * 6.2831),
        0.5 + 0.5 * sin(h * 6.2831 + 2.1),
        0.5 + 0.5 * sin(h * 6.2831 + 4.2)
    );
}

void main() {
    vec2 uv = vTextureCoord;

    vec4 base = texture2D(uTexture, uv);

    vec3 sparkColor = vec3(0.0);
    float sparkAlpha = 0.0;

    vec2 grid = floor(uv * uDensity);
    vec2 id = grid;

    float h = hash(id);

    vec2 sparkPos = fract(vec2(
        h,
        h + uTime * uSpeed
    ));

    float d = distance(fract(uv * uDensity), sparkPos);

    float spark = smoothstep(uSize, 0.0, d);

    vec3 color = randomColor(h) * spark;

    sparkColor += color;
    sparkAlpha += spark;

    vec3 colorValue = base.rgb + sparkColor;

    gl_FragColor = vec4(colorValue, max(base.a, sparkAlpha));
}
`,uniforms:{uTime:{value:0,type:"f32"},uDensity:{value:30,type:"f32"},uSpeed:{value:2.5,type:"f32"},uSize:{value:.15,type:"f32"}}},hologramScan:{label:"Hologram Scan",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform vec3 uColor;      
uniform float uScanWidth; 
uniform float uIntensity; 

float noise(float x) {
    return sin(x * 120.0) * 0.02;
}

void main() {
    vec2 uv = vTextureCoord;

    vec4 base = texture2D(uTexture, uv);

    float scanPos = fract(uTime * 0.5);
    float scanLine = smoothstep(
        uScanWidth,
        0.0,
        abs(uv.y - scanPos)
    );

    float lines = 0.5 + 0.5 * sin(uv.y * 300.0 + uTime * 10.0);

    float flicker = 0.9 + 0.1 * sin(uTime * 50.0);

    float holo =
        scanLine +
        lines * 0.2 +
        noise(uv.x + uTime) * 0.5;

    holo *= uIntensity * flicker;

    vec3 holoColor = uColor * holo;

    vec3 colorValue = base.rgb + holoColor;

    gl_FragColor = vec4(colorValue, base.a);
}
`,uniforms:{uTime:{value:0,type:"f32"},uColor:{value:[0,1,1],type:"vec3<f32>"},uScanWidth:{value:.02,type:"f32"},uIntensity:{value:1.2,type:"f32"}}},retro70s:{label:"Retro 70s",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uGrain;     
uniform float uFade;      
uniform float uVignette;  

float noise(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898,78.233)) + uTime) * 43758.5453);
}

void main() {
    vec2 uv = vTextureCoord;

    vec4 color = texture2D(uTexture, uv);

    vec3 faded = mix(color.rgb, vec3(
        dot(color.rgb, vec3(0.393, 0.769, 0.189)),
        dot(color.rgb, vec3(0.349, 0.686, 0.168)),
        dot(color.rgb, vec3(0.272, 0.534, 0.131))
    ), uFade);

    float grain = (noise(uv * 500.0) - 0.5) * uGrain;
    faded += grain;

    float flicker = 0.97 + 0.03 * sin(uTime * 60.0);
    faded *= flicker;

    float dist = distance(uv, vec2(0.5));
    float vignette = smoothstep(0.8, uVignette, dist);
    faded *= 1.0 - vignette;

    gl_FragColor = vec4(faded, color.a);
}
`,uniforms:{uTime:{value:0,type:"f32"},uGrain:{value:.08,type:"f32"},uFade:{value:.6,type:"f32"},uVignette:{value:1,type:"f32"}}},igOutline:{label:"IG Outline",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uThickness;
uniform vec3 uOutlineColor;

void main() {
    vec2 uv = vTextureCoord;

    vec2 px = vec2(uThickness) / vec2(1024.0, 1024.0);

    vec4 centerTex = texture2D(uTexture, uv);
    vec3 center = centerTex.rgb;

    vec3 up     = texture2D(uTexture, uv + vec2(0.0,  px.y)).rgb;
    vec3 down   = texture2D(uTexture, uv - vec2(0.0,  px.y)).rgb;
    vec3 left   = texture2D(uTexture, uv - vec2(px.x, 0.0)).rgb;
    vec3 right  = texture2D(uTexture, uv + vec2(px.x, 0.0)).rgb;

    float edge =
        length(center - up) +
        length(center - down) +
        length(center - left) +
        length(center - right);

    edge = smoothstep(0.15, 0.4, edge);

    vec3 colorValue = mix(center, uOutlineColor, edge);
    gl_FragColor = vec4(colorValue, centerTex.a);
}

`,uniforms:{uThickness:{value:1.5,type:"f32"},uOutlineColor:{value:[1,1,1],type:"vec3<f32>"}}},randomAccents:{label:"Random Accents",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uDensity;
uniform float uSize;
uniform float uIntensity;
uniform vec3 uColorA;
uniform vec3 uColorB;

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

vec3 accentColor(float h) {
    return mix(uColorA, uColorB, fract(h * 7.0));
}

void main() {
    vec2 uv = vTextureCoord;

    vec4 base = texture2D(uTexture, uv);

    vec2 gridUV = floor(uv * uDensity);
    float h = hash(gridUV);

    vec2 offset = vec2(
        fract(h * 13.3),
        fract(h * 7.7)
    );

    vec2 accentUV = fract(uv * uDensity) - offset;

    float dist = length(accentUV);

    float accent = smoothstep(uSize, 0.0, dist);

    accent *= 0.6 + 0.4 * sin(uTime * 10.0 + h * 6.28);

    vec3 color = accentColor(h) * accent * uIntensity;

    float alpha = accent;

    gl_FragColor = vec4(color + base.rgb, max(base.a, alpha));
}
`,uniforms:{uTime:{value:0,type:"f32"},uDensity:{value:20,type:"f32"},uSize:{value:.25,type:"f32"},uIntensity:{value:1.2,type:"f32"},uColorA:{value:[1,.2,.6],type:"vec3<f32>"},uColorB:{value:[.2,.8,1],type:"vec3<f32>"}}},solution:{label:"Solution",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform vec3 uColorA;
uniform vec3 uColorB;
uniform float uIntensity;

float noise(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
}

vec2 swirl(vec2 uv, float t) {
    vec2 center = vec2(0.5);
    vec2 diff = uv - center;
    float angle = 0.5 * t * length(diff);
    float s = sin(angle);
    float c = cos(angle);
    return center + vec2(c*diff.x - s*diff.y, s*diff.x + c*diff.y);
}

void main() {
    vec2 uv = vTextureCoord;

    vec2 uvSwirl = swirl(uv, uTime);

    vec4 base = texture2D(uTexture, uvSwirl);

    float n = noise(uv * 20.0 + uTime * 2.0);
    vec3 liquid = mix(uColorA, uColorB, n);

    vec3 colorValue = mix(base.rgb, liquid, uIntensity * n);

    gl_FragColor = vec4(colorValue, base.a);
}
`,uniforms:{uTime:{value:0,type:"f32"},uColorA:{value:[.2,.8,1],type:"vec3<f32>"},uColorB:{value:[1,.2,.6],type:"vec3<f32>"},uIntensity:{value:.8,type:"f32"}}},tvScanlines:{label:"TV Scanlines",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uLineThickness;
uniform float uLineIntensity;
uniform float uNoiseIntensity;
uniform vec3 uLineColor;

float rand(vec2 p){
    return fract(sin(dot(p ,vec2(12.9898,78.233))) * 43758.5453);
}

void main() {
    vec2 uv = vTextureCoord;

    vec4 tex = texture2D(uTexture, uv);
    vec3 base = tex.rgb;

    float line = sin(uv.y * 800.0 * uLineThickness) * 0.5 + 0.5;
    line = mix(1.0, line, uLineIntensity);

    float noise =
        (rand(vec2(uTime, uv.y * 1000.0)) - 0.5) * uNoiseIntensity;

    vec3 colorValue = base * line + noise;

    gl_FragColor = vec4(colorValue, tex.a);
}
`,uniforms:{uTime:{value:0,type:"f32"},uLineThickness:{value:2,type:"f32"},uLineIntensity:{value:.6,type:"f32"},uNoiseIntensity:{value:.05,type:"f32"},uLineColor:{value:[.8,1,.8],type:"vec3<f32>"}}},hdr:{label:"HDR",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uExposure;
uniform float uSaturation;
uniform float uContrast;

vec3 adjustSaturation(vec3 color, float sat) {
    float grey = dot(color, vec3(0.299, 0.587, 0.114));
    return mix(vec3(grey), color, sat);
}

vec3 adjustContrast(vec3 color, float contrast) {
    return (color - 0.5) * contrast + 0.5;
}

void main() {
    vec2 uv = vTextureCoord;

    vec4 tex = texture2D(uTexture, uv);
    vec3 color = tex.rgb;
    color *= uExposure;

    color = adjustSaturation(color, uSaturation);

    color = adjustContrast(color, uContrast);

    color = color / (color + vec3(1.0));

    gl_FragColor = vec4(color, tex.a);
}
`,uniforms:{uExposure:{value:1.2,type:"f32"},uSaturation:{value:4.3,type:"f32"},uContrast:{value:2.2,type:"f32"}}},blackFlash:{label:"Black Flash",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uIntensity;
uniform float uDuration;

void main() {
    vec2 uv = vTextureCoord;
    vec4 base = texture2D(uTexture, uv);

    float flash = smoothstep(0.0, uDuration * 0.5, mod(uTime, uDuration)) *
                  (1.0 - smoothstep(uDuration * 0.5, uDuration, mod(uTime, uDuration)));

    flash *= uIntensity;

    vec3 color = mix(base.rgb, vec3(0.0), flash);

    gl_FragColor = vec4(color, base.a);
}
`,uniforms:{uTime:{value:0,type:"f32"},uIntensity:{value:.7,type:"f32"},uDuration:{value:.2,type:"f32"}}},brightPulse:{label:"Bright Pulse",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uPulseScale;  
uniform float uBlurStrength; 
uniform float uGlowBoost; 

vec4 blur3(sampler2D tex, vec2 uv, float s) {
    vec4 c = vec4(0.0);
    c += texture2D(tex, uv + vec2(-s, -s)) * 0.0625;
    c += texture2D(tex, uv + vec2( 0.0, -s)) * 0.125;
    c += texture2D(tex, uv + vec2( s, -s)) * 0.0625;
    c += texture2D(tex, uv + vec2(-s,  0.0)) * 0.125;
    c += texture2D(tex, uv) * 0.25;
    c += texture2D(tex, uv + vec2( s,  0.0)) * 0.125;
    c += texture2D(tex, uv + vec2(-s,  s)) * 0.0625;
    c += texture2D(tex, uv + vec2( 0.0,  s)) * 0.125;
    c += texture2D(tex, uv + vec2( s,  s)) * 0.0625;
    return c * uGlowBoost;
}

void main() {
    vec2 uv = vTextureCoord;

    float scale = 1.0 + uPulseScale * (0.5 + 0.5 * sin(uTime * 3.0));
    vec2 center = vec2(0.28,0.48); 
    vec2 uvScaled = (uv - center) / scale + center;
    uvScaled = clamp(uvScaled, 0.0, 1.0);
    vec4 base = texture2D(uTexture, uvScaled);
    vec4 blurred = blur3(uTexture, uvScaled, uBlurStrength);
    vec4 colorValue = mix(base, blurred, 0.8);

    gl_FragColor = colorValue;
}
`,uniforms:{uTime:{value:0,type:"f32"},uPulseScale:{value:.2,type:"f32"},uBlurStrength:{value:.02,type:"f32"},uGlowBoost:{value:2,type:"f32"}}},negativeDivision:{label:"Negative Division",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uIntensity; // 0  original, 1  negativo completo
uniform float uContrast;  // fuerza de contraste

void main() {
    vec2 uv = vTextureCoord;
    vec4 color = texture2D(uTexture, uv);
    vec3 negative = 1.0 - color.rgb;

    vec3 contrasted = (negative - 0.5) * uContrast + 0.5;

    float maskedIntensity = uIntensity * color.a;

    vec3 colorValue =
        mix(color.rgb, contrasted, maskedIntensity);

    gl_FragColor = vec4(colorValue, color.a);
}
`,uniforms:{uIntensity:{value:1,type:"f32"},uContrast:{value:2.5,type:"f32"}}},cameraMove:{label:"Camera Move",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;
uniform float uIntensity;
uniform float uSpeed;

float rand(float x){
    return fract(sin(x * 12.9898) * 43758.5453);
}

vec2 shakeOffset(float time){
    float x = (rand(time * 0.7) - 0.5) * uIntensity;
    float y = (rand(time * 1.3 + 10.0) - 0.5) * uIntensity;
    return vec2(x, y);
}

void main() {
    vec2 uv = vTextureCoord;

    vec2 offset = shakeOffset(uTime * uSpeed);

    vec2 uvMoved = clamp(uv + offset, 0.0, 1.0);

    vec4 color = texture2D(uTexture, uvMoved);

    gl_FragColor = color;
}

`,uniforms:{uTime:{value:0,type:"f32"},uIntensity:{value:1,type:"f32"},uSpeed:{value:1,type:"f32"}}},hdrV2:{label:"HDR V2",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uExposure;
uniform float uBloom;
uniform float uContrast;

vec3 tonemapReinhard(vec3 color){
    return color / (color + vec3(1.0));
}

void main() {
    vec2 uv = vTextureCoord;
    vec4 tex = texture2D(uTexture, uv);

    if (tex.a < 0.01) {
        gl_FragColor = tex;
        return;
    }

    vec3 color = tex.rgb;

    vec3 bright = max(color - 0.6, 0.0) * uBloom;
    bright = tonemapReinhard(bright);

    vec3 hdrColor = color + bright * 0.6;

    hdrColor *= uExposure;

    hdrColor = (hdrColor - 0.5) * uContrast + 0.5;

    hdrColor = clamp(hdrColor, 0.0, 1.0);

    gl_FragColor = vec4(hdrColor, tex.a);
}
`,uniforms:{uExposure:{value:1,type:"f32"},uBloom:{value:1.5,type:"f32"},uContrast:{value:2,type:"f32"}}},fastZoom:{label:"Fast Zoom",fragment:`
precision highp float;

varying vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform float uTime;       
uniform float uZoomSpeed;  
uniform float uMaxZoom;    
uniform float uBlurStrength; 

vec4 blur3(sampler2D tex, vec2 uv, float s) {
    vec4 c = vec4(0.0);
    c += texture2D(tex, uv + vec2(-s, -s)) * 0.0625;
    c += texture2D(tex, uv + vec2( 0.0, -s)) * 0.125;
    c += texture2D(tex, uv + vec2( s, -s)) * 0.0625;
    c += texture2D(tex, uv + vec2(-s,  0.0)) * 0.125;
    c += texture2D(tex, uv) * 0.25;
    c += texture2D(tex, uv + vec2( s,  0.0)) * 0.125;
    c += texture2D(tex, uv + vec2(-s,  s)) * 0.0625;
    c += texture2D(tex, uv + vec2( 0.0,  s)) * 0.125;
    c += texture2D(tex, uv + vec2( s,  s)) * 0.0625;
    return c;
}

void main() {
    vec2 uv = vTextureCoord;
    vec2 center = vec2(0.28,0.48); 

    float zoom = 1.0 + (uMaxZoom - 1.0) * smoothstep(0.0, 1.0, sin(uTime * uZoomSpeed));

    vec2 uvZoomed = (uv - center) / zoom + center;

    uvZoomed = clamp(uvZoomed, 0.0, 1.0);

    vec4 color = texture2D(uTexture, uvZoomed);

    if (uBlurStrength > 0.0) {
        vec4 blurred = blur3(uTexture, uvZoomed, uBlurStrength);
        color = mix(color, blurred, 0.5);
    }

    gl_FragColor = color;
}
`,uniforms:{uTime:{value:0,type:"f32"},uZoomSpeed:{value:5,type:"f32"},uMaxZoom:{value:2,type:"f32"},uBlurStrength:{value:.01,type:"f32"}}}}},sk=Object.entries(sf).map(([i,e])=>({key:i,label:e.label,previewStatic:`https://cdn.subgen.co/previews/effects/static/effect_${i}_static.webp`,previewDynamic:`https://cdn.subgen.co/previews/effects/dynamic/effect_${i}_dynamic.webp`}));function rf({name:i,renderer:e}){let t;const s=Object.keys(sf).find(u=>u.toLowerCase()===i.toLowerCase());s&&(t=sf[s]);const{fragment:r,uniforms:n,label:o}=t,a=new Be,l=Ge.create({width:e.width,height:e.height}),c=new It({vertex:HR,fragment:r,name:`${o}-shader`}),h=new Gi({glProgram:c,resources:{effectUniforms:{...n}}});return a.filters=[h],{filter:h,render({width:u,height:d,canvasTexture:f,progress:m}){(l.width!==u||l.height!==d)&&l.resize(u,d);const g=f instanceof Ge?f:k.from(f);a.texture=g,a.width=u,a.height=d;const p=h.resources.effectUniforms.uniforms;return p.uTime=m,e.render({container:a,target:l,clear:!0}),l}}}function rk(i,e){const{opacity:t,zIndex:s,flip:r,left:n,top:o,width:a,height:l,angle:c}=i;e.x=n,e.y=o,e.width=Math.abs(a),e.height=Math.abs(l),e.angle=c,e.alpha=t,e.zIndex=s,r==="horizontal"?e.scale.x=-Math.abs(e.scale.x):r==="vertical"&&(e.scale.y=-Math.abs(e.scale.y))}class gn{constructor(e,t,s=null){this.sprite=t,this.targetContainer=s,!s&&e&&(this.targetContainer=e.stage),this.resolution=e?.renderer?.resolution??1,this.canvas=new OffscreenCanvas(1,1);const r=this.canvas.getContext("2d");if(r==null)throw new Error("Failed to create 2d context for PixiSpriteRenderer");this.context=r,this.root=new se,this.root.visible=!1,this.targetContainer&&this.targetContainer.addChild(this.root)}pixiSprite=null;texture=null;canvas;context;root=null;strokeGraphics=null;maskGraphics=null;shadowGraphics=null;shadowContainer=null;resolution=1;destroyed=!1;async updateFrame(e){if(this.destroyed)return;if(e==null){this.root!=null&&(this.root.visible=!1,this.applySpriteTransforms());return}if(e instanceof k){if(e.width===0||e.height===0){console.warn("PixiSpriteRenderer: Invalid texture dimensions",e.width,e.height);return}this.pixiSprite==null?(this.pixiSprite=new Be(e),this.pixiSprite.label="MainSprite",this.root.addChild(this.pixiSprite),this.applySpriteTransforms()):this.pixiSprite.texture=e,this.root!=null&&(this.root.visible=!0,this.applySpriteTransforms());return}if(e.width===0||e.height===0){console.warn("PixiSpriteRenderer: Invalid frame dimensions",e.width,e.height);return}const t=this.texture==null||this.pixiSprite==null;if(this.canvas.width!==e.width||this.canvas.height!==e.height||t){if(this.canvas.width=e.width,this.canvas.height=e.height,this.texture!=null&&(this.texture.destroy(!0),this.texture=null),this.texture=k.from(this.canvas),!this.texture||!this.texture.source){console.error("PixiSpriteRenderer: Failed to create valid texture");return}this.pixiSprite==null?(this.pixiSprite=new Be(this.texture),this.pixiSprite.label="MainSprite",this.root.addChild(this.pixiSprite),this.applySpriteTransforms()):this.pixiSprite.texture=this.texture}if(this.context.clearRect(0,0,this.canvas.width,this.canvas.height),this.context.drawImage(e,0,0),this.texture!=null&&this.texture.source!=null){const r=this.texture.source;if(r.resource){const n=r.resource;n.update&&n.update()}typeof r.update=="function"&&r.update()}this.root!=null&&(this.root.visible=!0,this.applySpriteTransforms())}applySpriteTransforms(){if(this.pixiSprite==null||this.root==null||this.destroyed)return;const{flip:e,center:t,width:s,height:r,angle:n,opacity:o,zIndex:a}=this.sprite;this.root.x=t.x,this.root.y=t.y,this.root.angle=(e==null?1:-1)*n,this.root.alpha=o,this.root.zIndex=a,this.root.scale.set(1,1),this.pixiSprite.anchor.set(.5,.5),this.pixiSprite.position.set(0,0);const l=this.pixiSprite.texture?.width??1,c=this.pixiSprite.texture?.height??1,h=s&&s!==0?Math.abs(s)/l:1,u=r&&r!==0?Math.abs(r)/c:1;e==="horizontal"?(this.pixiSprite.scale.x=-h,this.pixiSprite.scale.y=u):e==="vertical"?(this.pixiSprite.scale.x=h,this.pixiSprite.scale.y=-u):(this.pixiSprite.scale.x=h,this.pixiSprite.scale.y=u),this.applyStyle()}applyStyle(){if(this.pixiSprite==null||this.destroyed)return;const e=this.sprite.style||{},t=this.pixiSprite.texture?.width??0,s=this.pixiSprite.texture?.height??0;if(t===0||s===0)return;const r=e.borderRadius||0;r>0?(this.maskGraphics==null&&(this.maskGraphics=new _e,this.pixiSprite.addChild(this.maskGraphics),this.pixiSprite.mask=this.maskGraphics),this.maskGraphics.clear(),this.maskGraphics.roundRect(-t/2,-s/2,t,s,Math.min(r,t/2,s/2)),this.maskGraphics.fill({color:16777215,alpha:1}),this.maskGraphics.visible=!0):this.maskGraphics&&(this.maskGraphics.visible=!1,this.pixiSprite.mask=null),this.sprite.type!=="Text"&&this.sprite.type!=="Caption"?this.applyStroke(e,t,s):this.strokeGraphics&&(this.strokeGraphics.visible=!1),this.sprite.type!=="Text"&&this.sprite.type!=="Caption"?this.applyShadow(e):this.shadowContainer&&(this.shadowContainer.visible=!1,this.shadowContainer.filters=[])}applyStroke(e,t,s){const r=e.stroke;if(r&&r.width>0){this.strokeGraphics==null&&(this.strokeGraphics=new _e,this.pixiSprite.addChild(this.strokeGraphics)),this.strokeGraphics.clear();const n=Te(r.color)??16777215,o=r.width,a=e.borderRadius||0;if(this.strokeGraphics.setStrokeStyle({width:o,color:n,alignment:1}),a>0){const l=Math.min(a,t/2,s/2);this.strokeGraphics.roundRect(-t/2,-s/2,t,s,l)}else this.strokeGraphics.rect(-t/2,-s/2,t,s);this.strokeGraphics.stroke(),this.strokeGraphics.visible=!0}else this.strokeGraphics!=null&&(this.strokeGraphics.visible=!1)}applyShadow(e){const t=e.dropShadow,s=Math.abs(this.sprite.width??0),r=Math.abs(this.sprite.height??0);if(t&&s>0&&r>0&&(t.blur>0||t.distance>0)){this.shadowContainer==null&&(this.shadowContainer=new se,this.shadowContainer.label="ShadowContainer",this.shadowGraphics=new _e,this.shadowContainer.addChild(this.shadowGraphics),this.root.addChildAt(this.shadowContainer,0));const n=Te(t.color)??0,o=t.alpha??.5,a=t.blur??0,l=t.distance??0,c=t.angle??0,h=Math.cos(c)*l,u=Math.sin(c)*l;this.shadowContainer.position.set(h,u),this.shadowGraphics.clear();const d=e.borderRadius||0;if(d>0){const f=Math.min(d,s/2,r/2);this.shadowGraphics.roundRect(-s/2,-r/2,s,r,f)}else this.shadowGraphics.rect(-s/2,-r/2,s,r);if(this.shadowGraphics.fill({color:n,alpha:o}),a>0){(!this.shadowContainer.filters||this.shadowContainer.filters.length===0)&&(this.shadowContainer.filters=[new y0]);const f=this.shadowContainer.filters[0],m=this.root?Math.sqrt(this.root.worldTransform.a**2+this.root.worldTransform.b**2):1;f.strength=a*m,f.resolution=this.resolution,f.padding=Math.max(a*2*m,20)}else this.shadowContainer.filters=[];this.shadowContainer.visible=!0}else this.shadowContainer!=null&&(this.shadowContainer.visible=!1,this.shadowContainer.filters=[])}updateTransforms(){this.root!=null&&!this.destroyed&&this.applySpriteTransforms()}getSprite(){return this.pixiSprite}getRoot(){return this.root}destroy(){this.destroyed||(this.destroyed=!0,this.root!=null&&(this.root.parent&&this.root.parent.removeChild(this.root),this.root.destroy({children:!0}),this.root=null,this.pixiSprite=null),this.strokeGraphics!=null&&(this.strokeGraphics.destroy(),this.strokeGraphics=null),this.maskGraphics!=null&&(this.maskGraphics.destroy(),this.maskGraphics=null),this.shadowGraphics!=null&&(this.shadowGraphics.destroy(),this.shadowGraphics=null),this.shadowContainer!=null&&(this.shadowContainer.destroy({children:!0}),this.shadowContainer=null),this.texture!=null&&(this.texture.destroy(),this.texture=null))}}function Xs(i,e=!1){return i.toJSON(e)}async function Ys(i){let e,t=null;switch(i.type){case"Video":t=ke;break;case"Audio":t=je;break;case"Image":t=ze;break;case"Text":t=xt;break;case"Caption":t=ti;break;case"Effect":t=ut;break;case"Transition":t=xi;break;case"Placeholder":t=mn;break}if(t&&typeof t.fromObject=="function")return await t.fromObject(i);switch(i.type){case"Video":{const s=await fetch(i.src);if(!s.ok)throw new Error(`Failed to fetch video from ${i.src}: ${s.status} ${s.statusText}. Make sure the file exists in the public directory.`);const r=i.audio!==void 0?{audio:i.audio,volume:i.volume}:{volume:i.volume};e=new ke(s.body,r,i.src);break}case"Audio":{if(!i.src||i.src.trim()==="")throw new Error("AudioClip requires a valid source URL");const s={};i.loop!==void 0&&(s.loop=i.loop),i.volume!==void 0&&(s.volume=i.volume),e=await je.fromUrl(i.src,s);break}case"Image":{if(!i.src||i.src.trim()==="")throw new Error("ImageClip requires a valid source URL. Generated clips (like text-to-image) cannot be loaded from JSON without their source data.");try{const s=await fetch(i.src);if(!s.ok)throw new Error(`Failed to fetch image from ${i.src}: ${s.status} ${s.statusText}. Make sure the file exists in the public directory.`);const r=await s.blob();if(!r.type.startsWith("image/"))throw new Error(`Invalid image format: ${r.type}. Expected an image file.`);e=new ze(await createImageBitmap(r),i.src)}catch(s){throw s instanceof Error&&s.message.includes("could not be decoded")?new Error(`Failed to decode image from ${i.src}. The image may be corrupted, in an unsupported format, or there may be CORS issues.`):s}break}case"Text":{const s=i.text||"",r=i.style||{},n={fontSize:r.fontSize,fontFamily:r.fontFamily,fontWeight:r.fontWeight,fontStyle:r.fontStyle,fill:r.color,align:r.align};r.stroke&&(n.stroke=r.stroke.color,n.strokeWidth=r.stroke.width),r.shadow&&(n.dropShadow={color:r.shadow.color,alpha:r.shadow.alpha,blur:r.shadow.blur,distance:r.shadow.distance,angle:r.shadow.angle}),e=new xt(s,n);break}case"Caption":{const s=i.text||"",r=i.style||{},n={fontSize:r.fontSize,fontFamily:r.fontFamily,fontWeight:r.fontWeight,fontStyle:r.fontStyle,fill:r.color,align:r.align};if(r.fontUrl!==void 0?n.fontUrl=r.fontUrl:i.fontUrl!==void 0&&(n.fontUrl=i.fontUrl),r.stroke&&(n.stroke=r.stroke.color,n.strokeWidth=r.stroke.width),r.shadow&&(n.dropShadow={color:r.shadow.color,alpha:r.shadow.alpha,blur:r.shadow.blur,distance:r.shadow.distance,angle:r.shadow.angle}),i.caption){const o=i.caption;o.words&&(n.words=o.words),o.colors&&(o.colors.appeared!==void 0&&(n.appearedColor=o.colors.appeared),o.colors.active!==void 0&&(n.activeColor=o.colors.active),o.colors.activeFill!==void 0&&(n.activeFillColor=o.colors.activeFill),o.colors.background!==void 0&&(n.backgroundColor=o.colors.background),o.colors.keyword!==void 0&&(n.isKeyWordColor=o.colors.keyword)),o.preserveKeywordColor!==void 0&&(n.preservedColorKeyWord=o.preserveKeywordColor),o.positioning&&(o.positioning.bottomOffset!==void 0&&(n.bottomOffset=o.positioning.bottomOffset),o.positioning.videoWidth!==void 0&&(n.videoWidth=o.positioning.videoWidth),o.positioning.videoHeight!==void 0&&(n.videoHeight=o.positioning.videoHeight))}else i.bottomOffset!==void 0&&(n.bottomOffset=i.bottomOffset),i.words&&(n.words=i.words),i.appearedColor!==void 0&&(n.appearedColor=i.appearedColor),i.activeColor!==void 0&&(n.activeColor=i.activeColor),i.activeFillColor!==void 0&&(n.activeFillColor=i.activeFillColor),i.backgroundColor!==void 0&&(n.backgroundColor=i.backgroundColor),i.isKeyWordColor!==void 0&&(n.isKeyWordColor=i.isKeyWordColor),i.preservedColorKeyWord!==void 0&&(n.preservedColorKeyWord=i.preservedColorKeyWord),i.videoWidth!==void 0&&(n.videoWidth=i.videoWidth),i.videoHeight!==void 0&&(n.videoHeight=i.videoHeight);i.mediaId&&(n.mediaId=i.mediaId),e=new ti(s,n);break}case"Effect":{e=new ut(i.effect.key),e.effect=i.effect;break}default:throw new Error(`Unsupported clip type: ${i.type}`)}return e.left=i.left,e.top=i.top,e.width=i.width,e.height=i.height,e.angle=i.angle,e.display.from=i.display.from,e.display.to=i.display.to,e.duration=i.duration,e.playbackRate=i.playbackRate,e.zIndex=i.zIndex,e.opacity=i.opacity,e.flip=i.flip,i.style&&(e.style={...e.style,...i.style}),i.animation&&e.setAnimation(i.animation.keyFrames,i.animation.opts),i.id&&(e.id=i.id),i.effects&&(e.effects=i.effects),i.trim&&(e.trim.from=i.trim.from<1e6?i.trim.from*1e6:i.trim.from,e.trim.to=i.trim.to<1e6?i.trim.to*1e6:i.trim.to),e}var nf,Dx;function nk(){return Dx||(Dx=1,nf=[{name:"Bounce",paramsTypes:{shadow_colour:"vec4",shadow_height:"float",bounces:"float"},defaultParams:{shadow_colour:[0,0,0,.6],shadow_height:.075,bounces:3},glsl:`// Author: Adrian Purser
// License: MIT

uniform vec4 shadow_colour; // = vec4(0.,0.,0.,.6)
uniform float shadow_height; // = 0.075
uniform float bounces; // = 3.0

const float PI = 3.14159265358;

vec4 transition (vec2 uv) {
  float time = progress;
  float stime = sin(time * PI / 2.);
  float phase = time * PI * bounces;
  float y = (abs(cos(phase))) * (1.0 - stime);
  float d = uv.y - y;
  return mix(
    mix(
      getToColor(uv),
      shadow_colour,
      step(d, shadow_height) * (1. - mix(
        ((d / shadow_height) * shadow_colour.a) + (1.0 - shadow_colour.a),
        1.0,
        smoothstep(0.95, 1., progress) // fade-out the shadow at the end
      ))
    ),
    getFromColor(vec2(uv.x, uv.y + (1.0 - y))),
    step(d, 0.0)
  );
}
`,author:"Adrian Purser",license:"MIT",createdAt:"Fri, 10 Nov 2017 17:01:45 +0000",updatedAt:"Sat, 11 Nov 2017 08:50:40 +0100"},{name:"BowTieHorizontal",paramsTypes:{},defaultParams:{},glsl:`// Author: huynx
// License: MIT

vec2 bottom_left = vec2(0.0, 1.0);
vec2 bottom_right = vec2(1.0, 1.0);
vec2 top_left = vec2(0.0, 0.0);
vec2 top_right = vec2(1.0, 0.0);
vec2 center = vec2(0.5, 0.5);

float check(vec2 p1, vec2 p2, vec2 p3)
{
  return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
}

bool PointInTriangle (vec2 pt, vec2 p1, vec2 p2, vec2 p3)
{
    bool b1, b2, b3;
    b1 = check(pt, p1, p2) < 0.0;
    b2 = check(pt, p2, p3) < 0.0;
    b3 = check(pt, p3, p1) < 0.0;
    return ((b1 == b2) && (b2 == b3));
}

bool in_left_triangle(vec2 p){
  vec2 vertex1, vertex2, vertex3;
  vertex1 = vec2(progress, 0.5);
  vertex2 = vec2(0.0, 0.5-progress);
  vertex3 = vec2(0.0, 0.5+progress);
  if (PointInTriangle(p, vertex1, vertex2, vertex3))
  {
    return true;
  }
  return false;
}

bool in_right_triangle(vec2 p){
  vec2 vertex1, vertex2, vertex3;
  vertex1 = vec2(1.0-progress, 0.5);
  vertex2 = vec2(1.0, 0.5-progress);
  vertex3 = vec2(1.0, 0.5+progress);
  if (PointInTriangle(p, vertex1, vertex2, vertex3))
  {
    return true;
  }
  return false;
}

float blur_edge(vec2 bot1, vec2 bot2, vec2 top, vec2 testPt)
{
  vec2 lineDir = bot1 - top;
  vec2 perpDir = vec2(lineDir.y, -lineDir.x);
  vec2 dirToPt1 = bot1 - testPt;
  float dist1 = abs(dot(normalize(perpDir), dirToPt1));
  
  lineDir = bot2 - top;
  perpDir = vec2(lineDir.y, -lineDir.x);
  dirToPt1 = bot2 - testPt;
  float min_dist = min(abs(dot(normalize(perpDir), dirToPt1)), dist1);
  
  if (min_dist < 0.005) {
    return min_dist / 0.005;
  }
  else  {
    return 1.0;
  };
}


vec4 transition (vec2 uv) {
  if (in_left_triangle(uv))
  {
    if (progress < 0.1)
    {
      return getFromColor(uv);
    }
    if (uv.x < 0.5)
    {
      vec2 vertex1 = vec2(progress, 0.5);
      vec2 vertex2 = vec2(0.0, 0.5-progress);
      vec2 vertex3 = vec2(0.0, 0.5+progress);
      return mix(
        getFromColor(uv),
        getToColor(uv),
        blur_edge(vertex2, vertex3, vertex1, uv)
      );
    }
    else
    {
      if (progress > 0.0)
      {
        return getToColor(uv);
      }
      else
      {
        return getFromColor(uv);
      }
    }    
  }
  else if (in_right_triangle(uv))
  {
    if (uv.x >= 0.5)
    {
      vec2 vertex1 = vec2(1.0-progress, 0.5);
      vec2 vertex2 = vec2(1.0, 0.5-progress);
      vec2 vertex3 = vec2(1.0, 0.5+progress);
      return mix(
        getFromColor(uv),
        getToColor(uv),
        blur_edge(vertex2, vertex3, vertex1, uv)
      );  
    }
    else
    {
      return getFromColor(uv);
    }
  }
  else {
    return getFromColor(uv);
  }
}`,author:"huynx",license:"MIT",createdAt:"Sat, 24 Mar 2018 12:54:26 +0100",updatedAt:"Sat, 24 Mar 2018 12:54:26 +0100"},{name:"BowTieVertical",paramsTypes:{},defaultParams:{},glsl:`// Author: huynx\r
// License: MIT\r
\r
float check(vec2 p1, vec2 p2, vec2 p3)\r
{\r
  return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\r
}\r
\r
bool PointInTriangle (vec2 pt, vec2 p1, vec2 p2, vec2 p3)\r
{\r
    bool b1, b2, b3;\r
    b1 = check(pt, p1, p2) < 0.0;\r
    b2 = check(pt, p2, p3) < 0.0;\r
    b3 = check(pt, p3, p1) < 0.0;\r
    return ((b1 == b2) && (b2 == b3));\r
}\r
\r
bool in_top_triangle(vec2 p){\r
  vec2 vertex1, vertex2, vertex3;\r
  vertex1 = vec2(0.5, progress);\r
  vertex2 = vec2(0.5-progress, 0.0);\r
  vertex3 = vec2(0.5+progress, 0.0);\r
  if (PointInTriangle(p, vertex1, vertex2, vertex3))\r
  {\r
    return true;\r
  }\r
  return false;\r
}\r
\r
bool in_bottom_triangle(vec2 p){\r
  vec2 vertex1, vertex2, vertex3;\r
  vertex1 = vec2(0.5, 1.0 - progress);\r
  vertex2 = vec2(0.5-progress, 1.0);\r
  vertex3 = vec2(0.5+progress, 1.0);\r
  if (PointInTriangle(p, vertex1, vertex2, vertex3))\r
  {\r
    return true;\r
  }\r
  return false;\r
}\r
\r
float blur_edge(vec2 bot1, vec2 bot2, vec2 top, vec2 testPt)\r
{\r
  vec2 lineDir = bot1 - top;\r
  vec2 perpDir = vec2(lineDir.y, -lineDir.x);\r
  vec2 dirToPt1 = bot1 - testPt;\r
  float dist1 = abs(dot(normalize(perpDir), dirToPt1));\r
  \r
  lineDir = bot2 - top;\r
  perpDir = vec2(lineDir.y, -lineDir.x);\r
  dirToPt1 = bot2 - testPt;\r
  float min_dist = min(abs(dot(normalize(perpDir), dirToPt1)), dist1);\r
  \r
  if (min_dist < 0.005) {\r
    return min_dist / 0.005;\r
  }\r
  else  {\r
    return 1.0;\r
  };\r
}\r
\r
\r
vec4 transition (vec2 uv) {\r
  if (in_top_triangle(uv))\r
  {\r
    if (progress < 0.1)\r
    {\r
      return getFromColor(uv);\r
    }\r
    if (uv.y < 0.5)\r
    {\r
      vec2 vertex1 = vec2(0.5, progress);\r
      vec2 vertex2 = vec2(0.5-progress, 0.0);\r
      vec2 vertex3 = vec2(0.5+progress, 0.0);\r
      return mix(\r
        getFromColor(uv),\r
        getToColor(uv),\r
        blur_edge(vertex2, vertex3, vertex1, uv)\r
      );\r
    }\r
    else\r
    {\r
      if (progress > 0.0)\r
      {\r
        return getToColor(uv);\r
      }\r
      else\r
      {\r
        return getFromColor(uv);\r
      }\r
    }    \r
  }\r
  else if (in_bottom_triangle(uv))\r
  {\r
    if (uv.y >= 0.5)\r
    {\r
      vec2 vertex1 = vec2(0.5, 1.0-progress);\r
      vec2 vertex2 = vec2(0.5-progress, 1.0);\r
      vec2 vertex3 = vec2(0.5+progress, 1.0);\r
      return mix(\r
        getFromColor(uv),\r
        getToColor(uv),\r
        blur_edge(vertex2, vertex3, vertex1, uv)\r
      );  \r
    }\r
    else\r
    {\r
      return getFromColor(uv);\r
    }\r
  }\r
  else {\r
    return getFromColor(uv);\r
  }\r
}`,author:"huynx",license:"MIT",createdAt:"Tue, 27 Mar 2018 10:07:54 +0700",updatedAt:"Tue, 27 Mar 2018 10:07:54 +0700"},{name:"ButterflyWaveScrawler",paramsTypes:{amplitude:"float",waves:"float",colorSeparation:"float"},defaultParams:{amplitude:1,waves:30,colorSeparation:.3},glsl:`// Author: mandubian
// License: MIT
uniform float amplitude; // = 1.0
uniform float waves; // = 30.0
uniform float colorSeparation; // = 0.3
float PI = 3.14159265358979323846264;
float compute(vec2 p, float progress, vec2 center) {
vec2 o = p*sin(progress * amplitude)-center;
// horizontal vector
vec2 h = vec2(1., 0.);
// butterfly polar function (don't ask me why this one :))
float theta = acos(dot(o, h)) * waves;
return (exp(cos(theta)) - 2.*cos(4.*theta) + pow(sin((2.*theta - PI) / 24.), 5.)) / 10.;
}
vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy;
  float inv = 1. - progress;
  vec2 dir = p - vec2(.5);
  float dist = length(dir);
  float disp = compute(p, progress, vec2(0.5, 0.5)) ;
  vec4 texTo = getToColor(p + inv*disp);
  vec4 texFrom = vec4(
  getFromColor(p + progress*disp*(1.0 - colorSeparation)).r,
  getFromColor(p + progress*disp).g,
  getFromColor(p + progress*disp*(1.0 + colorSeparation)).b,
  1.0);
  return texTo*progress + texFrom*inv;
}
`,author:"mandubian",license:"MIT",createdAt:"Thu, 1 Jun 2017 11:47:17 +0200",updatedAt:"Thu, 1 Jun 2017 11:47:17 +0200"},{name:"CircleCrop",paramsTypes:{bgcolor:"vec4"},defaultParams:{bgcolor:[0,0,0,1]},glsl:`// License: MIT
// Author: fkuteken
// ported by gre from https://gist.github.com/fkuteken/f63e3009c1143950dee9063c3b83fb88

uniform vec4 bgcolor; // = vec4(0.0, 0.0, 0.0, 1.0)

vec2 ratio2 = vec2(1.0, 1.0 / ratio);
float s = pow(2.0 * abs(progress - 0.5), 3.0);

vec4 transition(vec2 p) {
  float dist = length((vec2(p) - 0.5) * ratio2);
  return mix(
    progress < 0.5 ? getFromColor(p) : getToColor(p), // branching is ok here as we statically depend on progress uniform (branching won't change over pixels)
    bgcolor,
    step(s, dist)
  );
}
`,license:"MIT",author:"fkuteken",createdAt:"Mon, 12 Jun 2017 12:52:34 +0800",updatedAt:"Mon, 12 Jun 2017 12:52:34 +0800"},{name:"ColourDistance",paramsTypes:{power:"float"},defaultParams:{power:5},glsl:`// License: MIT
// Author: P-Seebauer
// ported by gre from https://gist.github.com/P-Seebauer/2a5fa2f77c883dd661f9

uniform float power; // = 5.0

vec4 transition(vec2 p) {
  vec4 fTex = getFromColor(p);
  vec4 tTex = getToColor(p);
  float m = step(distance(fTex, tTex), progress);
  return mix(
    mix(fTex, tTex, m),
    tTex,
    pow(progress, power)
  );
}
`,license:"MIT",author:"P-Seebauer",createdAt:"Mon, 12 Jun 2017 12:57:42 +0800",updatedAt:"Mon, 12 Jun 2017 12:57:42 +0800"},{name:"CrazyParametricFun",paramsTypes:{a:"float",b:"float",amplitude:"float",smoothness:"float"},defaultParams:{a:4,b:1,amplitude:120,smoothness:.1},glsl:`// Author: mandubian
// License: MIT

uniform float a; // = 4
uniform float b; // = 1
uniform float amplitude; // = 120
uniform float smoothness; // = 0.1

vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy;
  vec2 dir = p - vec2(.5);
  float dist = length(dir);
  float x = (a - b) * cos(progress) + b * cos(progress * ((a / b) - 1.) );
  float y = (a - b) * sin(progress) - b * sin(progress * ((a / b) - 1.));
  vec2 offset = dir * vec2(sin(progress  * dist * amplitude * x), sin(progress * dist * amplitude * y)) / smoothness;
  return mix(getFromColor(p + offset), getToColor(p), smoothstep(0.2, 1.0, progress));
}
`,author:"mandubian",license:"MIT",createdAt:"Thu, 1 Jun 2017 13:03:12 +0200",updatedAt:"Thu, 1 Jun 2017 13:03:12 +0200"},{name:"CrossZoom",paramsTypes:{strength:"float"},defaultParams:{strength:.4},glsl:`// License: MIT
// Author: rectalogic
// ported by gre from https://gist.github.com/rectalogic/b86b90161503a0023231

// Converted from https://github.com/rectalogic/rendermix-basic-effects/blob/master/assets/com/rendermix/CrossZoom/CrossZoom.frag
// Which is based on https://github.com/evanw/glfx.js/blob/master/src/filters/blur/zoomblur.js
// With additional easing functions from https://github.com/rectalogic/rendermix-basic-effects/blob/master/assets/com/rendermix/Easing/Easing.glsllib

uniform float strength; // = 0.4

const float PI = 3.141592653589793;

float Linear_ease(in float begin, in float change, in float duration, in float time) {
    return change * time / duration + begin;
}

float Exponential_easeInOut(in float begin, in float change, in float duration, in float time) {
    if (time == 0.0)
        return begin;
    else if (time == duration)
        return begin + change;
    time = time / (duration / 2.0);
    if (time < 1.0)
        return change / 2.0 * pow(2.0, 10.0 * (time - 1.0)) + begin;
    return change / 2.0 * (-pow(2.0, -10.0 * (time - 1.0)) + 2.0) + begin;
}

float Sinusoidal_easeInOut(in float begin, in float change, in float duration, in float time) {
    return -change / 2.0 * (cos(PI * time / duration) - 1.0) + begin;
}

float rand (vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 crossFade(in vec2 uv, in float dissolve) {
    return mix(getFromColor(uv).rgb, getToColor(uv).rgb, dissolve);
}

vec4 transition(vec2 uv) {
    vec2 texCoord = uv.xy / vec2(1.0).xy;

    // Linear interpolate center across center half of the image
    vec2 center = vec2(Linear_ease(0.25, 0.5, 1.0, progress), 0.5);
    float dissolve = Exponential_easeInOut(0.0, 1.0, 1.0, progress);

    // Mirrored sinusoidal loop. 0->strength then strength->0
    float strength = Sinusoidal_easeInOut(0.0, strength, 0.5, progress);

    vec3 color = vec3(0.0);
    float total = 0.0;
    vec2 toCenter = center - texCoord;

    /* randomize the lookup values to hide the fixed number of samples */
    float offset = rand(uv);

    for (float t = 0.0; t <= 40.0; t++) {
        float percent = (t + offset) / 40.0;
        float weight = 4.0 * (percent - percent * percent);
        color += crossFade(texCoord + toCenter * percent * strength, dissolve) * weight;
        total += weight;
    }
    return vec4(color / total, 1.0);
}
`,license:"MIT",author:"rectalogic",createdAt:"Mon, 12 Jun 2017 12:33:07 +0800",updatedAt:"Mon, 12 Jun 2017 12:33:07 +0800"},{name:"Directional",paramsTypes:{direction:"vec2"},defaultParams:{direction:[0,1]},glsl:`// Author: Gatan Renaudeau
// License: MIT

uniform vec2 direction; // = vec2(0.0, 1.0)

vec4 transition (vec2 uv) {
  vec2 p = uv + progress * sign(direction);
  vec2 f = fract(p);
  return mix(
    getToColor(f),
    getFromColor(f),
    step(0.0, p.y) * step(p.y, 1.0) * step(0.0, p.x) * step(p.x, 1.0)
  );
}
`,author:"Gatan Renaudeau",license:"MIT",createdAt:"Thu, 19 Apr 2018 12:20:29 +0200",updatedAt:"Thu, 19 Apr 2018 12:20:29 +0200"},{name:"DoomScreenTransition",paramsTypes:{bars:"int",amplitude:"float",noise:"float",frequency:"float",dripScale:"float"},defaultParams:{bars:30,amplitude:2,noise:.1,frequency:.5,dripScale:.5},glsl:`// Author: Zeh Fernando
// License: MIT


// Transition parameters --------

// Number of total bars/columns
uniform int bars; // = 30

// Multiplier for speed ratio. 0 = no variation when going down, higher = some elements go much faster
uniform float amplitude; // = 2

// Further variations in speed. 0 = no noise, 1 = super noisy (ignore frequency)
uniform float noise; // = 0.1

// Speed variation horizontally. the bigger the value, the shorter the waves
uniform float frequency; // = 0.5

// How much the bars seem to "run" from the middle of the screen first (sticking to the sides). 0 = no drip, 1 = curved drip
uniform float dripScale; // = 0.5


// The code proper --------

float rand(int num) {
  return fract(mod(float(num) * 67123.313, 12.0) * sin(float(num) * 10.3) * cos(float(num)));
}

float wave(int num) {
  float fn = float(num) * frequency * 0.1 * float(bars);
  return cos(fn * 0.5) * cos(fn * 0.13) * sin((fn+10.0) * 0.3) / 2.0 + 0.5;
}

float drip(int num) {
  return sin(float(num) / float(bars - 1) * 3.141592) * dripScale;
}

float pos(int num) {
  return (noise == 0.0 ? wave(num) : mix(wave(num), rand(num), noise)) + (dripScale == 0.0 ? 0.0 : drip(num));
}

vec4 transition(vec2 uv) {
  int bar = int(uv.x * (float(bars)));
  float scale = 1.0 + pos(bar) * amplitude;
  float phase = progress * scale;
  float posY = uv.y / vec2(1.0).y;
  vec2 p;
  vec4 c;
  if (phase + posY < 1.0) {
    p = vec2(uv.x, uv.y + mix(0.0, vec2(1.0).y, phase)) / vec2(1.0).xy;
    c = getFromColor(p);
  } else {
    p = uv.xy / vec2(1.0).xy;
    c = getToColor(p);
  }

  // Finally, apply the color
  return c;
}
`,author:"Zeh Fernando",license:"MIT",createdAt:"Tue, 30 May 2017 09:39:09 -0700",updatedAt:"Tue, 30 May 2017 09:39:09 -0700"},{name:"Dreamy",paramsTypes:{},defaultParams:{},glsl:`// Author: mikolalysenko
// License: MIT

vec2 offset(float progress, float x, float theta) {
  float phase = progress*progress + progress + theta;
  float shifty = 0.03*progress*cos(10.0*(progress+x));
  return vec2(0, shifty);
}
vec4 transition(vec2 p) {
  return mix(getFromColor(p + offset(progress, p.x, 0.0)), getToColor(p + offset(1.0-progress, p.x, 3.14)), progress);
}
`,author:"mikolalysenko",license:"MIT",createdAt:"Mon, 12 Jun 2017 12:27:38 +0800",updatedAt:"Mon, 12 Jun 2017 12:27:38 +0800"},{name:"DreamyZoom",paramsTypes:{rotation:"float",scale:"float"},defaultParams:{rotation:6,scale:1.2},glsl:`// Author: Zeh Fernando
// License: MIT

// Definitions --------
#define DEG2RAD 0.03926990816987241548078304229099 // 1/180*PI


// Transition parameters --------

// In degrees
uniform float rotation; // = 6

// Multiplier
uniform float scale; // = 1.2


// The code proper --------

vec4 transition(vec2 uv) {
  // Massage parameters
  float phase = progress < 0.5 ? progress * 2.0 : (progress - 0.5) * 2.0;
  float angleOffset = progress < 0.5 ? mix(0.0, rotation * DEG2RAD, phase) : mix(-rotation * DEG2RAD, 0.0, phase);
  float newScale = progress < 0.5 ? mix(1.0, scale, phase) : mix(scale, 1.0, phase);
  
  vec2 center = vec2(0, 0);

  // Calculate the source point
  vec2 assumedCenter = vec2(0.5, 0.5);
  vec2 p = (uv.xy - vec2(0.5, 0.5)) / newScale * vec2(ratio, 1.0);

  // This can probably be optimized (with distance())
  float angle = atan(p.y, p.x) + angleOffset;
  float dist = distance(center, p);
  p.x = cos(angle) * dist / ratio + 0.5;
  p.y = sin(angle) * dist + 0.5;
  vec4 c = progress < 0.5 ? getFromColor(p) : getToColor(p);

  // Finally, apply the color
  return c + (progress < 0.5 ? mix(0.0, 1.0, phase) : mix(1.0, 0.0, phase));
}
`,author:"Zeh Fernando",license:"MIT",createdAt:"Tue, 30 May 2017 10:44:06 -0700",updatedAt:"Tue, 30 May 2017 10:44:06 -0700"},{name:"GlitchDisplace",paramsTypes:{},defaultParams:{},glsl:`// Author: Matt DesLauriers
// License: MIT

highp float random(vec2 co)
{
    highp float a = 12.9898;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}
float voronoi( in vec2 x ) {
    vec2 p = floor( x );
    vec2 f = fract( x );
    float res = 8.0;
    for( float j=-1.; j<=1.; j++ )
    for( float i=-1.; i<=1.; i++ ) {
        vec2  b = vec2( i, j );
        vec2  r = b - f + random( p + b );
        float d = dot( r, r );
        res = min( res, d );
    }
    return sqrt( res );
}

vec2 displace(vec4 tex, vec2 texCoord, float dotDepth, float textureDepth, float strength) {
    float b = voronoi(.003 * texCoord + 2.0);
    float g = voronoi(0.2 * texCoord);
    float r = voronoi(texCoord - 1.0);
    vec4 dt = tex * 1.0;
    vec4 dis = dt * dotDepth + 1.0 - tex * textureDepth;

    dis.x = dis.x - 1.0 + textureDepth*dotDepth;
    dis.y = dis.y - 1.0 + textureDepth*dotDepth;
    dis.x *= strength;
    dis.y *= strength;
    vec2 res_uv = texCoord ;
    res_uv.x = res_uv.x + dis.x - 0.0;
    res_uv.y = res_uv.y + dis.y;
    return res_uv;
}

float ease1(float t) {
  return t == 0.0 || t == 1.0
    ? t
    : t < 0.5
      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)
      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;
}
float ease2(float t) {
  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);
}



vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy;
  vec4 color1 = getFromColor(p);
  vec4 color2 = getToColor(p);
  vec2 disp = displace(color1, p, 0.33, 0.7, 1.0-ease1(progress));
  vec2 disp2 = displace(color2, p, 0.33, 0.5, ease2(progress));
  vec4 dColor1 = getToColor(disp);
  vec4 dColor2 = getFromColor(disp2);
  float val = ease1(progress);
  vec3 gray = vec3(dot(min(dColor2, dColor1).rgb, vec3(0.299, 0.587, 0.114)));
  dColor2 = vec4(gray, 1.0);
  dColor2 *= 2.0;
  color1 = mix(color1, dColor2, smoothstep(0.0, 0.5, progress));
  color2 = mix(color2, dColor1, smoothstep(1.0, 0.5, progress));
  return mix(color1, color2, val);
  //gl_FragColor = mix(gl_FragColor, dColor, smoothstep(0.0, 0.5, progress));
  
   //gl_FragColor = mix(texture2D(from, p), texture2D(to, p), progress);
}
`,author:"Matt DesLauriers",license:"MIT",createdAt:"Tue, 30 May 2017 14:53:04 -0400",updatedAt:"Tue, 30 May 2017 14:53:04 -0400"},{name:"GlitchMemories",paramsTypes:{},defaultParams:{},glsl:`// author: Gunnar Roth
// based on work from natewave
// license: MIT
vec4 transition(vec2 p) {
  vec2 block = floor(p.xy / vec2(16));
  vec2 uv_noise = block / vec2(64);
  uv_noise += floor(vec2(progress) * vec2(1200.0, 3500.0)) / vec2(64);
  vec2 dist = progress > 0.0 ? (fract(uv_noise) - 0.5) * 0.3 *(1.0 -progress) : vec2(0.0);
  vec2 red = p + dist * 0.2;
  vec2 green = p + dist * .3;
  vec2 blue = p + dist * .5;

  return vec4(mix(getFromColor(red), getToColor(red), progress).r,mix(getFromColor(green), getToColor(green), progress).g,mix(getFromColor(blue), getToColor(blue), progress).b,1.0);
}

`,author:"Gunnar Roth",license:"MIT",createdAt:"Wed, 21 Feb 2018 00:52:15 +0100",updatedAt:"Wed, 21 Feb 2018 19:32:02 +0100"},{name:"GridFlip",paramsTypes:{size:"ivec2",pause:"float",dividerWidth:"float",bgcolor:"vec4",randomness:"float"},defaultParams:{size:[4,4],pause:.1,dividerWidth:.05,bgcolor:[0,0,0,1],randomness:.1},glsl:`// License: MIT
// Author: TimDonselaar
// ported by gre from https://gist.github.com/TimDonselaar/9bcd1c4b5934ba60087bdb55c2ea92e5

uniform ivec2 size; // = ivec2(4)
uniform float pause; // = 0.1
uniform float dividerWidth; // = 0.05
uniform vec4 bgcolor; // = vec4(0.0, 0.0, 0.0, 1.0)
uniform float randomness; // = 0.1
 
float rand (vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float getDelta(vec2 p) {
  vec2 rectanglePos = floor(vec2(size) * p);
  vec2 rectangleSize = vec2(1.0 / vec2(size).x, 1.0 / vec2(size).y);
  float top = rectangleSize.y * (rectanglePos.y + 1.0);
  float bottom = rectangleSize.y * rectanglePos.y;
  float left = rectangleSize.x * rectanglePos.x;
  float right = rectangleSize.x * (rectanglePos.x + 1.0);
  float minX = min(abs(p.x - left), abs(p.x - right));
  float minY = min(abs(p.y - top), abs(p.y - bottom));
  return min(minX, minY);
}

float getDividerSize() {
  vec2 rectangleSize = vec2(1.0 / vec2(size).x, 1.0 / vec2(size).y);
  return min(rectangleSize.x, rectangleSize.y) * dividerWidth;
}

vec4 transition(vec2 p) {
  if(progress < pause) {
    float currentProg = progress / pause;
    float a = 1.0;
    if(getDelta(p) < getDividerSize()) {
      a = 1.0 - currentProg;
    }
    return mix(bgcolor, getFromColor(p), a);
  }
  else if(progress < 1.0 - pause){
    if(getDelta(p) < getDividerSize()) {
      return bgcolor;
    } else {
      float currentProg = (progress - pause) / (1.0 - pause * 2.0);
      vec2 q = p;
      vec2 rectanglePos = floor(vec2(size) * q);
      
      float r = rand(rectanglePos) - randomness;
      float cp = smoothstep(0.0, 1.0 - r, currentProg);
    
      float rectangleSize = 1.0 / vec2(size).x;
      float delta = rectanglePos.x * rectangleSize;
      float offset = rectangleSize / 2.0 + delta;
      
      p.x = (p.x - offset)/abs(cp - 0.5)*0.5 + offset;
      vec4 a = getFromColor(p);
      vec4 b = getToColor(p);
      
      float s = step(abs(vec2(size).x * (q.x - delta) - 0.5), abs(cp - 0.5));
      return mix(bgcolor, mix(b, a, step(cp, 0.5)), s);
    }
  }
  else {
    float currentProg = (progress - 1.0 + pause) / pause;
    float a = 1.0;
    if(getDelta(p) < getDividerSize()) {
      a = currentProg;
    }
    return mix(bgcolor, getToColor(p), a);
  }
}
`,license:"MIT",author:"TimDonselaar",createdAt:"Mon, 12 Jun 2017 11:32:51 +0800",updatedAt:"Mon, 12 Jun 2017 11:32:51 +0800"},{name:"InvertedPageCurl",paramsTypes:{},defaultParams:{},glsl:`// author: Hewlett-Packard
// license: BSD 3 Clause
// Adapted by Sergey Kosarevsky from:
// http://rectalogic.github.io/webvfx/examples_2transition-shader-pagecurl_8html-example.html

/*
Copyright (c) 2010 Hewlett-Packard Development Company, L.P. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

   * Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following disclaimer
     in the documentation and/or other materials provided with the
     distribution.
   * Neither the name of Hewlett-Packard nor the names of its
     contributors may be used to endorse or promote products derived from
     this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
in vec2 texCoord;
*/

const float MIN_AMOUNT = -0.16;
const float MAX_AMOUNT = 1.5;
float amount = progress * (MAX_AMOUNT - MIN_AMOUNT) + MIN_AMOUNT;

const float PI = 3.141592653589793;

const float scale = 512.0;
const float sharpness = 3.0;

float cylinderCenter = amount;
// 360 degrees * amount
float cylinderAngle = 2.0 * PI * amount;

const float cylinderRadius = 1.0 / PI / 2.0;

vec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation)
{
        float hitPoint = hitAngle / (2.0 * PI);
        point.y = hitPoint;
        return rrotation * point;
}

vec4 antiAlias(vec4 color1, vec4 color2, float distanc)
{
        distanc *= scale;
        if (distanc < 0.0) return color2;
        if (distanc > 2.0) return color1;
        float dd = pow(1.0 - distanc / 2.0, sharpness);
        return ((color2 - color1) * dd) + color1;
}

float distanceToEdge(vec3 point)
{
        float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);
        float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);
        if (point.x < 0.0) dx = -point.x;
        if (point.x > 1.0) dx = point.x - 1.0;
        if (point.y < 0.0) dy = -point.y;
        if (point.y > 1.0) dy = point.y - 1.0;
        if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);
        return min(dx, dy);
}

vec4 seeThrough(float yc, vec2 p, mat3 rotation, mat3 rrotation)
{
        float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);
        vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);
        if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0))
        {
            return getToColor(p);
        }

        if (yc > 0.0) return getFromColor(p);

        vec4 color = getFromColor(point.xy);
        vec4 tcolor = vec4(0.0);

        return antiAlias(color, tcolor, distanceToEdge(point));
}

vec4 seeThroughWithShadow(float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation)
{
        float shadow = distanceToEdge(point) * 30.0;
        shadow = (1.0 - shadow) / 3.0;

        if (shadow < 0.0) shadow = 0.0; else shadow *= amount;

        vec4 shadowColor = seeThrough(yc, p, rotation, rrotation);
        shadowColor.r -= shadow;
        shadowColor.g -= shadow;
        shadowColor.b -= shadow;

        return shadowColor;
}

vec4 backside(float yc, vec3 point)
{
        vec4 color = getFromColor(point.xy);
        float gray = (color.r + color.b + color.g) / 15.0;
        gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));
        color.rgb = vec3(gray);
        return color;
}

vec4 behindSurface(vec2 p, float yc, vec3 point, mat3 rrotation)
{
        float shado = (1.0 - ((-cylinderRadius - yc) / amount * 7.0)) / 6.0;
        shado *= 1.0 - abs(point.x - 0.5);

        yc = (-cylinderRadius - cylinderRadius - yc);

        float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;
        point = hitPoint(hitAngle, yc, point, rrotation);

        if (yc < 0.0 && point.x >= 0.0 && point.y >= 0.0 && point.x <= 1.0 && point.y <= 1.0 && (hitAngle < PI || amount > 0.5))
        {
                shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / (71.0 / 100.0));
                shado *= pow(-yc / cylinderRadius, 3.0);
                shado *= 0.5;
        }
        else
        {
                shado = 0.0;
        }
        return vec4(getToColor(p).rgb - shado, 1.0);
}

vec4 transition(vec2 p) {

  const float angle = 100.0 * PI / 180.0;
        float c = cos(-angle);
        float s = sin(-angle);

        mat3 rotation = mat3( c, s, 0,
                                                                -s, c, 0,
                                                                -0.801, 0.8900, 1
                                                                );
        c = cos(angle);
        s = sin(angle);

        mat3 rrotation = mat3(	c, s, 0,
                                                                        -s, c, 0,
                                                                        0.98500, 0.985, 1
                                                                );

        vec3 point = rotation * vec3(p, 1.0);

        float yc = point.y - cylinderCenter;

        if (yc < -cylinderRadius)
        {
                // Behind surface
                return behindSurface(p,yc, point, rrotation);
        }

        if (yc > cylinderRadius)
        {
                // Flat surface
                return getFromColor(p);
        }

        float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;

        float hitAngleMod = mod(hitAngle, 2.0 * PI);
        if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI/2.0 && amount < 0.0))
        {
                return seeThrough(yc, p, rotation, rrotation);
        }

        point = hitPoint(hitAngle, yc, point, rrotation);

        if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0)
        {
                return seeThroughWithShadow(yc, p, point, rotation, rrotation);
        }

        vec4 color = backside(yc, point);

        vec4 otherColor;
        if (yc < 0.0)
        {
                float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);
                shado *= pow(-yc / cylinderRadius, 3.0);
                shado *= 0.5;
                otherColor = vec4(0.0, 0.0, 0.0, shado);
        }
        else
        {
                otherColor = getFromColor(p);
        }

        color = antiAlias(color, otherColor, cylinderRadius - abs(yc));

        vec4 cl = seeThroughWithShadow(yc, p, point, rotation, rrotation);
        float dist = distanceToEdge(point);

        return antiAlias(color, cl, dist);
}
`,author:"Hewlett-Packard",license:"BSD 3 Clause",createdAt:"Wed, 21 Feb 2018 01:13:49 +0100",updatedAt:"Wed, 21 Feb 2018 16:00:02 +0100"},{name:"LinearBlur",paramsTypes:{intensity:"float"},defaultParams:{intensity:.1},glsl:`// author: gre
// license: MIT
uniform float intensity; // = 0.1
const int passes = 6;

vec4 transition(vec2 uv) {
    vec4 c1 = vec4(0.0);
    vec4 c2 = vec4(0.0);

    float disp = intensity*(0.5-distance(0.5, progress));
    for (int xi=0; xi<passes; xi++)
    {
        float x = float(xi) / float(passes) - 0.5;
        for (int yi=0; yi<passes; yi++)
        {
            float y = float(yi) / float(passes) - 0.5;
            vec2 v = vec2(x,y);
            float d = disp;
            c1 += getFromColor( uv + d*v);
            c2 += getToColor( uv + d*v);
        }
    }
    c1 /= float(passes*passes);
    c2 /= float(passes*passes);
    return mix(c1, c2, progress);
}
`,author:"gre",license:"MIT",createdAt:"Fri, 23 Feb 2018 15:18:22 +0100",updatedAt:"Fri, 23 Feb 2018 15:18:22 +0100"},{name:"Mosaic",paramsTypes:{endx:"int",endy:"int"},defaultParams:{endx:2,endy:-1},glsl:`// License: MIT
// Author: Xaychru
// ported by gre from https://gist.github.com/Xaychru/130bb7b7affedbda9df5

#define PI 3.14159265358979323
#define POW2(X) X*X
#define POW3(X) X*X*X
uniform int endx; // = 2
uniform int endy; // = -1

float Rand(vec2 v) {
  return fract(sin(dot(v.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
vec2 Rotate(vec2 v, float a) {
  mat2 rm = mat2(cos(a), -sin(a),
                 sin(a), cos(a));
  return rm*v;
}
float CosInterpolation(float x) {
  return -cos(x*PI)/2.+.5;
}
vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy - .5;
  vec2 rp = p;
  float rpr = (progress*2.-1.);
  float z = -(rpr*rpr*2.) + 3.;
  float az = abs(z);
  rp *= az;
  rp += mix(vec2(.5, .5), vec2(float(endx) + .5, float(endy) + .5), POW2(CosInterpolation(progress)));
  vec2 mrp = mod(rp, 1.);
  vec2 crp = rp;
  bool onEnd = int(floor(crp.x))==endx&&int(floor(crp.y))==endy;
  if(!onEnd) {
    float ang = float(int(Rand(floor(crp))*4.))*.5*PI;
    mrp = vec2(.5) + Rotate(mrp-vec2(.5), ang);
  }
  if(onEnd || Rand(floor(crp))>.5) {
    return getToColor(mrp);
  } else {
    return getFromColor(mrp);
  }
}
`,license:"MIT",author:"Xaychru",createdAt:"Mon, 12 Jun 2017 10:26:51 +0800",updatedAt:"Mon, 12 Jun 2017 10:26:51 +0800"},{name:"PolkaDotsCurtain",paramsTypes:{dots:"float",center:"vec2"},defaultParams:{dots:20,center:[0,0]},glsl:`// author: bobylito
// license: MIT
const float SQRT_2 = 1.414213562373;
uniform float dots;// = 20.0;
uniform vec2 center;// = vec2(0, 0);

vec4 transition(vec2 uv) {
  bool nextImage = distance(fract(uv * dots), vec2(0.5, 0.5)) < ( progress / distance(uv, center));
  return nextImage ? getToColor(uv) : getFromColor(uv);
}
`,author:"bobylito",license:"MIT",createdAt:"Tue, 20 Feb 2018 23:41:45 +0100",updatedAt:"Tue, 20 Feb 2018 23:41:45 +0100"},{name:"Radial",paramsTypes:{smoothness:"float"},defaultParams:{smoothness:1},glsl:`// License: MIT
// Author: Xaychru
// ported by gre from https://gist.github.com/Xaychru/ce1d48f0ce00bb379750

uniform float smoothness; // = 1.0

const float PI = 3.141592653589;

vec4 transition(vec2 p) {
  vec2 rp = p*2.-1.;
  return mix(
    getToColor(p),
    getFromColor(p),
    smoothstep(0., smoothness, atan(rp.y,rp.x) - (progress-.5) * PI * 2.5)
  );
}
`,license:"MIT",author:"Xaychru",createdAt:"Mon, 12 Jun 2017 10:36:24 +0800",updatedAt:"Mon, 12 Jun 2017 10:36:24 +0800"},{name:"SimpleZoom",paramsTypes:{zoom_quickness:"float"},defaultParams:{zoom_quickness:.8},glsl:`// Author: 0gust1
// License: MIT

uniform float zoom_quickness; // = 0.8
float nQuick = clamp(zoom_quickness,0.2,1.0);

vec2 zoom(vec2 uv, float amount) {
  return 0.5 + ((uv - 0.5) * (1.0-amount));	
}

vec4 transition (vec2 uv) {
  return mix(
    getFromColor(zoom(uv, smoothstep(0.0, nQuick, progress))),
    getToColor(uv),
   smoothstep(nQuick-0.2, 1.0, progress)
  );
}`,author:"0gust1",license:"MIT",createdAt:"Tue, 6 Mar 2018 00:43:47 +0100",updatedAt:"Tue, 6 Mar 2018 00:43:47 +0100"},{name:"StereoViewer",paramsTypes:{zoom:"float",corner_radius:"float"},defaultParams:{zoom:.88,corner_radius:.22},glsl:`// Tunable parameters
// How much to zoom (out) for the effect ~ 0.5 - 1.0
uniform float zoom; // = 0.88
// Corner radius as a fraction of the image height
uniform float corner_radius;  // = 0.22

// author: Ted Schundler
// license: BSD 2 Clause
// Free for use and modification by anyone with credit

// Copyright (c) 2016, Theodore K Schundler
// All rights reserved.

// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

///////////////////////////////////////////////////////////////////////////////
// Stereo Viewer Toy Transition                                              //
//                                                                           //
// Inspired by ViewMaster / Image3D image viewer devices.                    //
// This effect is similar to what you see when you press the device's lever. //
// There is a quick zoom in / out to make the transition 'valid' for GLSL.io //
///////////////////////////////////////////////////////////////////////////////

const vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
const vec2 c00 = vec2(0.0, 0.0); // the four corner points
const vec2 c01 = vec2(0.0, 1.0);
const vec2 c11 = vec2(1.0, 1.0);
const vec2 c10 = vec2(1.0, 0.0);

// Check if a point is within a given corner
bool in_corner(vec2 p, vec2 corner, vec2 radius) {
  // determine the direction we want to be filled
  vec2 axis = (c11 - corner) - corner;

  // warp the point so we are always testing the bottom left point with the
  // circle centered on the origin
  p = p - (corner + axis * radius);
  p *= axis / radius;
  return (p.x > 0.0 && p.y > -1.0) || (p.y > 0.0 && p.x > -1.0) || dot(p, p) < 1.0;
}

// Check all four corners
// return a float for v2 for anti-aliasing?
bool test_rounded_mask(vec2 p, vec2 corner_size) {
  return
      in_corner(p, c00, corner_size) &&
      in_corner(p, c01, corner_size) &&
      in_corner(p, c10, corner_size) &&
      in_corner(p, c11, corner_size);
}

// Screen blend mode - https://en.wikipedia.org/wiki/Blend_modes
// This more closely approximates what you see than linear blending
vec4 screen(vec4 a, vec4 b) {
  return 1.0 - (1.0 - a) * (1.0 -b);
}

// Given RGBA, find a value that when screened with itself
// will yield the original value.
vec4 unscreen(vec4 c) {
  return 1.0 - sqrt(1.0 - c);
}

// Grab a pixel, only if it isn't masked out by the rounded corners
vec4 sample_with_corners_from(vec2 p, vec2 corner_size) {
  p = (p - 0.5) / zoom + 0.5;
  if (!test_rounded_mask(p, corner_size)) {
    return black;
  }
  return unscreen(getFromColor(p));
}

vec4 sample_with_corners_to(vec2 p, vec2 corner_size) {
  p = (p - 0.5) / zoom + 0.5;
  if (!test_rounded_mask(p, corner_size)) {
    return black;
  }
  return unscreen(getToColor(p));
}

// special sampling used when zooming - extra zoom parameter and don't unscreen
vec4 simple_sample_with_corners_from(vec2 p, vec2 corner_size, float zoom_amt) {
  p = (p - 0.5) / (1.0 - zoom_amt + zoom * zoom_amt) + 0.5;
  if (!test_rounded_mask(p, corner_size)) {
    return black;
  }
  return getFromColor(p);
}

vec4 simple_sample_with_corners_to(vec2 p, vec2 corner_size, float zoom_amt) {
  p = (p - 0.5) / (1.0 - zoom_amt + zoom * zoom_amt) + 0.5;
  if (!test_rounded_mask(p, corner_size)) {
    return black;
  }
  return getToColor(p);
}

// Basic 2D affine transform matrix helpers
// These really shouldn't be used in a fragment shader - I should work out the
// the math for a translate & rotate function as a pair of dot products instead

mat3 rotate2d(float angle, float ratio) {
  float s = sin(angle);
  float c = cos(angle);
  return mat3(
    c, s ,0.0,
    -s, c, 0.0,
    0.0, 0.0, 1.0);
}

mat3 translate2d(float x, float y) {
  return mat3(
    1.0, 0.0, 0,
    0.0, 1.0, 0,
    -x, -y, 1.0);
}

mat3 scale2d(float x, float y) {
  return mat3(
    x, 0.0, 0,
    0.0, y, 0,
    0, 0, 1.0);
}

// Split an image and rotate one up and one down along off screen pivot points
vec4 get_cross_rotated(vec3 p3, float angle, vec2 corner_size, float ratio) {
  angle = angle * angle; // easing
  angle /= 2.4; // works out to be a good number of radians

  mat3 center_and_scale = translate2d(-0.5, -0.5) * scale2d(1.0, ratio);
  mat3 unscale_and_uncenter = scale2d(1.0, 1.0/ratio) * translate2d(0.5,0.5);
  mat3 slide_left = translate2d(-2.0,0.0);
  mat3 slide_right = translate2d(2.0,0.0);
  mat3 rotate = rotate2d(angle, ratio);

  mat3 op_a = center_and_scale * slide_right * rotate * slide_left * unscale_and_uncenter;
  mat3 op_b = center_and_scale * slide_left * rotate * slide_right * unscale_and_uncenter;

  vec4 a = sample_with_corners_from((op_a * p3).xy, corner_size);
  vec4 b = sample_with_corners_from((op_b * p3).xy, corner_size);

  return screen(a, b);
}

// Image stays put, but this time move two masks
vec4 get_cross_masked(vec3 p3, float angle, vec2 corner_size, float ratio) {
  angle = 1.0 - angle;
  angle = angle * angle; // easing
  angle /= 2.4;

  vec4 img;

  mat3 center_and_scale = translate2d(-0.5, -0.5) * scale2d(1.0, ratio);
  mat3 unscale_and_uncenter = scale2d(1.0 / zoom, 1.0 / (zoom * ratio)) * translate2d(0.5,0.5);
  mat3 slide_left = translate2d(-2.0,0.0);
  mat3 slide_right = translate2d(2.0,0.0);
  mat3 rotate = rotate2d(angle, ratio);

  mat3 op_a = center_and_scale * slide_right * rotate * slide_left * unscale_and_uncenter;
  mat3 op_b = center_and_scale * slide_left * rotate * slide_right * unscale_and_uncenter;

  bool mask_a = test_rounded_mask((op_a * p3).xy, corner_size);
  bool mask_b = test_rounded_mask((op_b * p3).xy, corner_size);

  if (mask_a || mask_b) {
    img = sample_with_corners_to(p3.xy, corner_size);
    return screen(mask_a ? img : black, mask_b ? img : black);
  } else {
    return black;
  }
}

vec4 transition(vec2 uv) {
  float a;
  vec2 p=uv.xy/vec2(1.0).xy;
  vec3 p3 = vec3(p.xy, 1.0); // for 2D matrix transforms

  // corner is warped to represent to size after mapping to 1.0, 1.0
  vec2 corner_size = vec2(corner_radius / ratio, corner_radius);

  if (progress <= 0.0) {
    // 0.0: start with the base frame always
    return getFromColor(p);
  } else if (progress < 0.1) {
    // 0.0-0.1: zoom out and add rounded corners
    a = progress / 0.1;
    return  simple_sample_with_corners_from(p, corner_size * a, a);
  } else if (progress < 0.48) {
    // 0.1-0.48: Split original image apart
    a = (progress - 0.1)/0.38;
    return get_cross_rotated(p3, a, corner_size, ratio);
  } else if (progress < 0.9) {
    // 0.48-0.52: black
    // 0.52 - 0.9: unmask new image
    return get_cross_masked(p3, (progress - 0.52)/0.38, corner_size, ratio);
  } else if (progress < 1.0) {
    // zoom out and add rounded corners
    a = (1.0 - progress) / 0.1;
    return simple_sample_with_corners_to(p, corner_size * a, a);
  } else {
    // 1.0 end with base frame
    return getToColor(p);
  }
}
`,author:"Ted Schundler",license:"BSD 2 Clause",createdAt:"Tue, 20 Feb 2018 23:20:29 +0100",updatedAt:"Wed, 21 Feb 2018 15:42:00 +0100"},{name:"Swirl",paramsTypes:{},defaultParams:{},glsl:`// License: MIT
// Author: Sergey Kosarevsky
// ( http://www.linderdaum.com )
// ported by gre from https://gist.github.com/corporateshark/cacfedb8cca0f5ce3f7c

vec4 transition(vec2 UV)
{
	float Radius = 1.0;

	float T = progress;

	UV -= vec2( 0.5, 0.5 );

	float Dist = length(UV);

	if ( Dist < Radius )
	{
		float Percent = (Radius - Dist) / Radius;
		float A = ( T <= 0.5 ) ? mix( 0.0, 1.0, T/0.5 ) : mix( 1.0, 0.0, (T-0.5)/0.5 );
		float Theta = Percent * Percent * A * 8.0 * 3.14159;
		float S = sin( Theta );
		float C = cos( Theta );
		UV = vec2( dot(UV, vec2(C, -S)), dot(UV, vec2(S, C)) );
	}
	UV += vec2( 0.5, 0.5 );

	vec4 C0 = getFromColor(UV);
	vec4 C1 = getToColor(UV);

	return mix( C0, C1, T );
}
`,license:"MIT",author:"Sergey Kosarevsky",createdAt:"Mon, 12 Jun 2017 12:38:27 +0800",updatedAt:"Mon, 12 Jun 2017 12:38:27 +0800"},{name:"WaterDrop",paramsTypes:{amplitude:"float",speed:"float"},defaultParams:{amplitude:30,speed:30},glsl:`// author: Pawe Pciennik
// license: MIT
uniform float amplitude; // = 30
uniform float speed; // = 30

vec4 transition(vec2 p) {
  vec2 dir = p - vec2(.5);
  float dist = length(dir);

  if (dist > progress) {
    return mix(getFromColor( p), getToColor( p), progress);
  } else {
    vec2 offset = dir * sin(dist * amplitude - progress * speed);
    return mix(getFromColor( p + offset), getToColor( p), progress);
  }
}
`,author:"Pawe Pciennik",license:"MIT",createdAt:"Wed, 21 Feb 2018 19:37:15 +0100",updatedAt:"Wed, 21 Feb 2018 19:37:15 +0100"},{name:"ZoomInCircles",paramsTypes:{},defaultParams:{},glsl:`// License: MIT
// Author: dycm8009
// ported by gre from https://gist.github.com/dycm8009/948e99b1800e81ad909a

vec2 zoom(vec2 uv, float amount) {
  return 0.5 + ((uv - 0.5) * amount);	
}

vec2 ratio2 = vec2(1.0, 1.0 / ratio);

vec4 transition(vec2 uv) {
  // TODO: some timing are hardcoded but should be one or many parameters
  // TODO: should also be able to configure how much circles
  // TODO: if() branching should be avoided when possible, prefer use of step() & other functions
  vec2 r = 2.0 * ((vec2(uv.xy) - 0.5) * ratio2);
  float pro = progress / 0.8;
  float z = pro * 0.2;
  float t = 0.0;
  if (pro > 1.0) {
    z = 0.2 + (pro - 1.0) * 5.;
    t = clamp((progress - 0.8) / 0.07, 0.0, 1.0);
  }
  if (length(r) < 0.5+z) {
    // uv = zoom(uv, 0.9 - 0.1 * pro);
  }
  else if (length(r) < 0.8+z*1.5) {
    uv = zoom(uv, 1.0 - 0.15 * pro);
    t = t * 0.5;
  }
  else if (length(r) < 1.2+z*2.5) {
    uv = zoom(uv, 1.0 - 0.2 * pro);
    t = t * 0.2;
  }
  else {
    uv = zoom(uv, 1.0 - 0.25 * pro);
  }
  return mix(getFromColor(uv), getToColor(uv), t);
}
`,license:"MIT",author:"dycm8009",createdAt:"Mon, 12 Jun 2017 11:24:34 +0800",updatedAt:"Mon, 12 Jun 2017 11:24:34 +0800"},{name:"angular",paramsTypes:{startingAngle:"float"},defaultParams:{startingAngle:90},glsl:`// Author: Fernando Kuteken
// License: MIT

#define PI 3.141592653589

uniform float startingAngle; // = 90;

vec4 transition (vec2 uv) {
  
  float offset = startingAngle * PI / 180.0;
  float angle = atan(uv.y - 0.5, uv.x - 0.5) + offset;
  float normalizedAngle = (angle + PI) / (2.0 * PI);
  
  normalizedAngle = normalizedAngle - floor(normalizedAngle);

  return mix(
    getFromColor(uv),
    getToColor(uv),
    step(normalizedAngle, progress)
    );
}
`,author:"Fernando Kuteken",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"burn",paramsTypes:{color:"vec3"},defaultParams:{color:[.9,.4,.2]},glsl:`// author: gre
// License: MIT
uniform vec3 color /* = vec3(0.9, 0.4, 0.2) */;
vec4 transition (vec2 uv) {
  return mix(
    getFromColor(uv) + vec4(progress*color, 1.0),
    getToColor(uv) + vec4((1.0-progress)*color, 1.0),
    progress
  );
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"cannabisleaf",paramsTypes:{},defaultParams:{},glsl:`// Author: @Flexi23
// License: MIT

// inspired by http://www.wolframalpha.com/input/?i=cannabis+curve

vec4 transition (vec2 uv) {
  if(progress == 0.0){
    return getFromColor(uv);
  }
  vec2 leaf_uv = (uv - vec2(0.5))/10./pow(progress,3.5);
	leaf_uv.y += 0.35;
	float r = 0.18;
	float o = atan(leaf_uv.y, leaf_uv.x);
  return mix(getFromColor(uv), getToColor(uv), 1.-step(1. - length(leaf_uv)+r*(1.+sin(o))*(1.+0.9 * cos(8.*o))*(1.+0.1*cos(24.*o))*(0.9+0.05*cos(200.*o)), 1.));
}
`,author:"@Flexi23",license:"MIT",createdAt:"Thu, 1 Jun 2017 15:58:58 +0200",updatedAt:"Thu, 1 Jun 2017 15:58:58 +0200"},{name:"circle",paramsTypes:{center:"vec2",backColor:"vec3"},defaultParams:{center:[.5,.5],backColor:[.1,.1,.1]},glsl:`// Author: Fernando Kuteken
// License: MIT

uniform vec2 center; // = vec2(0.5, 0.5);
uniform vec3 backColor; // = vec3(0.1, 0.1, 0.1);

vec4 transition (vec2 uv) {
  
  float distance = length(uv - center);
  float radius = sqrt(8.0) * abs(progress - 0.5);
  
  if (distance > radius) {
    return vec4(backColor, 1.0);
  }
  else {
    if (progress < 0.5) return getFromColor(uv);
    else return getToColor(uv);
  }
}
`,author:"Fernando Kuteken",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"circleopen",paramsTypes:{smoothness:"float",opening:"bool"},defaultParams:{smoothness:.3,opening:!0},glsl:`// author: gre
// License: MIT
uniform float smoothness; // = 0.3
uniform bool opening; // = true

const vec2 center = vec2(0.5, 0.5);
const float SQRT_2 = 1.414213562373;

vec4 transition (vec2 uv) {
  float x = opening ? progress : 1.-progress;
  float m = smoothstep(-smoothness, 0.0, SQRT_2*distance(center, uv) - x*(1.+smoothness));
  return mix(getFromColor(uv), getToColor(uv), opening ? 1.-m : m);
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"colorphase",paramsTypes:{fromStep:"vec4",toStep:"vec4"},defaultParams:{fromStep:[0,.2,.4,0],toStep:[.6,.8,1,1]},glsl:`// Author: gre
// License: MIT

// Usage: fromStep and toStep must be in [0.0, 1.0] range 
// and all(fromStep) must be < all(toStep)

uniform vec4 fromStep; // = vec4(0.0, 0.2, 0.4, 0.0)
uniform vec4 toStep; // = vec4(0.6, 0.8, 1.0, 1.0)

vec4 transition (vec2 uv) {
  vec4 a = getFromColor(uv);
  vec4 b = getToColor(uv);
  return mix(a, b, smoothstep(fromStep, toStep, vec4(progress)));
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"crosshatch",paramsTypes:{center:"vec2",threshold:"float",fadeEdge:"float"},defaultParams:{center:[.5,.5],threshold:3,fadeEdge:.1},glsl:`// License: MIT
// Author: pthrasher
// adapted by gre from https://gist.github.com/pthrasher/04fd9a7de4012cbb03f6

uniform vec2 center; // = vec2(0.5)
uniform float threshold; // = 3.0
uniform float fadeEdge; // = 0.1

float rand(vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
vec4 transition(vec2 p) {
  float dist = distance(center, p) / threshold;
  float r = progress - min(rand(vec2(p.y, 0.0)), rand(vec2(0.0, p.x)));
  return mix(getFromColor(p), getToColor(p), mix(0.0, mix(step(dist, r), 1.0, smoothstep(1.0-fadeEdge, 1.0, progress)), smoothstep(0.0, fadeEdge, progress)));    
}
`,license:"MIT",author:"pthrasher",createdAt:"Mon, 12 Jun 2017 10:02:12 +0800",updatedAt:"Mon, 12 Jun 2017 10:02:12 +0800"},{name:"crosswarp",paramsTypes:{},defaultParams:{},glsl:`// Author: Eke Pter <peterekepeter@gmail.com>
// License: MIT
vec4 transition(vec2 p) {
  float x = progress;
  x=smoothstep(.0,1.0,(x*2.0+p.x-1.0));
  return mix(getFromColor((p-.5)*(1.-x)+.5), getToColor((p-.5)*x+.5), x);
}
`,author:"Eke Pter <peterekepeter@gmail.com>",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"cube",paramsTypes:{persp:"float",unzoom:"float",reflection:"float",floating:"float"},defaultParams:{persp:.7,unzoom:.3,reflection:.4,floating:3},glsl:`// Author: gre
// License: MIT
uniform float persp; // = 0.7
uniform float unzoom; // = 0.3
uniform float reflection; // = 0.4
uniform float floating; // = 3.0

vec2 project (vec2 p) {
  return p * vec2(1.0, -1.2) + vec2(0.0, -floating/100.);
}

bool inBounds (vec2 p) {
  return all(lessThan(vec2(0.0), p)) && all(lessThan(p, vec2(1.0)));
}

vec4 bgColor (vec2 p, vec2 pfr, vec2 pto) {
  vec4 c = vec4(0.0, 0.0, 0.0, 1.0);
  pfr = project(pfr);
  // FIXME avoid branching might help perf!
  if (inBounds(pfr)) {
    c += mix(vec4(0.0), getFromColor(pfr), reflection * mix(1.0, 0.0, pfr.y));
  }
  pto = project(pto);
  if (inBounds(pto)) {
    c += mix(vec4(0.0), getToColor(pto), reflection * mix(1.0, 0.0, pto.y));
  }
  return c;
}

// p : the position
// persp : the perspective in [ 0, 1 ]
// center : the xcenter in [0, 1] \\ 0.5 excluded
vec2 xskew (vec2 p, float persp, float center) {
  float x = mix(p.x, 1.0-p.x, center);
  return (
    (
      vec2( x, (p.y - 0.5*(1.0-persp) * x) / (1.0+(persp-1.0)*x) )
      - vec2(0.5-distance(center, 0.5), 0.0)
    )
    * vec2(0.5 / distance(center, 0.5) * (center<0.5 ? 1.0 : -1.0), 1.0)
    + vec2(center<0.5 ? 0.0 : 1.0, 0.0)
  );
}

vec4 transition(vec2 op) {
  float uz = unzoom * 2.0*(0.5-distance(0.5, progress));
  vec2 p = -uz*0.5+(1.0+uz) * op;
  vec2 fromP = xskew(
    (p - vec2(progress, 0.0)) / vec2(1.0-progress, 1.0),
    1.0-mix(progress, 0.0, persp),
    0.0
  );
  vec2 toP = xskew(
    p / vec2(progress, 1.0),
    mix(pow(progress, 2.0), 1.0, persp),
    1.0
  );
  // FIXME avoid branching might help perf!
  if (inBounds(fromP)) {
    return getFromColor(fromP);
  }
  else if (inBounds(toP)) {
    return getToColor(toP);
  }
  return bgColor(op, fromP, toP);
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"directionalwarp",paramsTypes:{direction:"vec2"},defaultParams:{direction:[-1,1]},glsl:`// Author: pschroen
// License: MIT

uniform vec2 direction; // = vec2(-1.0, 1.0)

const float smoothness = 0.5;
const vec2 center = vec2(0.5, 0.5);

vec4 transition (vec2 uv) {
  vec2 v = normalize(direction);
  v /= abs(v.x) + abs(v.y);
  float d = v.x * center.x + v.y * center.y;
  float m = 1.0 - smoothstep(-smoothness, 0.0, v.x * uv.x + v.y * uv.y - (d - 0.5 + progress * (1.0 + smoothness)));
  return mix(getFromColor((uv - 0.5) * (1.0 - m) + 0.5), getToColor((uv - 0.5) * m + 0.5), m);
}
`,author:"pschroen",license:"MIT",createdAt:"Wed, 13 Dec 2017 12:08:49 -0500",updatedAt:"Wed, 13 Dec 2017 12:08:49 -0500"},{name:"directionalwipe",paramsTypes:{direction:"vec2",smoothness:"float"},defaultParams:{direction:[1,-1],smoothness:.5},glsl:`// Author: gre
// License: MIT

uniform vec2 direction; // = vec2(1.0, -1.0)
uniform float smoothness; // = 0.5
 
const vec2 center = vec2(0.5, 0.5);
 
vec4 transition (vec2 uv) {
  vec2 v = normalize(direction);
  v /= abs(v.x)+abs(v.y);
  float d = v.x * center.x + v.y * center.y;
  float m =
    (1.0-step(progress, 0.0)) * // there is something wrong with our formula that makes m not equals 0.0 with progress is 0.0
    (1.0 - smoothstep(-smoothness, 0.0, v.x * uv.x + v.y * uv.y - (d-0.5+progress*(1.+smoothness))));
  return mix(getFromColor(uv), getToColor(uv), m);
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"displacement",paramsTypes:{displacementMap:"sampler2D",strength:"float"},defaultParams:{displacementMap:null,strength:.5},glsl:`// Author: Travis Fischer
// License: MIT
//
// Adapted from a Codrops article by Robin Delaporte
// https://tympanus.net/Development/DistortionHoverEffect

uniform sampler2D displacementMap;

uniform float strength; // = 0.5

vec4 transition (vec2 uv) {
  float displacement = texture2D(displacementMap, uv).r * strength;

  vec2 uvFrom = vec2(uv.x + progress * displacement, uv.y);
  vec2 uvTo = vec2(uv.x - (1.0 - progress) * displacement, uv.y);

  return mix(
    getFromColor(uvFrom),
    getToColor(uvTo),
    progress
  );
}
`,author:"Travis Fischer",license:"MIT",createdAt:"Tue, 10 Apr 2018 23:03:38 -0400",updatedAt:"Tue, 10 Apr 2018 23:03:38 -0400"},{name:"doorway",paramsTypes:{reflection:"float",perspective:"float",depth:"float"},defaultParams:{reflection:.4,perspective:.4,depth:3},glsl:`// author: gre
// License: MIT 
uniform float reflection; // = 0.4
uniform float perspective; // = 0.4
uniform float depth; // = 3

const vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
const vec2 boundMin = vec2(0.0, 0.0);
const vec2 boundMax = vec2(1.0, 1.0);

bool inBounds (vec2 p) {
  return all(lessThan(boundMin, p)) && all(lessThan(p, boundMax));
}

vec2 project (vec2 p) {
  return p * vec2(1.0, -1.2) + vec2(0.0, -0.02);
}

vec4 bgColor (vec2 p, vec2 pto) {
  vec4 c = black;
  pto = project(pto);
  if (inBounds(pto)) {
    c += mix(black, getToColor(pto), reflection * mix(1.0, 0.0, pto.y));
  }
  return c;
}


vec4 transition (vec2 p) {
  vec2 pfr = vec2(-1.), pto = vec2(-1.);
  float middleSlit = 2.0 * abs(p.x-0.5) - progress;
  if (middleSlit > 0.0) {
    pfr = p + (p.x > 0.5 ? -1.0 : 1.0) * vec2(0.5*progress, 0.0);
    float d = 1.0/(1.0+perspective*progress*(1.0-middleSlit));
    pfr.y -= d/2.;
    pfr.y *= d;
    pfr.y += d/2.;
  }
  float size = mix(1.0, depth, 1.-progress);
  pto = (p + vec2(-0.5, -0.5)) * vec2(size, size) + vec2(0.5, 0.5);
  if (inBounds(pfr)) {
    return getFromColor(pfr);
  }
  else if (inBounds(pto)) {
    return getToColor(pto);
  }
  else {
    return bgColor(p, pto);
  }
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"fade",paramsTypes:{},defaultParams:{},glsl:`// author: gre
// license: MIT

vec4 transition (vec2 uv) {
  return mix(
    getFromColor(uv),
    getToColor(uv),
    progress
  );
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"fadecolor",paramsTypes:{color:"vec3",colorPhase:"float"},defaultParams:{color:[0,0,0],colorPhase:.4},glsl:`// author: gre
// License: MIT
uniform vec3 color;// = vec3(0.0)
uniform float colorPhase/* = 0.4 */; // if 0.0, there is no black phase, if 0.9, the black phase is very important
vec4 transition (vec2 uv) {
  return mix(
    mix(vec4(color, 1.0), getFromColor(uv), smoothstep(1.0-colorPhase, 0.0, progress)),
    mix(vec4(color, 1.0), getToColor(uv), smoothstep(    colorPhase, 1.0, progress)),
    progress);
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"fadegrayscale",paramsTypes:{intensity:"float"},defaultParams:{intensity:.3},glsl:`// Author: gre
// License: MIT

uniform float intensity; // = 0.3; // if 0.0, the image directly turn grayscale, if 0.9, the grayscale transition phase is very important
 
vec3 grayscale (vec3 color) {
  return vec3(0.2126*color.r + 0.7152*color.g + 0.0722*color.b);
}
 
vec4 transition (vec2 uv) {
  vec4 fc = getFromColor(uv);
  vec4 tc = getToColor(uv);
  return mix(
    mix(vec4(grayscale(fc.rgb), 1.0), fc, smoothstep(1.0-intensity, 0.0, progress)),
    mix(vec4(grayscale(tc.rgb), 1.0), tc, smoothstep(    intensity, 1.0, progress)),
    progress);
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"flyeye",paramsTypes:{size:"float",zoom:"float",colorSeparation:"float"},defaultParams:{size:.04,zoom:50,colorSeparation:.3},glsl:`// Author: gre
// License: MIT
uniform float size; // = 0.04
uniform float zoom; // = 50.0
uniform float colorSeparation; // = 0.3

vec4 transition(vec2 p) {
  float inv = 1. - progress;
  vec2 disp = size*vec2(cos(zoom*p.x), sin(zoom*p.y));
  vec4 texTo = getToColor(p + inv*disp);
  vec4 texFrom = vec4(
    getFromColor(p + progress*disp*(1.0 - colorSeparation)).r,
    getFromColor(p + progress*disp).g,
    getFromColor(p + progress*disp*(1.0 + colorSeparation)).b,
    1.0);
  return texTo*progress + texFrom*inv;
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"heart",paramsTypes:{},defaultParams:{},glsl:`// Author: gre
// License: MIT

float inHeart (vec2 p, vec2 center, float size) {
  if (size==0.0) return 0.0;
  vec2 o = (p-center)/(1.6*size);
  float a = o.x*o.x+o.y*o.y-0.3;
  return step(a*a*a, o.x*o.x*o.y*o.y*o.y);
}
vec4 transition (vec2 uv) {
  return mix(
    getFromColor(uv),
    getToColor(uv),
    inHeart(uv, vec2(0.5, 0.4), progress)
  );
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"hexagonalize",paramsTypes:{steps:"int",horizontalHexagons:"float"},defaultParams:{steps:50,horizontalHexagons:20},glsl:`// Author: Fernando Kuteken
// License: MIT
// Hexagonal math from: http://www.redblobgames.com/grids/hexagons/

uniform int steps; // = 50;
uniform float horizontalHexagons; //= 20;

struct Hexagon {
  float q;
  float r;
  float s;
};

Hexagon createHexagon(float q, float r){
  Hexagon hex;
  hex.q = q;
  hex.r = r;
  hex.s = -q - r;
  return hex;
}

Hexagon roundHexagon(Hexagon hex){
  
  float q = floor(hex.q + 0.5);
  float r = floor(hex.r + 0.5);
  float s = floor(hex.s + 0.5);

  float deltaQ = abs(q - hex.q);
  float deltaR = abs(r - hex.r);
  float deltaS = abs(s - hex.s);

  if (deltaQ > deltaR && deltaQ > deltaS)
    q = -r - s;
  else if (deltaR > deltaS)
    r = -q - s;
  else
    s = -q - r;

  return createHexagon(q, r);
}

Hexagon hexagonFromPoint(vec2 point, float size) {
  
  point.y /= ratio;
  point = (point - 0.5) / size;
  
  float q = (sqrt(3.0) / 3.0) * point.x + (-1.0 / 3.0) * point.y;
  float r = 0.0 * point.x + 2.0 / 3.0 * point.y;

  Hexagon hex = createHexagon(q, r);
  return roundHexagon(hex);
  
}

vec2 pointFromHexagon(Hexagon hex, float size) {
  
  float x = (sqrt(3.0) * hex.q + (sqrt(3.0) / 2.0) * hex.r) * size + 0.5;
  float y = (0.0 * hex.q + (3.0 / 2.0) * hex.r) * size + 0.5;
  
  return vec2(x, y * ratio);
}

vec4 transition (vec2 uv) {
  
  float dist = 2.0 * min(progress, 1.0 - progress);
  dist = steps > 0 ? ceil(dist * float(steps)) / float(steps) : dist;
  
  float size = (sqrt(3.0) / 3.0) * dist / horizontalHexagons;
  
  vec2 point = dist > 0.0 ? pointFromHexagon(hexagonFromPoint(uv, size), size) : uv;

  return mix(getFromColor(point), getToColor(point), progress);
  
}
`,author:"Fernando Kuteken",license:"MIT",createdAt:"Tue, 30 May 2017 21:55:47 -0300",updatedAt:"Tue, 30 May 2017 21:55:47 -0300"},{name:"kaleidoscope",paramsTypes:{speed:"float",angle:"float",power:"float"},defaultParams:{speed:1,angle:1,power:1.5},glsl:`// Author: nwoeanhinnogaehr
// License: MIT

uniform float speed; // = 1.0;
uniform float angle; // = 1.0;
uniform float power; // = 1.5;

vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy;
  vec2 q = p;
  float t = pow(progress, power)*speed;
  p = p -0.5;
  for (int i = 0; i < 7; i++) {
    p = vec2(sin(t)*p.x + cos(t)*p.y, sin(t)*p.y - cos(t)*p.x);
    t += angle;
    p = abs(mod(p, 2.0) - 1.0);
  }
  abs(mod(p, 1.0));
  return mix(
    mix(getFromColor(q), getToColor(q), progress),
    mix(getFromColor(p), getToColor(p), progress), 1.0 - 2.0*abs(progress - 0.5));
}
`,author:"nwoeanhinnogaehr",license:"MIT",createdAt:"Wed, 31 May 2017 21:48:26 -0400",updatedAt:"Wed, 31 May 2017 21:48:26 -0400"},{name:"luma",paramsTypes:{luma:"sampler2D"},defaultParams:{luma:null},glsl:`// Author: gre
// License: MIT

uniform sampler2D luma;

vec4 transition(vec2 uv) {
  return mix(
    getToColor(uv),
    getFromColor(uv),
    step(progress, texture2D(luma, uv).r)
  );
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"luminance_melt",paramsTypes:{direction:"bool",l_threshold:"float",above:"bool"},defaultParams:{direction:!0,l_threshold:.8,above:!1},glsl:`// Author: 0gust1
// License: MIT
//My own first transition  based on crosshatch code (from pthrasher), using  simplex noise formula (copied and pasted)
//-> cooler with high contrasted images (isolated dark subject on light background f.e.)
//TODO : try to rebase it on DoomTransition (from zeh)?
//optimizations :
//luminance (see http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color#answer-596241)
// Y = (R+R+B+G+G+G)/6
//or Y = (R+R+R+B+G+G+G+G)>>3 


//direction of movement :  0 : up, 1, down
uniform bool direction; // = 1 
//luminance threshold
uniform float l_threshold; // = 0.8 
//does the movement takes effect above or below luminance threshold ?
uniform bool above; // = false 


//Random function borrowed from everywhere
float rand(vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}


// Simplex noise :
// Description : Array and textureless GLSL 2D simplex noise function.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110822 (ijm)
//     License : MIT  
//               2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
// 

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v)
  {
  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                     -0.577350269189626,  // -1.0 + 2.0 * C.x
                      0.024390243902439); // 1.0 / 41.0
// First corner
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);

// Other corners
  vec2 i1;
  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
  //i1.y = 1.0 - i1.x;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  // x0 = x0 - 0.0 + 0.0 * C.xx ;
  // x1 = x0 - i1 + 1.0 * C.xx ;
  // x2 = x0 - 1.0 + 2.0 * C.xx ;
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

// Permutations
  i = mod289(i); // Avoid truncation effects in permutation
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
		+ i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;

// Gradients: 41 points uniformly over a line, mapped onto a diamond.
// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

// Normalise gradients implicitly by scaling m
// Approximation of: m *= inversesqrt( a0*a0 + h*h );
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

// Compute final noise value at P
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

// Simplex noise -- end

float luminance(vec4 color){
  //(0.299*R + 0.587*G + 0.114*B)
  return color.r*0.299+color.g*0.587+color.b*0.114;
}

vec2 center = vec2(1.0, direction);

vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy;
  if (progress == 0.0) {
    return getFromColor(p);
  } else if (progress == 1.0) {
    return getToColor(p);
  } else {
    float x = progress;
    float dist = distance(center, p)- progress*exp(snoise(vec2(p.x, 0.0)));
    float r = x - rand(vec2(p.x, 0.1));
    float m;
    if(above){
     m = dist <= r && luminance(getFromColor(p))>l_threshold ? 1.0 : (progress*progress*progress);
    }
    else{
     m = dist <= r && luminance(getFromColor(p))<l_threshold ? 1.0 : (progress*progress*progress);  
    }
    return mix(getFromColor(p), getToColor(p), m);    
  }
}
`,author:"0gust1",license:"MIT",createdAt:"Wed, 24 Jan 2018 19:02:32 +0100",updatedAt:"Wed, 24 Jan 2018 19:02:32 +0100"},{name:"morph",paramsTypes:{strength:"float"},defaultParams:{strength:.1},glsl:`// Author: paniq
// License: MIT
uniform float strength; // = 0.1

vec4 transition(vec2 p) {
  vec4 ca = getFromColor(p);
  vec4 cb = getToColor(p);
  
  vec2 oa = (((ca.rg+ca.b)*0.5)*2.0-1.0);
  vec2 ob = (((cb.rg+cb.b)*0.5)*2.0-1.0);
  vec2 oc = mix(oa,ob,0.5)*strength;
  
  float w0 = progress;
  float w1 = 1.0-w0;
  return mix(getFromColor(p+oc*w0), getToColor(p-oc*w1), progress);
}
`,author:"paniq",license:"MIT",createdAt:"Thu, 10 Aug 2017 00:27:36 +0200",updatedAt:"Thu, 10 Aug 2017 00:32:01 +0200"},{name:"multiply_blend",paramsTypes:{},defaultParams:{},glsl:`// Author: Fernando Kuteken
// License: MIT

vec4 blend(vec4 a, vec4 b) {
  return a * b;
}

vec4 transition (vec2 uv) {
  
  vec4 blended = blend(getFromColor(uv), getToColor(uv));
  
  if (progress < 0.5)
    return mix(getFromColor(uv), blended, 2.0 * progress);
  else
    return mix(blended, getToColor(uv), 2.0 * progress - 1.0);
}

`,author:"Fernando Kuteken",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"perlin",paramsTypes:{scale:"float",smoothness:"float",seed:"float"},defaultParams:{scale:4,smoothness:.01,seed:12.9898},glsl:`// Author: Rich Harris
// License: MIT

#ifdef GL_ES
precision mediump float;
#endif

uniform float scale; // = 4.0
uniform float smoothness; // = 0.01

uniform float seed; // = 12.9898

// http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
float random(vec2 co)
{
    highp float a = seed;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}

// 2D Noise based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    // Smooth Interpolation

    // Cubic Hermine Curve.  Same as SmoothStep()
    vec2 u = f*f*(3.0-2.0*f);
    // u = smoothstep(0.,1.,f);

    // Mix 4 coorners porcentages
    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

vec4 transition (vec2 uv) {
  vec4 from = getFromColor(uv);
  vec4 to = getToColor(uv);
  float n = noise(uv * scale);
  
  float p = mix(-smoothness, 1.0 + smoothness, progress);
  float lower = p - smoothness;
  float higher = p + smoothness;
  
  float q = smoothstep(lower, higher, n);
  
  return mix(
    from,
    to,
    1.0 - q
  );
}
`,author:"Rich Harris",license:"MIT",createdAt:"Tue, 23 Jan 2018 21:35:10 -0500",updatedAt:"Wed, 24 Jan 2018 07:35:04 -0500"},{name:"pinwheel",paramsTypes:{speed:"float"},defaultParams:{speed:2},glsl:`// Author: Mr Speaker
// License: MIT

uniform float speed; // = 2.0;

vec4 transition(vec2 uv) {
  
  vec2 p = uv.xy / vec2(1.0).xy;
  
  float circPos = atan(p.y - 0.5, p.x - 0.5) + progress * speed;
  float modPos = mod(circPos, 3.1415 / 4.);
  float signed = sign(progress - modPos);
  
  return mix(getToColor(p), getFromColor(p), step(signed, 0.5));
  
}
`,author:"Mr Speaker",license:"MIT",createdAt:"Tue, 30 May 2017 09:04:31 -0400",updatedAt:"Tue, 30 May 2017 09:04:31 -0400"},{name:"pixelize",paramsTypes:{squaresMin:"ivec2",steps:"int"},defaultParams:{squaresMin:[20,20],steps:50},glsl:`// Author: gre
// License: MIT
// forked from https://gist.github.com/benraziel/c528607361d90a072e98

uniform ivec2 squaresMin/* = ivec2(20) */; // minimum number of squares (when the effect is at its higher level)
uniform int steps /* = 50 */; // zero disable the stepping

float d = min(progress, 1.0 - progress);
float dist = steps>0 ? ceil(d * float(steps)) / float(steps) : d;
vec2 squareSize = 2.0 * dist / vec2(squaresMin);

vec4 transition(vec2 uv) {
  vec2 p = dist>0.0 ? (floor(uv / squareSize) + 0.5) * squareSize : uv;
  return mix(getFromColor(p), getToColor(p), progress);
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Wed, 31 May 2017 10:58:26 +0200"},{name:"polar_function",paramsTypes:{segments:"int"},defaultParams:{segments:5},glsl:`// Author: Fernando Kuteken
// License: MIT

#define PI 3.14159265359

uniform int segments; // = 5;

vec4 transition (vec2 uv) {
  
  float angle = atan(uv.y - 0.5, uv.x - 0.5) - 0.5 * PI;
  float normalized = (angle + 1.5 * PI) * (2.0 * PI);
  
  float radius = (cos(float(segments) * angle) + 4.0) / 4.0;
  float difference = length(uv - vec2(0.5, 0.5));
  
  if (difference > radius * progress)
    return getFromColor(uv);
  else
    return getToColor(uv);
}
`,author:"Fernando Kuteken",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"randomsquares",paramsTypes:{size:"ivec2",smoothness:"float"},defaultParams:{size:[10,10],smoothness:.5},glsl:`// Author: gre
// License: MIT

uniform ivec2 size; // = ivec2(10, 10)
uniform float smoothness; // = 0.5
 
float rand (vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec4 transition(vec2 p) {
  float r = rand(floor(vec2(size) * p));
  float m = smoothstep(0.0, -smoothness, r - (progress * (1.0 + smoothness)));
  return mix(getFromColor(p), getToColor(p), m);
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"ripple",paramsTypes:{amplitude:"float",speed:"float"},defaultParams:{amplitude:100,speed:50},glsl:`// Author: gre
// License: MIT
uniform float amplitude; // = 100.0
uniform float speed; // = 50.0

vec4 transition (vec2 uv) {
  vec2 dir = uv - vec2(.5);
  float dist = length(dir);
  vec2 offset = dir * (sin(progress * dist * amplitude - progress * speed) + .5) / 30.;
  return mix(
    getFromColor(uv + offset),
    getToColor(uv),
    smoothstep(0.2, 1.0, progress)
  );
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 15:15:27 +0200",updatedAt:"Tue, 30 May 2017 15:15:27 +0200"},{name:"rotate_scale_fade",paramsTypes:{center:"vec2",rotations:"float",scale:"float",backColor:"vec4"},defaultParams:{center:[.5,.5],rotations:1,scale:8,backColor:[.15,.15,.15,1]},glsl:`// Author: Fernando Kuteken
// License: MIT

#define PI 3.14159265359

uniform vec2 center; // = vec2(0.5, 0.5);
uniform float rotations; // = 1;
uniform float scale; // = 8;
uniform vec4 backColor; // = vec4(0.15, 0.15, 0.15, 1.0);

vec4 transition (vec2 uv) {
  
  vec2 difference = uv - center;
  vec2 dir = normalize(difference);
  float dist = length(difference);
  
  float angle = 2.0 * PI * rotations * progress;
  
  float c = cos(angle);
  float s = sin(angle);
  
  float currentScale = mix(scale, 1.0, 2.0 * abs(progress - 0.5));
  
  vec2 rotatedDir = vec2(dir.x  * c - dir.y * s, dir.x * s + dir.y * c);
  vec2 rotatedUv = center + rotatedDir * dist / currentScale;
  
  if (rotatedUv.x < 0.0 || rotatedUv.x > 1.0 ||
      rotatedUv.y < 0.0 || rotatedUv.y > 1.0)
    return backColor;
    
  return mix(getFromColor(rotatedUv), getToColor(rotatedUv), progress);
}
`,author:"Fernando Kuteken",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"squareswire",paramsTypes:{squares:"ivec2",direction:"vec2",smoothness:"float"},defaultParams:{squares:[10,10],direction:[1,-.5],smoothness:1.6},glsl:`// Author: gre
// License: MIT
 
uniform ivec2 squares;// = ivec2(10,10)
uniform vec2 direction;// = vec2(1.0, -0.5)
uniform float smoothness; // = 1.6

const vec2 center = vec2(0.5, 0.5);
vec4 transition (vec2 p) {
  vec2 v = normalize(direction);
  v /= abs(v.x)+abs(v.y);
  float d = v.x * center.x + v.y * center.y;
  float offset = smoothness;
  float pr = smoothstep(-offset, 0.0, v.x * p.x + v.y * p.y - (d-0.5+progress*(1.+offset)));
  vec2 squarep = fract(p*vec2(squares));
  vec2 squaremin = vec2(pr/2.0);
  vec2 squaremax = vec2(1.0 - pr/2.0);
  float a = (1.0 - step(progress, 0.0)) * step(squaremin.x, squarep.x) * step(squaremin.y, squarep.y) * step(squarep.x, squaremax.x) * step(squarep.y, squaremax.y);
  return mix(getFromColor(p), getToColor(p), a);
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"squeeze",paramsTypes:{colorSeparation:"float"},defaultParams:{colorSeparation:.04},glsl:`// Author: gre
// License: MIT
 
uniform float colorSeparation; // = 0.04
 
vec4 transition (vec2 uv) {
  float y = 0.5 + (uv.y-0.5) / (1.0-progress);
  if (y < 0.0 || y > 1.0) {
     return getToColor(uv);
  }
  else {
    vec2 fp = vec2(uv.x, y);
    vec2 off = progress * vec2(0.0, colorSeparation);
    vec4 c = getFromColor(fp);
    vec4 cn = getFromColor(fp - off);
    vec4 cp = getFromColor(fp + off);
    return vec4(cn.r, c.g, cp.b, c.a);
  }
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"swap",paramsTypes:{reflection:"float",perspective:"float",depth:"float"},defaultParams:{reflection:.4,perspective:.2,depth:3},glsl:`// Author: gre
// License: MIT
// General parameters
uniform float reflection; // = 0.4
uniform float perspective; // = 0.2
uniform float depth; // = 3.0
 
const vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
const vec2 boundMin = vec2(0.0, 0.0);
const vec2 boundMax = vec2(1.0, 1.0);
 
bool inBounds (vec2 p) {
  return all(lessThan(boundMin, p)) && all(lessThan(p, boundMax));
}
 
vec2 project (vec2 p) {
  return p * vec2(1.0, -1.2) + vec2(0.0, -0.02);
}
 
vec4 bgColor (vec2 p, vec2 pfr, vec2 pto) {
  vec4 c = black;
  pfr = project(pfr);
  if (inBounds(pfr)) {
    c += mix(black, getFromColor(pfr), reflection * mix(1.0, 0.0, pfr.y));
  }
  pto = project(pto);
  if (inBounds(pto)) {
    c += mix(black, getToColor(pto), reflection * mix(1.0, 0.0, pto.y));
  }
  return c;
}
 
vec4 transition(vec2 p) {
  vec2 pfr, pto = vec2(-1.);
 
  float size = mix(1.0, depth, progress);
  float persp = perspective * progress;
  pfr = (p + vec2(-0.0, -0.5)) * vec2(size/(1.0-perspective*progress), size/(1.0-size*persp*p.x)) + vec2(0.0, 0.5);
 
  size = mix(1.0, depth, 1.-progress);
  persp = perspective * (1.-progress);
  pto = (p + vec2(-1.0, -0.5)) * vec2(size/(1.0-perspective*(1.0-progress)), size/(1.0-size*persp*(0.5-p.x))) + vec2(1.0, 0.5);

  if (progress < 0.5) {
    if (inBounds(pfr)) {
      return getFromColor(pfr);
    }
    if (inBounds(pto)) {
      return getToColor(pto);
    }  
  }
  if (inBounds(pto)) {
    return getToColor(pto);
  }
  if (inBounds(pfr)) {
    return getFromColor(pfr);
  }
  return bgColor(p, pfr, pto);
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Sun, 18 Feb 2018 17:45:50 +0100"},{name:"undulatingBurnOut",paramsTypes:{smoothness:"float",center:"vec2",color:"vec3"},defaultParams:{smoothness:.03,center:[.5,.5],color:[0,0,0]},glsl:`// License: MIT
// Author: pthrasher
// adapted by gre from https://gist.github.com/pthrasher/8e6226b215548ba12734

uniform float smoothness; // = 0.03
uniform vec2 center; // = vec2(0.5)
uniform vec3 color; // = vec3(0.0)

const float M_PI = 3.14159265358979323846;

float quadraticInOut(float t) {
  float p = 2.0 * t * t;
  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;
}

float getGradient(float r, float dist) {
  float d = r - dist;
  return mix(
    smoothstep(-smoothness, 0.0, r - dist * (1.0 + smoothness)),
    -1.0 - step(0.005, d),
    step(-0.005, d) * step(d, 0.01)
  );
}

float getWave(vec2 p){
  vec2 _p = p - center; // offset from center
  float rads = atan(_p.y, _p.x);
  float degs = degrees(rads) + 180.0;
  vec2 range = vec2(0.0, M_PI * 30.0);
  vec2 domain = vec2(0.0, 360.0);
  float ratio = (M_PI * 30.0) / 360.0;
  degs = degs * ratio;
  float x = progress;
  float magnitude = mix(0.02, 0.09, smoothstep(0.0, 1.0, x));
  float offset = mix(40.0, 30.0, smoothstep(0.0, 1.0, x));
  float ease_degs = quadraticInOut(sin(degs));
  float deg_wave_pos = (ease_degs * magnitude) * sin(x * offset);
  return x + deg_wave_pos;
}

vec4 transition(vec2 p) {
  float dist = distance(center, p);
  float m = getGradient(getWave(p), dist);
  vec4 cfrom = getFromColor(p);
  vec4 cto = getToColor(p);
  return mix(mix(cfrom, cto, m), mix(cfrom, vec4(color, 1.0), 0.75), step(m, -2.0));
}
`,license:"MIT",author:"pthrasher",createdAt:"Mon, 12 Jun 2017 10:23:37 +0800",updatedAt:"Mon, 12 Jun 2017 10:23:37 +0800"},{name:"wind",paramsTypes:{size:"float"},defaultParams:{size:.2},glsl:`// Author: gre
// License: MIT

// Custom parameters
uniform float size; // = 0.2

float rand (vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec4 transition (vec2 uv) {
  float r = rand(vec2(0, uv.y));
  float m = smoothstep(0.0, -size, uv.x*(1.0-size) + size*r - (progress * (1.0 + size)));
  return mix(
    getFromColor(uv),
    getToColor(uv),
    m
  );
}
`,author:"gre",license:"MIT",createdAt:"Tue, 30 May 2017 14:26:44 +0200",updatedAt:"Tue, 30 May 2017 14:26:44 +0200"},{name:"windowblinds",paramsTypes:{},defaultParams:{},glsl:`// Author: Fabien Benetou
// License: MIT

vec4 transition (vec2 uv) {
  float t = progress;
  
  if (mod(floor(uv.y*100.*progress),2.)==0.)
    t*=2.-.5;
  
  return mix(
    getFromColor(uv),
    getToColor(uv),
    mix(t, progress, smoothstep(0.8, 1.0, progress))
  );
}
`,author:"Fabien Benetou",license:"MIT",createdAt:"Wed, 31 May 2017 14:11:48 +0200",updatedAt:"Wed, 31 May 2017 14:11:48 +0200"},{name:"windowslice",paramsTypes:{count:"float",smoothness:"float"},defaultParams:{count:10,smoothness:.5},glsl:`// Author: gre
// License: MIT

uniform float count; // = 10.0
uniform float smoothness; // = 0.5

vec4 transition (vec2 p) {
  float pr = smoothstep(-smoothness, 0.0, p.x - progress * (1.0 + smoothness));
  float s = step(pr, fract(count * p.x));
  return mix(getFromColor(p), getToColor(p), s);
}
`,author:"gre",license:"MIT",createdAt:"Wed, 28 Mar 2018 17:23:26 +0200",updatedAt:"Wed, 28 Mar 2018 17:23:26 +0200"},{name:"wipeDown",paramsTypes:{},defaultParams:{},glsl:`// Author: Jake Nelson
// License: MIT

vec4 transition(vec2 uv) {
  vec2 p=uv.xy/vec2(1.0).xy;
  vec4 a=getFromColor(p);
  vec4 b=getToColor(p);
  return mix(a, b, step(1.0-p.y,progress));
}
`,author:"Jake Nelson",license:"MIT",createdAt:"Wed, 1 Nov 2017 15:26:01 -0500",updatedAt:"Thu, 2 Nov 2017 18:39:26 -0500"},{name:"wipeLeft",paramsTypes:{},defaultParams:{},glsl:`// Author: Jake Nelson
// License: MIT

vec4 transition(vec2 uv) {
  vec2 p=uv.xy/vec2(1.0).xy;
  vec4 a=getFromColor(p);
  vec4 b=getToColor(p);
  return mix(a, b, step(1.0-p.x,progress));
}
`,author:"Jake Nelson",license:"MIT",createdAt:"Wed, 1 Nov 2017 15:26:28 -0500",updatedAt:"Fri, 3 Nov 2017 18:03:50 +0100"},{name:"wipeRight",paramsTypes:{},defaultParams:{},glsl:`// Author: Jake Nelson
// License: MIT

vec4 transition(vec2 uv) {
  vec2 p=uv.xy/vec2(1.0).xy;
  vec4 a=getFromColor(p);
  vec4 b=getToColor(p);
  return mix(a, b, step(0.0+p.x,progress));
}
`,author:"Jake Nelson",license:"MIT",createdAt:"Wed, 1 Nov 2017 15:27:02 -0500",updatedAt:"Thu, 2 Nov 2017 18:40:22 -0500"},{name:"wipeUp",paramsTypes:{},defaultParams:{},glsl:`// Author: Jake Nelson
// License: MIT

vec4 transition(vec2 uv) {
  vec2 p=uv.xy/vec2(1.0).xy;
  vec4 a=getFromColor(p);
  vec4 b=getToColor(p);
  return mix(a, b, step(0.0+p.y,progress));
}
`,author:"Jake Nelson",license:"MIT",createdAt:"Wed, 1 Nov 2017 15:24:36 -0500",updatedAt:"Thu, 2 Nov 2017 18:37:42 -0500"}]),nf}var ok=nk();const Ki=tu(ok),ak=`
	in vec2 aPosition;
	out vec2 _uv;               
	uniform mat3 projectionMatrix;
	uniform vec4 uInputSize;
	uniform vec4 uOutputFrame;
	out vec2 vTextureCoord;
	uniform vec4 uOutputTexture;

	vec4 filterVertexPosition( void )
	{
			vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;

			position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
			position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

			return vec4(position, 0.0, 1.0);
	}

	vec2 filterTextureCoord( void )
	{
	return aPosition * (uOutputFrame.zw * uInputSize.zw);
	}

	void main(void)
	{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vec2 absolute = aPosition * uOutputFrame.zw + uOutputFrame.xy;
	_uv = absolute / uOutputTexture.xy;
	}
`,de={custom:i=>{const e=i.defaultParams||{},t=i.paramsTypes||{};return Object.fromEntries(Object.entries(e).map(([s,r])=>[s,{value:r,type:lk(t[s])}]))},basics:{_fromR:{value:1,type:"f32"},_toR:{value:1,type:"f32"},ratio:{value:1,type:"f32"},progress:{value:0,type:"f32"},customUniform:{value:0,type:"f32"},center:{value:[.5,.5],type:"vec2<f32>"}}},lk=i=>i==="f32"||i==="i32"?i:i==="float"?"f32":`${i}<f32>`,ck=i=>`
	precision highp float;
	in vec2 vTextureCoord;
	in vec2 _uv; // Normalized [0,1] coordinates with center at (0.5, 0.5) for canvas-centered transitions
	uniform sampler2D from, to;
	uniform float progress, ratio, _fromR, _toR;
	uniform float customUniform;
	uniform vec2 center; // Center point of the canvas (0.5, 0.5) - NOT element centers

	vec4 getFromColor(vec2 uv){
		return texture2D(from, .5+(uv-.5)*vec2(max(ratio/_fromR,1.), max(_fromR/ratio,1.)));
	}
	vec4 getToColor(vec2 uv){
		return texture2D(to, .5+(uv-.5)*vec2(max(ratio/_toR,1.), max(_toR/ratio,1.)));
	}

	// Helper function to get distance from canvas center
	float distanceFromCenter(vec2 uv) {
		return distance(uv, center);
	}
	
	// Helper function to get angle from canvas center
	float angleFromCenter(vec2 uv) {
		vec2 centered = uv - center;
		return atan(centered.y, centered.x);
	}
	
	// Helper function to get centered coordinates relative to canvas center
	vec2 getCenteredCoord(vec2 uv) {
		return uv - center; // Coordinates relative to canvas center
	}

	// gl-transition code here
	${i}
	// gl-transition code end

	void main(){
		// Use _uv which is properly normalized to [0,1] range with center at (0.5, 0.5)
		// This ensures transitions are centered on the canvas, not element centers
		vec2 uv = _uv;
		gl_FragColor = transition(uv);
	}
`,hk=`
const float PI = 3.141592653589;

vec4 transition(vec2 p) {
  vec2 rp = p * 2.0 - 1.0;
  float angle = atan(rp.y, rp.x);
  float threshold = (progress - 0.5) * PI * 2.5;
  float mix_factor = smoothstep(0.0, 0.1, angle - threshold);
  return mix(getToColor(p), getFromColor(p), mix_factor);
}
`,uk=`
uniform vec2 gridSize;
uniform float pause;
uniform float dividerWidth;
uniform vec4 bgColor;
uniform float randomness;

float rand(vec2 co) { 
  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

float getDelta(vec2 p) { 
  vec2 rectanglePos = floor(gridSize * p); 
  vec2 rectangleSize = vec2(1.0 / gridSize.x, 1.0 / gridSize.y); 
  float top = rectangleSize.y * (rectanglePos.y + 1.0); 
  float bottom = rectangleSize.y * rectanglePos.y; 
  float left = rectangleSize.x * rectanglePos.x; 
  float right = rectangleSize.x * (rectanglePos.x + 1.0); 
  float minX = min(abs(p.x - left), abs(p.x - right)); 
  float minY = min(abs(p.y - top), abs(p.y - bottom)); 
  return min(minX, minY);
}

float getDividerSize() { 
  vec2 rectangleSize = vec2(1.0 / gridSize.x, 1.0 / gridSize.y); 
  return min(rectangleSize.x, rectangleSize.y) * dividerWidth;
}

vec4 transition(vec2 p) { 
  if (progress < pause) { 
    float currentProg = progress / pause; 
    float a = 1.0; 
    if (getDelta(p) < getDividerSize()) { 
      a = 1.0 - currentProg; 
    } 
    return mix(bgColor, getFromColor(p), a); 
  } 

  if (progress < 1.0 - pause) { 
    if (getDelta(p) < getDividerSize()) { 
      return bgColor; 
    } 

    float currentProg = (progress - pause) / (1.0 - pause * 2.0); 
    vec2 rectanglePos = floor(gridSize * p); 
    float r = rand(rectanglePos) - randomness; 
    float cp = smoothstep(0.0, 1.0 - r, currentProg); 
    float rectangleSize = 1.0 / gridSize.x; 
    float delta = rectanglePos.x * rectangleSize; 
    float offset = rectangleSize * 0.5 + delta; 

    vec2 warped = p; 
    warped.x = (warped.x - offset) / max(abs(cp - 0.5), 0.001) * 0.5 + offset; 

    float s = step(abs(gridSize.x * (p.x - delta) - 0.5), abs(cp - 0.5)); 
    vec4 mixColor = mix(getToColor(warped), getFromColor(warped), step(cp, 0.5)); 
    return mix(bgColor, mixColor, s); 
  } 

  float currentProg = (progress - 1.0 + pause) / pause; 
  float a = 1.0; 
  if (getDelta(p) < getDividerSize()) { 
    a = currentProg; 
  } 
  return mix(bgColor, getToColor(p), a);
}
`,dk={gridSize:{value:[4,4],type:"vec2<f32>"},pause:{value:.1,type:"f32"},dividerWidth:{value:.05,type:"f32"},bgColor:{value:[0,0,0,1],type:"vec4<f32>"},randomness:{value:.1,type:"f32"}},fk=`
uniform vec3 backColor;

vec4 transition(vec2 uv) { 
  float distance = length(uv - center); 
  float radius = sqrt(8.0) * abs(progress - 0.5); 

  if (distance > radius) { 
    return vec4(backColor, 1.0); 
  } else { 
    if (progress < 0.5) return getFromColor(uv); 
    else return getToColor(uv); 
  }
}
`,pk=`
uniform vec2 direction;

vec4 transition(vec2 uv) { 
  vec2 p = uv + progress * sign(direction); 
  vec2 f = fract(p); 
  return mix( 
    getToColor(f), 
    getFromColor(f), 
    step(0.0, p.y) * step(p.y, 1.0) * step(0.0, p.x) * step(p.x, 1.0) 
  );
}
`,mk={direction:{value:[0,1],type:"vec2<f32>"}},gk=`
uniform float smoothness;
uniform vec3 color;

const float M_PI = 3.14159265358979323846;

float quadraticInOut(float t) { 
  float p = 2.0 * t * t; 
  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;
}

float getGradient(float r, float dist) { 
  float d = r - dist; 
  return mix( 
    smoothstep(-smoothness, 0.0, r - dist * (1.0 + smoothness)), 
    -1.0 - step(0.005, d), 
    step(-0.005, d) * step(d, 0.01) 
  );
}

float getWave(vec2 p){ 
  vec2 _p = p - center; // offset from center 
  float rads = atan(_p.y, _p.x); 
  float degs = degrees(rads) + 180.0; 
  vec2 range = vec2(0.0, M_PI * 30.0); 
  vec2 domain = vec2(0.0, 360.0); 
  float ratio = (M_PI * 30.0) / 360.0; 
  degs = degs * ratio; 
  float x = progress; 
  float magnitude = mix(0.02, 0.09, smoothstep(0.0, 1.0, x)); 
  float offset = mix(40.0, 30.0, smoothstep(0.0, 1.0, x)); 
  float ease_degs = quadraticInOut(sin(degs)); 
  float deg_wave_pos = (ease_degs * magnitude) * sin(x * offset); 
  return x + deg_wave_pos;
}

vec4 transition(vec2 p) { 
  float dist = distance(center, p); 
  float m = getGradient(getWave(p), dist); 
  vec4 cfrom = getFromColor(p); 
  vec4 cto = getToColor(p); 
  return mix(mix(cfrom, cto, m), mix(cfrom, vec4(color, 1.0), 0.75), step(m, -2.0));
}
`,_k={smoothness:{value:.1,type:"f32"},center:{value:[.5,.5],type:"vec2<f32>"},color:{value:[1,.5,0],type:"vec3<f32>"}},xk=`
uniform ivec2 squares;
uniform vec2 direction;
uniform float smoothness;

vec4 transition (vec2 p) { 
  vec2 v = normalize(direction); 
  v /= abs(v.x)+abs(v.y); 
  float d = v.x * center.x + v.y * center.y; 
  float offset = smoothness; 
  float pr = smoothstep(-offset, 0.0, v.x * p.x + v.y * p.y - (d-0.5+progress*(1.+offset))); 
  vec2 squarep = fract(p*vec2(squares)); 
  vec2 squaremin = vec2(pr/2.0); 
  vec2 squaremax = vec2(1.0 - pr/2.0); 
  float a = (1.0 - step(progress, 0.0)) * step(squaremin.x, squarep.x) * step(squaremin.y, squarep.y) * step(squarep.x, squaremax.x) * step(squarep.y, squaremax.y); 
  return mix(getFromColor(p), getToColor(p), a);
}
`,vk={squares:{value:[10,10],type:"vec2<i32>"},direction:{value:[1,-.5],type:"vec2<f32>"},smoothness:{value:1.6,type:"f32"}},yk=`
#define PI 3.14159265359

uniform float rotations;
uniform float scale;
uniform vec4 backColor;

vec4 transition (vec2 uv) { 
  vec2 difference = uv - center; 
  vec2 dir = normalize(difference); 
  float dist = length(difference); 

  float angle = 2.0 * PI * rotations * progress; 

  float c = cos(angle); 
  float s = sin(angle); 

  float currentScale = mix(scale, 1.0, 2.0 * abs(progress - 0.5)); 

  vec2 rotatedDir = vec2(dir.x * c - dir.y * s, dir.x * s + dir.y * c); 
  vec2 rotatedUv = center + rotatedDir * dist / currentScale; 

  if (rotatedUv.x < 0.0 || rotatedUv.x > 1.0 || 
      rotatedUv.y < 0.0 || rotatedUv.y > 1.0) 
    return backColor; 

  return mix(getFromColor(rotatedUv), getToColor(rotatedUv), progress);
}
`,bk={center:{value:[.5,.5],type:"vec2<f32>"},rotations:{value:1,type:"f32"},scale:{value:8,type:"f32"},backColor:{value:[.15,.15,.15,1],type:"vec4<f32>"}},Tk=`
uniform ivec2 size;
uniform float smoothness;

float rand (vec2 co) { 
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec4 transition(vec2 p) { 
  float r = rand(floor(vec2(size) * p)); 
  float m = smoothstep(0.0, -smoothness, r - (progress * (1.0 + smoothness))); 
  return mix(getFromColor(p), getToColor(p), m);
}
`,wk={size:{value:[10,10],type:"vec2<i32>"},smoothness:{value:.5,type:"f32"}},Sk=`
#define PI 3.14159265359

uniform int segments;

vec4 transition (vec2 uv) { 
  float angle = atan(uv.y - 0.5, uv.x - 0.5) - 0.5 * PI; 
  float normalized = (angle + 1.5 * PI) * (2.0 * PI); 

  float radius = (cos(float(segments) * angle) + 4.0) / 4.0; 
  float difference = length(uv - vec2(0.5, 0.5)); 

  if (difference > radius * progress) 
    return getFromColor(uv); 
  else 
    return getToColor(uv);
}
`,Ck={segments:{value:5,type:"i32"}},Ak=`
uniform ivec2 squaresMin;
uniform int steps;

vec4 transition(vec2 uv) { 
  float d = min(progress, 1.0 - progress);
  float dist = steps>0 ? ceil(d * float(steps)) / float(steps) : d;
  vec2 squareSize = 2.0 * dist / vec2(squaresMin);
  
  vec2 p = dist>0.0 ? (floor(uv / squareSize) + 0.5) * squareSize : uv; 
  return mix(getFromColor(p), getToColor(p), progress);
}
`,Ek={squaresMin:{value:[20,20],type:"vec2<i32>"},steps:{value:50,type:"i32"}},Ik=`
uniform float scale;
uniform float smoothness;
uniform float seed;

// http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
float random(vec2 co)
{ 
  float a = seed; 
  float b = 78.233; 
  float c = 43758.5453; 
  float dt = dot(co.xy, vec2(a, b)); 
  float sn = mod(dt, 3.14); 
  return fract(sin(sn) * c);
}

// 2D Noise based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise(vec2 st) { 
  vec2 i = floor(st); 
  vec2 f = fract(st); 

  // Four corners in 2D of a tile 
  float a = random(i); 
  float b = random(i + vec2(1.0, 0.0)); 
  float c = random(i + vec2(0.0, 1.0)); 
  float d = random(i + vec2(1.0, 1.0)); 

  //Smooth Interpolation 

  // Cubic Hermine Curve. Same as SmoothStep() 
  vec2 u = f*f*(3.0-2.0*f); 
  // u = smoothstep(0.,1.,f); 

  // Mix 4 coorners percentages 
  return mix(a, b, u.x) + 
         (c - a)* u.y * (1.0 - u.x) + 
         (d - b) * u.x * u.y;
}

vec4 transition (vec2 uv) { 
  vec4 from = getFromColor(uv); 
  vec4 to = getToColor(uv); 
  float n = noise(uv * scale); 

  float p = mix(-smoothness, 1.0 + smoothness, progress); 
  float lower = p - smoothness; 
  float higher = p + smoothness; 

  float q = smoothstep(lower, higher, n); 

  return mix( 
    from, 
    to, 
    1.0 - q 
  );
}
`,Pk={scale:{value:4,type:"f32"},smoothness:{value:.01,type:"f32"},seed:{value:12.9898,type:"f32"}},Rk=`

#define PI 3.14159265358979323846

uniform float spiralTurns;
uniform float spiralWidth;

vec4 transition(vec2 uv) {

    vec2 p = uv - center;

    float r = length(p);
    float angle = atan(p.y, p.x);

    float normalizedAngle = (angle + PI) / (2.0 * PI);

    float spiral = normalizedAngle + r * spiralTurns;
    spiral = fract(spiral);

    float factor = smoothstep(
        progress - spiralWidth,
        progress + spiralWidth,
        spiral
    );
    return mix(
        getToColor(uv),       // ahora aparece primero
        getFromColor(uv),     // aparece despus
        factor
    );
}


`,kk={spiralTurns:{value:1.5,type:"f32"},spiralWidth:{value:.02,type:"f32"}},Mk=`
//direction of movement : 0 : up, 1, down
uniform float direction; // = 1.0 (using float instead of bool for WebGPU)

//luminance threshold
uniform float l_threshold; // = 0.8

//does the movement take effect above or below luminance threshold ?
uniform float above; // = 0.0 (false) (using float instead of bool for WebGPU)

//Random function borrowed from everywhere
float rand(vec2 co){ 
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

// Simplex noise:
// Description : Array and textureless GLSL 2D simplex noise function.
// Author: Ian McEwan, Ashima Arts.
// Maintainer : ijm
// Lastmod: 20110822 (ijm)
// License: MIT
// 2011 Ashima Arts. All rights reserved.
// Distributed under the MIT License. See LICENSE file.
// https://github.com/ashima/webgl-noise

vec3 mod289(vec3 x) { 
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) { 
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) { 
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v) 
{ 
  const vec4 C = vec4(0.211324865405187, // (3.0-sqrt(3.0))/6.0 
                      0.366025403784439, // 0.5*(sqrt(3.0)-1.0) 
                      -0.577350269189626, // -1.0 + 2.0 * C.x 
                      0.024390243902439); // 1.0 / 41.0
  // First corner 
  vec2 i = floor(v + dot(v, C.yy) ); 
  vec2 x0 = v - i + dot(i, C.xx);

  // Other corners 
  vec2 i1; 
  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0 
  //i1.y = 1.0 - i1.x; 
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); 
  // x0 = x0 - 0.0 + 0.0 * C.xx ; 
  // x1 = x0 - i1 + 1.0 * C.xx ; 
  // x2 = x0 - 1.0 + 2.0 * C.xx ; 
  vec4 x12 = x0.xyxy + C.xxzz; 
  x12.xy -= i1;

  //Permutations 
  i = mod289(i); // Avoid truncation effects in permutation 
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) 
                    + i.x + vec3(0.0, i1.x, 1.0 )); 

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0); 
  m = m*m ; 
  m = m*m ;

  // Gradients: 41 points uniformly over a line, mapped onto a diamond.
  // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287) 

  vec3 x = 2.0 * fract(p * C.www) - 1.0; 
  vec3 h = abs(x) - 0.5; 
  vec3 ox = floor(x + 0.5); 
  vec3 a0 = x - ox;

  // Normalize gradients implicitly by scaling m
  // Approximation of: m *= inversesqrt( a0*a0 + h*h ); 
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

  // Compute final noise value at P 
  vec3 g; 
  g.x = a0.x * x0.x + h.x * x0.y; 
  g.yz = a0.yz * x12.xz + h.yz * x12.yw; 
  return 130.0 * dot(m, g);
}

// Simplex noise -- end

float luminance(vec4 color){ 
  //(0.299*R + 0.587*G + 0.114*B) 
  return color.r*0.299+color.g*0.587+color.b*0.114;
}

vec4 transition(vec2 uv) { 
  vec2 p = uv.xy / vec2(1.0).xy; 
  vec2 center = vec2(1.0, direction);
  
  if (progress == 0.0) { 
    return getFromColor(p); 
  } else if (progress == 1.0) { 
    return getToColor(p); 
  } else { 
    float x = progress; 
    float dist = distance(center, p) - progress*exp(snoise(vec2(p.x, 0.0))); 
    float r = x - rand(vec2(p.x, 0.1)); 
    float m; 
    if(above > 0.5){ 
      m = dist <= r && luminance(getFromColor(p))>l_threshold ? 1.0 : (progress*progress*progress); 
    } 
    else{ 
      m = dist <= r && luminance(getFromColor(p))<l_threshold ? 1.0 : (progress*progress*progress); 
    } 
    return mix(getFromColor(p), getToColor(p), m); 
  }
}
`,Fk={direction:{value:1,type:"f32"},l_threshold:{value:.8,type:"f32"},above:{value:0,type:"f32"}},Uk=`
uniform int steps; // = 50
uniform float horizontalHexagons; // = 20.0

struct Hexagon { 
  float q; 
  float r; 
  float s;
};

Hexagon createHexagon(float q, float r){ 
  Hexagon hex; 
  hex.q = q; 
  hex.r = r; 
  hex.s = -q - r; 
  return hex;
}

Hexagon roundHexagon(Hexagon hex){ 
  float q = floor(hex.q + 0.5); 
  float r = floor(hex.r + 0.5); 
  float s = floor(hex.s + 0.5); 

  float deltaQ = abs(q - hex.q); 
  float deltaR = abs(r - hex.r); 
  float deltaS = abs(s - hex.s); 

  if (deltaQ > deltaR && deltaQ > deltaS) 
    q = -r - s; 
  else if (deltaR > deltaS) 
    r = -q - s; 
  else 
    s = -q - r; 

  return createHexagon(q, r);
}

Hexagon hexagonFromPoint(vec2 point, float size) { 
  point.y /= ratio; 
  point = (point - 0.5) / size; 

  float q = (sqrt(3.0) / 3.0) * point.x + (-1.0 / 3.0) * point.y; 
  float r = 0.0 * point.x + 2.0/3.0 * point.y; 

  Hexagon hex = createHexagon(q, r); 
  return roundHexagon(hex);
}

vec2 pointFromHexagon(Hexagon hex, float size) { 
  float x = (sqrt(3.0) * hex.q + (sqrt(3.0) / 2.0) * hex.r) * size + 0.5; 
  float y = (0.0 * hex.q + (3.0/2.0) * hex.r) * size + 0.5; 

  return vec2(x, y * ratio);
}

vec4 transition (vec2 uv) { 
  float dist = 2.0 * min(progress, 1.0 - progress); 
  dist = steps > 0 ? ceil(dist * float(steps)) / float(steps) : dist; 

  float size = (sqrt(3.0) / 3.0) * dist / horizontalHexagons; 

  vec2 point = dist > 0.0 ? pointFromHexagon(hexagonFromPoint(uv, size), size) : uv; 

  return mix(getFromColor(point), getToColor(point), progress);
}
`,Bk={steps:{value:50,type:"i32"},horizontalHexagons:{value:20,type:"f32"}},Ok=`
float inHeart (vec2 p, vec2 center, float size) { 
  if (size==0.0) return 0.0; 
  vec2 o = (p-center)/(1.6*size); 
  o.y = -o.y;
  float a = o.x*o.x+o.y*o.y-0.3; 
  return step(a*a*a, o.x*o.x*o.y*o.y*o.y);
}

vec4 transition (vec2 uv) { 
  return mix( 
    getFromColor(uv), 
    getToColor(uv), 
    inHeart(uv, vec2(0.5, 0.5), progress) 
  );
}
`,Dk={},Gk=`
uniform sampler2D displacementMap;
uniform float strength; // = 0.5

vec4 transition (vec2 uv) { 
  float displacement = texture2D(displacementMap, uv).r * strength; 

  vec2 uvFrom = vec2(uv.x + progress * displacement, uv.y); 
  vec2 uvTo = vec2(uv.x - (1.0 - progress) * displacement, uv.y); 

  return mix( 
    getFromColor(uvFrom), 
    getToColor(uvTo), 
    progress 
  );
}
`,zk={strength:{value:.5,type:"f32"}},Lk=`
uniform vec2 direction; // = vec2(1.0, -1.0)
uniform float smoothness; // = 0.5

// Note: center is already defined as a uniform in the fragment wrapper

vec4 transition (vec2 uv) {
  vec2 v = normalize(direction);
  v /= abs(v.x)+abs(v.y);
  float d = v.x * center.x + v.y * center.y;
  float m = 
    (1.0-step(progress, 0.0)) * // there is something wrong with our formula that makes m not equals 0.0 with progress is 0.0 
    (1.0 - smoothstep(-smoothness, 0.0, v.x * uv.x + v.y * uv.y - (d-0.5+progress*(1.+smoothness)))); 
  return mix(getFromColor(uv), getToColor(uv), m);
}
`,Nk={direction:{value:[1,-1],type:"vec2<f32>"},smoothness:{value:.5,type:"f32"}},Hk=`
uniform vec2 direction; // = vec2(-1.0, 1.0)

const float smoothness = 0.5;
// Note: center is already defined as a uniform in the fragment wrapper

vec4 transition (vec2 uv) { 
  vec2 v = normalize(direction); 
  v /= abs(v.x) + abs(v.y); 
  float d = v.x * center.x + v.y * center.y; 
  float m = 1.0 - smoothstep(-smoothness, 0.0, v.x * uv.x + v.y * uv.y - (d - 0.5 + progress * (1.0 + smoothness))); 
  return mix(getFromColor((uv - 0.5) * (1.0 - m) + 0.5), getToColor((uv - 0.5) * m + 0.5), m);
}
`,Wk={direction:{value:[-1,1],type:"vec2<f32>"}},Vk=`
uniform float threshold; // = 3.0
uniform float fadeEdge; // = 0.1

// Note: center is already defined as a uniform in the fragment wrapper

float rand(vec2 co) { 
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec4 transition(vec2 p) { 
  float dist = distance(center, p) / threshold; 
  float r = progress - min(rand(vec2(p.y, 0.0)), rand(vec2(0.0, p.x))); 
  return mix(getFromColor(p), getToColor(p), mix(0.0, mix(step(dist, r), 1.0, smoothstep(1.0-fadeEdge, 1.0, progress)), smoothstep(0.0, fadeEdge, progress)));
}
`,$k={threshold:{value:3,type:"f32"},fadeEdge:{value:.1,type:"f32"}},Xk=`
uniform float smoothness; // = 0.3
uniform float opening; // = 1.0 (using float instead of bool for WebGPU: 1.0 = true, 0.0 = false)

// Note: center is already defined as a uniform in the fragment wrapper
const float SQRT_2 = 1.414213562373;

vec4 transition (vec2 uv) { 
  float x = opening > 0.5 ? progress : 1.0 - progress; 
  float m = smoothstep(-smoothness, 0.0, SQRT_2*distance(center, uv) - x*(1.0+smoothness)); 
  return mix(getFromColor(uv), getToColor(uv), opening > 0.5 ? 1.0 - m : m);
}
`,Gx={smoothness:{value:.3,type:"f32"},opening:{value:1,type:"f32"}},Yk=`
vec4 transition (vec2 uv) {
  if(progress == 0.0){
    return getFromColor(uv);
  }
  vec2 leaf_uv = (uv - vec2(0.5))/10.0/pow(progress,3.5);
  leaf_uv.y = -leaf_uv.y;
  leaf_uv.y += 0.35;
  float r = 0.18;
  float o = atan(leaf_uv.y, leaf_uv.x);
  return mix(getFromColor(uv), getToColor(uv), 1.0-step(1.0 - length(leaf_uv)+r*(1.0+sin(o))*(1.0+0.9 * cos(8.0*o))*(1.0+0.1*cos(24.0*o))*(0.9+0.05*cos(200.0*o)), 1.0));
}
`,qk={},Kk=`
uniform float zoom; // = 0.88
uniform float corner_radius; // = 0.22

const vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
const vec2 c00 = vec2(0.0, 0.0);
const vec2 c01 = vec2(0.0, 1.0);
const vec2 c11 = vec2(1.0, 1.0);
const vec2 c10 = vec2(1.0, 0.0);

bool in_corner(vec2 p, vec2 corner, vec2 radius) { 
  vec2 axis = (c11 - corner) - corner; 
  p = p - (corner + axis * radius); 
  p *= axis / radius; 
  return (p.x > 0.0 && p.y > -1.0) || (p.y > 0.0 && p.x > -1.0) || dot(p, p) < 1.0;
}

bool test_rounded_mask(vec2 p, vec2 corner_size) { 
  return 
    in_corner(p, c00, corner_size) && 
    in_corner(p, c01, corner_size) && 
    in_corner(p, c10, corner_size) && 
    in_corner(p, c11, corner_size);
}

vec4 screen(vec4 a, vec4 b) { 
  return 1.0 - (1.0 - a) * (1.0 - b);
}

vec4 unscreen(vec4 c) { 
  return 1.0 - sqrt(1.0 - c);
}

vec4 sample_with_corners_from(vec2 p, vec2 corner_size) { 
  p = (p - 0.5) / zoom + 0.5; 
  if (!test_rounded_mask(p, corner_size)) { 
    return black; 
  } 
  return unscreen(getFromColor(p));
}

vec4 sample_with_corners_to(vec2 p, vec2 corner_size) { 
  p = (p - 0.5) / zoom + 0.5; 
  if (!test_rounded_mask(p, corner_size)) { 
    return black; 
  } 
  return unscreen(getToColor(p));
}

vec4 simple_sample_with_corners_from(vec2 p, vec2 corner_size, float zoom_amt) { 
  p = (p - 0.5) / (1.0 - zoom_amt + zoom * zoom_amt) + 0.5; 
  if (!test_rounded_mask(p, corner_size)) { 
    return black; 
  } 
  return getFromColor(p);
}

vec4 simple_sample_with_corners_to(vec2 p, vec2 corner_size, float zoom_amt) { 
  p = (p - 0.5) / (1.0 - zoom_amt + zoom * zoom_amt) + 0.5; 
  if (!test_rounded_mask(p, corner_size)) { 
    return black; 
  } 
  return getToColor(p);
}

mat3 rotate2d(float angle, float ratio) { 
  float s = sin(angle); 
  float c = cos(angle); 
  return mat3( 
    c, s, 0.0, 
    -s, c, 0.0, 
    0.0, 0.0, 1.0);
}

mat3 translate2d(float x, float y) { 
  return mat3( 
    1.0, 0.0, 0.0, 
    0.0, 1.0, 0.0, 
    -x, -y, 1.0);
}

mat3 scale2d(float x, float y) { 
  return mat3( 
    x, 0.0, 0.0, 
    0.0, y, 0.0, 
    0.0, 0.0, 1.0);
}

// Split an image and rotate one up and one down along off screen pivot points
vec4 get_cross_rotated(vec3 p3, float angle, vec2 corner_size, float ratio) { 
  angle = angle * angle; // easing 
  angle /= 2.4; // works out to be a good number of radians 

  mat3 center_and_scale = translate2d(-0.5, -0.5) * scale2d(1.0, ratio); 
  mat3 unscale_and_uncenter = scale2d(1.0, 1.0/ratio) * translate2d(0.5, 0.5); 
  mat3 slide_left = translate2d(-2.0, 0.0); 
  mat3 slide_right = translate2d(2.0, 0.0); 
  mat3 rotate = rotate2d(angle, ratio); 

  mat3 op_a = center_and_scale * slide_right * rotate * slide_left * unscale_and_uncenter; 
  mat3 op_b = center_and_scale * slide_left * rotate * slide_right * unscale_and_uncenter; 

  vec4 a = sample_with_corners_from((op_a * p3).xy, corner_size); 
  vec4 b = sample_with_corners_from((op_b * p3).xy, corner_size); 

  return screen(a, b);
}

// Image stays put, but this time moves two masks
vec4 get_cross_masked(vec3 p3, float angle, vec2 corner_size, float ratio) { 
  angle = 1.0 - angle; 
  angle = angle * angle; // easing 
  angle /= 2.4; 

  vec4 img; 

  mat3 center_and_scale = translate2d(-0.5, -0.5) * scale2d(1.0, ratio); 
  mat3 unscale_and_uncenter = scale2d(1.0 / zoom, 1.0 / (zoom * ratio)) * translate2d(0.5, 0.5); 
  mat3 slide_left = translate2d(-2.0, 0.0); 
  mat3 slide_right = translate2d(2.0, 0.0); 
  mat3 rotate = rotate2d(angle, ratio); 

  mat3 op_a = center_and_scale * slide_right * rotate * slide_left * unscale_and_uncenter; 
  mat3 op_b = center_and_scale * slide_left * rotate * slide_right * unscale_and_uncenter; 

  bool mask_a = test_rounded_mask((op_a * p3).xy, corner_size); 
  bool mask_b = test_rounded_mask((op_b * p3).xy, corner_size); 

  if (mask_a || mask_b) { 
    img = sample_with_corners_to(p3.xy, corner_size); 
    return screen(mask_a ? img : black, mask_b ? img : black); 
  } else { 
    return black; 
  }
}

vec4 transition(vec2 uv) { 
  float a; 
  vec2 p = uv.xy / vec2(1.0).xy; 
  vec3 p3 = vec3(p.xy, 1.0); 

  vec2 corner_size = vec2(corner_radius / ratio, corner_radius); 

  if (progress <= 0.0) { 
    return getFromColor(p); 
  } else if (progress < 0.1) { 
    a = progress / 0.1; 
    return simple_sample_with_corners_from(p, corner_size * a, a); 
  } else if (progress < 0.48) { 
    a = (progress - 0.1) / 0.38; 
    return get_cross_rotated(p3, a, corner_size, ratio); 
  } else if (progress < 0.9) { 
    return get_cross_masked(p3, (progress - 0.52) / 0.38, corner_size, ratio); 
  } else if (progress < 1.0) { 
    a = (1.0 - progress) / 0.1; 
    return simple_sample_with_corners_to(p, corner_size * a, a); 
  } else { 
    return getToColor(p); 
  }
}
`,jk={zoom:{value:.88,type:"f32"},corner_radius:{value:.22,type:"f32"}},Zk=`
float random(vec2 co) { 
  float a = 12.9898; 
  float b = 78.233; 
  float c = 43758.5453; 
  float dt = dot(co.xy, vec2(a, b)); 
  float sn = mod(dt, 3.14); 
  return fract(sin(sn) * c);
}

float voronoi(vec2 x) { 
  vec2 p = floor(x); 
  vec2 f = fract(x); 
  float res = 8.0; 
  for(float j = -1.; j <= 1.; j++) 
    for(float i = -1.; i <= 1.; i++) { 
      vec2 b = vec2(i, j); 
      vec2 r = b - f + random(p + b); 
      float d = dot(r, r); 
      res = min(res, d); 
    } 
  return sqrt(res);
}

vec2 displace(vec4 tex, vec2 texCoord, float dotDepth, float textureDepth, float strength) { 
  float b = voronoi(.003 * texCoord + 2.0); 
  float g = voronoi(0.2 * texCoord); 
  float r = voronoi(texCoord - 1.0); 
  vec4 dt = tex * 1.0; 
  vec4 dis = dt * dotDepth + 1.0 - tex * textureDepth; 

  dis.x = dis.x - 1.0 + textureDepth * dotDepth; 
  dis.y = dis.y - 1.0 + textureDepth * dotDepth; 
  dis.x *= strength; 
  dis.y *= strength; 
  vec2 res_uv = texCoord; 
  res_uv.x = res_uv.x + dis.x - 0.0; 
  res_uv.y = res_uv.y + dis.y; 
  return res_uv;
}

float ease1(float t) { 
  return t == 0.0 || t == 1.0 
    ? t 
    : t < 0.5 
    ? +0.5 * pow(2.0, (20.0 * t) - 10.0) 
    : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;
}

float ease2(float t) { 
  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);
}

vec4 transition(vec2 uv) { 
  vec2 p = uv.xy / vec2(1.0).xy; 
  vec4 color1 = getFromColor(p); 
  vec4 color2 = getToColor(p); 
  vec2 disp = displace(color1, p, 0.33, 0.7, 1.0 - ease1(progress)); 
  vec2 disp2 = displace(color2, p, 0.33, 0.5, ease2(progress)); 
  vec4 dColor1 = getToColor(disp); 
  vec4 dColor2 = getFromColor(disp2); 
  float val = ease1(progress); 
  vec3 gray = vec3(dot(min(dColor2, dColor1).rgb, vec3(0.299, 0.587, 0.114))); 
  dColor2 = vec4(gray, 1.0); 
  dColor2 *= 2.0; 
  color1 = mix(color1, dColor2, smoothstep(0.0, 0.5, progress)); 
  color2 = mix(color2, dColor1, smoothstep(1.0, 0.5, progress)); 
  return mix(color1, color2, val); 
}
`,Jk=`
uniform float strength; // = 0.4

const float PI = 3.141592653589793;

float Linear_ease(float begin, float change, float duration, float time) { 
  return change * time / duration + begin;
}

float Exponential_easeInOut(float begin, float change, float duration, float time) { 
  if (time == 0.0) 
    return begin; 
  else if (time == duration) 
    return begin + change; 
  time = time / (duration / 2.0); 
  if (time < 1.0) 
    return change / 2.0 * pow(2.0, 10.0 * (time - 1.0)) + begin; 
  return change / 2.0 * (-pow(2.0, -10.0 * (time - 1.0)) + 2.0) + begin;
}

float Sine_easeInOut(float begin, float change, float duration, float time) { 
  return -change / 2.0 * (cos(PI * time / duration) - 1.0) + begin;
}

float rand(vec2 co) { 
  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 crossFade(vec2 uv, float dissolve) { 
  return mix(getFromColor(uv).rgb, getToColor(uv).rgb, dissolve);
}

vec4 transition(vec2 uv) { 
  vec2 texCoord = uv.xy / vec2(1.0).xy; 

  // Linear interpolate center across center half of the image 
  vec2 center = vec2(Linear_ease(0.25, 0.5, 1.0, progress), 0.5); 
  float dissolve = Exponential_easeInOut(0.0, 1.0, 1.0, progress); 

  // Mirrored sine loop. 0->strength then strength->0 
  float strengthValue = Sine_easeInOut(0.0, strength, 0.5, progress); 

  vec3 color = vec3(0.0); 
  float total = 0.0; 
  vec2 toCenter = center - texCoord; 

  /* randomize the lookup values to hide the fixed number of samples */ 
  float offset = rand(uv); 

  for (float t = 0.0; t <= 40.0; t++) { 
    float percent = (t + offset) / 40.0; 
    float weight = 4.0 * (percent - percent * percent); 
    color += crossFade(texCoord + toCenter * percent * strengthValue, dissolve) * weight; 
    total += weight; 
  } 
  return vec4(color / total, 1.0);
}
`,Qk={strength:{value:.4,type:"f32"}},eM=`
uniform float a; // = 4
uniform float b; // = 1
uniform float amplitude; // = 120
uniform float smoothness; // = 0.1

vec4 transition(vec2 uv) { 
  vec2 p = uv.xy / vec2(1.0).xy; 
  vec2 dir = p - vec2(.5); 
  float dist = length(dir); 
  float x = (a - b) * cos(progress) + b * cos(progress * ((a / b) - 1.)); 
  float y = (a - b) * sin(progress) - b * sin(progress * ((a / b) - 1.)); 
  vec2 offset = dir * vec2(sin(progress * dist * amplitude * x), sin(progress * dist * amplitude * y)) / smoothness; 
  return mix(getFromColor(p + offset), getToColor(p), smoothstep(0.2, 1.0, progress));
}
`,tM={a:{value:4,type:"f32"},b:{value:1,type:"f32"},amplitude:{value:120,type:"f32"},smoothness:{value:.1,type:"f32"}},iM=`
// License: MIT

vec2 bottom_left = vec2(0.0, 1.0);
vec2 bottom_right = vec2(1.0, 1.0);
vec2 top_left = vec2(0.0, 0.0);
vec2 top_right = vec2(1.0, 0.0);

float check(vec2 p1, vec2 p2, vec2 p3)
{
  return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
}

bool PointInTriangle (vec2 pt, vec2 p1, vec2 p2, vec2 p3)
{
    bool b1, b2, b3;
    b1 = check(pt, p1, p2) < 0.0;
    b2 = check(pt, p2, p3) < 0.0;
    b3 = check(pt, p3, p1) < 0.0;
    return ((b1 == b2) && (b2 == b3));
}

bool in_left_triangle(vec2 p){
  vec2 vertex1, vertex2, vertex3;
  vertex1 = vec2(progress, 0.5);
  vertex2 = vec2(0.0, 0.5-progress);
  vertex3 = vec2(0.0, 0.5+progress);
  if (PointInTriangle(p, vertex1, vertex2, vertex3))
  {
    return true;
  }
  return false;
}

bool in_right_triangle(vec2 p){
  vec2 vertex1, vertex2, vertex3;
  vertex1 = vec2(1.0-progress, 0.5);
  vertex2 = vec2(1.0, 0.5-progress);
  vertex3 = vec2(1.0, 0.5+progress);
  if (PointInTriangle(p, vertex1, vertex2, vertex3))
  {
    return true;
  }
  return false;
}

float blur_edge(vec2 bot1, vec2 bot2, vec2 top, vec2 testPt)
{
  vec2 lineDir = bot1 - top;
  vec2 perpDir = vec2(lineDir.y, -lineDir.x);
  vec2 dirToPt1 = bot1 - testPt;
  float dist1 = abs(dot(normalize(perpDir), dirToPt1));
  
  lineDir = bot2 - top;
  perpDir = vec2(lineDir.y, -lineDir.x);
  dirToPt1 = bot2 - testPt;
  float min_dist = min(abs(dot(normalize(perpDir), dirToPt1)), dist1);
  
  if (min_dist < 0.005) {
    return min_dist / 0.005;
  }
  else  {
    return 1.0;
  };
}


vec4 transition (vec2 uv) {
  if (in_left_triangle(uv))
  {
    if (progress < 0.1)
    {
      return getFromColor(uv);
    }
    if (uv.x < 0.5)
    {
      vec2 vertex1 = vec2(progress, 0.5);
      vec2 vertex2 = vec2(0.0, 0.5-progress);
      vec2 vertex3 = vec2(0.0, 0.5+progress);
      return mix(
        getFromColor(uv),
        getToColor(uv),
        blur_edge(vertex2, vertex3, vertex1, uv)
      );
    }
    else
    {
      if (progress > 0.0)
      {
        return getToColor(uv);
      }
      else
      {
        return getFromColor(uv);
      }
    }    
  }
  else if (in_right_triangle(uv))
  {
    if (uv.x >= 0.5)
    {
      vec2 vertex1 = vec2(1.0-progress, 0.5);
      vec2 vertex2 = vec2(1.0, 0.5-progress);
      vec2 vertex3 = vec2(1.0, 0.5+progress);
      return mix(
        getFromColor(uv),
        getToColor(uv),
        blur_edge(vertex2, vertex3, vertex1, uv)
      );  
    }
    else
    {
      return getFromColor(uv);
    }
  }
  else {
    return getFromColor(uv);
  }
}
`,sM=`

const float SQRT_2 = 1.414213562373;
uniform float dots;// = 20.0;

vec4 transition(vec2 uv) {
  bool nextImage = distance(fract(uv * dots), vec2(0.5, 0.5)) < ( progress / distance(uv, center));
  return nextImage ? getToColor(uv) : getFromColor(uv);
}
`,rM={radialSwipe:{label:"Radial Swipe",fragment:hk}},ji={...Ki.reduce((i,e)=>(i[e.name]={label:e.name,fragment:e.glsl,uniforms:e.defaultParams,previewDynamic:`transition: ${e.name}`},i),{}),...rM},nM=Object.entries(ji).map(([i,e])=>({key:i,label:e.label,previewStatic:`https://cdn.subgen.co/previews/static/transition_${i}_static.webp`,previewDynamic:`https://cdn.subgen.co/previews/dynamic/transition_${i}_dynamic.webp`}));function of({name:i,renderer:e}){let t=Ki.find(N=>N.name===i);if(!t){const N=Object.keys(ji).find(q=>q.toLowerCase()===i.toLowerCase());N&&(t=ji[N])}if(t||(t=Ki.find(N=>N.name.toLowerCase()===i.toLowerCase())),!t){const N=[i,i.toLowerCase(),i.charAt(0).toUpperCase()+i.slice(1).toLowerCase(),i.replace(/([A-Z])/g,"_$1").toLowerCase().replace(/^_/,""),i.replace(/_/g,"")];for(const q of N){if(t=Ki.find(Ie=>Ie.name.toLowerCase()===q.toLowerCase()),t)break;const me=Object.keys(ji).find(Ie=>Ie.toLowerCase()===q.toLowerCase());if(me){t=ji[me];break}}}if(!t){const N=Ki.length,q=Ki.slice(0,5).map(Ie=>Ie.name).join(", "),me=Object.keys(ji).slice(0,3).join(", ");throw console.error(`Transition not found: "${i}". Available in gl-transitions (${N} total):`,q+"..."),console.error("Available locally:",me+"..."),new Error(`Transition "${i}" not found in gl-transitions library or local definitions`)}const s=new Be(k.WHITE),r=Ge.create({width:e.width,height:e.height}),n=new Et({}),o=new Et({}),a=t.name==="displacement"||i.toLowerCase()==="displacement"||t.label==="displacement",l=a?new Et({}):void 0;let c=null;if(a){c=document.createElement("canvas"),c.width=256,c.height=256;const N=c.getContext("2d");if(N){const q=N.createImageData(256,256);for(let me=0;me<q.data.length;me+=4){const Ie=Math.random();q.data[me]=Ie*255,q.data[me+1]=Ie*255,q.data[me+2]=Ie*255,q.data[me+3]=255}N.putImageData(q,0,0)}}let h=t.glsl||t.fragment;if(!h)throw new Error(`Transition "${i}" has no glsl or fragment code`);let u={...de.basics,...de.custom(t)};Object.entries(u).forEach(([,N])=>{N.type==="int<f32>"&&(N.type="i32",typeof N.value=="number"&&(N.value=Math.trunc(N.value))),N.type==="ivec2<f32>"&&(N.type="vec2<f32>")});const d=t.name==="GridFlip"||i.toLowerCase()==="gridflip"||t.label==="gridflip",f=t.name==="circle"||i.toLowerCase()==="circle"||t.label==="circle",m=t.name==="directional"||i.toLowerCase()==="directional"||t.label==="directional",g=t.name==="UndulatingBurnOut"||i.toLowerCase()==="undulatingburnout"||t.label==="undulatingBurnOut",p=t.name==="SquaresWire"||i.toLowerCase()==="squareswire"||t.label==="squaresWire",_=t.name==="rotate_scale_fade"||i.toLowerCase()==="rotatescalefade"||t.label==="rotateScaleFade",x=t.name==="RandomSquares"||i.toLowerCase()==="randomsquares"||t.label==="randomSquares",v=t.name==="polar_function"||i.toLowerCase()==="polar_function"||t.label==="polar_function",y=t.name==="pixelate"||i.toLowerCase()==="pixelate"||t.label==="pixelate",T=t.name==="perlin"||i.toLowerCase()==="perlin"||t.label==="perlin",S=t.name==="luma"||i.toLowerCase()==="luma"||t.label==="luma",w=t.name==="luminance_melt"||i.toLowerCase()==="luminance_melt"||i.toLowerCase()==="luminancemelt"||t.label==="luminance_melt",E=t.name==="hexagonalize"||i.toLowerCase()==="hexagonalize"||t.label==="hexagonalize",P=t.name==="heart"||i.toLowerCase()==="heart"||t.label==="heart",C=t.name==="displacement"||i.toLowerCase()==="displacement"||t.label==="displacement",A=t.name==="directionalwipe"||i.toLowerCase()==="directionalwipe"||i.toLowerCase()==="directional_wipe"||t.label==="directionalwipe",B=t.name==="directionalwarp"||i.toLowerCase()==="directionalwarp"||i.toLowerCase()==="directional_warp"||t.label==="directionalwarp",D=t.name==="crosshatch"||i.toLowerCase()==="crosshatch"||t.label==="crosshatch",$=t.name==="circleopen"||i.toLowerCase()==="circleopen"||i.toLowerCase()==="circle_open"||t.label==="circleopen",pe=t.name==="cannabisleaf"||i.toLowerCase()==="cannabisleaf"||i.toLowerCase()==="cannabis_leaf"||t.label==="cannabisleaf",M=t.name==="StereoViewer"||i.toLowerCase()==="stereoviewer"||i.toLowerCase()==="stereo_viewer"||t.label==="StereoViewer",F=t.name==="GlitchDisplace"||i.toLowerCase()==="glitchDisplace"||t.label==="GlitchDisplace",ne=t.name==="CrossZoom"||i.toLowerCase()==="crosszoom"||t.label==="CrossZoom",G=t.name==="CrazyParametricFun"||i.toLowerCase()==="crazyparametricfun"||t.label==="CrazyParametricFun",ie=t.name==="BowTieHorizontal"||i.toLowerCase()==="bowtiehorizontal"||t.label==="BowTieHorizontal",we=t.name==="PolkaDotsCurtain"||i.toLowerCase()==="polkadotscurtain"||t.label==="PolkaDotsCurtain",ce=t.name==="Pixelize"||i.toLowerCase()==="pixelize"||t.label==="Pixelize";d&&(h=uk,u={...de.basics,...dk}),f&&(h=fk,u={...de.basics,...Gx}),m&&(h=pk,u={...de.basics,...mk}),g&&(h=gk,u={...de.basics,..._k}),p&&(h=xk,u={...de.basics,...vk}),_&&(h=yk,u={...de.basics,...bk}),x&&(h=Tk,u={...de.basics,...wk}),v&&(h=Sk,u={...de.basics,...Ck}),y&&(h=Bx,u={...de.basics,...Ox}),T&&(h=Ik,u={...de.basics,...Pk}),S&&(h=Rk,u={...de.basics,...kk}),w&&(h=Mk,u={...de.basics,...Fk}),E&&(h=Uk,u={...de.basics,...Bk}),P&&(h=Ok,u={...de.basics,...Dk}),C&&(h=Gk,u={...de.basics,...zk}),A&&(h=Lk,u={...de.basics,...Nk}),B&&(h=Hk,u={...de.basics,...Wk}),D&&(h=Vk,u={...de.basics,...$k}),$&&(h=Xk,u={...de.basics,...Gx}),pe&&(h=Yk,u={...de.basics,...qk}),M&&(h=Kk,u={...de.basics,...jk}),F&&(h=Zk),ne&&(h=Jk,u={...de.basics,...Qk}),G&&(h=eM,u={...de.basics,...tM}),ie&&(h=iM),we&&(h=sM),ce&&(h=Ak,u={...de.basics,...Ek});const Ce={from:n,to:o,uniforms:u};a&&l&&(Ce.displacementMap=l,c&&(l.resource=c,l.update()));const Oe=new Gi({glProgram:new It({vertex:ak,fragment:ck(h)}),resources:Ce});return s.filters=[Oe],{render({width:N,height:q,from:me,to:Ie,progress:Ji}){if((s.width!==N||s.height!==q)&&(s.setSize({width:N,height:q}),r.resize(N,q)),me instanceof k?Oe.resources.from=me.source:(n.resource=me,n.update(),Oe.resources.from=n),Ie instanceof k?Oe.resources.to=Ie.source:(o.resource=Ie,o.update(),Oe.resources.to=o),a&&l&&c){if(c.width!==N||c.height!==q){c.width=N,c.height=q;const ii=c.getContext("2d");if(ii){const Pt=ii.createImageData(N,q);for(let Ke=0;Ke<Pt.data.length;Ke+=4){const vt=Math.random();Pt.data[Ke]=vt*255,Pt.data[Ke+1]=vt*255,Pt.data[Ke+2]=vt*255,Pt.data[Ke+3]=255}ii.putImageData(Pt,0,0)}}l.resource=c,l.update()}return Oe.resources.uniforms.uniforms.progress=Ji,e.render({container:s,target:r,clear:!1,width:N,height:q}),r},destroy(){r.destroy(),s.destroy({children:!0})}}}let oM=0;async function zx(i){i()>50&&(await Zh(15),await zx(i))}class aM extends Jh{static async isSupported(e={}){return(self.OffscreenCanvas!=null&&self.VideoEncoder!=null&&self.VideoDecoder!=null&&self.VideoFrame!=null&&self.AudioEncoder!=null&&self.AudioDecoder!=null&&self.AudioData!=null&&((await self.VideoEncoder.isConfigSupported({codec:e.videoCodec??"avc1.42E032",width:e.width??1920,height:e.height??1080,bitrate:e.bitrate??7e6})).supported??!1)&&(await self.AudioEncoder.isConfigSupported({codec:(await Bp()).codec,sampleRate:he.sampleRate,numberOfChannels:he.channelCount})).supported)??!1}logger=ee.create(`id:${oM++},`);destroyed=!1;sprites=[];canvas;pixiApp=null;stopOutput=null;opts;hasVideoTrack;constructor(e={}){super();const{width:t=0,height:s=0}=e;this.canvas=new OffscreenCanvas(t,s),this.opts=Object.assign({bgColor:"#000",width:0,height:0,videoCodec:"avc1.42E032",audio:!0,bitrate:5e6,fps:30,metaDataTags:null},e),this.hasVideoTrack=t*s>0,Bp().catch(r=>{this.logger.warn("Failed to detect audio codec:",r)})}async initPixiApp(){const{width:e,height:t}=this.opts;if(this.pixiApp=new Hu,await this.pixiApp.init({canvas:this.canvas,width:e,height:t,backgroundColor:0,antialias:!1,autoDensity:!1,resolution:1,preference:"webgl"}),this.pixiApp.renderer==null||this.pixiApp.stage==null)throw new Error("Pixi.js Application failed to initialize properly");try{const s=this.pixiApp;s.ticker&&typeof s.ticker.stop=="function"&&s.ticker.stop()}catch{}}async addSprite(e,t={}){const s={rect:{x:e.left,y:e.top,w:e.width,h:e.height},display:{...e.display},duration:e.duration,playbackRate:e.playbackRate,zIndex:e.zIndex};this.logger.info("Compositor add clip",s);const r=await e.clone();this.pixiApp!=null&&this.pixiApp.renderer!=null&&typeof r.setRenderer=="function"&&r.setRenderer(this.pixiApp.renderer),this.logger.info("Compositor add clip ready"),this.sprites.push(Object.assign(r,{main:t.main??!1,expired:!1})),this.sprites.sort((n,o)=>n.zIndex-o.zIndex)}initMuxer(e){const{fps:t,width:s,height:r,videoCodec:n,bitrate:o,audio:a,metaDataTags:l}=this.opts,c=this.sprites.some(d=>d.width>0&&d.height>0),h=this.hasVideoTrack&&c;return M1({video:h?{width:s,height:r,expectFPS:t,codec:n,bitrate:o,__unsafe_hardwareAcceleration__:this.opts.__unsafe_hardwareAcceleration__}:null,audio:a===!1?null:{codec:he.codecType,sampleRate:he.sampleRate,channelCount:he.channelCount},duration:e,metaDataTags:l})}output(e={}){if(this.sprites.length===0)throw Error("No sprite added");const t=this.sprites.find(u=>u.main),r=this.sprites.map(u=>u.display.from+u.duration).filter(u=>u!==1/0),n=e.maxTime??(t!=null?t.display.from+t.duration:r.length>0?Math.max(...r):1/0);if(n===1/0||n<=0)throw Error("Unable to determine the end time, please specify a main sprite, or limit the duration of ImageClip, AudioClip");n===-1&&this.logger.warn("Unable to determine the end time, process value don't update"),this.logger.info(`start combinate video, maxTime:${n}`);const o=this.initMuxer(n);let a=performance.now();const l=this.runEncoding(o,n,{onProgress:u=>{this.logger.debug("OutputProgress:",u),this.emit("OutputProgress",u)},onEnded:async()=>{await o.flush(),this.logger.info("===== output ended =====, cost:",performance.now()-a),this.emit("OutputProgress",1),this.destroy()},onError:u=>{this.emit("error",u),h(u),this.destroy()}});this.stopOutput=()=>{l(),o.close(),h()};const{stream:c,stop:h}=Mx(o.mp4file,500,this.destroy);return c}destroy(){if(!this.destroyed&&(this.destroyed=!0,this.stopOutput?.(),this.off("OutputProgress"),this.off("error"),this.pixiApp!=null))try{const e=this.pixiApp;if(e.destroyed===!0){this.pixiApp=null;return}if(e.ticker&&typeof e.ticker.stop=="function")try{e.ticker.stop()}catch{}if(e.renderer!=null){const t=e.renderer.gl;if(t&&t.isContextLost()){this.pixiApp=null;return}this.pixiApp.destroy()}}catch(e){console.warn("Error while destroying Pixi application:",e)}finally{this.pixiApp=null}}runEncoding(e,t,{onProgress:s,onEnded:r,onError:n}){let o=0;const a={aborted:!1};let l=null,c=null;const h=async()=>{const{fps:f,bgColor:m,audio:g}=this.opts,p=Math.round(1e6/f),_=this.sprites.some(y=>y.width>0&&y.height>0);c=lM({pixiApp:this.pixiApp,sprites:this.sprites,aborter:a});const x=cM({muxer:e,canvas:this.canvas,outputAudio:g,hasVideoTrack:this.hasVideoTrack&&_,timeSlice:p,fps:f});let v=0;for(;;){if(l!=null)return;if(a.aborted||t!==-1&&v>t||this.sprites.length===0){u(),await r();return}o=v/t;const{audios:y,mainSprDone:T,hasVideo:S}=await c.render(v);if(T){u(),await r();return}if(a.aborted)return;this.hasVideoTrack&&S&&await new Promise(w=>requestAnimationFrame(w)),x(v,y,S),v+=p,await zx(e.getEncodeQueueSize)}},u=()=>{a.aborted||(a.aborted=!0,clearInterval(d),c?.cleanup(),this.sprites.forEach(f=>{f.destroy()}))};h().catch(f=>{l=f,this.logger.error(f),u(),n(f)});const d=setInterval(()=>{s(o)},500);return u}exportToJSON(){const e=this.sprites.map(s=>Xs(s,s.main)),t=[];return this.sprites.forEach(s=>{if(s.transition){const r=this.sprites.filter(n=>n.id!==s.id&&n.zIndex===s.zIndex&&n.display.from<s.display.from&&(n instanceof ke||n instanceof ze)).sort((n,o)=>o.display.to-n.display.to)[0];r&&t.push({key:s.transition.name,duration:s.transition.duration,clips:[r.id,s.id]})}}),{clips:e,settings:{width:this.opts.width,height:this.opts.height,fps:this.opts.fps,bgColor:this.opts.bgColor,videoCodec:this.opts.videoCodec,bitrate:this.opts.bitrate,audio:this.opts.audio,metaDataTags:this.opts.metaDataTags}}}async loadFromJSON(e){this.sprites.forEach(t=>{t.destroy()}),this.sprites=[],e.settings&&(e.settings.width!==void 0&&(this.opts.width=e.settings.width),e.settings.height!==void 0&&(this.opts.height=e.settings.height),e.settings.fps!==void 0&&(this.opts.fps=e.settings.fps),e.settings.bgColor!==void 0&&(this.opts.bgColor=e.settings.bgColor),e.settings.videoCodec!==void 0&&(this.opts.videoCodec=e.settings.videoCodec),e.settings.bitrate!==void 0&&(this.opts.bitrate=e.settings.bitrate),e.settings.audio!==void 0&&(this.opts.audio=e.settings.audio===!1?!1:void 0),e.settings.metaDataTags!==void 0&&(this.opts.metaDataTags=e.settings.metaDataTags));for(const t of e.clips){const s=await Ys(t);if(await this.addSprite(s,{main:t.main||!1}),t.type==="Transition"){const r=t.toClipId,n=this.sprites.find(o=>o.id===r);n?n.transition={name:t.transitionEffect.key,duration:t.duration,prevClipId:t.fromClipId||""}:console.warn(`[Compositor] Could not find target clip ${r} for transition ${t.transitionEffect.key}`)}}}}function lM(i){const{pixiApp:e,sprites:t,aborter:s}=i,r=e!=null,n=new Map,o=new Map,a=new Map,l=Ge.create({width:e?.renderer.width||0,height:e?.renderer.height||0}),c=Ge.create({width:e?.renderer.width||0,height:e?.renderer.height||0}),h=new _e().rect(0,0,e?.renderer.width||0,e?.renderer.height||0).fill({color:0}),u=new Map,d=T=>t.filter(S=>S.id!==T.id&&S.zIndex===T.zIndex&&S.display.from<T.display.from&&(S instanceof ke||S instanceof ze)).sort((S,w)=>w.display.to-S.display.to)[0]||null,f=async(T,S,w)=>{let E=null;if(T.transition?.prevClipId&&(E=t.find(B=>B.id===T.transition.prevClipId)||null),E||(E=d(T)),!E)return null;const P=E.duration>0?E.duration:0,C=Math.max(0,Math.min(S-E.display.from,P)),{video:A}=await w(E,C);return A},m=(T,S,w)=>{if(!e)return;e.renderer.render({container:h,target:w,clear:!0});const E=new Be(S instanceof k?S:k.from(S));E.x=T.center.x,E.y=T.center.y,E.anchor.set(.5,.5);const P=E.texture.width||1,C=E.texture.height||1,A=T.width&&T.width!==0?Math.abs(T.width)/P:1,B=T.height&&T.height!==0?Math.abs(T.height)/C:1;T.flip==="horizontal"?(E.scale.x=-A,E.scale.y=B):T.flip==="vertical"?(E.scale.x=A,E.scale.y=-B):(E.scale.x=A,E.scale.y=B),E.rotation=(T.flip==null?1:-1)*T.angle,E.alpha=T.opacity;const D=T.style||{},$=D.borderRadius||0;let pe=null;$>0&&(pe=new _e,pe.roundRect(-P/2,-C/2,P,C,Math.min($,P/2,C/2)),pe.fill({color:16777215,alpha:1}),E.addChild(pe),E.mask=pe);const M=D.stroke;let F=null;if(M&&M.width>0){F=new _e;const ie=Te(M.color)??16777215,we=M.width;if(F.setStrokeStyle({width:we,color:ie,alignment:1}),$>0){const ce=Math.min($,P/2,C/2);F.roundRect(-P/2,-C/2,P,C,ce)}else F.rect(-P/2,-C/2,P,C);F.stroke(),E.addChild(F)}const ne=D.dropShadow;let G=null;if(ne&&(ne.blur>0||ne.distance>0)){G=new _e;const ie=Te(ne.color)??0,we=ne.alpha??.5,ce=ne.distance??0,Ce=ne.angle??0,Oe=Math.cos(Ce)*ce,N=Math.sin(Ce)*ce;if($>0){const q=Math.min($,P/2,C/2);G.roundRect(-P/2+Oe,-C/2+N,P,C,q)}else G.rect(-P/2+Oe,-C/2+N,P,C);G.fill({color:ie,alpha:we}),E.addChildAt(G,0)}e.renderer.render({container:E,target:w,clear:!1}),S instanceof k||E.texture.destroy(!0),F&&F.destroy(),pe&&pe.destroy(),G&&G.destroy(),E.destroy()};let g=null,p=null,_=null;r&&e!=null&&(g=new se,p=new se,_=new se,p.sortableChildren=!0,_.sortableChildren=!0,e.stage.addChild(p),e.stage.addChild(_),g.visible=!1,e.stage.addChild(g));const x=[...t].sort((T,S)=>T.zIndex-S.zIndex);return{render:async T=>{const S=[];let w=!1,E=!1;const P=new Map,C=async(A,B)=>{const D=`${A.id}_${B}`;if(P.has(D))return P.get(D);const $=await A.getFrame(B);return P.set(D,$),$};for(const A of a.values())A.visible=!1;for(const A of x){if(s.aborted)break;if(T<A.display.from||A.expired){if(r&&e!=null){const F=n.get(A);F&&await F.updateFrame(null)}continue}const B=T-A.display.from,D=B*A.playbackRate;A.animate(D);const{video:$,audio:pe,done:M}=await C(A,B);if(S.push(pe),r&&e!=null&&p!=null){if((A instanceof ke||A instanceof ze)&&A.transition&&B>=0&&B<=A.transition.duration){const G=await f(A,T,C),ie=$;if(G&&ie){const we=B/A.transition.duration,ce=d(A);ce?m(ce,G,l):e.renderer.render({container:h,target:l,clear:!0}),m(A,ie,c);let Ce=o.get(A.id);Ce||(Ce=of({name:A.transition.name,renderer:e.renderer}),o.set(A.id,Ce));const Oe=Ce.render({width:e.renderer.width,height:e.renderer.height,from:l,to:c,progress:we});let N=a.get(A.id);N||(N=new Be,N.label=`TransitionSprite_${A.id}`,a.set(A.id,N),p.addChild(N)),N.texture=Oe,N.visible=!0,N.x=0,N.y=0,N.width=e.renderer.width,N.height=e.renderer.height,N.anchor.set(0,0),N.zIndex=A.zIndex,E=!0;const q=n.get(A);if(q){const me=q.getRoot();me&&(me.visible=!1)}if(ce){const me=n.get(ce);if(me){const Ie=me.getRoot();Ie&&(Ie.visible=!1)}}continue}}let ne=n.get(A);ne==null&&$!=null&&(ne=new gn(e,A,p),n.set(A,ne)),ne!=null&&($!=null?(E=!0,await ne.updateFrame($)):await ne.updateFrame(null)),ne?.updateTransforms()}if(A.duration>0&&T>A.display.from+A.duration||M){if(A.main&&(w=!0),A.expired=!0,r){const F=n.get(A);if(F!=null){const ne=F.getRoot();ne&&(ne.visible=!1)}}}else if(r){const F=n.get(A);F?.updateTransforms()}}if(r&&e!=null&&g!=null&&p!=null&&_!=null){let A=null;for(const B of t)if(B instanceof ut&&T>=B.display.from&&T<B.display.from+B.duration){A={id:B.id,key:B.effect.key,startTime:B.display.from,duration:B.duration};break}if(!A)for(const B of t){if(B.effects&&B.effects.length>0){for(const D of B.effects)if(T>=D.startTime&&T<D.startTime+D.duration){A=D;break}}if(A)break}_.removeChildren();for(const B of n.values()){const D=B.getRoot();D&&D.parent!==p&&(D.parent&&D.parent.removeChild(D),p.addChild(D))}if(A){const{key:B,startTime:D,duration:$,id:pe}=A,M=T-D,F=$>0?Math.min(Math.max(M/$,0),1):0,ne=t.some(G=>G.id===pe&&G instanceof ut);for(const G of t){let ie=!1;if(ne?ie=G.id!==pe&&!(G instanceof ut):ie=!!G.effects&&G.effects.some(we=>we.id===pe),ie){const we=n.get(G);if(we){const ce=we.getRoot();ce&&(ce.parent&&ce.parent.removeChild(ce),g.addChild(ce))}}}if(g.children.length>0){let G=u.get(pe);if(!G)try{const ie=rf({name:B,renderer:e.renderer});ie&&ie.filter&&(G={filter:ie.filter,render:ie.render},u.set(pe,G))}catch(ie){console.warn("Failed to create effect",B,ie)}if(G){const{filter:ie,render:we}=G;ie.resources&&ie.resources.effectUniforms&&(ie.resources.effectUniforms.uniforms.uTime=F);const ce=e.renderer.width,Ce=e.renderer.height,Oe=Ge.create({width:ce,height:Ce});if(g.visible=!0,e.renderer.render({container:g,target:Oe,clear:!0}),g.visible=!1,we){const N=we({canvasTexture:Oe,progress:F,width:ce,height:Ce}),q=new Be(N);q.width=ce,q.height=Ce,_.addChild(q)}}}}}return r&&e!=null&&e.render(),{audios:S,mainSprDone:w,hasVideo:E}},cleanup:()=>{l&&l.destroy(!0),c&&c.destroy(!0),h&&h.destroy(!0);for(const T of a.values())T.destroy();a.clear(),o.clear(),g&&g.destroy({children:!0}),p&&p.destroy({children:!0}),_&&_.destroy({children:!0}),n.forEach(T=>{T.destroy()}),n.clear()}}}function cM(i){const{canvas:e,outputAudio:t,muxer:s,hasVideoTrack:r,timeSlice:n}=i;let o=0;const a=Math.floor(3*i.fps),l=hM(1024);return(c,h,u)=>{if(t!==!1)for(const d of l(c,h))s.encodeAudio(d);if(r&&u)try{const d=new VideoFrame(e,{duration:n,timestamp:c});s.encodeVideo(d,{keyFrame:o%a===0}),o+=1}catch(d){console.warn("Failed to create VideoFrame from canvas, skipping frame:",d)}}}function hM(i){const e=i*he.channelCount,t=new Float32Array(e*3);let s=0,r=0;const n=i/he.sampleRate*1e6,o=new Float32Array(e),a=l=>{let c=0;const h=Math.floor(s/e),u=[];for(let d=0;d<h;d++)u.push(new AudioData({timestamp:r,numberOfChannels:he.channelCount,numberOfFrames:i,sampleRate:he.sampleRate,format:"f32",data:t.subarray(c,c+e)})),c+=e,r+=n;for(t.set(t.subarray(c,s),0),s-=c;l-r>n;)u.push(new AudioData({timestamp:r,numberOfChannels:he.channelCount,numberOfFrames:i,sampleRate:he.sampleRate,format:"f32",data:o})),r+=n;return u};return(l,c)=>{const h=Math.max(...c.map(u=>u[0]?.length??0));for(let u=0;u<h;u++){let d=0,f=0;for(let m=0;m<c.length;m++){const g=c[m][0]?.[u]??0,p=c[m][1]?.[u]??g;d+=g,f+=p}t[s]=d,t[s+1]=f,s+=2}return a(l)}}class uM extends _e{constructor(){super(),this.eventMode="static",this.cursor="move"}draw(e,t=1){const r=1.5*t;this.clear(),this.setStrokeStyle({width:r,color:165063}).rect(e.x,e.y,e.width,e.height).stroke(),this.hitArea=e}}class Wt extends _e{#e=!1;handle;cursor;callbacks;constructor(e,t,s){super(),this.handle=e,this.cursor=t,this.callbacks=s,this.eventMode="static",this.#a(),this.on("pointerdown",this.#i),this.on("globalpointermove",this.#r),this.on("pointerup",this.#l),this.on("pointerupoutside",this.#l)}#a(){this.clear();const e=165063;if(this.handle==="rot")this.circle(0,0,8),this.fill({color:"#ffffff"}),this.stroke({width:1,color:13421772}),this.moveTo(0,-4),this.arc(0,0,4,-Math.PI/2,Math.PI,!1),this.stroke({width:1,color:0}),this.moveTo(0,-8),this.lineTo(-3,-5),this.lineTo(0,-2),this.stroke({width:1,color:0,cap:"round",join:"round"}),this.hitArea=new Zr(0,0,24);else if(["ml","mr","mt","mb"].includes(this.handle)){const t=this.handle==="ml"||this.handle==="mr",s=t?6:24,r=t?24:6;this.roundRect(-s/2,-r/2,s,r,3),this.fill({color:"#ffffff"}),this.stroke({width:1,color:e}),this.hitArea=new W(-15,-15,30,30)}else this.rect(-4,-4,8,8),this.fill({color:"#ffffff"}),this.stroke({width:1,color:e}),this.hitArea=new W(-15,-15,30,30)}#i=e=>{this.#e=!0,this.cursor="grabbing",this.callbacks.beginDrag(this.handle,e.global),e.stopPropagation()};#r=e=>{this.#e&&(this.callbacks.updateDrag(this.handle,e.global),e.stopPropagation())};#l=e=>{this.#e&&(this.#e=!1,this.cursor="pointer",this.callbacks.endDrag(),e.stopPropagation())}}const Lx={delta:new O};class dM extends se{group;wireframe=new uM;selectionOutlines=new _e;isDragging=!1;lastPointer=new X;activeHandle=null;#e;#a=new Map;#i=new X;#r=0;#l=0;#c=new W;#s=new X;#h=new W;#t=[new X,new X,new X,new X];#n=1;#o=1;opts;constructor(e){super(),this.opts=e,this.group=e.group,this.eventMode="static";const t={beginDrag:(s,r)=>this.#y(s,r),updateDrag:(s,r)=>this.#b(s,r),endDrag:()=>this.#m()};this.#e={tl:new Wt("tl","nwse-resize",t),tr:new Wt("tr","nesw-resize",t),bl:new Wt("bl","nesw-resize",t),br:new Wt("br","nwse-resize",t),ml:new Wt("ml","ew-resize",t),mr:new Wt("mr","ew-resize",t),mt:new Wt("mt","ns-resize",t),mb:new Wt("mb","ns-resize",t),rot:new Wt("rot","crosshair",{beginDrag:(s,r)=>this.#w(r),updateDrag:(s,r)=>this.#S(r),endDrag:()=>this.#m()})},this.addChild(this.selectionOutlines,this.wireframe,...Object.values(this.#e)),this.#_(),this.visible=!1,Je.shared.addOnce(()=>{!this.destroyed&&this.parent&&(this.#u(),this.visible=!0)})}#_(){this.on("pointerdown",this.#x),this.on("pointerup",this.#p),this.on("pointerupoutside",this.#p),this.on("globalpointermove",this.#v)}#u(){if(this.group.length===1){const e=this.group[0];this.#r=e.rotation;const t=this.#f(e);let s,r;this.opts.clip?(s=this.opts.clip.width,r=this.opts.clip.height):(s=t.width,r=t.height);const n=e.toGlobal(new X(0,0));this.#i.set(n.x,n.y),this.#h.copyFrom(new W(-s/2,-r/2,s,r))}else{let e=1/0,t=1/0,s=-1/0,r=-1/0;if(this.parent)for(const c of this.group){const h=this.#f(c);this.#t[0].set(h.x,h.y),this.#t[1].set(h.x+h.width,h.y),this.#t[2].set(h.x+h.width,h.y+h.height),this.#t[3].set(h.x,h.y+h.height);for(const u of this.#t)c.toGlobal(u,u),this.toLocal(u,void 0,u),e=Math.min(e,u.x),t=Math.min(t,u.y),s=Math.max(s,u.x),r=Math.max(r,u.y)}const n=s-e,o=r-t,a=e+n/2,l=t+o/2;if(this.#h.copyFrom(new W(-n/2,-o/2,n,o)),this.parent){const c=this.toGlobal(new X(a,l));this.#i.set(c.x,c.y)}}this.#d()}#f(e){const t=e.children.filter(l=>l.label!=="ShadowContainer");if(t.length===0){const l=e.getLocalBounds();return new W(l.minX,l.minY,l.maxX-l.minX,l.maxY-l.minY)}const s=t.find(l=>l.label==="MainSprite");if(s){const l=s.getLocalBounds(),c=s.localTransform,h=c.apply(new X(l.x,l.y)),u=c.apply(new X(l.x+l.width,l.y)),d=c.apply(new X(l.x+l.width,l.y+l.height)),f=c.apply(new X(l.x,l.y+l.height)),m=Math.min(h.x,u.x,d.x,f.x),g=Math.max(h.x,u.x,d.x,f.x),p=Math.min(h.y,u.y,d.y,f.y),_=Math.max(h.y,u.y,d.y,f.y);return new W(m,p,g-m,_-p)}let r=1/0,n=1/0,o=-1/0,a=-1/0;for(const l of t){const c=l.getBounds(),h=e.toLocal(new X(c.minX,c.minY)),u=e.toLocal(new X(c.maxX,c.maxY));r=Math.min(r,h.x,u.x),n=Math.min(n,h.y,u.y),o=Math.max(o,h.x,u.x),a=Math.max(a,h.y,u.y)}return new W(r,n,o-r,a-n)}updateBounds(){this.#u()}#x=e=>{this.#u(),this.isDragging=!0,this.lastPointer.copyFrom(e.global),this.cursor="grabbing"};#p=()=>{this.isDragging&&this.emit("transformEnd"),this.isDragging=!1,this.activeHandle=null,this.cursor="default"};#v=e=>{if(!this.isDragging||this.activeHandle||!this.parent)return;const t=this.parent.toLocal(this.lastPointer),s=this.parent.toLocal(e.global),r=s.x-t.x,n=s.y-t.y;for(const l of this.group)l.x+=r,l.y+=n;const o=e.global.x-this.lastPointer.x,a=e.global.y-this.lastPointer.y;this.#i.x+=o,this.#i.y+=a,this.lastPointer.copyFrom(e.global),this.#d(),this.emit("transforming")};#y(e,t){this.#u(),this.isDragging=!0,this.activeHandle=e,this.#a.clear();for(const s of this.group)this.#a.set(s,s.localTransform.clone());this.rotation=this.#r,this.#c.copyFrom(this.#h),this.#A(e)}#b(e,t){this.#T(e,t)}async#T(e,t){const s=this.#s,r=this.#E(e,this.toLocal(t),s),n=r.width/this.#c.width,o=r.height/this.#c.height,a=this.toGlobal(s);if(this.opts.clip&&this.opts.clip.type==="Text"){const c=r.width;this.emit("textClipResize",{handle:e,newWidth:c,newHeight:r.height,pivotWorld:a,proposed:r,sx:n,sy:o})}else this.#g(this.#I(a,this.#r,n,o));this.#h.copyFrom(r),this.#d(),this.emit("transforming")}#w(e){this.#u(),this.isDragging=!0,this.activeHandle="rot",this.#a.clear();for(const t of this.group)this.#a.set(t,t.localTransform.clone());this.#l=Math.atan2(e.y-this.#i.y,e.x-this.#i.x)}#S(e){const s=Math.atan2(e.y-this.#i.y,e.x-this.#i.x)-this.#l,r=this.#r+s;this.#g(this.#P(this.#i,s)),this.rotation=r,this.#d(r),this.emit("transforming")}#m(){this.isDragging=!1,this.#r=this.rotation,this.activeHandle=null,this.#d(this.#r),this.emit("transformEnd")}#d(e=this.#r){this.parent&&this.position.copyFrom(this.parent.toLocal(this.#i)),this.rotation=e;const s=1/((this.parent?Math.abs(this.parent.worldTransform.a):1)||1),r=this.#h;this.wireframe.draw(r,s);const n=r.x+r.width/2,o=r.y+r.height/2,a=this.opts.clip?.getVisibleHandles?.()??["tl","tr","bl","br","ml","mr","mt","mb","rot"],l=[this.#e.tl,this.#e.tr,this.#e.bl,this.#e.br,this.#e.ml,this.#e.mr,this.#e.mt,this.#e.mb,this.#e.rot];for(const c of l)c.scale.set(s);this.#e.tl.visible=a.includes("tl"),this.#e.tr.visible=a.includes("tr"),this.#e.bl.visible=a.includes("bl"),this.#e.br.visible=a.includes("br"),this.#e.ml.visible=a.includes("ml"),this.#e.mr.visible=a.includes("mr"),this.#e.mt.visible=a.includes("mt"),this.#e.mb.visible=a.includes("mb"),this.#e.rot.visible=a.includes("rot"),this.#e.tl.position.set(r.x,r.y),this.#e.tr.position.set(r.x+r.width,r.y),this.#e.bl.position.set(r.x,r.y+r.height),this.#e.br.position.set(r.x+r.width,r.y+r.height),this.#e.ml.position.set(r.x,o),this.#e.mr.position.set(r.x+r.width,o),this.#e.mt.position.set(n,r.y),this.#e.mb.position.set(n,r.y+r.height),this.#e.rot.position.set(n,r.y-30*s),this.#C(s)}#C(e){if(this.selectionOutlines.clear(),this.group.length<=1||!this.parent)return;const t={width:1*e,color:43775,alpha:1};for(const s of this.group){const r=this.#f(s);this.#t[0].set(r.x,r.y),this.#t[1].set(r.x+r.width,r.y),this.#t[2].set(r.x+r.width,r.y+r.height),this.#t[3].set(r.x,r.y+r.height);for(const n of this.#t)s.toGlobal(n,n),this.toLocal(n,void 0,n);this.selectionOutlines.moveTo(this.#t[0].x,this.#t[0].y).lineTo(this.#t[1].x,this.#t[1].y).lineTo(this.#t[2].x,this.#t[2].y).lineTo(this.#t[3].x,this.#t[3].y).closePath().stroke(t)}}#A(e){const t=this.#c;if(this.opts.centeredScaling){this.#s.set(t.x+t.width/2,t.y+t.height/2);return}e==="tl"?this.#s.set(t.x+t.width,t.y+t.height):e==="tr"?this.#s.set(t.x,t.y+t.height):e==="bl"?this.#s.set(t.x+t.width,t.y):e==="br"?this.#s.set(t.x,t.y):e==="ml"?this.#s.set(t.x+t.width,t.y+t.height/2):e==="mr"?this.#s.set(t.x,t.y+t.height/2):e==="mt"?this.#s.set(t.x+t.width/2,t.y+t.height):e==="mb"&&this.#s.set(t.x+t.width/2,t.y)}#E(e,t,s){if(this.opts.centeredScaling){const n=Math.max(this.#n,Math.abs(t.x-s.x)*2),o=Math.max(this.#o,Math.abs(t.y-s.y)*2);return new W(s.x-n/2,s.y-o/2,n,o)}if(e==="tl"){const n=Math.min(t.x,s.x-this.#n),o=Math.min(t.y,s.y-this.#o);return new W(n,o,s.x-n,s.y-o)}if(e==="tr"){const n=Math.max(t.x,s.x+this.#n),o=Math.min(t.y,s.y-this.#o);return new W(s.x,o,n-s.x,s.y-o)}if(e==="bl"){const n=Math.min(t.x,s.x-this.#n),o=Math.max(t.y,s.y+this.#o);return new W(n,s.y,s.x-n,o-s.y)}if(e==="br"){const n=Math.max(t.x,s.x+this.#n),o=Math.max(t.y,s.y+this.#o);return new W(s.x,s.y,n-s.x,o-s.y)}const r=this.#c;if(e==="ml"){const n=Math.min(t.x,s.x-this.#n);return new W(n,r.y,s.x-n,r.height)}if(e==="mr"){const n=Math.max(t.x,s.x+this.#n);return new W(s.x,r.y,n-s.x,r.height)}if(e==="mt"){const n=Math.min(t.y,s.y-this.#o);return new W(r.x,n,r.width,s.y-n)}if(e==="mb"){const n=Math.max(t.y,s.y+this.#o);return new W(r.x,s.y,r.width,n-s.y)}return new W(s.x,s.y,this.#n,this.#o)}#I(e,t,s,r){return Lx.delta.identity().translate(-e.x,-e.y).rotate(-t).scale(s,r).rotate(t).translate(e.x,e.y)}#P(e,t){return Lx.delta.identity().translate(-e.x,-e.y).rotate(t).translate(e.x,e.y)}#g(e){for(const t of this.group){const s=this.#a.get(t),r=t.parent;if(!s||!r)continue;const n=r.worldTransform.clone().invert(),o=r.worldTransform.clone().append(s),a=e.clone().append(o),l=n.clone().append(a);t.setFromMatrix(l)}}}class fM{constructor(e){this.studio=e}selectedClips=new Set;activeTransformer=null;interactiveClips=new Set;selectionGraphics=null;isDragSelecting=!1;dragSelectionStart=new X;isUpdatingTextClipRealtime=!1;textClipResizedWidth=null;textClipResizeHandle=null;textClipResizedSx=null;textClipResizedSy=null;init(e,t){this.selectionGraphics=new _e,this.selectionGraphics.visible=!1,this.selectionGraphics.zIndex=1e3,t.addChild(this.selectionGraphics),e.stage.eventMode="static",e.stage.hitArea=e.screen,e.stage.on("pointerdown",s=>this.onStagePointerDown(s)),e.stage.on("globalpointermove",s=>this.onStagePointerMove(s)),e.stage.on("pointerup",()=>this.onStagePointerUp()),e.stage.on("pointerupoutside",()=>this.onStagePointerUp())}onStagePointerDown(e){e.target===this.studio.pixiApp?.stage&&(e.shiftKey||this.deselectClip(),this.isDragSelecting=!0,this.studio.artboard?.toLocal(e.global,void 0,this.dragSelectionStart),this.selectionGraphics&&(this.selectionGraphics.clear(),this.selectionGraphics.visible=!0))}onStagePointerMove(e){if(this.isDragSelecting&&this.selectionGraphics&&this.studio.artboard){const t=this.studio.artboard.toLocal(e.global),s=Math.min(this.dragSelectionStart.x,t.x),r=Math.min(this.dragSelectionStart.y,t.y),n=Math.abs(t.x-this.dragSelectionStart.x),o=Math.abs(t.y-this.dragSelectionStart.y);this.selectionGraphics.clear(),this.selectionGraphics.rect(s,r,n,o).fill({color:703971,alpha:.3}),this.selectionGraphics.rect(s,r,n,o).stroke({width:2,color:703971})}}onStagePointerUp(){if(this.isDragSelecting&&this.selectionGraphics&&this.studio.artboard){const e=this.selectionGraphics.getBounds(),t=[],s=new W(e.x,e.y,e.width,e.height);if(s.width>2||s.height>2){for(const r of this.studio.clips){const n=this.studio.spriteRenderers.get(r);if(!n)continue;const o=n.getRoot();if(!o||!o.visible)continue;const a=o.getBounds();s.x<a.x+a.width&&s.x+s.width>a.x&&s.y<a.y+a.height&&s.y+s.height>a.y&&t.push(r)}if(t.length>0)for(const r of t)this.selectClip(r,!0)}this.selectionGraphics.clear(),this.selectionGraphics.visible=!1,this.isDragSelecting=!1}}setupSpriteInteractivity(e){if(this.interactiveClips.has(e))return;const t=this.studio.spriteRenderers.get(e);if(t==null)return;const s=t.getRoot();s!=null&&(s.eventMode="static",s.cursor="pointer",s.on("pointerdown",r=>{const n=this.getTopmostClipAtPoint(r.global);n&&this.selectClip(n,r.shiftKey)}),this.interactiveClips.add(e))}getTopmostClipAtPoint(e){if(!this.studio.pixiApp)return null;let t=null,s=-1/0;for(const r of this.interactiveClips){const n=this.studio.spriteRenderers.get(r);if(!n)continue;const o=n.getRoot();if(!o||!o.visible)continue;const a=o.toLocal(e),l=o.getLocalBounds();a.x>=l.minX&&a.x<=l.maxX&&a.y>=l.minY&&a.y<=l.maxY&&r.zIndex>s&&(s=r.zIndex,t=r)}return t}selectClip(e,t=!1){if(!(this.studio.destroyed||this.studio.pixiApp==null)){if(t||this.deselectClip(),t&&this.selectedClips.has(e)){this.selectedClips.delete(e),this.recreateTransformer(),this.studio.emit("selection:updated",{selected:Array.from(this.selectedClips)});return}this.selectedClips.add(e),this.recreateTransformer(),t?this.studio.emit("selection:updated",{selected:Array.from(this.selectedClips)}):this.studio.emit("selection:created",{selected:Array.from(this.selectedClips)})}}selectClipsByIds(e){const t=this.studio.clips.filter(s=>e.includes(s.id));this.setSelection(t)}setSelection(e){if(!(this.studio.destroyed||this.studio.pixiApp==null)&&!(this.selectedClips.size===e.length&&e.every(t=>this.selectedClips.has(t)))){for(const t of this.selectedClips)this.syncSpriteToClipProperties(t);this.destroyTransformer(),this.selectedClips.clear();for(const t of e)this.selectedClips.add(t);this.selectedClips.size>0?(this.createTransformer(),this.studio.emit("selection:updated",{selected:Array.from(this.selectedClips)})):this.studio.emit("selection:cleared",{deselected:[]})}}deselectClip(){if(this.selectedClips.size>0)for(const t of this.selectedClips)this.syncSpriteToClipProperties(t);this.destroyTransformer();const e=Array.from(this.selectedClips);this.selectedClips.clear(),e.length>0&&this.studio.emit("selection:cleared",{deselected:e})}clear(){this.deselectClip(),this.interactiveClips.clear()}recreateTransformer(){this.destroyTransformer(),this.selectedClips.size>0&&this.createTransformer()}destroyTransformer(){this.activeTransformer!=null&&(this.activeTransformer.parent!=null&&this.activeTransformer.parent.removeChild(this.activeTransformer),this.activeTransformer.destroy(),this.activeTransformer=null)}createTransformer(){if(this.studio.destroyed||this.studio.artboard==null||this.selectedClips.size===0)return;const e=[];let t=null;for(const r of this.selectedClips){const n=this.studio.spriteRenderers.get(r);if(n==null)continue;const o=n.getRoot();o!=null&&(e.push(o),this.selectedClips.size===1&&(t=r))}if(e.length===0){console.warn("Cannot create transformer: no sprites found");return}this.activeTransformer=new dM({group:e,clip:t});let s=null;this.activeTransformer.on("transforming",()=>{s===null&&(s=requestAnimationFrame(()=>{s=null,this.syncSelectedClipsTransformsRealtime()}))}),this.activeTransformer.on("textClipResize",r=>{this.textClipResizedWidth=r.newWidth,this.textClipResizeHandle=r.handle,this.textClipResizedSx=r.sx,this.textClipResizedSy=r.sy}),this.activeTransformer.on("transformEnd",()=>{s!==null&&(cancelAnimationFrame(s),s=null),this.syncSelectedClipsTransforms()}),this.activeTransformer.on("pointerdown",r=>{const n=this.getTopmostClipAtPoint(r.global);n&&!this.selectedClips.has(n)&&(this.selectClip(n,r.shiftKey),r.stopPropagation())}),this.studio.artboard.addChild(this.activeTransformer)}async syncSelectedClipsTransformsRealtime(){if(!(this.selectedClips.size===0||this.activeTransformer==null)&&!this.isUpdatingTextClipRealtime){this.isUpdatingTextClipRealtime=!0;try{const e=this.activeTransformer.activeHandle;if(e!=="mr"&&e!=="ml")return;for(const t of this.selectedClips){if(!(t instanceof xt))continue;const s=this.studio.spriteRenderers.get(t);if(s==null)continue;const r=s.getRoot(),n=s.getSprite();if(r==null||n==null||n.texture==null)continue;const o=Math.abs(r.scale.x*n.scale.x);if(o===1)continue;const a=t.left,l=t.top,c=t.width,h=n.texture.width,u=o*h;await t.updateStyle({wordWrap:!0,wordWrapWidth:u});const d=await t.getTexture();d&&(await s.updateFrame(d),n.scale.set(1,1),r.scale.set(1,1),e==="ml"?t.left=a+c-t.width:t.left=a,t.top=l,r.x=t.left+t.width/2,r.y=t.top+t.height/2,this.activeTransformer.updateBounds())}}finally{this.isUpdatingTextClipRealtime=!1}}}async syncSelectedClipsTransforms(){if(!(this.selectedClips.size===0||this.activeTransformer==null)){for(const e of this.selectedClips){const t=this.studio.spriteRenderers.get(e);if(t==null)continue;const s=t.getRoot(),r=t.getSprite();if(s==null||r==null||r.texture==null)continue;const n=r.texture.width,o=r.texture.height,a=Math.abs(s.scale.x*r.scale.x)*n,l=Math.abs(s.scale.y*r.scale.y)*o,c=(e instanceof xt||e instanceof ti)&&this.textClipResizedWidth!==null?this.textClipResizedWidth:a,h=e.width,d=(e.style?.fontSize??16)*Math.max(this.textClipResizedSx||1,this.textClipResizedSy||1);let f=s.x;const m=s.y-l/2,g=s.x-c/2;if(e instanceof xt&&this.textClipResizedWidth!==null){const _={wordWrap:!0,wordWrapWidth:c};this.textClipResizeHandle==="mr"?(f=e.left+c/2,s.x=f):this.textClipResizeHandle==="ml"?(f=e.left+c/2-(c-h),s.x=f):["br","tr"].includes(this.textClipResizeHandle)?(f=e.left+c/2,_.fontSize=d):["bl","tl"].includes(this.textClipResizeHandle)&&(f=e.left+c/2-(c-h),_.fontSize=d),await e.updateStyle(_);const x=await e.getTexture();x&&(await t.updateFrame(x),e.width=c,e.height=x.height,this.textClipResizedWidth=null,e.left=f-e.width/2,e.top=s.y-e.height/2,r.scale.set(1,1),s.scale.set(1,1))}else{e.left=g,e.top=m,e.width=a,e.height=l;const _=e.flip==null?1:-1;e.angle=_*s.angle}}this.activeTransformer!=null&&this.activeTransformer.updateBounds();for(const e of this.selectedClips){const t=this.studio.spriteRenderers.get(e);t?.updateTransforms()}}}syncSpriteToClipProperties(e){const t=this.studio.spriteRenderers.get(e);if(t!=null){const s=t.getRoot(),r=t.getSprite();if(s!=null&&r!=null&&r.texture!=null){const n=r.texture.width,o=r.texture.height,a=Math.abs(s.scale.x*r.scale.x)*n,l=Math.abs(s.scale.y*r.scale.y)*o,c=s.x-a/2,h=s.y-l/2;e.left=c,e.top=h,e.width=a,e.height=l;const u=e.flip==null?1:-1;e.angle=u*s.angle,t.updateTransforms()}}}async deleteSelected(){return this.studio.deleteSelected()}}class pM{constructor(e){this.studio=e}isPlaying=!1;currentTime=0;maxDuration=0;playStartTime=0;playStartTimestamp=0;rafId=null;playbackElements=new Map;setMaxDuration(e){this.maxDuration=e}async play(){if(!(this.isPlaying||this.studio.destroyed)){if(this.maxDuration<=0||this.maxDuration===1/0||isNaN(this.maxDuration)){console.warn("Cannot play: invalid duration",this.maxDuration);return}this.isPlaying||(this.isPlaying=!0),this.playStartTime=this.currentTime,this.playStartTimestamp=performance.now();for(const[e,{element:t}]of this.playbackElements.entries()){if(!(this.currentTime>=e.display.from&&(e.display.to===0||this.currentTime<=e.display.to))){this.isPlaybackCapable(e)&&e.pause(t);continue}const r=(this.currentTime-e.display.from)/1e6;this.isPlaybackCapable(e)&&await e.play(t,r)}this.renderLoop(),this.studio.emit("play",{isPlaying:!0})}}pause(){this.isPlaying=!1,this.rafId!=null&&(cancelAnimationFrame(this.rafId),this.rafId=null);for(const[e,{element:t}]of this.playbackElements.entries())this.isPlaybackCapable(e)&&e.pause(t);this.studio.emit("pause",{isPlaying:!1})}async stop(){this.pause(),await this.seek(0)}async seek(e){if(this.studio.destroyed)return;const t=this.isPlaying;this.playStartTime=Math.max(0,Math.min(e,this.maxDuration)),this.playStartTimestamp=performance.now(),this.currentTime=this.playStartTime;for(const[s,{element:r}]of this.playbackElements.entries()){if(!(this.currentTime>=s.display.from&&(s.display.to===0||this.currentTime<=s.display.to))){this.isPlaybackCapable(s)&&s.pause(r);continue}const o=(this.currentTime-s.display.from)/1e6;this.isPlaybackCapable(s)&&await s.seek(r,o)}if(await this.studio.updateFrame(this.currentTime),this.studio.emit("currentTime",{currentTime:this.currentTime}),t){this.isPlaying=!0;for(const[s,{element:r}]of this.playbackElements.entries()){if(!(this.currentTime>=s.display.from&&(s.display.to===0||this.currentTime<=s.display.to)))continue;const o=(this.currentTime-s.display.from)/1e6;this.isPlaybackCapable(s)&&await s.play(r,o)}}}async renderLoop(){if(!this.isPlaying||this.studio.destroyed||this.studio.pixiApp==null)return;if(this.maxDuration<=0||this.maxDuration===1/0||isNaN(this.maxDuration)){this.pause();return}const e=async()=>{if(!this.isPlaying||this.studio.destroyed||this.studio.pixiApp==null)return;if(this.currentTime>=this.maxDuration){this.currentTime=this.maxDuration,this.pause();return}const s=(performance.now()-this.playStartTimestamp)*1e3;this.currentTime=Math.min(this.playStartTime+s,this.maxDuration),this.studio.emit("currentTime",{currentTime:this.currentTime});try{await this.studio.updateFrame(this.currentTime)}catch(r){console.warn("Error updating frame:",r)}this.isPlaying&&(this.rafId=requestAnimationFrame(e))};e()}isPlaybackCapable(e){return"play"in e&&"pause"in e&&"seek"in e}}class Zi{static instance;fonts=new Map;constructor(){}static getInstance(){return Zi.instance||(Zi.instance=new Zi),Zi.instance}async addFont(e){if(!this.fonts.has(e.name))try{const s=await new FontFace(e.name,`url(${e.url})`).load();document.fonts.add(s),this.fonts.set(e.name,s)}catch(t){console.error(`Failed to load font ${e.name}:`,t)}}async loadFonts(e){await Promise.all(e.map(t=>this.addFont(t)))}removeFont(e){const t=this.fonts.get(e);t&&(document.fonts.delete(t),this.fonts.delete(e))}clear(){this.fonts.forEach(e=>{document.fonts.delete(e)}),this.fonts.clear()}getLoadedFonts(){return Array.from(this.fonts.keys())}}const Nx=Zi.getInstance();class mM{constructor(e){this.studio=e}tracks=[];clips=[];getTrackById(e){return this.tracks.find(t=>t.id===e)}getClipById(e){return this.clips.find(t=>t.id===e)}findTrackIdByClipId(e){for(const t of this.tracks)if(t.clipIds.includes(e))return t.id}getTrackIndex(e){return this.tracks.findIndex(t=>t.id===e)}addTrack(e){const t={id:e.id||`track_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,name:e.name,type:e.type,clipIds:[]};return this.tracks.push(t),this.studio.emit("track:added",{track:t}),t}async removeTrack(e){const t=this.tracks.findIndex(n=>n.id===e);if(t===-1)return;const r=[...this.tracks[t].clipIds];for(const n of r)await this.removeClipById(n);this.tracks.splice(t,1),this.studio.emit("track:removed",{trackId:e})}async addMedia(e){if(this.studio.destroyed)return;const t=this.studio.opts.width,s=this.studio.opts.height;t&&s&&(typeof e.scaleToFit=="function"&&await e.scaleToFit(t,s),typeof e.centerInScene=="function"&&e.centerInScene(t,s));const r=e.duration>0?e.duration:5e6;e.duration<=0&&(e.duration=r);const n=this.tracks.filter(l=>["media","video","image","Video","Image"].includes(l.type)),o=n.find(l=>l.clipIds.length>0)||n[0];let a;if(o){a=o.id;const l=r;for(const c of o.clipIds){const h=this.getClipById(c);if(h){const u=h.display.from+l,d=h.display.to+l;await this.updateClip(c,{display:{from:u,to:d}})}}}e.display.from=0,e.display.to=r,await this.addClip(e,{trackId:a}),await this.studio.seek(0)}async addTransition(e,t=2e6,s,r){if(this.studio.destroyed)return;let n=null,o=null;if(s&&r&&(n=this.getClipById(s)??null,o=this.getClipById(r)??null,!n||!o)){console.warn("[Studio] Invalid fromClipId or toClipId",{fromClipId:s,toClipId:r});return}if(!o){const f=this.tracks.filter(m=>["media","video","image","Video","Image"].includes(m.type)||m.clipIds.length>1);for(const m of f){const g=m.clipIds.map(p=>this.getClipById(p)).filter(p=>!!p&&p.type!=="Transition").sort((p,_)=>p.display.from-_.display.from);for(let p=0;p<g.length-1;p++){const _=g[p],x=g[p+1];if(Math.abs(x.display.from-_.display.to)<1e5){n=_,o=x;break}}if(n&&o)break}}if(o&&!n){const f=this.findTrackIdByClipId(o.id);if(f){const m=this.tracks.find(g=>g.id===f);if(m){const g=m.clipIds.map(_=>this.getClipById(_)).filter(_=>!!_&&_.type!=="Transition").sort((_,x)=>_.display.from-x.display.from),p=g.findIndex(_=>_.id===o.id);p>0&&(n=g[p-1])}}}if(!n||!o){console.warn("[Studio] Unable to resolve Clip A and Clip B for transition");return}const a=t,l=o.display.from-a/2,c=l+a,h={key:e,name:e,duration:a,fromClipId:n.id,toClipId:o.id,start:Math.max(0,l),end:c},u=this.findTrackIdByClipId(o.id);if(u){const f=this.tracks.find(m=>m.id===u);if(f){const m=f.clipIds.map(g=>this.getClipById(g)).filter(g=>{if(!g||g.type!=="Transition")return!1;const p=g;return p.fromClipId===n.id&&p.toClipId===o.id});for(const g of m)await this.removeClip(g)}}this.studio.transitionRenderers.has(n.id)&&(this.studio.transitionRenderers.get(n.id)?.destroy(),this.studio.transitionRenderers.delete(n.id)),this.studio.transitionRenderers.has(o.id)&&(this.studio.transitionRenderers.get(o.id)?.destroy(),this.studio.transitionRenderers.delete(o.id)),"transition"in n&&(n.transition={...h}),"transition"in o&&(o.transition={...h});const d=new xi(e);d.duration=a,d.fromClipId=Math.max(0,l)===0?null:n.id,d.toClipId=o.id,d.fromClipId===null&&n&&(d.fromClipId=n.id),d.display.from=Math.max(0,l),d.display.to=c,await this.addClip(d,{trackId:u}),this.studio.seek(this.studio.currentTime)}async addClip(e,t){const s=Array.isArray(e)?e:[e];if(s.length===0)return;const{trackId:r,audioSource:n}=this.normalizeAddClipOptions(t);if(this.studio.destroyed)return;if(this.studio.pixiApp==null)throw new Error("Failed to initialize Pixi.js Application");const o=[];for(const a of s)await this.prepareClipForTimeline(a,r),o.push(a);await this.recalculateMaxDuration();for(const a of o)await this.setupClipVisuals(a,n);await this.studio.updateFrame(this.studio.currentTime),this.emitAddClipEvents(o,r)}normalizeAddClipOptions(e){let t,s;if(e&&(typeof e=="string"||e instanceof File||e instanceof Blob))t=e;else if(typeof e=="object"&&e!==null&&!("size"in e)){const r=e;t=r.audioSource,s=r.trackId}return{trackId:s,audioSource:t}}async prepareClipForTimeline(e,t){const s=async()=>{await this.studio.updateFrame(this.studio.currentTime);const r=this.studio.selection;r.activeTransformer!=null&&r.selectedClips.has(e)&&typeof r.activeTransformer.updateBounds=="function"&&r.activeTransformer.updateBounds()};e.on("propsChange",s),this.studio.clipListeners.set(e,s),this.studio.pixiApp!=null&&typeof e.setRenderer=="function"&&e.setRenderer(this.studio.pixiApp.renderer),await e.ready,e.id||(e.id=`clip_${Date.now()}_${Math.random().toString(36).substr(2,9)}`),this.clips.includes(e)||this.clips.push(e),this.addClipToTrack(e,t)}addClipToTrack(e,t){if(t){const s=this.tracks.find(r=>r.id===t);s?s.clipIds.includes(e.id)||s.clipIds.push(e.id):this.tracks.unshift({id:t,name:`Track ${this.tracks.length+1}`,type:e.type,clipIds:[e.id]})}else{const s=`track_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;this.tracks.unshift({id:s,name:`Track ${this.tracks.length+1}`,type:e.type,clipIds:[e.id]})}}async setupClipVisuals(e,t){const s=await e.ready;if(await this.setupPlaybackForClip(e,t),s.width>0&&s.height>0){const r=this.studio.clipsNormalContainer,n=e.type==="Video"&&this.isPlaybackCapable(e);if(!n||n&&e.tickInterceptor!=null){const o=new gn(this.studio.pixiApp,e,r);this.studio.spriteRenderers.set(e,o)}}this.studio.opts.interactivity&&this.studio.selection.setupSpriteInteractivity(e)}emitAddClipEvents(e,t){if(e.length!==0)if(e.length===1){const s=e[0],r=t||this.tracks.find(n=>n.clipIds.includes(s.id))?.id||"";this.studio.emit("clip:added",{clip:s,trackId:r})}else this.studio.emit("clips:added",{clips:e,trackId:t})}async removeClip(e){const t=this.clips.findIndex(a=>a===e);if(t===-1)return;if(e instanceof xi){if(e.fromClipId){const a=this.getClipById(e.fromClipId);a&&"transition"in a&&delete a.transition}if(e.toClipId){const a=this.getClipById(e.toClipId);a&&"transition"in a&&delete a.transition}}this.studio.selection.selectedClips.has(e)&&this.studio.selection.deselectClip(),this.clips.splice(t,1);for(const a of this.tracks){const l=a.clipIds.indexOf(e.id);l!==-1&&a.clipIds.splice(l,1)}this.studio.selection.interactiveClips.delete(e);const s=this.studio.clipListeners.get(e);s&&(e.off("propsChange",s),this.studio.clipListeners.delete(e));const r=this.studio.spriteRenderers.get(e);r!=null&&(r.destroy(),this.studio.spriteRenderers.delete(e));const n=this.studio.transport.playbackElements.get(e);n!=null&&(this.isPlaybackCapable(e)&&e.cleanupPlayback(n.element,n.objectUrl),this.studio.transport.playbackElements.delete(e));const o=this.studio.videoSprites.get(e);o!=null&&this.studio.pixiApp!=null&&(o.parent&&o.parent.removeChild(o),o.destroy(),this.studio.videoSprites.delete(e)),await this.recalculateMaxDuration(),this.studio.emit("clip:removed",{clipId:e.id})}async removeClipById(e){const t=this.clips.find(s=>s.id===e);t&&await this.removeClip(t)}async updateClip(e,t){const s=this.clips.find(r=>r.id===e);s&&(await this.applyClipUpdate(s,t),await this.recalculateMaxDuration(),await this.studio.updateFrame(this.studio.currentTime),this.updateTransformer(s),this.studio.emit("clip:updated",{clip:s}))}async updateClips(e){const t=[];for(const{id:s,updates:r}of e){const n=this.clips.find(o=>o.id===s);n&&(await this.applyClipUpdate(n,r),t.push(n))}if(t.length!==0){await this.recalculateMaxDuration(),await this.studio.updateFrame(this.studio.currentTime);for(const s of t)this.updateTransformer(s),this.studio.emit("clip:updated",{clip:s})}}async replaceClipsBySource(e,t){const s=this.clips.filter(r=>r.src===e);if(s.length!==0){this.studio.suspendRendering();for(const r of s){if(!this.clips.includes(r))continue;const n=this.findTrackIdByClipId(r.id);if(!n)continue;const o=this.getTrackById(n);if(!o)continue;const a=await t(r),l=async()=>{await this.studio.updateFrame(this.studio.currentTime),this.updateTransformer(a)};a.on("propsChange",l),this.studio.clipListeners.set(a,l),this.studio.pixiApp!=null&&typeof a.setRenderer=="function"&&a.setRenderer(this.studio.pixiApp.renderer),await a.ready;const c=this.clips.indexOf(r);c!==-1&&(this.clips[c]=a);const h=o.clipIds.indexOf(r.id);h!==-1&&(o.clipIds[h]=a.id),await this.setupClipVisuals(a);const u=this.studio.spriteRenderers.get(r);u&&(u.destroy(),this.studio.spriteRenderers.delete(r));const d=this.studio.videoSprites.get(r);d&&(d.parent&&d.parent.removeChild(d),d.destroy(),this.studio.videoSprites.delete(r));const f=this.studio.clipListeners.get(r);f&&(r.off("propsChange",f),this.studio.clipListeners.delete(r)),this.studio.selection.selectedClips.has(r)&&(this.studio.selection.selectedClips.delete(r),this.studio.selection.selectedClips.add(a)),this.studio.emit("clip:replaced",{oldClip:r,newClip:a,trackId:n})}await this.recalculateMaxDuration(),this.studio.resumeRendering(),await this.studio.updateFrame(this.studio.currentTime)}}async applyClipUpdate(e,t){if(e instanceof xt&&(await e.updateStyle(t),"style"in t&&delete t.style),Object.assign(e,t),t.display&&!t.duration?e.duration=t.display.to-t.display.from:t.duration&&(!t.display||!t.display.to)&&(e.display||(e.display={from:0,to:t.duration}),e.display.to=e.display.from+t.duration),t.display&&t.duration){const s=t.display.to-t.display.from;s!==t.duration&&(e.duration=s)}else e.display&&(e.display.to=e.display.from+e.duration)}updateTransformer(e){const t=this.studio.selection;t.selectedClips.has(e)&&t.activeTransformer&&t.activeTransformer.updateBounds()}exportToJSON(){const e=this.clips.map(r=>Xs(r,!1)),t=this.tracks.map(r=>({id:r.id,name:r.name,type:r.type,clipIds:r.clipIds})),s=[];return this.clips.forEach(r=>{if(r.transition){const n=this.tracks.find(o=>o.clipIds.includes(r.id));if(n){const o=n.clipIds.indexOf(r.id);if(o>0){const a=n.clipIds[o-1];s.push({key:r.transition.name,duration:r.transition.duration,clips:[a,r.id]})}}}}),{tracks:t,clips:e,settings:{width:this.studio.opts.width,height:this.studio.opts.height,fps:this.studio.opts.fps,bgColor:this.studio.opts.bgColor}}}async loadFromJSON(e){if(await this.clear(),e.settings){const s=e.settings.width&&e.settings.width!==this.studio.opts.width||e.settings.height&&e.settings.height!==this.studio.opts.height;if(e.settings.width&&(this.studio.opts.width=e.settings.width),e.settings.height&&(this.studio.opts.height=e.settings.height),e.settings.fps&&(this.studio.opts.fps=e.settings.fps),e.settings.bgColor&&(this.studio.opts.bgColor=e.settings.bgColor),s&&this.studio.pixiApp!=null){const r=this.studio.opts.width,n=this.studio.opts.height;this.studio.pixiApp.renderer.resize(r,n),this.studio.opts.canvas&&(this.studio.opts.canvas.width=r,this.studio.opts.canvas.height=n)}}const t=[];if(e.clips){await this.ensureFontsForClips(e.clips);const s=new Map;if(e.tracks){for(const n of e.tracks)if(n.clipIds)for(const o of n.clipIds)s.set(o,n.id)}if(e.tracks)for(const n of e.tracks)this.tracks.push({id:n.id,name:n.name,type:n.type,clipIds:[]});for(const n of e.clips)t.push((async()=>{try{let o=n.id?s.get(n.id):void 0;if(n.type==="Transition"){const l=n,c=l.toClipId||l.fromClipId;c&&(o=s.get(c))}if(n.type!=="Text"&&n.type!=="Caption"&&n.type!=="Effect"&&n.type!=="Transition"&&(!n.src||n.src.trim()===""))return console.warn(`Skipping clip ${n.type} with empty source`,n),{clip:null};const a=await Ys(n);return(a.type==="Video"||a.type==="Image")&&(!n.width||!n.height)&&(console.log("Scaling clip",n),this.studio.opts.width&&this.studio.opts.height&&(typeof a.scaleToFit=="function"&&await a.scaleToFit(this.studio.opts.width,this.studio.opts.height),typeof a.centerInScene=="function"&&a.centerInScene(this.studio.opts.width,this.studio.opts.height))),{clip:a,intendedTrackId:o}}catch(o){return console.error(`Failed to load clip ${n.id||"unknown"}:`,o),{clip:null}}})());const r=await Promise.all(t);for(const{clip:n,intendedTrackId:o}of r)n&&(n.id||(n.id=`clip_${Date.now()}_${Math.random().toString(36).substr(2,9)}`),this.clips.push(n),this.addClipToTrack(n,o))}this.studio.pixiApp&&await Promise.all(this.clips.map(async s=>{const r=async()=>{await this.studio.updateFrame(this.studio.currentTime);const n=this.studio.selection;n.activeTransformer!=null&&n.selectedClips.has(s)&&typeof n.activeTransformer.updateBounds=="function"&&n.activeTransformer.updateBounds()};s.on("propsChange",r),this.studio.clipListeners.set(s,r),typeof s.setRenderer=="function"&&s.setRenderer(this.studio.pixiApp.renderer),await s.ready,await this.setupClipVisuals(s)}));for(const s of this.clips){const r=s.effects;if(Array.isArray(r))for(const n of r)this.studio.globalEffects.has(n.id)||this.studio.globalEffects.set(n.id,{id:n.id,key:n.key,startTime:n.startTime,duration:n.duration})}await this.recalculateMaxDuration();try{await this.studio.updateFrame(this.studio.currentTime)}catch(s){console.error("[Studio] Failed to update initial frame:",s)}this.studio.emit("studio:restored",{clips:this.clips,tracks:this.tracks,settings:this.studio.opts})}async deleteSelected(){const e=this.studio.selection.selectedClips,t=Array.from(e);if(t.length!==0)for(const s of t)await this.removeClip(s)}async duplicateSelected(){const e=this.studio.selection.selectedClips,t=Array.from(e);if(t.length===0)return;const s=[];for(const r of t){const n=this.findTrackIdByClipId(r.id);if(!n)continue;const o=this.tracks.find(u=>u.id===n);if(!o)continue;const a=Xs(r,!1),l=await Ys(a);l.id=`clip_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;const c=`track_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,h=`${o.name} (Copy)`;this.addTrack({id:c,name:h,type:o.type}),await this.addClip(l,{trackId:c}),s.push(l.id)}s.length>0&&this.studio.selection.selectClipsByIds(s)}async splitSelected(e){const t=Array.from(this.studio.selection.selectedClips);if(t.length!==1){console.warn("[Studio] Split requires exactly one selected clip");return}const s=t[0],r=e??this.studio.currentTime;if(r<=s.display.from||s.display.to>0&&r>=s.display.to){console.warn("[Studio] Split time is outside clip bounds");return}const n=Xs(s,!1),o=r-s.display.from,a=s.playbackRate||1,l=o*a,c={duration:o,display:{from:s.display.from,to:r}};s.trim&&(c.trim={from:s.trim.from,to:s.trim.from+l}),await this.updateClip(s.id,c);const h={...n};h.display={from:r,to:n.display.to},h.duration=n.duration-o,h.trim&&(h.trim={from:h.trim.from+l,to:h.trim.to});const u=await Ys(h);u.id=`clip_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;const d=this.findTrackIdByClipId(s.id);d&&(await this.addClip(u,{trackId:d}),this.studio.selection.selectClipsByIds([u.id]))}async trimSelected(e){const t=Array.from(this.studio.selection.selectedClips);if(t.length!==1){console.warn("[Studio] Trim requires exactly one selected clip");return}const s=t[0],r=e*1e6,n=s.playbackRate||1,o=r*n;if(r>=s.duration){console.warn("[Studio] Trim amount exceeds clip duration");return}const a=s.duration-r,l=s.display.from+r,c=s.display.to,h={duration:a,display:{from:l,to:c}};if(s.trim)h.trim={from:s.trim.from+o,to:s.trim.to};else{const u=s.sourceDuration||s.duration;h.trim={from:o,to:u}}await this.updateClip(s.id,h)}async updateSelected(e){const t=Array.from(this.studio.selection.selectedClips);if(t.length!==0)for(const s of t)await this.updateClip(s.id,e)}async setTracks(e){this.tracks=e,await this.recalculateMaxDuration(),await this.studio.updateFrame(this.studio.currentTime)}async ensureFontsForClips(e){const t=new Map;for(const s of e){if(s.type==="Text"){const r=s.style?.fontUrl||s.fontUrl;r&&t.set(r,{name:s.style?.fontFamily||s.fontFamily||"CustomFont",url:r})}if(s.type==="Caption"){const r=s.style?.fontUrl||s.fontUrl;r&&t.set(r,{name:s.style?.fontFamily||s.fontFamily||"CustomFont",url:r})}}if(t.size>0)try{await Nx.loadFonts(Array.from(t.values()))}catch(s){console.warn("Failed to load some fonts:",s)}}async recalculateMaxDuration(){let e=0;for(const t of this.clips){t.display.to===0&&t.duration!==1/0&&!isNaN(t.duration)&&t.duration>0;const s=t.duration>0?t.duration:0;if(s===1/0)continue;const r=t.display.to>0?t.display.to:t.display.from+s;r>e&&(e=r)}this.studio.maxDuration=e}async setupPlaybackForClip(e,t){if(this.studio.pixiApp!=null){if(!this.isPlaybackCapable(e)){if(this.studio.pixiApp!=null&&(await e.ready).width>0&&(await e.ready).height>0){const s=new gn(this.studio.pixiApp,e,this.studio.clipsNormalContainer);this.studio.spriteRenderers.set(e,s)}return}try{const s=e;if(e.type==="Audio"&&t&&typeof t!="string"){const o=URL.createObjectURL(t);e.src=o}const{element:r,objectUrl:n}=await s.createPlaybackElement();if(e.type==="Video"){const o=k.from(r),a=new Be(o);a.visible=!1,this.studio.clipsNormalContainer&&this.studio.clipsNormalContainer.addChild(a),this.studio.videoSprites.set(e,a)}this.studio.transport.playbackElements.set(e,{element:r,objectUrl:n})}catch(s){if(console.warn(`Failed to setup playback for ${e.constructor.name}`,s),this.studio.pixiApp!=null&&(await e.ready).width>0&&(await e.ready).height>0){const r=new gn(this.studio.pixiApp,e,this.studio.artboard);this.studio.spriteRenderers.set(e,r)}}}}isPlaybackCapable(e){return"createPlaybackElement"in e&&"play"in e&&"pause"in e&&"seek"in e&&"syncPlayback"in e&&"cleanupPlayback"in e}async clear(){this.studio.selection.deselectClip(),this.studio.selection.interactiveClips.clear();for(const[e,t]of this.studio.clipListeners)e.off("propsChange",t);this.studio.clipListeners.clear(),this.studio.globalEffects.clear(),this.studio.effectFilters.clear(),this.studio.transitionRenderers.forEach(e=>e.destroy()),this.studio.transitionRenderers.clear(),this.studio.transitionSprites.forEach(e=>{e.parent&&e.parent.removeChild(e),e.destroy()}),this.studio.transitionSprites.clear(),this.studio.spriteRenderers.forEach(e=>e.destroy()),this.studio.spriteRenderers.clear();for(const[e,t]of this.studio.transport.playbackElements)this.isPlaybackCapable(e)&&e.cleanupPlayback(t.element,t.objectUrl);this.studio.transport.playbackElements.clear();for(const e of this.studio.videoSprites.values())e.destroy();this.studio.videoSprites.clear(),this.tracks=[],this.clips=[],this.studio.maxDuration=0,this.studio.currentTime=0,this.studio.emit("reset")}async rippleDelete(e,t){if(e>=t)return;const s=t-e,r=[...this.clips];for(const n of r){const o=n.display.from,a=n.display.to;if(!(a<=e)){if(o>=t){await this.updateClip(n.id,{display:{from:n.display.from-s,to:n.display.to-s}});continue}if(o>=e&&a<=t){await this.removeClip(n);continue}if(o<e&&a>t){const l=await n.clone();l.id=`clip_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;const c=e,h=e+(a-t),u=n.trim.from+(t-o)*n.playbackRate,d=n.trim.to,f=this.tracks.find(m=>m.clipIds.includes(n.id));f&&(await this.addClip(l,{trackId:f.id}),await this.updateClip(l.id,{display:{from:c,to:h},trim:{from:u,to:d}})),await this.updateClip(n.id,{display:{from:n.display.from,to:e},trim:{from:n.trim.from,to:n.trim.from+(e-o)*n.playbackRate}});continue}if(o<e&&a<=t){await this.updateClip(n.id,{display:{from:n.display.from,to:e},trim:{from:n.trim.from,to:n.trim.from+(e-o)*n.playbackRate}});continue}if(o>=e&&a>t){await this.updateClip(n.id,{display:{from:e,to:e+(a-t)},trim:{from:n.trim.from+(t-o)*n.playbackRate,to:n.trim.to}});continue}}}await this.recalculateMaxDuration(),await this.studio.updateFrame(this.studio.currentTime)}}class gM extends Jh{selection;transport;timeline;pixiApp=null;get tracks(){return this.timeline.tracks}get clips(){return this.timeline.clips}spriteRenderers=new Map;artboard=null;clipContainer=null;artboardMask=null;artboardBg=null;get activeTransformer(){return this.selection.activeTransformer}set activeTransformer(e){this.selection.activeTransformer=e}get selectedClips(){return this.selection.selectedClips}set selectedClips(e){this.selection.selectedClips=e}get interactiveClips(){return this.selection.interactiveClips}set interactiveClips(e){this.selection.interactiveClips=e}get playbackElements(){return this.transport.playbackElements}videoSprites=new Map;clipListeners=new Map;get isPlaying(){return this.transport.isPlaying}set isPlaying(e){this.transport.isPlaying=e}get currentTime(){return this.transport.currentTime}set currentTime(e){this.transport.currentTime=e}get maxDuration(){return this.transport.maxDuration}set maxDuration(e){this.transport.maxDuration=e}opts;destroyed=!1;renderingSuspended=!1;globalEffects=new Map;activeGlobalEffect=null;currentGlobalEffectSprite=null;effectFilters=new Map;transitionRenderers=new Map;transitionSprites=new Map;transFromTexture=null;transToTexture=null;transBgGraphics=null;clipsNormalContainer=null;clipsEffectContainer=null;videoTextureCache=new WeakMap;lastFromFrame=null;lastToFrame=null;hexToNumber(e){const t=e.startsWith("#")?e.slice(1):e;return parseInt(t,16)}ready;constructor(e){super(),this.opts={fps:30,bgColor:"#000000",interactivity:!0,...e},this.selection=new fM(this),this.transport=new pM(this),this.timeline=new mM(this),this.ready=this.initPixiApp(),this.on("clip:removed",this.handleClipRemoved),this.on("clip:updated",this.handleTimelineChange),this.on("clip:added",this.handleTimelineChange),this.on("clips:added",this.handleTimelineChange),this.on("track:removed",this.handleTimelineChange),this.on("track:added",this.handleTimelineChange)}handleTimelineChange=()=>{this.updateFrame(this.currentTime)};handleClipRemoved=({clipId:e})=>{for(const[r,n]of this.spriteRenderers)if(r.id===e){const o=n.getRoot();o&&o.parent&&o.parent.removeChild(o),n.destroy(),this.spriteRenderers.delete(r);break}const t=this.transitionSprites.get(e);t&&(t.parent&&t.parent.removeChild(t),t.destroy(),this.transitionSprites.delete(e)),this.transitionRenderers.get(e)&&this.transitionRenderers.delete(e);for(const[r,n]of this.videoSprites)if(r.id===e){n.parent&&n.parent.removeChild(n),n.destroy(),this.videoSprites.delete(r);break}for(const[r]of this.clipListeners)if(r.id===e){this.clipListeners.delete(r);break}this.updateFrame(this.currentTime)};async initPixiApp(){if(this.destroyed)return;const e=this.opts.canvas||document.createElement("canvas");e.width=this.opts.width,e.height=this.opts.height;const t=new Hu,s=e.parentElement||window;await t.init({canvas:e,resizeTo:s,backgroundColor:this.hexToNumber(this.opts.bgColor),antialias:!0,resolution:window.devicePixelRatio||1,autoDensity:!0}),this.pixiApp=t,t.stage.eventMode="static",t.stage.hitArea=t.screen,this.artboard=new se,this.artboard.label="ArtboardRoot",t.stage.addChild(this.artboard),this.selection.init(t,this.artboard),this.artboardBg=new _e,this.artboardBg.rect(0,0,this.opts.width,this.opts.height).fill({color:0}),this.artboard.addChild(this.artboardBg),this.clipContainer=new se,this.clipContainer.label="ClipContainer",this.artboard.addChild(this.clipContainer),this.artboardMask=new _e,this.artboardMask.rect(0,0,this.opts.width,this.opts.height).fill({color:16777215}),this.clipContainer.addChild(this.artboardMask),this.clipContainer.mask=this.artboardMask,this.clipsEffectContainer=new se,this.clipsEffectContainer.label="ClipsEffect",this.clipsEffectContainer.visible=!1,this.clipsEffectContainer.zIndex=1,this.clipsEffectContainer.sortableChildren=!0,this.clipContainer.addChild(this.clipsEffectContainer),this.clipsNormalContainer=new se,this.clipsNormalContainer.label="ClipsNormal",this.clipsNormalContainer.zIndex=10,this.clipsNormalContainer.sortableChildren=!0,this.clipContainer.addChild(this.clipsNormalContainer),this.transFromTexture=Ge.create({width:this.opts.width,height:this.opts.height}),this.transToTexture=Ge.create({width:this.opts.width,height:this.opts.height}),this.transBgGraphics=new _e,this.transBgGraphics.rect(0,0,this.opts.width,this.opts.height).fill({color:0,alpha:0}),this.clipContainer.sortableChildren=!0,this.updateArtboardLayout(),t.renderer.on("resize",()=>{this.handleResize()})}getOptions(){return this.opts}updateDimensions(e,t){this.opts.width=e,this.opts.height=t,this.artboardBg&&this.artboardBg.clear().rect(0,0,e,t).fill({color:3355443}),this.artboardMask&&this.artboardMask.clear().rect(0,0,e,t).fill({color:16777215}),this.transFromTexture&&this.transFromTexture.resize(e,t),this.transToTexture&&this.transToTexture.resize(e,t),this.transBgGraphics&&this.transBgGraphics.clear().rect(0,0,e,t).fill({color:0,alpha:0}),this.updateArtboardLayout(),this.updateFrame(this.currentTime)}handleResize=()=>{this.destroyed||!this.pixiApp||this.updateArtboardLayout()};updateArtboardLayout(){if(!this.pixiApp||!this.artboard)return;const e=this.pixiApp.canvas.width,t=this.pixiApp.canvas.height,s=this.opts.width,r=this.opts.height,n=this.pixiApp.canvas.parentElement?.clientWidth||e,o=this.pixiApp.canvas.parentElement?.clientHeight||t,a=n/s,l=o/r,c=Math.min(a,l);this.artboard.scale.set(c),this.artboard.x=(n-s*c)/2,this.artboard.y=(o-r*c)/2}getCanvas(){if(this.opts.canvas)return this.opts.canvas;if(this.pixiApp?.canvas)return this.pixiApp.canvas;throw new Error("Canvas not initialized yet. Wait for initPixiApp to complete.")}async addMedia(e){return this.timeline.addMedia(e)}async addTransition(e,t=2e6,s,r){return this.timeline.addTransition(e,t,s,r)}findTrackIdByClipId(e){return this.timeline.findTrackIdByClipId(e)}async addClip(e,t){return this.timeline.addClip(e,t)}addTrack(e){return this.timeline.addTrack(e)}async setTracks(e){return this.timeline.setTracks(e)}async removeTrack(e){return this.timeline.removeTrack(e)}getClipById(e){return this.timeline.getClipById(e)}async updateClip(e,t){return this.timeline.updateClip(e,t)}async updateClips(e){this.suspendRendering(),await this.timeline.updateClips(e),this.resumeRendering(),this.updateFrame(this.currentTime)}suspendRendering(){this.renderingSuspended=!0}resumeRendering(){this.renderingSuspended=!1}getTracks(){return this.timeline.tracks}getClip(e){return this.timeline.getClipById(e)}setupSpriteInteractivity(e){this.selection.setupSpriteInteractivity(e)}async removeClip(e){return this.timeline.removeClip(e)}async removeClipById(e){return this.timeline.removeClipById(e)}async deleteSelected(){return this.timeline.deleteSelected()}async duplicateSelected(){return this.timeline.duplicateSelected()}async splitSelected(e){return this.timeline.splitSelected(e)}async trimSelected(e){return this.timeline.trimSelected(e)}async updateSelected(e){return this.timeline.updateSelected(e)}async clear(){await this.timeline.clear(),this.transFromTexture&&(this.transFromTexture.destroy(!0),this.transFromTexture=null),this.transToTexture&&(this.transToTexture.destroy(!0),this.transToTexture=null),this.transBgGraphics&&(this.transBgGraphics.destroy(!0),this.transBgGraphics=null),this.emit("reset")}async play(){return this.transport.play()}pause(){this.transport.pause()}async stop(){return this.transport.stop()}async seek(e){return this.transport.seek(e)}getCurrentTime(){return this.transport.currentTime}getMaxDuration(){return this.transport.maxDuration}getIsPlaying(){return this.transport.isPlaying}getSelectedClips(){return Array.from(this.selectedClips)}getVideoTexture(e){let t=this.videoTextureCache.get(e);return t||(t=k.from(e),this.videoTextureCache.set(e,t)),t}isPlaybackCapable(e){return"createPlaybackElement"in e&&"play"in e&&"pause"in e&&"seek"in e&&"syncPlayback"in e&&"cleanupPlayback"in e}async updateFrame(e){if(this.destroyed||this.pixiApp==null||this.renderingSuspended)return;this.updateActiveGlobalEffect(e);const t=new Set,s=this.tracks.length;for(const n of this.clips){const o=this.getTrackIndex(n.id);if(o!==-1){const a=(s-o)*10;n.zIndex=a;const l=this.spriteRenderers.get(n);if(l){const c=l.getRoot();c&&(c.zIndex=a)}}}const r=[...this.clips].sort((n,o)=>n.zIndex-o.zIndex);for(const n of r){if(e<n.display.from){const p=this.spriteRenderers.get(n);p!=null&&await p.updateFrame(null);const _=this.playbackElements.get(n);_!=null&&this.isPlaybackCapable(n)&&n.pause(_.element);continue}if(n.display.to>0&&e>=n.display.to){const p=this.spriteRenderers.get(n);p!=null&&await p.updateFrame(null);const _=this.playbackElements.get(n);_!=null&&this.isPlaybackCapable(n)&&n.pause(_.element);continue}const o=e-n.display.from,a=o*n.playbackRate;n.animate(a);const l=await n.ready,c=n.duration||l.duration;if(c>0&&o>=c){const p=this.spriteRenderers.get(n);p!=null&&await p.updateFrame(null);const _=this.playbackElements.get(n);_!=null&&this.isPlaybackCapable(n)&&n.pause(_.element);continue}const h=this.playbackElements.get(n),u=n.type==="Video"||n.type==="Image",d=n.transition?n.transition.start:0,f=n.transition?n.transition.end:0,m=u&&n.transition&&e>=d&&e<f;if(h!=null&&this.isPlaybackCapable(n)){const p=o/1e6;if(n.syncPlayback(h.element,this.isPlaying,p),n.type==="Video"&&this.isPlaybackCapable(n)){const _=this.videoSprites.get(n);if(_!=null){const x=n.meta.duration/1e6;if(this.spriteRenderers.has(n))_.visible=!1;else if(_.visible=!m&&p>=0&&p<x,_.visible&&rk(n,_),!m)continue}}else continue}if(m){this.transFromTexture||(this.transFromTexture=Ge.create({width:this.opts.width,height:this.opts.height})),this.transToTexture||(this.transToTexture=Ge.create({width:this.opts.width,height:this.opts.height})),this.transBgGraphics||(this.transBgGraphics=new _e,this.transBgGraphics.rect(0,0,this.opts.width,this.opts.height).fill({color:0,alpha:0}));const p=this.getClipById(n?.transition?.fromClipId),_=this.getClipById(n?.transition?.toClipId);let x=null,v=null;if(p){const y=Math.max(0,e-p.display.from),{video:T}=await p.getFrame(y);T instanceof HTMLVideoElement?x=this.getVideoTexture(T):x=T,x&&(this.lastFromFrame=x)}if(_){const y=Math.max(0,e-_.display.from),{video:T}=await _.getFrame(y);T instanceof HTMLVideoElement?v=this.getVideoTexture(T):v=T,v&&(this.lastToFrame=v)}if(x||(x=this.lastFromFrame),v||(v=this.lastToFrame),!x||!v)continue;if(x&&v&&this.pixiApp&&this.transFromTexture&&this.transToTexture){const y=(e-d)/n?.transition?.duration;p&&x&&this.renderClipToTransitionTexture(p,x,this.transFromTexture),_&&v&&this.renderClipToTransitionTexture(_,v,this.transToTexture);let T=this.transitionRenderers.get(n.id);if(!T)try{T=of({name:n?.transition?.name,renderer:this.pixiApp.renderer}),this.transitionRenderers.set(n.id,T)}catch(S){console.error("[Studio] Failed to create transition renderer:",S)}if(T){const S=T.render({width:this.opts.width,height:this.opts.height,from:this.transFromTexture,to:this.transToTexture,progress:y});let w=this.transitionSprites.get(n.id);w||(w=new Be,w.label=`TransitionSprite_${n.id}`,this.transitionSprites.set(n.id,w),this.clipsNormalContainer&&this.clipsNormalContainer.addChild(w)),w.texture=S,w.visible=!0,w.x=0,w.y=0,w.width=this.opts.width,w.height=this.opts.height,w.anchor.set(0,0),w.zIndex=n.zIndex,t.add(n.id);const E=this.spriteRenderers.get(n);E?.getRoot()&&(E.getRoot().visible=!1);const P=this.videoSprites.get(n);if(P&&(P.visible=!1),p){const C=this.spriteRenderers.get(p);C?.getRoot()&&(C.getRoot().visible=!1);const A=this.videoSprites.get(p);A&&(A.visible=!1)}continue}}}const g=this.spriteRenderers.get(n);if(g!=null){const p=this.selectedClips.has(n);if(n.type==="Image"){const x=n.getTexture();if(x!=null){await g.updateFrame(x),p||g.updateTransforms();continue}}if(n.type==="Text"){const x=await n.getTexture();if(x!=null){await g.updateFrame(x),p||g.updateTransforms();continue}}if(n.type==="Caption"){n.updateState(o);const x=await n.getTexture();if(x!=null){await g.updateFrame(x),p||g.updateTransforms(),this.opts.interactivity&&this.selection.setupSpriteInteractivity(n);continue}else console.log("[Studio] CaptionClip texture is null, falling back to traditional path")}const{video:_}=await n.getFrame(o);await g.updateFrame(_),p||g.updateTransforms(),this.opts.interactivity&&this.selection.setupSpriteInteractivity(n)}}if(this.activeGlobalEffect&&this.clipsNormalContainer&&this.clipsEffectContainer){const{startTime:n,duration:o}=this.activeGlobalEffect,a=e-n,l=Math.min(Math.max(a/o,0),1);if(l>0&&l<1){try{for(const h of this.clips)this.moveClipToEffectContainer(h,!1);const c=this.clips.some(h=>h.id===this.activeGlobalEffect.id&&h instanceof ut);for(const h of this.clips){let u=!1;if(c){const d=this.activeGlobalEffect.trackIndex??-1,f=this.getTrackIndex(h.id);u=h.id!==this.activeGlobalEffect.id&&!(h instanceof ut)&&f>d}else{const d=h.effects;u=Array.isArray(d)&&d.some(f=>f&&f.id===this.activeGlobalEffect.id)}u&&this.moveClipToEffectContainer(h,!0)}}catch(c){console.warn("Failed to reparent clips for effect; falling back to full-scene render",c)}this.clipsNormalContainer.visible=!0,await this.applyGlobalEffectIfNeeded(e)}else{for(const c of this.clips)try{this.moveClipToEffectContainer(c,!1)}catch{}this.clipsNormalContainer.visible=!0,this.currentGlobalEffectSprite&&(this.currentGlobalEffectSprite.parent&&this.currentGlobalEffectSprite.parent.removeChild(this.currentGlobalEffectSprite),this.currentGlobalEffectSprite.destroy(),this.currentGlobalEffectSprite=null)}}else if(this.clipsNormalContainer){for(const n of this.clips)try{this.moveClipToEffectContainer(n,!1)}catch{}this.clipsNormalContainer.visible=!0,this.currentGlobalEffectSprite&&(this.currentGlobalEffectSprite.parent&&this.currentGlobalEffectSprite.parent.removeChild(this.currentGlobalEffectSprite),this.currentGlobalEffectSprite.destroy(),this.currentGlobalEffectSprite=null)}for(const[n,o]of this.transitionSprites.entries())t.has(n)||(o.visible=!1);this.pixiApp!=null&&this.pixiApp.render()}moveClipToEffectContainer(e,t=!0){if(!this.clipsNormalContainer||!this.clipsEffectContainer)return;const s=t?this.clipsEffectContainer:this.clipsNormalContainer,r=this.spriteRenderers.get(e);if(r){const o=r.getRoot();if(o&&o.parent!==s){try{o.parent&&o.parent.removeChild&&o.parent.removeChild(o)}catch(a){console.warn("moveClipToEffectContainer: could not remove root from parent",a)}s.addChild(o)}}const n=this.transitionSprites.get(e.id);if(n&&n.parent!==s){try{n.parent&&n.parent.removeChild&&n.parent.removeChild(n)}catch(o){console.warn("moveClipToEffectContainer: could not remove transSprite from parent",o)}s.addChild(n)}}applyGlobalEffect(e,t,s){const r=t.id||`${e}_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,n={id:r,key:e,startTime:t.startTime,duration:t.duration??1e6};for(const o of s)o instanceof ze&&o.addEffect(n),o instanceof ke&&o.addEffect(n),o instanceof xt&&o.addEffect(n),o instanceof ti&&o.addEffect(n);return this.globalEffects.set(r,n),r}getTrackIndex(e){return this.tracks.findIndex(t=>t.clipIds.includes(e))}async getTransitionFromFrame(e,t){let s=null;if(e.transition?.prevClipId&&(s=this.clips.find(a=>a.id===e.transition.prevClipId)||null),s||(s=this.getPreviousClipOnTrack(e)),!s)return null;const r=s.duration>0?s.duration:0,n=Math.max(0,Math.min(t-s.display.from,r)),{video:o}=await s.getFrame(n);return o}getPreviousClipOnTrack(e){const t=this.getTrackIndex(e.id);return t===-1?null:this.clips.filter(s=>s.id!==e.id&&this.getTrackIndex(s.id)===t&&s.display.from<e.display.from&&(s instanceof ke||s instanceof ze)).sort((s,r)=>r.display.to-s.display.to)[0]||null}renderClipToTransitionTexture(e,t,s){if(!this.pixiApp||!this.transBgGraphics)return;const r=this.pixiApp.renderer.background.alpha;this.pixiApp.renderer.background.alpha=0,this.pixiApp.renderer.render({container:this.transBgGraphics,target:s,clear:!0}),this.pixiApp.renderer.background.alpha=r;const n=new Be(t instanceof k?t:k.from(t));n.x=e.center.x,n.y=e.center.y,n.anchor.set(.5,.5);const o=n.texture.width||1,a=n.texture.height||1,l=e.width&&e.width!==0?Math.abs(e.width)/o:1,c=e.height&&e.height!==0?Math.abs(e.height)/a:1;e.flip==="horizontal"?(n.scale.x=-l,n.scale.y=c):e.flip==="vertical"?(n.scale.x=l,n.scale.y=-c):(n.scale.x=l,n.scale.y=c),n.rotation=(e.flip==null?1:-1)*e.angle,n.alpha=e.opacity,this.pixiApp.renderer.render({container:n,target:s,clear:!1}),t instanceof k||n.texture.destroy(!0),n.destroy()}removeGlobalEffect(e){this.globalEffects.delete(e)}clearGlobalEffects(){this.globalEffects.clear()}updateActiveGlobalEffect(e){let t=null;for(const s of this.clips)if(s instanceof ut&&e>=s.display.from&&(s.display.to===0||e<s.display.to)){t={id:s.id,key:s.effect.key,startTime:s.display.from,duration:s.duration>0?s.duration:s.display.to-s.display.from,trackIndex:this.getTrackIndex(s.id)};break}if(!t)for(const s of this.globalEffects.values()){const r=s.startTime+s.duration;if(e>=s.startTime&&e<r){t={id:s.id,key:s.key,startTime:s.startTime,duration:s.duration,trackIndex:-1};break}}this.activeGlobalEffect=t}async applyGlobalEffectIfNeeded(e){if(this.currentGlobalEffectSprite&&(this.currentGlobalEffectSprite.parent&&this.currentGlobalEffectSprite.parent.removeChild(this.currentGlobalEffectSprite),this.currentGlobalEffectSprite.destroy(),this.currentGlobalEffectSprite=null),!this.activeGlobalEffect||!this.pixiApp||!this.clipContainer||!this.artboard||!this.clipsNormalContainer||!this.clipsEffectContainer)return;const{key:t,startTime:s,duration:r}=this.activeGlobalEffect,n=e-s,o=Math.min(Math.max(n/r,0),1);if(o<=0||o>=1)return;this.clipsEffectContainer.visible=!0;let a=this.effectFilters.get(t);if(!a)try{if(a=rf({name:t.toLowerCase(),renderer:this.pixiApp.renderer}),a)this.effectFilters.set(t,a);else return}catch(f){console.error(f);return}const l=this.opts.width,c=this.opts.height,h=Ge.create({width:l,height:c});this.pixiApp.renderer.render({container:this.clipsEffectContainer,target:h,clear:!0}),this.clipsEffectContainer.visible=!1;const u=a.render({canvasTexture:h,progress:o,width:l,height:c}),d=new Be(u);d.x=0,d.y=0,d.width=l,d.height=c,d.scale.set(1),d.zIndex=5,this.clipContainer.addChild(d),this.currentGlobalEffectSprite=d,h.destroy(!0)}destroy(){if(!this.destroyed){window.removeEventListener("resize",this.handleResize),this.destroyed=!0,this.stop(),this.clear(),this.transitionRenderers.clear(),this.transFromTexture&&(this.transFromTexture.destroy(!0),this.transFromTexture=null),this.transToTexture&&(this.transToTexture.destroy(!0),this.transToTexture=null),this.transBgGraphics&&(this.transBgGraphics.destroy(!0),this.transBgGraphics=null);for(const e of this.transitionSprites.values())e.destroy();this.transitionSprites.clear(),this.pixiApp&&(this.pixiApp.destroy(!0,{children:!0,texture:!0}),this.pixiApp=null)}}selectClip(e,t=!1){this.selection.selectClip(e,t)}setSelection(e){this.selection.setSelection(e)}selectClipsByIds(e){this.selection.selectClipsByIds(e)}deselectClip(){this.selection.deselectClip()}exportToJSON(){return this.timeline.exportToJSON()}async loadFromJSON(e){return this.timeline.loadFromJSON(e)}}V.add(HS),V.mixin(se,WS),V.add(cg),V.add(hg),V.add(_0),V.mixin(se,gI),V.add(g0),V.add(rx),V.add(ad),V.add(ax),V.add(dx),V.add(fx),V.add(Sx),V.add(wx),V.add(_x),V.add(bx),V.add(vx),V.add(gx),V.add(mx),V.add(S0),V.add(T0);const _M=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"})),xM=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"}));re.AudioClip=je,re.CaptionClip=ti,re.Compositor=aM,re.EffectClip=ut,re.GL_EFFECT_OPTIONS=sk,re.GL_TRANSITION_OPTIONS=nM,re.ImageClip=ze,re.Log=ee,re.MP4Clip=ke,re.PlaceholderClip=mn,re.Studio=gM,re.TextClip=xt,re.TransitionClip=xi,re.VideoClip=ke,re.clipToJSON=Xs,re.createChromakey=Tw,re.fastConcatMP4=Ux,re.fixFMP4Duration=DR,re.fontManager=Nx,re.jsonToClip=Ys,re.makeEffect=rf,re.makeTransition=of,re.mixinMP4AndAudio=NR,re.renderTxt2ImgBitmap=Pw,Object.defineProperty(re,Symbol.toStringTag,{value:"Module"})}));
